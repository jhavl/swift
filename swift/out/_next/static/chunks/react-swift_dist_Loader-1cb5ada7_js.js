/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["react-swift_dist_Loader-1cb5ada7_js"],{

/***/ "../../react-swift/dist/Loader-1cb5ada7.js":
/*!*************************************************!*\
  !*** ../../react-swift/dist/Loader-1cb5ada7.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-13441088.js */ \"../../react-swift/dist/index-13441088.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"../../react-swift/node_modules/react-dom/index.js\");\n\n\n\n\n/**\n * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.\n *\n * Supports both binary and ASCII encoded files, with automatic detection of type.\n *\n * The loader returns a non-indexed buffer geometry.\n *\n * Limitations:\n *  Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\n *  There is perhaps some question as to how valid it is to always assume little-endian-ness.\n *  ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *  var loader = new STLLoader();\n *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {\n *    scene.add( new THREE.Mesh( geometry ) );\n *  });\n *\n * For binary STLs geometry might contain colors for vertices. To use it:\n *  // use the same code to load STL as above\n *  if (geometry.hasColors) {\n *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: true });\n *  } else { .... }\n *  var mesh = new THREE.Mesh( geometry, material );\n *\n * For ASCII STLs containing multiple solids, each solid is assigned to a different group.\n * Groups can be used to assign a different color by defining an array of materials with the same length of\n * geometry.groups and passing it to the Mesh constructor:\n *\n * var mesh = new THREE.Mesh( geometry, material );\n *\n * For example:\n *\n *  var materials = [];\n *  var nGeometryGroups = geometry.groups.length;\n *\n *  var colorMap = ...; // Some logic to index colors.\n *\n *  for (var i = 0; i < nGeometryGroups; i++) {\n *\n *\t\tvar material = new THREE.MeshPhongMaterial({\n *\t\t\tcolor: colorMap[i],\n *\t\t\twireframe: false\n *\t\t});\n *\n *  }\n *\n *  materials.push(material);\n *  var mesh = new THREE.Mesh(geometry, materials);\n */\n\n\nvar STLLoader = function ( manager ) {\n\n\t_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n};\n\nSTLLoader.prototype = Object.assign( Object.create( _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\tconstructor: STLLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.F( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( data ) {\n\n\t\tfunction isBinary( data ) {\n\n\t\t\tvar expect, face_size, n_faces, reader;\n\t\t\treader = new DataView( data );\n\t\t\tface_size = ( 32 / 8 * 3 ) + ( ( 32 / 8 * 3 ) * 3 ) + ( 16 / 8 );\n\t\t\tn_faces = reader.getUint32( 80, true );\n\t\t\texpect = 80 + ( 32 / 8 ) + ( n_faces * face_size );\n\n\t\t\tif ( expect === reader.byteLength ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// An ASCII STL data must begin with 'solid ' as the first six bytes.\n\t\t\t// However, ASCII STLs lacking the SPACE after the 'd' are known to be\n\t\t\t// plentiful.  So, check the first 5 bytes for 'solid'.\n\n\t\t\t// Several encodings, such as UTF-8, precede the text with up to 5 bytes:\n\t\t\t// https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\n\t\t\t// Search for \"solid\" to start anywhere after those prefixes.\n\n\t\t\t// US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\n\n\t\t\tvar solid = [ 115, 111, 108, 105, 100 ];\n\n\t\t\tfor ( var off = 0; off < 5; off ++ ) {\n\n\t\t\t\t// If \"solid\" text is matched to the current offset, declare it to be an ASCII STL.\n\n\t\t\t\tif ( matchDataViewAt( solid, reader, off ) ) return false;\n\n\t\t\t}\n\n\t\t\t// Couldn't find \"solid\" text at the beginning; it is binary STL.\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction matchDataViewAt( query, reader, offset ) {\n\n\t\t\t// Check if each byte in query matches the corresponding byte from the current offset\n\n\t\t\tfor ( var i = 0, il = query.length; i < il; i ++ ) {\n\n\t\t\t\tif ( query[ i ] !== reader.getUint8( offset + i, false ) ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction parseBinary( data ) {\n\n\t\t\tvar reader = new DataView( data );\n\t\t\tvar faces = reader.getUint32( 80, true );\n\n\t\t\tvar r, g, b, hasColors = false, colors;\n\t\t\tvar defaultR, defaultG, defaultB, alpha;\n\n\t\t\t// process STL header\n\t\t\t// check for default color in header (\"COLOR=rgba\" sequence).\n\n\t\t\tfor ( var index = 0; index < 80 - 10; index ++ ) {\n\n\t\t\t\tif ( ( reader.getUint32( index, false ) == 0x434F4C4F /*COLO*/ ) &&\n\t\t\t\t\t( reader.getUint8( index + 4 ) == 0x52 /*'R'*/ ) &&\n\t\t\t\t\t( reader.getUint8( index + 5 ) == 0x3D /*'='*/ ) ) {\n\n\t\t\t\t\thasColors = true;\n\t\t\t\t\tcolors = new Float32Array( faces * 3 * 3 );\n\n\t\t\t\t\tdefaultR = reader.getUint8( index + 6 ) / 255;\n\t\t\t\t\tdefaultG = reader.getUint8( index + 7 ) / 255;\n\t\t\t\t\tdefaultB = reader.getUint8( index + 8 ) / 255;\n\t\t\t\t\talpha = reader.getUint8( index + 9 ) / 255;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar dataOffset = 84;\n\t\t\tvar faceLength = 12 * 4 + 2;\n\n\t\t\tvar geometry = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\t\tvar vertices = new Float32Array( faces * 3 * 3 );\n\t\t\tvar normals = new Float32Array( faces * 3 * 3 );\n\n\t\t\tfor ( var face = 0; face < faces; face ++ ) {\n\n\t\t\t\tvar start = dataOffset + face * faceLength;\n\t\t\t\tvar normalX = reader.getFloat32( start, true );\n\t\t\t\tvar normalY = reader.getFloat32( start + 4, true );\n\t\t\t\tvar normalZ = reader.getFloat32( start + 8, true );\n\n\t\t\t\tif ( hasColors ) {\n\n\t\t\t\t\tvar packedColor = reader.getUint16( start + 48, true );\n\n\t\t\t\t\tif ( ( packedColor & 0x8000 ) === 0 ) {\n\n\t\t\t\t\t\t// facet has its own unique color\n\n\t\t\t\t\t\tr = ( packedColor & 0x1F ) / 31;\n\t\t\t\t\t\tg = ( ( packedColor >> 5 ) & 0x1F ) / 31;\n\t\t\t\t\t\tb = ( ( packedColor >> 10 ) & 0x1F ) / 31;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tr = defaultR;\n\t\t\t\t\t\tg = defaultG;\n\t\t\t\t\t\tb = defaultB;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 1; i <= 3; i ++ ) {\n\n\t\t\t\t\tvar vertexstart = start + i * 12;\n\t\t\t\t\tvar componentIdx = ( face * 3 * 3 ) + ( ( i - 1 ) * 3 );\n\n\t\t\t\t\tvertices[ componentIdx ] = reader.getFloat32( vertexstart, true );\n\t\t\t\t\tvertices[ componentIdx + 1 ] = reader.getFloat32( vertexstart + 4, true );\n\t\t\t\t\tvertices[ componentIdx + 2 ] = reader.getFloat32( vertexstart + 8, true );\n\n\t\t\t\t\tnormals[ componentIdx ] = normalX;\n\t\t\t\t\tnormals[ componentIdx + 1 ] = normalY;\n\t\t\t\t\tnormals[ componentIdx + 2 ] = normalZ;\n\n\t\t\t\t\tif ( hasColors ) {\n\n\t\t\t\t\t\tcolors[ componentIdx ] = r;\n\t\t\t\t\t\tcolors[ componentIdx + 1 ] = g;\n\t\t\t\t\t\tcolors[ componentIdx + 2 ] = b;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'position', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.c( vertices, 3 ) );\n\t\t\tgeometry.setAttribute( 'normal', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.c( normals, 3 ) );\n\n\t\t\tif ( hasColors ) {\n\n\t\t\t\tgeometry.setAttribute( 'color', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.c( colors, 3 ) );\n\t\t\t\tgeometry.hasColors = true;\n\t\t\t\tgeometry.alpha = alpha;\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction parseASCII( data ) {\n\n\t\t\tvar geometry = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\t\t\tvar patternSolid = /solid([\\s\\S]*?)endsolid/g;\n\t\t\tvar patternFace = /facet([\\s\\S]*?)endfacet/g;\n\t\t\tvar faceCounter = 0;\n\n\t\t\tvar patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source;\n\t\t\tvar patternVertex = new RegExp( 'vertex' + patternFloat + patternFloat + patternFloat, 'g' );\n\t\t\tvar patternNormal = new RegExp( 'normal' + patternFloat + patternFloat + patternFloat, 'g' );\n\n\t\t\tvar vertices = [];\n\t\t\tvar normals = [];\n\n\t\t\tvar normal = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t\t\tvar result;\n\n\t\t\tvar groupCount = 0;\n\t\t\tvar startVertex = 0;\n\t\t\tvar endVertex = 0;\n\n\t\t\twhile ( ( result = patternSolid.exec( data ) ) !== null ) {\n\n\t\t\t\tstartVertex = endVertex;\n\n\t\t\t\tvar solid = result[ 0 ];\n\n\t\t\t\twhile ( ( result = patternFace.exec( solid ) ) !== null ) {\n\n\t\t\t\t\tvar vertexCountPerFace = 0;\n\t\t\t\t\tvar normalCountPerFace = 0;\n\n\t\t\t\t\tvar text = result[ 0 ];\n\n\t\t\t\t\twhile ( ( result = patternNormal.exec( text ) ) !== null ) {\n\n\t\t\t\t\t\tnormal.x = parseFloat( result[ 1 ] );\n\t\t\t\t\t\tnormal.y = parseFloat( result[ 2 ] );\n\t\t\t\t\t\tnormal.z = parseFloat( result[ 3 ] );\n\t\t\t\t\t\tnormalCountPerFace ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\twhile ( ( result = patternVertex.exec( text ) ) !== null ) {\n\n\t\t\t\t\t\tvertices.push( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ), parseFloat( result[ 3 ] ) );\n\t\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\t\t\t\t\t\tvertexCountPerFace ++;\n\t\t\t\t\t\tendVertex ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// every face have to own ONE valid normal\n\n\t\t\t\t\tif ( normalCountPerFace !== 1 ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the normal of face number ' + faceCounter );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// each face have to own THREE valid vertices\n\n\t\t\t\t\tif ( vertexCountPerFace !== 3 ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the vertices of face number ' + faceCounter );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceCounter ++;\n\n\t\t\t\t}\n\n\t\t\t\tvar start = startVertex;\n\t\t\t\tvar count = endVertex - startVertex;\n\n\t\t\t\tgeometry.addGroup( start, count, groupCount );\n\t\t\t\tgroupCount ++;\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'position', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( vertices, 3 ) );\n\t\t\tgeometry.setAttribute( 'normal', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( normals, 3 ) );\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction ensureString( buffer ) {\n\n\t\t\tif ( typeof buffer !== 'string' ) {\n\n\t\t\t\treturn _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.f.decodeText( new Uint8Array( buffer ) );\n\n\t\t\t}\n\n\t\t\treturn buffer;\n\n\t\t}\n\n\t\tfunction ensureBinary( buffer ) {\n\n\t\t\tif ( typeof buffer === 'string' ) {\n\n\t\t\t\tvar array_buffer = new Uint8Array( buffer.length );\n\t\t\t\tfor ( var i = 0; i < buffer.length; i ++ ) {\n\n\t\t\t\t\tarray_buffer[ i ] = buffer.charCodeAt( i ) & 0xff; // implicitly assumes little-endian\n\n\t\t\t\t}\n\n\t\t\t\treturn array_buffer.buffer || array_buffer;\n\n\t\t\t} else {\n\n\t\t\t\treturn buffer;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// start\n\n\t\tvar binData = ensureBinary( data );\n\n\t\treturn isBinary( binData ) ? parseBinary( binData ) : parseASCII( ensureString( data ) );\n\n\t}\n\n} );\n\nvar GLTFLoader = ( function () {\n\n\tfunction GLTFLoader( manager ) {\n\n\t\t_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n\t\tthis.dracoLoader = null;\n\t\tthis.ktx2Loader = null;\n\t\tthis.meshoptDecoder = null;\n\n\t\tthis.pluginCallbacks = [];\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsClearcoatExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureBasisUExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureWebPExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsTransmissionExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFLightsExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMeshoptCompression( parser );\n\n\t\t} );\n\n\t}\n\n\tGLTFLoader.prototype = Object.assign( Object.create( _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\t\tconstructor: GLTFLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar resourcePath;\n\n\t\t\tif ( this.resourcePath !== '' ) {\n\n\t\t\t\tresourcePath = this.resourcePath;\n\n\t\t\t} else if ( this.path !== '' ) {\n\n\t\t\t\tresourcePath = this.path;\n\n\t\t\t} else {\n\n\t\t\t\tresourcePath = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.f.extractUrlBase( url );\n\n\t\t\t}\n\n\t\t\t// Tells the LoadingManager to track an extra item, which resolves after\n\t\t\t// the model is fully loaded. This means the count of items loaded will\n\t\t\t// be incorrect, but ensures manager.onLoad() does not fire early.\n\t\t\tthis.manager.itemStart( url );\n\n\t\t\tvar _onError = function ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t};\n\n\t\t\tvar loader = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.F( this.manager );\n\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.setRequestHeader( this.requestHeader );\n\t\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\t\tloader.load( url, function ( data ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tscope.parse( data, resourcePath, function ( gltf ) {\n\n\t\t\t\t\t\tonLoad( gltf );\n\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t\t}, _onError );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t_onError( e );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, _onError );\n\n\t\t},\n\n\t\tsetDRACOLoader: function ( dracoLoader ) {\n\n\t\t\tthis.dracoLoader = dracoLoader;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetDDSLoader: function () {\n\n\t\t\tthrow new Error(\n\n\t\t\t\t'THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".'\n\n\t\t\t);\n\n\t\t},\n\n\t\tsetKTX2Loader: function ( ktx2Loader ) {\n\n\t\t\tthis.ktx2Loader = ktx2Loader;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetMeshoptDecoder: function ( meshoptDecoder ) {\n\n\t\t\tthis.meshoptDecoder = meshoptDecoder;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tregister: function ( callback ) {\n\n\t\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\n\n\t\t\t\tthis.pluginCallbacks.push( callback );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tunregister: function ( callback ) {\n\n\t\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\n\n\t\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tparse: function ( data, path, onLoad, onError ) {\n\n\t\t\tvar content;\n\t\t\tvar extensions = {};\n\t\t\tvar plugins = {};\n\n\t\t\tif ( typeof data === 'string' ) {\n\n\t\t\t\tcontent = data;\n\n\t\t\t} else {\n\n\t\t\t\tvar magic = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.f.decodeText( new Uint8Array( data, 0, 4 ) );\n\n\t\t\t\tif ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\textensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );\n\n\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\tif ( onError ) onError( error );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontent = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcontent = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.f.decodeText( new Uint8Array( data ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar json = JSON.parse( content );\n\n\t\t\tif ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {\n\n\t\t\t\tif ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar parser = new GLTFParser( json, {\n\n\t\t\t\tpath: path || this.resourcePath || '',\n\t\t\t\tcrossOrigin: this.crossOrigin,\n\t\t\t\trequestHeader: this.requestHeader,\n\t\t\t\tmanager: this.manager,\n\t\t\t\tktx2Loader: this.ktx2Loader,\n\t\t\t\tmeshoptDecoder: this.meshoptDecoder\n\n\t\t\t} );\n\n\t\t\tparser.fileLoader.setRequestHeader( this.requestHeader );\n\n\t\t\tfor ( var i = 0; i < this.pluginCallbacks.length; i ++ ) {\n\n\t\t\t\tvar plugin = this.pluginCallbacks[ i ]( parser );\n\t\t\t\tplugins[ plugin.name ] = plugin;\n\n\t\t\t\t// Workaround to avoid determining as unknown extension\n\t\t\t\t// in addUnknownExtensionsToUserData().\n\t\t\t\t// Remove this workaround if we move all the existing\n\t\t\t\t// extension handlers to plugin system\n\t\t\t\textensions[ plugin.name ] = true;\n\n\t\t\t}\n\n\t\t\tif ( json.extensionsUsed ) {\n\n\t\t\t\tfor ( var i = 0; i < json.extensionsUsed.length; ++ i ) {\n\n\t\t\t\t\tvar extensionName = json.extensionsUsed[ i ];\n\t\t\t\t\tvar extensionsRequired = json.extensionsRequired || [];\n\n\t\t\t\t\tswitch ( extensionName ) {\n\n\t\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_UNLIT:\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsUnlitExtension();\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFTextureTransformExtension();\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase EXTENSIONS.KHR_MESH_QUANTIZATION:\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMeshQuantizationExtension();\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tif ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tparser.setExtensions( extensions );\n\t\t\tparser.setPlugins( plugins );\n\t\t\tparser.parse( onLoad, onError );\n\n\t\t}\n\n\t} );\n\n\t/* GLTFREGISTRY */\n\n\tfunction GLTFRegistry() {\n\n\t\tvar objects = {};\n\n\t\treturn\t{\n\n\t\t\tget: function ( key ) {\n\n\t\t\t\treturn objects[ key ];\n\n\t\t\t},\n\n\t\t\tadd: function ( key, object ) {\n\n\t\t\t\tobjects[ key ] = object;\n\n\t\t\t},\n\n\t\t\tremove: function ( key ) {\n\n\t\t\t\tdelete objects[ key ];\n\n\t\t\t},\n\n\t\t\tremoveAll: function () {\n\n\t\t\t\tobjects = {};\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/*********************************/\n\t/********** EXTENSIONS ***********/\n\t/*********************************/\n\n\tvar EXTENSIONS = {\n\t\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\n\t\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n\t\tKHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n\t\tKHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n\t\tKHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n\t\tKHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n\t\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n\t\tKHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n\t\tKHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n\t\tKHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n\t\tEXT_TEXTURE_WEBP: 'EXT_texture_webp',\n\t\tEXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'\n\t};\n\n\t/**\n\t * Punctual Lights Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n\t */\n\tfunction GLTFLightsExtension( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n\n\t\t// Object3D instance caches\n\t\tthis.cache = { refs: {}, uses: {} };\n\n\t}\n\n\tGLTFLightsExtension.prototype._markDefs = function () {\n\n\t\tvar parser = this.parser;\n\t\tvar nodeDefs = this.parser.json.nodes || [];\n\n\t\tfor ( var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tvar nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.extensions\n\t\t\t\t&& nodeDef.extensions[ this.name ]\n\t\t\t\t&& nodeDef.extensions[ this.name ].light !== undefined ) {\n\n\t\t\t\tparser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tGLTFLightsExtension.prototype._loadLight = function ( lightIndex ) {\n\n\t\tvar parser = this.parser;\n\t\tvar cacheKey = 'light:' + lightIndex;\n\t\tvar dependency = parser.cache.get( cacheKey );\n\n\t\tif ( dependency ) return dependency;\n\n\t\tvar json = parser.json;\n\t\tvar extensions = ( json.extensions && json.extensions[ this.name ] ) || {};\n\t\tvar lightDefs = extensions.lights || [];\n\t\tvar lightDef = lightDefs[ lightIndex ];\n\t\tvar lightNode;\n\n\t\tvar color = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.C( 0xffffff );\n\n\t\tif ( lightDef.color !== undefined ) color.fromArray( lightDef.color );\n\n\t\tvar range = lightDef.range !== undefined ? lightDef.range : 0;\n\n\t\tswitch ( lightDef.type ) {\n\n\t\t\tcase 'directional':\n\t\t\t\tlightNode = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__._( color );\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tcase 'point':\n\t\t\t\tlightNode = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.Z( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\tbreak;\n\n\t\t\tcase 'spot':\n\t\t\t\tlightNode = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.Y( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\t// Handle spotlight properties.\n\t\t\t\tlightDef.spot = lightDef.spot || {};\n\t\t\t\tlightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n\t\t\t\tlightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n\t\t\t\tlightNode.angle = lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );\n\n\t\t}\n\n\t\t// Some lights (e.g. spot) default to a position other than the origin. Reset the position\n\t\t// here, because node-level parsing will only override position if explicitly specified.\n\t\tlightNode.position.set( 0, 0, 0 );\n\n\t\tlightNode.decay = 2;\n\n\t\tif ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;\n\n\t\tlightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );\n\n\t\tdependency = Promise.resolve( lightNode );\n\n\t\tparser.cache.add( cacheKey, dependency );\n\n\t\treturn dependency;\n\n\t};\n\n\tGLTFLightsExtension.prototype.createNodeAttachment = function ( nodeIndex ) {\n\n\t\tvar self = this;\n\t\tvar parser = this.parser;\n\t\tvar json = parser.json;\n\t\tvar nodeDef = json.nodes[ nodeIndex ];\n\t\tvar lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};\n\t\tvar lightIndex = lightDef.light;\n\n\t\tif ( lightIndex === undefined ) return null;\n\n\t\treturn this._loadLight( lightIndex ).then( function ( light ) {\n\n\t\t\treturn parser._getNodeRef( self.cache, lightIndex, light );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Unlit Materials Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n\t */\n\tfunction GLTFMaterialsUnlitExtension() {\n\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n\n\t}\n\n\tGLTFMaterialsUnlitExtension.prototype.getMaterialType = function () {\n\n\t\treturn _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.g;\n\n\t};\n\n\tGLTFMaterialsUnlitExtension.prototype.extendParams = function ( materialParams, materialDef, parser ) {\n\n\t\tvar pending = [];\n\n\t\tmaterialParams.color = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.C( 1.0, 1.0, 1.0 );\n\t\tmaterialParams.opacity = 1.0;\n\n\t\tvar metallicRoughness = materialDef.pbrMetallicRoughness;\n\n\t\tif ( metallicRoughness ) {\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tvar array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t};\n\n\t/**\n\t * Clearcoat Materials Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n\t */\n\tfunction GLTFMaterialsClearcoatExtension( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n\n\t}\n\n\tGLTFMaterialsClearcoatExtension.prototype.getMaterialType = function ( materialIndex ) {\n\n\t\tvar parser = this.parser;\n\t\tvar materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.$;\n\n\t};\n\n\tGLTFMaterialsClearcoatExtension.prototype.extendMaterialParams = function ( materialIndex, materialParams ) {\n\n\t\tvar parser = this.parser;\n\t\tvar materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tvar pending = [];\n\n\t\tvar extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.clearcoatFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoat = extension.clearcoatFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatNormalTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );\n\n\t\t\tif ( extension.clearcoatNormalTexture.scale !== undefined ) {\n\n\t\t\t\tvar scale = extension.clearcoatNormalTexture.scale;\n\n\t\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\tmaterialParams.clearcoatNormalScale = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a( scale, - scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t};\n\n\t/**\n\t * Transmission Materials Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n\t * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n\t */\n\tfunction GLTFMaterialsTransmissionExtension( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n\n\t}\n\n\tGLTFMaterialsTransmissionExtension.prototype.getMaterialType = function ( materialIndex ) {\n\n\t\tvar parser = this.parser;\n\t\tvar materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.$;\n\n\t};\n\n\tGLTFMaterialsTransmissionExtension.prototype.extendMaterialParams = function ( materialIndex, materialParams ) {\n\n\t\tvar parser = this.parser;\n\t\tvar materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tvar pending = [];\n\n\t\tvar extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.transmissionFactor !== undefined ) {\n\n\t\t\tmaterialParams.transmission = extension.transmissionFactor;\n\n\t\t}\n\n\t\tif ( extension.transmissionTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t};\n\n\t/**\n\t * BasisU Texture Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n\t */\n\tfunction GLTFTextureBasisUExtension( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n\n\t}\n\n\tGLTFTextureBasisUExtension.prototype.loadTexture = function ( textureIndex ) {\n\n\t\tvar parser = this.parser;\n\t\tvar json = parser.json;\n\n\t\tvar textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar extension = textureDef.extensions[ this.name ];\n\t\tvar source = json.images[ extension.source ];\n\t\tvar loader = parser.options.ktx2Loader;\n\n\t\tif ( ! loader ) {\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );\n\n\t\t\t} else {\n\n\t\t\t\t// Assumes that the extension is optional and that a fallback texture is present\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.loadTextureImage( textureIndex, source, loader );\n\n\t};\n\n\t/**\n\t * WebP Texture Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n\t */\n\tfunction GLTFTextureWebPExtension( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n\t\tthis.isSupported = null;\n\n\t}\n\n\tGLTFTextureWebPExtension.prototype.loadTexture = function ( textureIndex ) {\n\n\t\tvar name = this.name;\n\t\tvar parser = this.parser;\n\t\tvar json = parser.json;\n\n\t\tvar textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar extension = textureDef.extensions[ name ];\n\t\tvar source = json.images[ extension.source ];\n\n\t\tvar loader = parser.textureLoader;\n\t\tif ( source.uri ) {\n\n\t\t\tvar handler = parser.options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.detectSupport().then( function ( isSupported ) {\n\n\t\t\tif ( isSupported ) return parser.loadTextureImage( textureIndex, source, loader );\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );\n\n\t\t\t}\n\n\t\t\t// Fall back to PNG or JPEG.\n\t\t\treturn parser.loadTexture( textureIndex );\n\n\t\t} );\n\n\t};\n\n\tGLTFTextureWebPExtension.prototype.detectSupport = function () {\n\n\t\tif ( ! this.isSupported ) {\n\n\t\t\tthis.isSupported = new Promise( function ( resolve ) {\n\n\t\t\t\tvar image = new Image();\n\n\t\t\t\t// Lossy test image. Support for lossy images doesn't guarantee support for all\n\t\t\t\t// WebP images, unfortunately.\n\t\t\t\timage.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';\n\n\t\t\t\timage.onload = image.onerror = function () {\n\n\t\t\t\t\tresolve( image.height === 1 );\n\n\t\t\t\t};\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn this.isSupported;\n\n\t};\n\n\t/**\n\t* meshopt BufferView Compression Extension\n\t*\n\t* Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n\t*/\n\tfunction GLTFMeshoptCompression( parser ) {\n\n\t\tthis.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n\t\tthis.parser = parser;\n\n\t}\n\n\tGLTFMeshoptCompression.prototype.loadBufferView = function ( index ) {\n\n\t\tvar json = this.parser.json;\n\t\tvar bufferView = json.bufferViews[ index ];\n\n\t\tif ( bufferView.extensions && bufferView.extensions[ this.name ] ) {\n\n\t\t\tvar extensionDef = bufferView.extensions[ this.name ];\n\n\t\t\tvar buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );\n\t\t\tvar decoder = this.parser.options.meshoptDecoder;\n\n\t\t\tif ( ! decoder || ! decoder.supported ) {\n\n\t\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Assumes that the extension is optional and that fallback buffer data is present\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn Promise.all( [ buffer, decoder.ready ] ).then( function ( res ) {\n\n\t\t\t\tvar byteOffset = extensionDef.byteOffset || 0;\n\t\t\t\tvar byteLength = extensionDef.byteLength || 0;\n\n\t\t\t\tvar count = extensionDef.count;\n\t\t\t\tvar stride = extensionDef.byteStride;\n\n\t\t\t\tvar result = new ArrayBuffer( count * stride );\n\t\t\t\tvar source = new Uint8Array( res[ 0 ], byteOffset, byteLength );\n\n\t\t\t\tdecoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );\n\t\t\t\treturn result;\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t};\n\n\t/* BINARY EXTENSION */\n\tvar BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\n\tvar BINARY_EXTENSION_HEADER_LENGTH = 12;\n\tvar BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\n\n\tfunction GLTFBinaryExtension( data ) {\n\n\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\n\t\tthis.content = null;\n\t\tthis.body = null;\n\n\t\tvar headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );\n\n\t\tthis.header = {\n\t\t\tmagic: _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.f.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),\n\t\t\tversion: headerView.getUint32( 4, true ),\n\t\t\tlength: headerView.getUint32( 8, true )\n\t\t};\n\n\t\tif ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );\n\n\t\t} else if ( this.header.version < 2.0 ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );\n\n\t\t}\n\n\t\tvar chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n\t\tvar chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );\n\t\tvar chunkIndex = 0;\n\n\t\twhile ( chunkIndex < chunkContentsLength ) {\n\n\t\t\tvar chunkLength = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tvar chunkType = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tif ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {\n\n\t\t\t\tvar contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );\n\t\t\t\tthis.content = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.f.decodeText( contentArray );\n\n\t\t\t} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {\n\n\t\t\t\tvar byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n\t\t\t\tthis.body = data.slice( byteOffset, byteOffset + chunkLength );\n\n\t\t\t}\n\n\t\t\t// Clients must ignore chunks with unknown types.\n\n\t\t\tchunkIndex += chunkLength;\n\n\t\t}\n\n\t\tif ( this.content === null ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: JSON content not found.' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * DRACO Mesh Compression Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n\t */\n\tfunction GLTFDracoMeshCompressionExtension( json, dracoLoader ) {\n\n\t\tif ( ! dracoLoader ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );\n\n\t\t}\n\n\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n\t\tthis.json = json;\n\t\tthis.dracoLoader = dracoLoader;\n\t\tthis.dracoLoader.preload();\n\n\t}\n\n\tGLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function ( primitive, parser ) {\n\n\t\tvar json = this.json;\n\t\tvar dracoLoader = this.dracoLoader;\n\t\tvar bufferViewIndex = primitive.extensions[ this.name ].bufferView;\n\t\tvar gltfAttributeMap = primitive.extensions[ this.name ].attributes;\n\t\tvar threeAttributeMap = {};\n\t\tvar attributeNormalizedMap = {};\n\t\tvar attributeTypeMap = {};\n\n\t\tfor ( var attributeName in gltfAttributeMap ) {\n\n\t\t\tvar threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tthreeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];\n\n\t\t}\n\n\t\tfor ( attributeName in primitive.attributes ) {\n\n\t\t\tvar threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tif ( gltfAttributeMap[ attributeName ] !== undefined ) {\n\n\t\t\t\tvar accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];\n\t\t\t\tvar componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t\tattributeTypeMap[ threeAttributeName ] = componentType;\n\t\t\t\tattributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {\n\n\t\t\treturn new Promise( function ( resolve ) {\n\n\t\t\t\tdracoLoader.decodeDracoFile( bufferView, function ( geometry ) {\n\n\t\t\t\t\tfor ( var attributeName in geometry.attributes ) {\n\n\t\t\t\t\t\tvar attribute = geometry.attributes[ attributeName ];\n\t\t\t\t\t\tvar normalized = attributeNormalizedMap[ attributeName ];\n\n\t\t\t\t\t\tif ( normalized !== undefined ) attribute.normalized = normalized;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve( geometry );\n\n\t\t\t\t}, threeAttributeMap, attributeTypeMap );\n\n\t\t\t} );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Texture Transform Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n\t */\n\tfunction GLTFTextureTransformExtension() {\n\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n\n\t}\n\n\tGLTFTextureTransformExtension.prototype.extendTexture = function ( texture, transform ) {\n\n\t\ttexture = texture.clone();\n\n\t\tif ( transform.offset !== undefined ) {\n\n\t\t\ttexture.offset.fromArray( transform.offset );\n\n\t\t}\n\n\t\tif ( transform.rotation !== undefined ) {\n\n\t\t\ttexture.rotation = transform.rotation;\n\n\t\t}\n\n\t\tif ( transform.scale !== undefined ) {\n\n\t\t\ttexture.repeat.fromArray( transform.scale );\n\n\t\t}\n\n\t\tif ( transform.texCoord !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.' );\n\n\t\t}\n\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t};\n\n\t/**\n\t * Specular-Glossiness Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n\t */\n\n\t/**\n\t * A sub class of StandardMaterial with some of the functionality\n\t * changed via the `onBeforeCompile` callback\n\t * @pailhead\n\t */\n\n\tfunction GLTFMeshStandardSGMaterial( params ) {\n\n\t\t_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.h.call( this );\n\n\t\tthis.isGLTFSpecularGlossinessMaterial = true;\n\n\t\t//various chunks that need replacing\n\t\tvar specularMapParsFragmentChunk = [\n\t\t\t'#ifdef USE_SPECULARMAP',\n\t\t\t'\tuniform sampler2D specularMap;',\n\t\t\t'#endif'\n\t\t].join( '\\n' );\n\n\t\tvar glossinessMapParsFragmentChunk = [\n\t\t\t'#ifdef USE_GLOSSINESSMAP',\n\t\t\t'\tuniform sampler2D glossinessMap;',\n\t\t\t'#endif'\n\t\t].join( '\\n' );\n\n\t\tvar specularMapFragmentChunk = [\n\t\t\t'vec3 specularFactor = specular;',\n\t\t\t'#ifdef USE_SPECULARMAP',\n\t\t\t'\tvec4 texelSpecular = texture2D( specularMap, vUv );',\n\t\t\t'\ttexelSpecular = sRGBToLinear( texelSpecular );',\n\t\t\t'\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',\n\t\t\t'\tspecularFactor *= texelSpecular.rgb;',\n\t\t\t'#endif'\n\t\t].join( '\\n' );\n\n\t\tvar glossinessMapFragmentChunk = [\n\t\t\t'float glossinessFactor = glossiness;',\n\t\t\t'#ifdef USE_GLOSSINESSMAP',\n\t\t\t'\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );',\n\t\t\t'\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',\n\t\t\t'\tglossinessFactor *= texelGlossiness.a;',\n\t\t\t'#endif'\n\t\t].join( '\\n' );\n\n\t\tvar lightPhysicalFragmentChunk = [\n\t\t\t'PhysicalMaterial material;',\n\t\t\t'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',\n\t\t\t'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',\n\t\t\t'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',\n\t\t\t'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',\n\t\t\t'material.specularRoughness += geometryRoughness;',\n\t\t\t'material.specularRoughness = min( material.specularRoughness, 1.0 );',\n\t\t\t'material.specularColor = specularFactor;',\n\t\t].join( '\\n' );\n\n\t\tvar uniforms = {\n\t\t\tspecular: { value: new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.C().setHex( 0xffffff ) },\n\t\t\tglossiness: { value: 1 },\n\t\t\tspecularMap: { value: null },\n\t\t\tglossinessMap: { value: null }\n\t\t};\n\n\t\tthis._extraUniforms = uniforms;\n\n\t\tthis.onBeforeCompile = function ( shader ) {\n\n\t\t\tfor ( var uniformName in uniforms ) {\n\n\t\t\t\tshader.uniforms[ uniformName ] = uniforms[ uniformName ];\n\n\t\t\t}\n\n\t\t\tshader.fragmentShader = shader.fragmentShader\n\t\t\t\t.replace( 'uniform float roughness;', 'uniform vec3 specular;' )\n\t\t\t\t.replace( 'uniform float metalness;', 'uniform float glossiness;' )\n\t\t\t\t.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk )\n\t\t\t\t.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk )\n\t\t\t\t.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk )\n\t\t\t\t.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk )\n\t\t\t\t.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );\n\n\t\t};\n\n\t\tObject.defineProperties( this, {\n\n\t\t\tspecular: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn uniforms.specular.value;\n\n\t\t\t\t},\n\t\t\t\tset: function ( v ) {\n\n\t\t\t\t\tuniforms.specular.value = v;\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tspecularMap: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn uniforms.specularMap.value;\n\n\t\t\t\t},\n\t\t\t\tset: function ( v ) {\n\n\t\t\t\t\tuniforms.specularMap.value = v;\n\n\t\t\t\t\tif ( v ) {\n\n\t\t\t\t\t\tthis.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdelete this.defines.USE_SPECULARMAP;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tglossiness: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn uniforms.glossiness.value;\n\n\t\t\t\t},\n\t\t\t\tset: function ( v ) {\n\n\t\t\t\t\tuniforms.glossiness.value = v;\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tglossinessMap: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn uniforms.glossinessMap.value;\n\n\t\t\t\t},\n\t\t\t\tset: function ( v ) {\n\n\t\t\t\t\tuniforms.glossinessMap.value = v;\n\n\t\t\t\t\tif ( v ) {\n\n\t\t\t\t\t\tthis.defines.USE_GLOSSINESSMAP = '';\n\t\t\t\t\t\tthis.defines.USE_UV = '';\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdelete this.defines.USE_GLOSSINESSMAP;\n\t\t\t\t\t\tdelete this.defines.USE_UV;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} );\n\n\t\tdelete this.metalness;\n\t\tdelete this.roughness;\n\t\tdelete this.metalnessMap;\n\t\tdelete this.roughnessMap;\n\n\t\tthis.setValues( params );\n\n\t}\n\n\tGLTFMeshStandardSGMaterial.prototype = Object.create( _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.h.prototype );\n\tGLTFMeshStandardSGMaterial.prototype.constructor = GLTFMeshStandardSGMaterial;\n\n\tGLTFMeshStandardSGMaterial.prototype.copy = function ( source ) {\n\n\t\t_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.h.prototype.copy.call( this, source );\n\t\tthis.specularMap = source.specularMap;\n\t\tthis.specular.copy( source.specular );\n\t\tthis.glossinessMap = source.glossinessMap;\n\t\tthis.glossiness = source.glossiness;\n\t\tdelete this.metalness;\n\t\tdelete this.roughness;\n\t\tdelete this.metalnessMap;\n\t\tdelete this.roughnessMap;\n\t\treturn this;\n\n\t};\n\n\tfunction GLTFMaterialsPbrSpecularGlossinessExtension() {\n\n\t\treturn {\n\n\t\t\tname: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,\n\n\t\t\tspecularGlossinessParams: [\n\t\t\t\t'color',\n\t\t\t\t'map',\n\t\t\t\t'lightMap',\n\t\t\t\t'lightMapIntensity',\n\t\t\t\t'aoMap',\n\t\t\t\t'aoMapIntensity',\n\t\t\t\t'emissive',\n\t\t\t\t'emissiveIntensity',\n\t\t\t\t'emissiveMap',\n\t\t\t\t'bumpMap',\n\t\t\t\t'bumpScale',\n\t\t\t\t'normalMap',\n\t\t\t\t'normalMapType',\n\t\t\t\t'displacementMap',\n\t\t\t\t'displacementScale',\n\t\t\t\t'displacementBias',\n\t\t\t\t'specularMap',\n\t\t\t\t'specular',\n\t\t\t\t'glossinessMap',\n\t\t\t\t'glossiness',\n\t\t\t\t'alphaMap',\n\t\t\t\t'envMap',\n\t\t\t\t'envMapIntensity',\n\t\t\t\t'refractionRatio',\n\t\t\t],\n\n\t\t\tgetMaterialType: function () {\n\n\t\t\t\treturn GLTFMeshStandardSGMaterial;\n\n\t\t\t},\n\n\t\t\textendParams: function ( materialParams, materialDef, parser ) {\n\n\t\t\t\tvar pbrSpecularGlossiness = materialDef.extensions[ this.name ];\n\n\t\t\t\tmaterialParams.color = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.C( 1.0, 1.0, 1.0 );\n\t\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\t\tvar pending = [];\n\n\t\t\t\tif ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {\n\n\t\t\t\t\tvar array = pbrSpecularGlossiness.diffuseFactor;\n\n\t\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {\n\n\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture ) );\n\n\t\t\t\t}\n\n\t\t\t\tmaterialParams.emissive = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.C( 0.0, 0.0, 0.0 );\n\t\t\t\tmaterialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\n\t\t\t\tmaterialParams.specular = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.C( 1.0, 1.0, 1.0 );\n\n\t\t\t\tif ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {\n\n\t\t\t\t\tmaterialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );\n\n\t\t\t\t}\n\n\t\t\t\tif ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {\n\n\t\t\t\t\tvar specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\n\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );\n\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn Promise.all( pending );\n\n\t\t\t},\n\n\t\t\tcreateMaterial: function ( materialParams ) {\n\n\t\t\t\tvar material = new GLTFMeshStandardSGMaterial( materialParams );\n\t\t\t\tmaterial.fog = true;\n\n\t\t\t\tmaterial.color = materialParams.color;\n\n\t\t\t\tmaterial.map = materialParams.map === undefined ? null : materialParams.map;\n\n\t\t\t\tmaterial.lightMap = null;\n\t\t\t\tmaterial.lightMapIntensity = 1.0;\n\n\t\t\t\tmaterial.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;\n\t\t\t\tmaterial.aoMapIntensity = 1.0;\n\n\t\t\t\tmaterial.emissive = materialParams.emissive;\n\t\t\t\tmaterial.emissiveIntensity = 1.0;\n\t\t\t\tmaterial.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;\n\n\t\t\t\tmaterial.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;\n\t\t\t\tmaterial.bumpScale = 1;\n\n\t\t\t\tmaterial.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;\n\t\t\t\tmaterial.normalMapType = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.i;\n\n\t\t\t\tif ( materialParams.normalScale ) material.normalScale = materialParams.normalScale;\n\n\t\t\t\tmaterial.displacementMap = null;\n\t\t\t\tmaterial.displacementScale = 1;\n\t\t\t\tmaterial.displacementBias = 0;\n\n\t\t\t\tmaterial.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;\n\t\t\t\tmaterial.specular = materialParams.specular;\n\n\t\t\t\tmaterial.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;\n\t\t\t\tmaterial.glossiness = materialParams.glossiness;\n\n\t\t\t\tmaterial.alphaMap = null;\n\n\t\t\t\tmaterial.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;\n\t\t\t\tmaterial.envMapIntensity = 1.0;\n\n\t\t\t\tmaterial.refractionRatio = 0.98;\n\n\t\t\t\treturn material;\n\n\t\t\t},\n\n\t\t};\n\n\t}\n\n\t/**\n\t * Mesh Quantization Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n\t */\n\tfunction GLTFMeshQuantizationExtension() {\n\n\t\tthis.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n\n\t}\n\n\t/*********************************/\n\t/********** INTERPOLATION ********/\n\t/*********************************/\n\n\t// Spline Interpolation\n\t// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\n\tfunction GLTFCubicSplineInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\t_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a0.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tGLTFCubicSplineInterpolant.prototype = Object.create( _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a0.prototype );\n\tGLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;\n\n\tGLTFCubicSplineInterpolant.prototype.copySampleValue_ = function ( index ) {\n\n\t\t// Copies a sample value to the result buffer. See description of glTF\n\t\t// CUBICSPLINE values layout in interpolate_() function below.\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tvalueSize = this.valueSize,\n\t\t\toffset = index * valueSize * 3 + valueSize;\n\n\t\tfor ( var i = 0; i !== valueSize; i ++ ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t};\n\n\tGLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\n\tGLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\n\tGLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer;\n\t\tvar values = this.sampleValues;\n\t\tvar stride = this.valueSize;\n\n\t\tvar stride2 = stride * 2;\n\t\tvar stride3 = stride * 3;\n\n\t\tvar td = t1 - t0;\n\n\t\tvar p = ( t - t0 ) / td;\n\t\tvar pp = p * p;\n\t\tvar ppp = pp * p;\n\n\t\tvar offset1 = i1 * stride3;\n\t\tvar offset0 = offset1 - stride3;\n\n\t\tvar s2 = - 2 * ppp + 3 * pp;\n\t\tvar s3 = ppp - pp;\n\t\tvar s0 = 1 - s2;\n\t\tvar s1 = s3 - pp + p;\n\n\t\t// Layout of keyframe output values for CUBICSPLINE animations:\n\t\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\t\tfor ( var i = 0; i !== stride; i ++ ) {\n\n\t\t\tvar p0 = values[ offset0 + i + stride ]; // splineVertex_k\n\t\t\tvar m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)\n\t\t\tvar p1 = values[ offset1 + i + stride ]; // splineVertex_k+1\n\t\t\tvar m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n\t\t\tresult[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n\n\t\t}\n\n\t\treturn result;\n\n\t};\n\n\t/*********************************/\n\t/********** INTERNALS ************/\n\t/*********************************/\n\n\t/* CONSTANTS */\n\n\tvar WEBGL_CONSTANTS = {\n\t\tFLOAT: 5126,\n\t\t//FLOAT_MAT2: 35674,\n\t\tFLOAT_MAT3: 35675,\n\t\tFLOAT_MAT4: 35676,\n\t\tFLOAT_VEC2: 35664,\n\t\tFLOAT_VEC3: 35665,\n\t\tFLOAT_VEC4: 35666,\n\t\tLINEAR: 9729,\n\t\tREPEAT: 10497,\n\t\tSAMPLER_2D: 35678,\n\t\tPOINTS: 0,\n\t\tLINES: 1,\n\t\tLINE_LOOP: 2,\n\t\tLINE_STRIP: 3,\n\t\tTRIANGLES: 4,\n\t\tTRIANGLE_STRIP: 5,\n\t\tTRIANGLE_FAN: 6,\n\t\tUNSIGNED_BYTE: 5121,\n\t\tUNSIGNED_SHORT: 5123\n\t};\n\n\tvar WEBGL_COMPONENT_TYPES = {\n\t\t5120: Int8Array,\n\t\t5121: Uint8Array,\n\t\t5122: Int16Array,\n\t\t5123: Uint16Array,\n\t\t5125: Uint32Array,\n\t\t5126: Float32Array\n\t};\n\n\tvar WEBGL_FILTERS = {\n\t\t9728: _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a1,\n\t\t9729: _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.m,\n\t\t9984: _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a2,\n\t\t9985: _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a3,\n\t\t9986: _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a4,\n\t\t9987: _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.n\n\t};\n\n\tvar WEBGL_WRAPPINGS = {\n\t\t33071: _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a5,\n\t\t33648: _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a6,\n\t\t10497: _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.o\n\t};\n\n\tvar WEBGL_TYPE_SIZES = {\n\t\t'SCALAR': 1,\n\t\t'VEC2': 2,\n\t\t'VEC3': 3,\n\t\t'VEC4': 4,\n\t\t'MAT2': 4,\n\t\t'MAT3': 9,\n\t\t'MAT4': 16\n\t};\n\n\tvar ATTRIBUTES = {\n\t\tPOSITION: 'position',\n\t\tNORMAL: 'normal',\n\t\tTANGENT: 'tangent',\n\t\tTEXCOORD_0: 'uv',\n\t\tTEXCOORD_1: 'uv2',\n\t\tCOLOR_0: 'color',\n\t\tWEIGHTS_0: 'skinWeight',\n\t\tJOINTS_0: 'skinIndex',\n\t};\n\n\tvar PATH_PROPERTIES = {\n\t\tscale: 'scale',\n\t\ttranslation: 'position',\n\t\trotation: 'quaternion',\n\t\tweights: 'morphTargetInfluences'\n\t};\n\n\tvar INTERPOLATION = {\n\t\tCUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n\t\t                        // keyframe track will be initialized with a default interpolation type, then modified.\n\t\tLINEAR: _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.J,\n\t\tSTEP: _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a7\n\t};\n\n\tvar ALPHA_MODES = {\n\t\tOPAQUE: 'OPAQUE',\n\t\tMASK: 'MASK',\n\t\tBLEND: 'BLEND'\n\t};\n\n\t/* UTILITY FUNCTIONS */\n\n\tfunction resolveURL( url, path ) {\n\n\t\t// Invalid URL\n\t\tif ( typeof url !== 'string' || url === '' ) return '';\n\n\t\t// Host Relative URL\n\t\tif ( /^https?:\\/\\//i.test( path ) && /^\\//.test( url ) ) {\n\n\t\t\tpath = path.replace( /(^https?:\\/\\/[^\\/]+).*/i, '$1' );\n\n\t\t}\n\n\t\t// Absolute URL http://,https://,//\n\t\tif ( /^(https?:)?\\/\\//i.test( url ) ) return url;\n\n\t\t// Data URI\n\t\tif ( /^data:.*,.*$/i.test( url ) ) return url;\n\n\t\t// Blob URL\n\t\tif ( /^blob:.*$/i.test( url ) ) return url;\n\n\t\t// Relative URL\n\t\treturn path + url;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n\t */\n\tfunction createDefaultMaterial( cache ) {\n\n\t\tif ( cache[ 'DefaultMaterial' ] === undefined ) {\n\n\t\t\tcache[ 'DefaultMaterial' ] = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.h( {\n\t\t\t\tcolor: 0xFFFFFF,\n\t\t\t\temissive: 0x000000,\n\t\t\t\tmetalness: 1,\n\t\t\t\troughness: 1,\n\t\t\t\ttransparent: false,\n\t\t\t\tdepthTest: true,\n\t\t\t\tside: _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a8\n\t\t\t} );\n\n\t\t}\n\n\t\treturn cache[ 'DefaultMaterial' ];\n\n\t}\n\n\tfunction addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {\n\n\t\t// Add unknown glTF extensions to an object's userData.\n\n\t\tfor ( var name in objectDef.extensions ) {\n\n\t\t\tif ( knownExtensions[ name ] === undefined ) {\n\n\t\t\t\tobject.userData.gltfExtensions = object.userData.gltfExtensions || {};\n\t\t\t\tobject.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @param {Object3D|Material|BufferGeometry} object\n\t * @param {GLTF.definition} gltfDef\n\t */\n\tfunction assignExtrasToUserData( object, gltfDef ) {\n\n\t\tif ( gltfDef.extras !== undefined ) {\n\n\t\t\tif ( typeof gltfDef.extras === 'object' ) {\n\n\t\t\t\tObject.assign( object.userData, gltfDef.extras );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n\t *\n\t * @param {BufferGeometry} geometry\n\t * @param {Array<GLTF.Target>} targets\n\t * @param {GLTFParser} parser\n\t * @return {Promise<BufferGeometry>}\n\t */\n\tfunction addMorphTargets( geometry, targets, parser ) {\n\n\t\tvar hasMorphPosition = false;\n\t\tvar hasMorphNormal = false;\n\n\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\tvar target = targets[ i ];\n\n\t\t\tif ( target.POSITION !== undefined ) hasMorphPosition = true;\n\t\t\tif ( target.NORMAL !== undefined ) hasMorphNormal = true;\n\n\t\t\tif ( hasMorphPosition && hasMorphNormal ) break;\n\n\t\t}\n\n\t\tif ( ! hasMorphPosition && ! hasMorphNormal ) return Promise.resolve( geometry );\n\n\t\tvar pendingPositionAccessors = [];\n\t\tvar pendingNormalAccessors = [];\n\n\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\tvar target = targets[ i ];\n\n\t\t\tif ( hasMorphPosition ) {\n\n\t\t\t\tvar pendingAccessor = target.POSITION !== undefined\n\t\t\t\t\t? parser.getDependency( 'accessor', target.POSITION )\n\t\t\t\t\t: geometry.attributes.position;\n\n\t\t\t\tpendingPositionAccessors.push( pendingAccessor );\n\n\t\t\t}\n\n\t\t\tif ( hasMorphNormal ) {\n\n\t\t\t\tvar pendingAccessor = target.NORMAL !== undefined\n\t\t\t\t\t? parser.getDependency( 'accessor', target.NORMAL )\n\t\t\t\t\t: geometry.attributes.normal;\n\n\t\t\t\tpendingNormalAccessors.push( pendingAccessor );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( [\n\t\t\tPromise.all( pendingPositionAccessors ),\n\t\t\tPromise.all( pendingNormalAccessors )\n\t\t] ).then( function ( accessors ) {\n\n\t\t\tvar morphPositions = accessors[ 0 ];\n\t\t\tvar morphNormals = accessors[ 1 ];\n\n\t\t\tif ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;\n\t\t\tif ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;\n\t\t\tgeometry.morphTargetsRelative = true;\n\n\t\t\treturn geometry;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * @param {Mesh} mesh\n\t * @param {GLTF.Mesh} meshDef\n\t */\n\tfunction updateMorphTargets( mesh, meshDef ) {\n\n\t\tmesh.updateMorphTargets();\n\n\t\tif ( meshDef.weights !== undefined ) {\n\n\t\t\tfor ( var i = 0, il = meshDef.weights.length; i < il; i ++ ) {\n\n\t\t\t\tmesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// .extras has user-defined data, so check that .extras.targetNames is an array.\n\t\tif ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {\n\n\t\t\tvar targetNames = meshDef.extras.targetNames;\n\n\t\t\tif ( mesh.morphTargetInfluences.length === targetNames.length ) {\n\n\t\t\t\tmesh.morphTargetDictionary = {};\n\n\t\t\t\tfor ( var i = 0, il = targetNames.length; i < il; i ++ ) {\n\n\t\t\t\t\tmesh.morphTargetDictionary[ targetNames[ i ] ] = i;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction createPrimitiveKey( primitiveDef ) {\n\n\t\tvar dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];\n\t\tvar geometryKey;\n\n\t\tif ( dracoExtension ) {\n\n\t\t\tgeometryKey = 'draco:' + dracoExtension.bufferView\n\t\t\t\t+ ':' + dracoExtension.indices\n\t\t\t\t+ ':' + createAttributesKey( dracoExtension.attributes );\n\n\t\t} else {\n\n\t\t\tgeometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;\n\n\t\t}\n\n\t\treturn geometryKey;\n\n\t}\n\n\tfunction createAttributesKey( attributes ) {\n\n\t\tvar attributesKey = '';\n\n\t\tvar keys = Object.keys( attributes ).sort();\n\n\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\tattributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';\n\n\t\t}\n\n\t\treturn attributesKey;\n\n\t}\n\n\t/* GLTF PARSER */\n\n\tfunction GLTFParser( json, options ) {\n\n\t\tthis.json = json || {};\n\t\tthis.extensions = {};\n\t\tthis.plugins = {};\n\t\tthis.options = options || {};\n\n\t\t// loader object cache\n\t\tthis.cache = new GLTFRegistry();\n\n\t\t// associations between Three.js objects and glTF elements\n\t\tthis.associations = new Map();\n\n\t\t// BufferGeometry caching\n\t\tthis.primitiveCache = {};\n\n\t\t// Object3D instance caches\n\t\tthis.meshCache = { refs: {}, uses: {} };\n\t\tthis.cameraCache = { refs: {}, uses: {} };\n\t\tthis.lightCache = { refs: {}, uses: {} };\n\n\t\t// Track node names, to ensure no duplicates\n\t\tthis.nodeNamesUsed = {};\n\n\t\t// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n\t\t// expensive work of uploading a texture to the GPU off the main thread.\n\t\tif ( typeof createImageBitmap !== 'undefined' && /Firefox/.test( navigator.userAgent ) === false ) {\n\n\t\t\tthis.textureLoader = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.I( this.options.manager );\n\n\t\t} else {\n\n\t\t\tthis.textureLoader = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.j( this.options.manager );\n\n\t\t}\n\n\t\tthis.textureLoader.setCrossOrigin( this.options.crossOrigin );\n\t\tthis.textureLoader.setRequestHeader( this.options.requestHeader );\n\n\t\tthis.fileLoader = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.F( this.options.manager );\n\t\tthis.fileLoader.setResponseType( 'arraybuffer' );\n\n\t\tif ( this.options.crossOrigin === 'use-credentials' ) {\n\n\t\t\tthis.fileLoader.setWithCredentials( true );\n\n\t\t}\n\n\t}\n\n\tGLTFParser.prototype.setExtensions = function ( extensions ) {\n\n\t\tthis.extensions = extensions;\n\n\t};\n\n\tGLTFParser.prototype.setPlugins = function ( plugins ) {\n\n\t\tthis.plugins = plugins;\n\n\t};\n\n\tGLTFParser.prototype.parse = function ( onLoad, onError ) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\n\t\t// Clear the loader cache\n\t\tthis.cache.removeAll();\n\n\t\t// Mark the special nodes/meshes in json for efficient parse\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\treturn ext._markDefs && ext._markDefs();\n\n\t\t} );\n\n\t\tPromise.all( this._invokeAll( function ( ext ) {\n\n\t\t\treturn ext.beforeRoot && ext.beforeRoot();\n\n\t\t} ) ).then( function () {\n\n\t\t\treturn Promise.all( [\n\n\t\t\t\tparser.getDependencies( 'scene' ),\n\t\t\t\tparser.getDependencies( 'animation' ),\n\t\t\t\tparser.getDependencies( 'camera' ),\n\n\t\t\t] );\n\n\t\t} ).then( function ( dependencies ) {\n\n\t\t\tvar result = {\n\t\t\t\tscene: dependencies[ 0 ][ json.scene || 0 ],\n\t\t\t\tscenes: dependencies[ 0 ],\n\t\t\t\tanimations: dependencies[ 1 ],\n\t\t\t\tcameras: dependencies[ 2 ],\n\t\t\t\tasset: json.asset,\n\t\t\t\tparser: parser,\n\t\t\t\tuserData: {}\n\t\t\t};\n\n\t\t\taddUnknownExtensionsToUserData( extensions, result, json );\n\n\t\t\tassignExtrasToUserData( result, json );\n\n\t\t\tPromise.all( parser._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.afterRoot && ext.afterRoot( result );\n\n\t\t\t} ) ).then( function () {\n\n\t\t\t\tonLoad( result );\n\n\t\t\t} );\n\n\t\t} ).catch( onError );\n\n\t};\n\n\t/**\n\t * Marks the special nodes/meshes in json for efficient parse.\n\t */\n\tGLTFParser.prototype._markDefs = function () {\n\n\t\tvar nodeDefs = this.json.nodes || [];\n\t\tvar skinDefs = this.json.skins || [];\n\t\tvar meshDefs = this.json.meshes || [];\n\n\t\t// Nothing in the node definition indicates whether it is a Bone or an\n\t\t// Object3D. Use the skins' joint references to mark bones.\n\t\tfor ( var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {\n\n\t\t\tvar joints = skinDefs[ skinIndex ].joints;\n\n\t\t\tfor ( var i = 0, il = joints.length; i < il; i ++ ) {\n\n\t\t\t\tnodeDefs[ joints[ i ] ].isBone = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Iterate over all nodes, marking references to shared resources,\n\t\t// as well as skeleton joints.\n\t\tfor ( var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tvar nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.meshCache, nodeDef.mesh );\n\n\t\t\t\t// Nothing in the mesh definition indicates whether it is\n\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\n\t\t\t\t// to mark SkinnedMesh if node has skin.\n\t\t\t\tif ( nodeDef.skin !== undefined ) {\n\n\t\t\t\t\tmeshDefs[ nodeDef.mesh ].isSkinnedMesh = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.cameraCache, nodeDef.camera );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Counts references to shared node / Object3D resources. These resources\n\t * can be reused, or \"instantiated\", at multiple nodes in the scene\n\t * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n\t * be marked. Non-scenegraph resources (like Materials, Geometries, and\n\t * Textures) can be reused directly and are not marked here.\n\t *\n\t * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\t */\n\tGLTFParser.prototype._addNodeRef = function ( cache, index ) {\n\n\t\tif ( index === undefined ) return;\n\n\t\tif ( cache.refs[ index ] === undefined ) {\n\n\t\t\tcache.refs[ index ] = cache.uses[ index ] = 0;\n\n\t\t}\n\n\t\tcache.refs[ index ] ++;\n\n\t};\n\n\t/** Returns a reference to a shared resource, cloning it if necessary. */\n\tGLTFParser.prototype._getNodeRef = function ( cache, index, object ) {\n\n\t\tif ( cache.refs[ index ] <= 1 ) return object;\n\n\t\tvar ref = object.clone();\n\n\t\tref.name += '_instance_' + ( cache.uses[ index ] ++ );\n\n\t\treturn ref;\n\n\t};\n\n\tGLTFParser.prototype._invokeOne = function ( func ) {\n\n\t\tvar extensions = Object.values( this.plugins );\n\t\textensions.push( this );\n\n\t\tfor ( var i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tvar result = func( extensions[ i ] );\n\n\t\t\tif ( result ) return result;\n\n\t\t}\n\n\t};\n\n\tGLTFParser.prototype._invokeAll = function ( func ) {\n\n\t\tvar extensions = Object.values( this.plugins );\n\t\textensions.unshift( this );\n\n\t\tvar pending = [];\n\n\t\tfor ( var i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tvar result = func( extensions[ i ] );\n\n\t\t\tif ( result ) pending.push( result );\n\n\t\t}\n\n\t\treturn pending;\n\n\t};\n\n\t/**\n\t * Requests the specified dependency asynchronously, with caching.\n\t * @param {string} type\n\t * @param {number} index\n\t * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n\t */\n\tGLTFParser.prototype.getDependency = function ( type, index ) {\n\n\t\tvar cacheKey = type + ':' + index;\n\t\tvar dependency = this.cache.get( cacheKey );\n\n\t\tif ( ! dependency ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'scene':\n\t\t\t\t\tdependency = this.loadScene( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'node':\n\t\t\t\t\tdependency = this.loadNode( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mesh':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMesh && ext.loadMesh( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'accessor':\n\t\t\t\t\tdependency = this.loadAccessor( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bufferView':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadBufferView && ext.loadBufferView( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'buffer':\n\t\t\t\t\tdependency = this.loadBuffer( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'material':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMaterial && ext.loadMaterial( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'texture':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadTexture && ext.loadTexture( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'skin':\n\t\t\t\t\tdependency = this.loadSkin( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'animation':\n\t\t\t\t\tdependency = this.loadAnimation( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'camera':\n\t\t\t\t\tdependency = this.loadCamera( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'Unknown type: ' + type );\n\n\t\t\t}\n\n\t\t\tthis.cache.add( cacheKey, dependency );\n\n\t\t}\n\n\t\treturn dependency;\n\n\t};\n\n\t/**\n\t * Requests all dependencies of the specified type asynchronously, with caching.\n\t * @param {string} type\n\t * @return {Promise<Array<Object>>}\n\t */\n\tGLTFParser.prototype.getDependencies = function ( type ) {\n\n\t\tvar dependencies = this.cache.get( type );\n\n\t\tif ( ! dependencies ) {\n\n\t\t\tvar parser = this;\n\t\t\tvar defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];\n\n\t\t\tdependencies = Promise.all( defs.map( function ( def, index ) {\n\n\t\t\t\treturn parser.getDependency( type, index );\n\n\t\t\t} ) );\n\n\t\t\tthis.cache.add( type, dependencies );\n\n\t\t}\n\n\t\treturn dependencies;\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tGLTFParser.prototype.loadBuffer = function ( bufferIndex ) {\n\n\t\tvar bufferDef = this.json.buffers[ bufferIndex ];\n\t\tvar loader = this.fileLoader;\n\n\t\tif ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );\n\n\t\t}\n\n\t\t// If present, GLB container is required to be the first buffer.\n\t\tif ( bufferDef.uri === undefined && bufferIndex === 0 ) {\n\n\t\t\treturn Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );\n\n\t\t}\n\n\t\tvar options = this.options;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tloader.load( resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {\n\n\t\t\t\treject( new Error( 'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) );\n\n\t\t\t} );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferViewIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tGLTFParser.prototype.loadBufferView = function ( bufferViewIndex ) {\n\n\t\tvar bufferViewDef = this.json.bufferViews[ bufferViewIndex ];\n\n\t\treturn this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {\n\n\t\t\tvar byteLength = bufferViewDef.byteLength || 0;\n\t\t\tvar byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\treturn buffer.slice( byteOffset, byteOffset + byteLength );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n\t * @param {number} accessorIndex\n\t * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n\t */\n\tGLTFParser.prototype.loadAccessor = function ( accessorIndex ) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\n\t\tvar accessorDef = this.json.accessors[ accessorIndex ];\n\n\t\tif ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {\n\n\t\t\t// Ignore empty accessors, which may be used to declare runtime\n\t\t\t// information about attributes coming from another source (e.g. Draco\n\t\t\t// compression extension).\n\t\t\treturn Promise.resolve( null );\n\n\t\t}\n\n\t\tvar pendingBufferViews = [];\n\n\t\tif ( accessorDef.bufferView !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );\n\n\t\t} else {\n\n\t\t\tpendingBufferViews.push( null );\n\n\t\t}\n\n\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );\n\n\t\t}\n\n\t\treturn Promise.all( pendingBufferViews ).then( function ( bufferViews ) {\n\n\t\t\tvar bufferView = bufferViews[ 0 ];\n\n\t\t\tvar itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\tvar TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\t\t\tvar elementBytes = TypedArray.BYTES_PER_ELEMENT;\n\t\t\tvar itemBytes = elementBytes * itemSize;\n\t\t\tvar byteOffset = accessorDef.byteOffset || 0;\n\t\t\tvar byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;\n\t\t\tvar normalized = accessorDef.normalized === true;\n\t\t\tvar array, bufferAttribute;\n\n\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\n\t\t\tif ( byteStride && byteStride !== itemBytes ) {\n\n\t\t\t\t// Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n\t\t\t\t// This makes sure that IBA.count reflects accessor.count properly\n\t\t\t\tvar ibSlice = Math.floor( byteOffset / byteStride );\n\t\t\t\tvar ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n\t\t\t\tvar ib = parser.cache.get( ibCacheKey );\n\n\t\t\t\tif ( ! ib ) {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );\n\n\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\n\t\t\t\t\tib = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.k( array, byteStride / elementBytes );\n\n\t\t\t\t\tparser.cache.add( ibCacheKey, ib );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.l( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );\n\n\t\t\t} else {\n\n\t\t\t\tif ( bufferView === null ) {\n\n\t\t\t\t\tarray = new TypedArray( accessorDef.count * itemSize );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.c( array, itemSize, normalized );\n\n\t\t\t}\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\t\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\t\tvar itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n\t\t\t\tvar TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];\n\n\t\t\t\tvar byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n\t\t\t\tvar byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n\n\t\t\t\tvar sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );\n\t\t\t\tvar sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );\n\n\t\t\t\tif ( bufferView !== null ) {\n\n\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n\t\t\t\t\tbufferAttribute = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.c( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0, il = sparseIndices.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar index = sparseIndices[ i ];\n\n\t\t\t\t\tbufferAttribute.setX( index, sparseValues[ i * itemSize ] );\n\t\t\t\t\tif ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );\n\t\t\t\t\tif ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );\n\t\t\t\t\tif ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );\n\t\t\t\t\tif ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bufferAttribute;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n\t * @param {number} textureIndex\n\t * @return {Promise<THREE.Texture>}\n\t */\n\tGLTFParser.prototype.loadTexture = function ( textureIndex ) {\n\n\t\tvar json = this.json;\n\t\tvar options = this.options;\n\t\tvar textureDef = json.textures[ textureIndex ];\n\t\tvar source = json.images[ textureDef.source ];\n\n\t\tvar loader = this.textureLoader;\n\n\t\tif ( source.uri ) {\n\n\t\t\tvar handler = options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.loadTextureImage( textureIndex, source, loader );\n\n\t};\n\n\tGLTFParser.prototype.loadTextureImage = function ( textureIndex, source, loader ) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\t\tvar options = this.options;\n\n\t\tvar textureDef = json.textures[ textureIndex ];\n\n\t\tvar URL = self.URL || self.webkitURL;\n\n\t\tvar sourceURI = source.uri;\n\t\tvar isObjectURL = false;\n\t\tvar hasAlpha = true;\n\n\t\tif ( source.mimeType === 'image/jpeg' ) hasAlpha = false;\n\n\t\tif ( source.bufferView !== undefined ) {\n\n\t\t\t// Load binary image data from bufferView, if provided.\n\n\t\t\tsourceURI = parser.getDependency( 'bufferView', source.bufferView ).then( function ( bufferView ) {\n\n\t\t\t\tif ( source.mimeType === 'image/png' ) {\n\n\t\t\t\t\t// Inspect the PNG 'IHDR' chunk to determine whether the image could have an\n\t\t\t\t\t// alpha channel. This check is conservative  the image could have an alpha\n\t\t\t\t\t// channel with all values == 1, and the indexed type (colorType == 3) only\n\t\t\t\t\t// sometimes contains alpha.\n\t\t\t\t\t//\n\t\t\t\t\t// https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header\n\t\t\t\t\tvar colorType = new DataView( bufferView, 25, 1 ).getUint8( 0, false );\n\t\t\t\t\thasAlpha = colorType === 6 || colorType === 4 || colorType === 3;\n\n\t\t\t\t}\n\n\t\t\t\tisObjectURL = true;\n\t\t\t\tvar blob = new Blob( [ bufferView ], { type: source.mimeType } );\n\t\t\t\tsourceURI = URL.createObjectURL( blob );\n\t\t\t\treturn sourceURI;\n\n\t\t\t} );\n\n\t\t} else if ( source.uri === undefined ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Image ' + textureIndex + ' is missing URI and bufferView' );\n\n\t\t}\n\n\t\treturn Promise.resolve( sourceURI ).then( function ( sourceURI ) {\n\n\t\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\t\tvar onLoad = resolve;\n\n\t\t\t\tif ( loader.isImageBitmapLoader === true ) {\n\n\t\t\t\t\tonLoad = function ( imageBitmap ) {\n\n\t\t\t\t\t\tresolve( new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a9( imageBitmap ) );\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tloader.load( resolveURL( sourceURI, options.path ), onLoad, undefined, reject );\n\n\t\t\t} );\n\n\t\t} ).then( function ( texture ) {\n\n\t\t\t// Clean up resources and configure Texture.\n\n\t\t\tif ( isObjectURL === true ) {\n\n\t\t\t\tURL.revokeObjectURL( sourceURI );\n\n\t\t\t}\n\n\t\t\ttexture.flipY = false;\n\n\t\t\tif ( textureDef.name ) texture.name = textureDef.name;\n\n\t\t\t// When there is definitely no alpha channel in the texture, set RGBFormat to save space.\n\t\t\tif ( ! hasAlpha ) texture.format = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.R;\n\n\t\t\tvar samplers = json.samplers || {};\n\t\t\tvar sampler = samplers[ textureDef.sampler ] || {};\n\n\t\t\ttexture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.m;\n\t\t\ttexture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.n;\n\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.o;\n\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.o;\n\n\t\t\tparser.associations.set( texture, {\n\t\t\t\ttype: 'textures',\n\t\t\t\tindex: textureIndex\n\t\t\t} );\n\n\t\t\treturn texture;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Asynchronously assigns a texture to the given material parameters.\n\t * @param {Object} materialParams\n\t * @param {string} mapName\n\t * @param {Object} mapDef\n\t * @return {Promise}\n\t */\n\tGLTFParser.prototype.assignTexture = function ( materialParams, mapName, mapDef ) {\n\n\t\tvar parser = this;\n\n\t\treturn this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {\n\n\t\t\t// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured\n\t\t\t// However, we will copy UV set 0 to UV set 1 on demand for aoMap\n\t\t\tif ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && ! ( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );\n\n\t\t\t}\n\n\t\t\tif ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {\n\n\t\t\t\tvar transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;\n\n\t\t\t\tif ( transform ) {\n\n\t\t\t\t\tvar gltfReference = parser.associations.get( texture );\n\t\t\t\t\ttexture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );\n\t\t\t\t\tparser.associations.set( texture, gltfReference );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tmaterialParams[ mapName ] = texture;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Assigns final material to a Mesh, Line, or Points instance. The instance\n\t * already has a material (generated from the glTF material options alone)\n\t * but reuse of the same glTF material may require multiple threejs materials\n\t * to accommodate different primitive types, defines, etc. New materials will\n\t * be created if necessary, and reused from a cache.\n\t * @param  {Object3D} mesh Mesh, Line, or Points instance.\n\t */\n\tGLTFParser.prototype.assignFinalMaterial = function ( mesh ) {\n\n\t\tvar geometry = mesh.geometry;\n\t\tvar material = mesh.material;\n\n\t\tvar useVertexTangents = geometry.attributes.tangent !== undefined;\n\t\tvar useVertexColors = geometry.attributes.color !== undefined;\n\t\tvar useFlatShading = geometry.attributes.normal === undefined;\n\t\tvar useSkinning = mesh.isSkinnedMesh === true;\n\t\tvar useMorphTargets = Object.keys( geometry.morphAttributes ).length > 0;\n\t\tvar useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;\n\n\t\tif ( mesh.isPoints ) {\n\n\t\t\tvar cacheKey = 'PointsMaterial:' + material.uuid;\n\n\t\t\tvar pointsMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! pointsMaterial ) {\n\n\t\t\t\tpointsMaterial = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.P();\n\t\t\t\t_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.p.prototype.copy.call( pointsMaterial, material );\n\t\t\t\tpointsMaterial.color.copy( material.color );\n\t\t\t\tpointsMaterial.map = material.map;\n\t\t\t\tpointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n\t\t\t\tthis.cache.add( cacheKey, pointsMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = pointsMaterial;\n\n\t\t} else if ( mesh.isLine ) {\n\n\t\t\tvar cacheKey = 'LineBasicMaterial:' + material.uuid;\n\n\t\t\tvar lineMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! lineMaterial ) {\n\n\t\t\t\tlineMaterial = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.q();\n\t\t\t\t_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.p.prototype.copy.call( lineMaterial, material );\n\t\t\t\tlineMaterial.color.copy( material.color );\n\n\t\t\t\tthis.cache.add( cacheKey, lineMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = lineMaterial;\n\n\t\t}\n\n\t\t// Clone the material if it will be modified\n\t\tif ( useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets ) {\n\n\t\t\tvar cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n\n\t\t\tif ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:';\n\t\t\tif ( useSkinning ) cacheKey += 'skinning:';\n\t\t\tif ( useVertexTangents ) cacheKey += 'vertex-tangents:';\n\t\t\tif ( useVertexColors ) cacheKey += 'vertex-colors:';\n\t\t\tif ( useFlatShading ) cacheKey += 'flat-shading:';\n\t\t\tif ( useMorphTargets ) cacheKey += 'morph-targets:';\n\t\t\tif ( useMorphNormals ) cacheKey += 'morph-normals:';\n\n\t\t\tvar cachedMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! cachedMaterial ) {\n\n\t\t\t\tcachedMaterial = material.clone();\n\n\t\t\t\tif ( useSkinning ) cachedMaterial.skinning = true;\n\t\t\t\tif ( useVertexColors ) cachedMaterial.vertexColors = true;\n\t\t\t\tif ( useFlatShading ) cachedMaterial.flatShading = true;\n\t\t\t\tif ( useMorphTargets ) cachedMaterial.morphTargets = true;\n\t\t\t\tif ( useMorphNormals ) cachedMaterial.morphNormals = true;\n\n\t\t\t\tif ( useVertexTangents ) {\n\n\t\t\t\t\tcachedMaterial.vertexTangents = true;\n\n\t\t\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\t\tif ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;\n\t\t\t\t\tif ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;\n\n\t\t\t\t}\n\n\t\t\t\tthis.cache.add( cacheKey, cachedMaterial );\n\n\t\t\t\tthis.associations.set( cachedMaterial, this.associations.get( material ) );\n\n\t\t\t}\n\n\t\t\tmaterial = cachedMaterial;\n\n\t\t}\n\n\t\t// workarounds for mesh and geometry\n\n\t\tif ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {\n\n\t\t\tgeometry.setAttribute( 'uv2', geometry.attributes.uv );\n\n\t\t}\n\n\t\tmesh.material = material;\n\n\t};\n\n\tGLTFParser.prototype.getMaterialType = function ( /* materialIndex */ ) {\n\n\t\treturn _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.h;\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n\t * @param {number} materialIndex\n\t * @return {Promise<Material>}\n\t */\n\tGLTFParser.prototype.loadMaterial = function ( materialIndex ) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\t\tvar materialDef = json.materials[ materialIndex ];\n\n\t\tvar materialType;\n\t\tvar materialParams = {};\n\t\tvar materialExtensions = materialDef.extensions || {};\n\n\t\tvar pending = [];\n\n\t\tif ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {\n\n\t\t\tvar sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];\n\t\t\tmaterialType = sgExtension.getMaterialType();\n\t\t\tpending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {\n\n\t\t\tvar kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];\n\t\t\tmaterialType = kmuExtension.getMaterialType();\n\t\t\tpending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t} else {\n\n\t\t\t// Specification:\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n\t\t\tvar metallicRoughness = materialDef.pbrMetallicRoughness || {};\n\n\t\t\tmaterialParams.color = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.C( 1.0, 1.0, 1.0 );\n\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tvar array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );\n\n\t\t\t}\n\n\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n\t\t\tif ( metallicRoughness.metallicRoughnessTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\n\t\t\t}\n\n\t\t\tmaterialType = this._invokeOne( function ( ext ) {\n\n\t\t\t\treturn ext.getMaterialType && ext.getMaterialType( materialIndex );\n\n\t\t\t} );\n\n\t\t\tpending.push( Promise.all( this._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );\n\n\t\t\t} ) ) );\n\n\t\t}\n\n\t\tif ( materialDef.doubleSided === true ) {\n\n\t\t\tmaterialParams.side = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.D;\n\n\t\t}\n\n\t\tvar alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n\t\tif ( alphaMode === ALPHA_MODES.BLEND ) {\n\n\t\t\tmaterialParams.transparent = true;\n\n\t\t\t// See: https://github.com/mrdoob/three.js/issues/17706\n\t\t\tmaterialParams.depthWrite = false;\n\n\t\t} else {\n\n\t\t\tmaterialParams.transparent = false;\n\n\t\t\tif ( alphaMode === ALPHA_MODES.MASK ) {\n\n\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.normalTexture !== undefined && materialType !== _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.g ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );\n\n\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\tmaterialParams.normalScale = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a( 1, - 1 );\n\n\t\t\tif ( materialDef.normalTexture.scale !== undefined ) {\n\n\t\t\t\tmaterialParams.normalScale.set( materialDef.normalTexture.scale, - materialDef.normalTexture.scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.occlusionTexture !== undefined && materialType !== _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.g ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );\n\n\t\t\tif ( materialDef.occlusionTexture.strength !== undefined ) {\n\n\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.emissiveFactor !== undefined && materialType !== _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.g ) {\n\n\t\t\tmaterialParams.emissive = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( materialDef.emissiveFactor );\n\n\t\t}\n\n\t\tif ( materialDef.emissiveTexture !== undefined && materialType !== _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.g ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\tvar material;\n\n\t\t\tif ( materialType === GLTFMeshStandardSGMaterial ) {\n\n\t\t\t\tmaterial = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );\n\n\t\t\t} else {\n\n\t\t\t\tmaterial = new materialType( materialParams );\n\n\t\t\t}\n\n\t\t\tif ( materialDef.name ) material.name = materialDef.name;\n\n\t\t\t// baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\n\t\t\tif ( material.map ) material.map.encoding = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.s;\n\t\t\tif ( material.emissiveMap ) material.emissiveMap.encoding = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.s;\n\n\t\t\tassignExtrasToUserData( material, materialDef );\n\n\t\t\tparser.associations.set( material, { type: 'materials', index: materialIndex } );\n\n\t\t\tif ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );\n\n\t\t\treturn material;\n\n\t\t} );\n\n\t};\n\n\t/** When Object3D instances are targeted by animation, they need unique names. */\n\tGLTFParser.prototype.createUniqueName = function ( originalName ) {\n\n\t\tvar sanitizedName = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.r.sanitizeNodeName( originalName || '' );\n\n\t\tvar name = sanitizedName;\n\n\t\tfor ( var i = 1; this.nodeNamesUsed[ name ]; ++ i ) {\n\n\t\t\tname = sanitizedName + '_' + i;\n\n\t\t}\n\n\t\tthis.nodeNamesUsed[ name ] = true;\n\n\t\treturn name;\n\n\t};\n\n\t/**\n\t * @param {BufferGeometry} geometry\n\t * @param {GLTF.Primitive} primitiveDef\n\t * @param {GLTFParser} parser\n\t */\n\tfunction computeBounds( geometry, primitiveDef, parser ) {\n\n\t\tvar attributes = primitiveDef.attributes;\n\n\t\tvar box = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.af();\n\n\t\tif ( attributes.POSITION !== undefined ) {\n\n\t\t\tvar accessor = parser.json.accessors[ attributes.POSITION ];\n\n\t\t\tvar min = accessor.min;\n\t\t\tvar max = accessor.max;\n\n\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\t\tbox.set(\n\t\t\t\t\tnew _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V( min[ 0 ], min[ 1 ], min[ 2 ] ),\n\t\t\t\t\tnew _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V( max[ 0 ], max[ 1 ], max[ 2 ] ) );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar targets = primitiveDef.targets;\n\n\t\tif ( targets !== undefined ) {\n\n\t\t\tvar maxDisplacement = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\tvar vector = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\t\tvar target = targets[ i ];\n\n\t\t\t\tif ( target.POSITION !== undefined ) {\n\n\t\t\t\t\tvar accessor = parser.json.accessors[ target.POSITION ];\n\t\t\t\t\tvar min = accessor.min;\n\t\t\t\t\tvar max = accessor.max;\n\n\t\t\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\t\t\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\t\t\t\t// we need to get max of absolute components because target weight is [-1,1]\n\t\t\t\t\t\tvector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );\n\t\t\t\t\t\tvector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );\n\t\t\t\t\t\tvector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );\n\n\t\t\t\t\t\t// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n\t\t\t\t\t\t// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n\t\t\t\t\t\t// are used to implement key-frame animations and as such only two are active at a time - this results in very large\n\t\t\t\t\t\t// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n\t\t\t\t\t\tmaxDisplacement.max( vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n\t\t\tbox.expandByVector( maxDisplacement );\n\n\t\t}\n\n\t\tgeometry.boundingBox = box;\n\n\t\tvar sphere = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.ag();\n\n\t\tbox.getCenter( sphere.center );\n\t\tsphere.radius = box.min.distanceTo( box.max ) / 2;\n\n\t\tgeometry.boundingSphere = sphere;\n\n\t}\n\n\t/**\n\t * @param {BufferGeometry} geometry\n\t * @param {GLTF.Primitive} primitiveDef\n\t * @param {GLTFParser} parser\n\t * @return {Promise<BufferGeometry>}\n\t */\n\tfunction addPrimitiveAttributes( geometry, primitiveDef, parser ) {\n\n\t\tvar attributes = primitiveDef.attributes;\n\n\t\tvar pending = [];\n\n\t\tfunction assignAttributeAccessor( accessorIndex, attributeName ) {\n\n\t\t\treturn parser.getDependency( 'accessor', accessorIndex )\n\t\t\t\t.then( function ( accessor ) {\n\n\t\t\t\t\tgeometry.setAttribute( attributeName, accessor );\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\tfor ( var gltfAttributeName in attributes ) {\n\n\t\t\tvar threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();\n\n\t\t\t// Skip attributes already provided by e.g. Draco extension.\n\t\t\tif ( threeAttributeName in geometry.attributes ) continue;\n\n\t\t\tpending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );\n\n\t\t}\n\n\t\tif ( primitiveDef.indices !== undefined && ! geometry.index ) {\n\n\t\t\tvar accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {\n\n\t\t\t\tgeometry.setIndex( accessor );\n\n\t\t\t} );\n\n\t\t\tpending.push( accessor );\n\n\t\t}\n\n\t\tassignExtrasToUserData( geometry, primitiveDef );\n\n\t\tcomputeBounds( geometry, primitiveDef, parser );\n\n\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\treturn primitiveDef.targets !== undefined\n\t\t\t\t? addMorphTargets( geometry, primitiveDef.targets, parser )\n\t\t\t\t: geometry;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * @param {BufferGeometry} geometry\n\t * @param {Number} drawMode\n\t * @return {BufferGeometry}\n\t */\n\tfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\t\tvar index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tvar indices = [];\n\n\t\t\tvar position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( var i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tvar numberOfTriangles = index.count - 2;\n\t\tvar newIndices = [];\n\n\t\tif ( drawMode === _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aa ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( var i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( var i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tvar newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\n\t\treturn newGeometry;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n\t *\n\t * Creates BufferGeometries from primitives.\n\t *\n\t * @param {Array<GLTF.Primitive>} primitives\n\t * @return {Promise<Array<BufferGeometry>>}\n\t */\n\tGLTFParser.prototype.loadGeometries = function ( primitives ) {\n\n\t\tvar parser = this;\n\t\tvar extensions = this.extensions;\n\t\tvar cache = this.primitiveCache;\n\n\t\tfunction createDracoPrimitive( primitive ) {\n\n\t\t\treturn extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]\n\t\t\t\t.decodePrimitive( primitive, parser )\n\t\t\t\t.then( function ( geometry ) {\n\n\t\t\t\t\treturn addPrimitiveAttributes( geometry, primitive, parser );\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\tvar pending = [];\n\n\t\tfor ( var i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tvar primitive = primitives[ i ];\n\t\t\tvar cacheKey = createPrimitiveKey( primitive );\n\n\t\t\t// See if we've already created this geometry\n\t\t\tvar cached = cache[ cacheKey ];\n\n\t\t\tif ( cached ) {\n\n\t\t\t\t// Use the cached geometry if it exists\n\t\t\t\tpending.push( cached.promise );\n\n\t\t\t} else {\n\n\t\t\t\tvar geometryPromise;\n\n\t\t\t\tif ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {\n\n\t\t\t\t\t// Use DRACO geometry if available\n\t\t\t\t\tgeometryPromise = createDracoPrimitive( primitive );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Otherwise create a new geometry\n\t\t\t\t\tgeometryPromise = addPrimitiveAttributes( new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.B(), primitive, parser );\n\n\t\t\t\t}\n\n\t\t\t\t// Cache this geometry\n\t\t\t\tcache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };\n\n\t\t\t\tpending.push( geometryPromise );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n\t * @param {number} meshIndex\n\t * @return {Promise<Group|Mesh|SkinnedMesh>}\n\t */\n\tGLTFParser.prototype.loadMesh = function ( meshIndex ) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\n\t\tvar meshDef = json.meshes[ meshIndex ];\n\t\tvar primitives = meshDef.primitives;\n\n\t\tvar pending = [];\n\n\t\tfor ( var i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tvar material = primitives[ i ].material === undefined\n\t\t\t\t? createDefaultMaterial( this.cache )\n\t\t\t\t: this.getDependency( 'material', primitives[ i ].material );\n\n\t\t\tpending.push( material );\n\n\t\t}\n\n\t\tpending.push( parser.loadGeometries( primitives ) );\n\n\t\treturn Promise.all( pending ).then( function ( results ) {\n\n\t\t\tvar materials = results.slice( 0, results.length - 1 );\n\t\t\tvar geometries = results[ results.length - 1 ];\n\n\t\t\tvar meshes = [];\n\n\t\t\tfor ( var i = 0, il = geometries.length; i < il; i ++ ) {\n\n\t\t\t\tvar geometry = geometries[ i ];\n\t\t\t\tvar primitive = primitives[ i ];\n\n\t\t\t\t// 1. create Mesh\n\n\t\t\t\tvar mesh;\n\n\t\t\t\tvar material = materials[ i ];\n\n\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n\t\t\t\t\tprimitive.mode === undefined ) {\n\n\t\t\t\t\t// .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n\t\t\t\t\tmesh = meshDef.isSkinnedMesh === true\n\t\t\t\t\t\t? new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.t( geometry, material )\n\t\t\t\t\t\t: new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.v( geometry, material );\n\n\t\t\t\t\tif ( mesh.isSkinnedMesh === true && ! mesh.geometry.attributes.skinWeight.normalized ) {\n\n\t\t\t\t\t\t// we normalize floating point skin weight array to fix malformed assets (see #15319)\n\t\t\t\t\t\t// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs\n\t\t\t\t\t\tmesh.normalizeSkinWeights();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.ab );\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aa );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {\n\n\t\t\t\t\tmesh = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.w( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {\n\n\t\t\t\t\tmesh = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.x( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {\n\n\t\t\t\t\tmesh = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.y( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {\n\n\t\t\t\t\tmesh = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.z( geometry, material );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );\n\n\t\t\t\t}\n\n\t\t\t\tif ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {\n\n\t\t\t\t\tupdateMorphTargets( mesh, meshDef );\n\n\t\t\t\t}\n\n\t\t\t\tmesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );\n\n\t\t\t\tassignExtrasToUserData( mesh, meshDef );\n\n\t\t\t\tif ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );\n\n\t\t\t\tparser.assignFinalMaterial( mesh );\n\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t}\n\n\t\t\tif ( meshes.length === 1 ) {\n\n\t\t\t\treturn meshes[ 0 ];\n\n\t\t\t}\n\n\t\t\tvar group = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\n\t\t\tfor ( var i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\tgroup.add( meshes[ i ] );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n\t * @param {number} cameraIndex\n\t * @return {Promise<THREE.Camera>}\n\t */\n\tGLTFParser.prototype.loadCamera = function ( cameraIndex ) {\n\n\t\tvar camera;\n\t\tvar cameraDef = this.json.cameras[ cameraIndex ];\n\t\tvar params = cameraDef[ cameraDef.type ];\n\n\t\tif ( ! params ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing camera parameters.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( cameraDef.type === 'perspective' ) {\n\n\t\t\tcamera = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.A( _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.H.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );\n\n\t\t} else if ( cameraDef.type === 'orthographic' ) {\n\n\t\t\tcamera = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.O( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );\n\n\t\t}\n\n\t\tif ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );\n\n\t\tassignExtrasToUserData( camera, cameraDef );\n\n\t\treturn Promise.resolve( camera );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n\t * @param {number} skinIndex\n\t * @return {Promise<Object>}\n\t */\n\tGLTFParser.prototype.loadSkin = function ( skinIndex ) {\n\n\t\tvar skinDef = this.json.skins[ skinIndex ];\n\n\t\tvar skinEntry = { joints: skinDef.joints };\n\n\t\tif ( skinDef.inverseBindMatrices === undefined ) {\n\n\t\t\treturn Promise.resolve( skinEntry );\n\n\t\t}\n\n\t\treturn this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {\n\n\t\t\tskinEntry.inverseBindMatrices = accessor;\n\n\t\t\treturn skinEntry;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n\t * @param {number} animationIndex\n\t * @return {Promise<AnimationClip>}\n\t */\n\tGLTFParser.prototype.loadAnimation = function ( animationIndex ) {\n\n\t\tvar json = this.json;\n\n\t\tvar animationDef = json.animations[ animationIndex ];\n\n\t\tvar pendingNodes = [];\n\t\tvar pendingInputAccessors = [];\n\t\tvar pendingOutputAccessors = [];\n\t\tvar pendingSamplers = [];\n\t\tvar pendingTargets = [];\n\n\t\tfor ( var i = 0, il = animationDef.channels.length; i < il; i ++ ) {\n\n\t\t\tvar channel = animationDef.channels[ i ];\n\t\t\tvar sampler = animationDef.samplers[ channel.sampler ];\n\t\t\tvar target = channel.target;\n\t\t\tvar name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n\t\t\tvar input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\n\t\t\tvar output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\n\n\t\t\tpendingNodes.push( this.getDependency( 'node', name ) );\n\t\t\tpendingInputAccessors.push( this.getDependency( 'accessor', input ) );\n\t\t\tpendingOutputAccessors.push( this.getDependency( 'accessor', output ) );\n\t\t\tpendingSamplers.push( sampler );\n\t\t\tpendingTargets.push( target );\n\n\t\t}\n\n\t\treturn Promise.all( [\n\n\t\t\tPromise.all( pendingNodes ),\n\t\t\tPromise.all( pendingInputAccessors ),\n\t\t\tPromise.all( pendingOutputAccessors ),\n\t\t\tPromise.all( pendingSamplers ),\n\t\t\tPromise.all( pendingTargets )\n\n\t\t] ).then( function ( dependencies ) {\n\n\t\t\tvar nodes = dependencies[ 0 ];\n\t\t\tvar inputAccessors = dependencies[ 1 ];\n\t\t\tvar outputAccessors = dependencies[ 2 ];\n\t\t\tvar samplers = dependencies[ 3 ];\n\t\t\tvar targets = dependencies[ 4 ];\n\n\t\t\tvar tracks = [];\n\n\t\t\tfor ( var i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\tvar node = nodes[ i ];\n\t\t\t\tvar inputAccessor = inputAccessors[ i ];\n\t\t\t\tvar outputAccessor = outputAccessors[ i ];\n\t\t\t\tvar sampler = samplers[ i ];\n\t\t\t\tvar target = targets[ i ];\n\n\t\t\t\tif ( node === undefined ) continue;\n\n\t\t\t\tnode.updateMatrix();\n\t\t\t\tnode.matrixAutoUpdate = true;\n\n\t\t\t\tvar TypedKeyframeTrack;\n\n\t\t\t\tswitch ( PATH_PROPERTIES[ target.path ] ) {\n\n\t\t\t\t\tcase PATH_PROPERTIES.weights:\n\n\t\t\t\t\t\tTypedKeyframeTrack = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.ae;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase PATH_PROPERTIES.rotation:\n\n\t\t\t\t\t\tTypedKeyframeTrack = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.ad;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase PATH_PROPERTIES.position:\n\t\t\t\t\tcase PATH_PROPERTIES.scale:\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tTypedKeyframeTrack = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.ac;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tvar targetName = node.name ? node.name : node.uuid;\n\n\t\t\t\tvar interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.J;\n\n\t\t\t\tvar targetNames = [];\n\n\t\t\t\tif ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {\n\n\t\t\t\t\t// Node may be a Group (glTF mesh with several primitives) or a Mesh.\n\t\t\t\t\tnode.traverse( function ( object ) {\n\n\t\t\t\t\t\tif ( object.isMesh === true && object.morphTargetInfluences ) {\n\n\t\t\t\t\t\t\ttargetNames.push( object.name ? object.name : object.uuid );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetNames.push( targetName );\n\n\t\t\t\t}\n\n\t\t\t\tvar outputArray = outputAccessor.array;\n\n\t\t\t\tif ( outputAccessor.normalized ) {\n\n\t\t\t\t\tvar scale;\n\n\t\t\t\t\tif ( outputArray.constructor === Int8Array ) {\n\n\t\t\t\t\t\tscale = 1 / 127;\n\n\t\t\t\t\t} else if ( outputArray.constructor === Uint8Array ) {\n\n\t\t\t\t\t\tscale = 1 / 255;\n\n\t\t\t\t\t} else if ( outputArray.constructor == Int16Array ) {\n\n\t\t\t\t\t\tscale = 1 / 32767;\n\n\t\t\t\t\t} else if ( outputArray.constructor === Uint16Array ) {\n\n\t\t\t\t\t\tscale = 1 / 65535;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported output accessor component type.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar scaled = new Float32Array( outputArray.length );\n\n\t\t\t\t\tfor ( var j = 0, jl = outputArray.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tscaled[ j ] = outputArray[ j ] * scale;\n\n\t\t\t\t\t}\n\n\t\t\t\t\toutputArray = scaled;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0, jl = targetNames.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar track = new TypedKeyframeTrack(\n\t\t\t\t\t\ttargetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],\n\t\t\t\t\t\tinputAccessor.array,\n\t\t\t\t\t\toutputArray,\n\t\t\t\t\t\tinterpolation\n\t\t\t\t\t);\n\n\t\t\t\t\t// Override interpolation with custom factory method.\n\t\t\t\t\tif ( sampler.interpolation === 'CUBICSPLINE' ) {\n\n\t\t\t\t\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {\n\n\t\t\t\t\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\n\t\t\t\t\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n\t\t\t\t\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\n\n\t\t\t\t\t\t\treturn new GLTFCubicSplineInterpolant( this.times, this.values, this.getValueSize() / 3, result );\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\t\t\t\t\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( track );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\n\n\t\t\treturn new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.K( name, undefined, tracks );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n\t * @param {number} nodeIndex\n\t * @return {Promise<Object3D>}\n\t */\n\tGLTFParser.prototype.loadNode = function ( nodeIndex ) {\n\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\t\tvar parser = this;\n\n\t\tvar nodeDef = json.nodes[ nodeIndex ];\n\n\t\t// reserve node's name before its dependencies, so the root has the intended name.\n\t\tvar nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';\n\n\t\treturn ( function () {\n\n\t\t\tvar pending = [];\n\n\t\t\tif ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\tpending.push( parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {\n\n\t\t\t\t\tvar node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );\n\n\t\t\t\t\t// if weights are provided on the node, override weights on the mesh.\n\t\t\t\t\tif ( nodeDef.weights !== undefined ) {\n\n\t\t\t\t\t\tnode.traverse( function ( o ) {\n\n\t\t\t\t\t\t\tif ( ! o.isMesh ) return;\n\n\t\t\t\t\t\t\tfor ( var i = 0, il = nodeDef.weights.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\t\to.morphTargetInfluences[ i ] = nodeDef.weights[ i ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn node;\n\n\t\t\t\t} ) );\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\t\tpending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {\n\n\t\t\t\t\treturn parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );\n\n\t\t\t\t} ) );\n\n\t\t\t}\n\n\t\t\tparser._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );\n\n\t\t\t} ).forEach( function ( promise ) {\n\n\t\t\t\tpending.push( promise );\n\n\t\t\t} );\n\n\t\t\treturn Promise.all( pending );\n\n\t\t}() ).then( function ( objects ) {\n\n\t\t\tvar node;\n\n\t\t\t// .isBone isn't in glTF spec. See ._markDefs\n\t\t\tif ( nodeDef.isBone === true ) {\n\n\t\t\t\tnode = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.N();\n\n\t\t\t} else if ( objects.length > 1 ) {\n\n\t\t\t\tnode = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\n\t\t\t} else if ( objects.length === 1 ) {\n\n\t\t\t\tnode = objects[ 0 ];\n\n\t\t\t} else {\n\n\t\t\t\tnode = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.U();\n\n\t\t\t}\n\n\t\t\tif ( node !== objects[ 0 ] ) {\n\n\t\t\t\tfor ( var i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\t\t\tnode.add( objects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.name ) {\n\n\t\t\t\tnode.userData.name = nodeDef.name;\n\t\t\t\tnode.name = nodeName;\n\n\t\t\t}\n\n\t\t\tassignExtrasToUserData( node, nodeDef );\n\n\t\t\tif ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );\n\n\t\t\tif ( nodeDef.matrix !== undefined ) {\n\n\t\t\t\tvar matrix = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\t\t\tmatrix.fromArray( nodeDef.matrix );\n\t\t\t\tnode.applyMatrix4( matrix );\n\n\t\t\t} else {\n\n\t\t\t\tif ( nodeDef.translation !== undefined ) {\n\n\t\t\t\t\tnode.position.fromArray( nodeDef.translation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.rotation !== undefined ) {\n\n\t\t\t\t\tnode.quaternion.fromArray( nodeDef.rotation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.scale !== undefined ) {\n\n\t\t\t\t\tnode.scale.fromArray( nodeDef.scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tparser.associations.set( node, { type: 'nodes', index: nodeIndex } );\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n\t * @param {number} sceneIndex\n\t * @return {Promise<Group>}\n\t */\n\tGLTFParser.prototype.loadScene = function () {\n\n\t\t// scene node hierachy builder\n\n\t\tfunction buildNodeHierachy( nodeId, parentObject, json, parser ) {\n\n\t\t\tvar nodeDef = json.nodes[ nodeId ];\n\n\t\t\treturn parser.getDependency( 'node', nodeId ).then( function ( node ) {\n\n\t\t\t\tif ( nodeDef.skin === undefined ) return node;\n\n\t\t\t\t// build skeleton here as well\n\n\t\t\t\tvar skinEntry;\n\n\t\t\t\treturn parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {\n\n\t\t\t\t\tskinEntry = skin;\n\n\t\t\t\t\tvar pendingJoints = [];\n\n\t\t\t\t\tfor ( var i = 0, il = skinEntry.joints.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tpendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Promise.all( pendingJoints );\n\n\t\t\t\t} ).then( function ( jointNodes ) {\n\n\t\t\t\t\tnode.traverse( function ( mesh ) {\n\n\t\t\t\t\t\tif ( ! mesh.isMesh ) return;\n\n\t\t\t\t\t\tvar bones = [];\n\t\t\t\t\t\tvar boneInverses = [];\n\n\t\t\t\t\t\tfor ( var j = 0, jl = jointNodes.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tvar jointNode = jointNodes[ j ];\n\n\t\t\t\t\t\t\tif ( jointNode ) {\n\n\t\t\t\t\t\t\t\tbones.push( jointNode );\n\n\t\t\t\t\t\t\t\tvar mat = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\n\t\t\t\t\t\t\t\tif ( skinEntry.inverseBindMatrices !== undefined ) {\n\n\t\t\t\t\t\t\t\t\tmat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tboneInverses.push( mat );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[ j ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmesh.bind( new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.X( bones, boneInverses ), mesh.matrixWorld );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\treturn node;\n\n\t\t\t\t} );\n\n\t\t\t} ).then( function ( node ) {\n\n\t\t\t\t// build node hierachy\n\n\t\t\t\tparentObject.add( node );\n\n\t\t\t\tvar pending = [];\n\n\t\t\t\tif ( nodeDef.children ) {\n\n\t\t\t\t\tvar children = nodeDef.children;\n\n\t\t\t\t\tfor ( var i = 0, il = children.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar child = children[ i ];\n\t\t\t\t\t\tpending.push( buildNodeHierachy( child, node, json, parser ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn Promise.all( pending );\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn function loadScene( sceneIndex ) {\n\n\t\t\tvar json = this.json;\n\t\t\tvar extensions = this.extensions;\n\t\t\tvar sceneDef = this.json.scenes[ sceneIndex ];\n\t\t\tvar parser = this;\n\n\t\t\t// Loader returns Group, not Scene.\n\t\t\t// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n\t\t\tvar scene = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\t\t\tif ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );\n\n\t\t\tassignExtrasToUserData( scene, sceneDef );\n\n\t\t\tif ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );\n\n\t\t\tvar nodeIds = sceneDef.nodes || [];\n\n\t\t\tvar pending = [];\n\n\t\t\tfor ( var i = 0, il = nodeIds.length; i < il; i ++ ) {\n\n\t\t\t\tpending.push( buildNodeHierachy( nodeIds[ i ], scene, json, parser ) );\n\n\t\t\t}\n\n\t\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\t\treturn scene;\n\n\t\t\t} );\n\n\t\t};\n\n\t}();\n\n\treturn GLTFLoader;\n\n} )();\n\nvar TGALoader = function ( manager ) {\n\n\t_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n};\n\nTGALoader.prototype = Object.assign( Object.create( _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\tconstructor: TGALoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar texture = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.ah();\n\n\t\tvar loader = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.F( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setPath( this.path );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\ttexture.image = scope.parse( buffer );\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t},\n\n\tparse: function ( buffer ) {\n\n\t\t// reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\n\n\t\tfunction tgaCheckHeader( header ) {\n\n\t\t\tswitch ( header.image_type ) {\n\n\t\t\t\t// check indexed type\n\n\t\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\t\tif ( header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1 ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid type colormap data for indexed type.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// check colormap type\n\n\t\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\t\tif ( header.colormap_type ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid type colormap data for colormap type.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// What the need of a file without data ?\n\n\t\t\t\tcase TGA_TYPE_NO_DATA:\n\t\t\t\t\tconsole.error( 'THREE.TGALoader: No data.' );\n\n\t\t\t\t\t// Invalid type ?\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid type \"%s\".', header.image_type );\n\n\t\t\t}\n\n\t\t\t// check image width and height\n\n\t\t\tif ( header.width <= 0 || header.height <= 0 ) {\n\n\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid image size.' );\n\n\t\t\t}\n\n\t\t\t// check image pixel size\n\n\t\t\tif ( header.pixel_size !== 8 && header.pixel_size !== 16 &&\n\t\t\t\theader.pixel_size !== 24 && header.pixel_size !== 32 ) {\n\n\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid pixel size \"%s\".', header.pixel_size );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// parse tga image buffer\n\n\t\tfunction tgaParse( use_rle, use_pal, header, offset, data ) {\n\n\t\t\tvar pixel_data,\n\t\t\t\tpixel_size,\n\t\t\t\tpixel_total,\n\t\t\t\tpalettes;\n\n\t\t\tpixel_size = header.pixel_size >> 3;\n\t\t\tpixel_total = header.width * header.height * pixel_size;\n\n\t\t\t // read palettes\n\n\t\t\t if ( use_pal ) {\n\n\t\t\t\t palettes = data.subarray( offset, offset += header.colormap_length * ( header.colormap_size >> 3 ) );\n\n\t\t\t }\n\n\t\t\t // read RLE\n\n\t\t\t if ( use_rle ) {\n\n\t\t\t\t pixel_data = new Uint8Array( pixel_total );\n\n\t\t\t\tvar c, count, i;\n\t\t\t\tvar shift = 0;\n\t\t\t\tvar pixels = new Uint8Array( pixel_size );\n\n\t\t\t\twhile ( shift < pixel_total ) {\n\n\t\t\t\t\tc = data[ offset ++ ];\n\t\t\t\t\tcount = ( c & 0x7f ) + 1;\n\n\t\t\t\t\t// RLE pixels\n\n\t\t\t\t\tif ( c & 0x80 ) {\n\n\t\t\t\t\t\t// bind pixel tmp array\n\n\t\t\t\t\t\tfor ( i = 0; i < pixel_size; ++ i ) {\n\n\t\t\t\t\t\t\tpixels[ i ] = data[ offset ++ ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// copy pixel array\n\n\t\t\t\t\t\tfor ( i = 0; i < count; ++ i ) {\n\n\t\t\t\t\t\t\tpixel_data.set( pixels, shift + i * pixel_size );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tshift += pixel_size * count;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// raw pixels\n\n\t\t\t\t\t\tcount *= pixel_size;\n\n\t\t\t\t\t\tfor ( i = 0; i < count; ++ i ) {\n\n\t\t\t\t\t\t\tpixel_data[ shift + i ] = data[ offset ++ ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tshift += count;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t } else {\n\n\t\t\t\t// raw pixels\n\n\t\t\t\tpixel_data = data.subarray(\n\t\t\t\t\t offset, offset += ( use_pal ? header.width * header.height : pixel_total )\n\t\t\t\t);\n\n\t\t\t }\n\n\t\t\t return {\n\t\t\t\tpixel_data: pixel_data,\n\t\t\t\tpalettes: palettes\n\t\t\t };\n\n\t\t}\n\n\t\tfunction tgaGetImageData8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes ) {\n\n\t\t\tvar colormap = palettes;\n\t\t\tvar color, i = 0, x, y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i ++ ) {\n\n\t\t\t\t\tcolor = image[ i ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = colormap[ ( color * 3 ) + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = colormap[ ( color * 3 ) + 1 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = colormap[ ( color * 3 ) + 2 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageData16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tvar color, i = 0, x, y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\n\n\t\t\t\t\tcolor = image[ i + 0 ] + ( image[ i + 1 ] << 8 ); // Inversed ?\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = ( color & 0x7C00 ) >> 7;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = ( color & 0x03E0 ) >> 2;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = ( color & 0x001F ) >> 3;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = ( color & 0x8000 ) ? 0 : 255;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageData24bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tvar i = 0, x, y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 3 ) {\n\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageData32bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tvar i = 0, x, y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 4 ) {\n\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 3 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageDataGrey8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tvar color, i = 0, x, y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i ++ ) {\n\n\t\t\t\t\tcolor = image[ i ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = color;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = color;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = color;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageDataGrey16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tvar i = 0, x, y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\n\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 1 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction getTgaRGBA( data, width, height, image, palette ) {\n\n\t\t\tvar x_start,\n\t\t\t\ty_start,\n\t\t\t\tx_step,\n\t\t\t\ty_step,\n\t\t\t\tx_end,\n\t\t\t\ty_end;\n\n\t\t\tswitch ( ( header.flags & TGA_ORIGIN_MASK ) >> TGA_ORIGIN_SHIFT ) {\n\n\t\t\t\tdefault:\n\t\t\t\tcase TGA_ORIGIN_UL:\n\t\t\t\t\tx_start = 0;\n\t\t\t\t\tx_step = 1;\n\t\t\t\t\tx_end = width;\n\t\t\t\t\ty_start = 0;\n\t\t\t\t\ty_step = 1;\n\t\t\t\t\ty_end = height;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_BL:\n\t\t\t\t\tx_start = 0;\n\t\t\t\t\tx_step = 1;\n\t\t\t\t\tx_end = width;\n\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\ty_step = - 1;\n\t\t\t\t\ty_end = - 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_UR:\n\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\tx_step = - 1;\n\t\t\t\t\tx_end = - 1;\n\t\t\t\t\ty_start = 0;\n\t\t\t\t\ty_step = 1;\n\t\t\t\t\ty_end = height;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_BR:\n\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\tx_step = - 1;\n\t\t\t\t\tx_end = - 1;\n\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\ty_step = - 1;\n\t\t\t\t\ty_end = - 1;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( use_grey ) {\n\n\t\t\t\tswitch ( header.pixel_size ) {\n\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\ttgaGetImageDataGrey8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\ttgaGetImageDataGrey16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Format not supported.' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tswitch ( header.pixel_size ) {\n\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\ttgaGetImageData8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\ttgaGetImageData16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 24:\n\t\t\t\t\t\ttgaGetImageData24bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 32:\n\t\t\t\t\t\ttgaGetImageData32bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Format not supported.' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Load image data according to specific method\n\t\t\t// var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n\t\t\t// func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// TGA constants\n\n\t\tvar TGA_TYPE_NO_DATA = 0,\n\t\t\tTGA_TYPE_INDEXED = 1,\n\t\t\tTGA_TYPE_RGB = 2,\n\t\t\tTGA_TYPE_GREY = 3,\n\t\t\tTGA_TYPE_RLE_INDEXED = 9,\n\t\t\tTGA_TYPE_RLE_RGB = 10,\n\t\t\tTGA_TYPE_RLE_GREY = 11,\n\n\t\t\tTGA_ORIGIN_MASK = 0x30,\n\t\t\tTGA_ORIGIN_SHIFT = 0x04,\n\t\t\tTGA_ORIGIN_BL = 0x00,\n\t\t\tTGA_ORIGIN_BR = 0x01,\n\t\t\tTGA_ORIGIN_UL = 0x02,\n\t\t\tTGA_ORIGIN_UR = 0x03;\n\n\t\tif ( buffer.length < 19 ) console.error( 'THREE.TGALoader: Not enough data to contain header.' );\n\n\t\tvar content = new Uint8Array( buffer ),\n\t\t\toffset = 0,\n\t\t\theader = {\n\t\t\t\tid_length: content[ offset ++ ],\n\t\t\t\tcolormap_type: content[ offset ++ ],\n\t\t\t\timage_type: content[ offset ++ ],\n\t\t\t\tcolormap_index: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\tcolormap_length: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\tcolormap_size: content[ offset ++ ],\n\t\t\t\torigin: [\n\t\t\t\t\tcontent[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\t\tcontent[ offset ++ ] | content[ offset ++ ] << 8\n\t\t\t\t],\n\t\t\t\twidth: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\theight: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\tpixel_size: content[ offset ++ ],\n\t\t\t\tflags: content[ offset ++ ]\n\t\t\t};\n\n\t\t// check tga if it is valid format\n\n\t\ttgaCheckHeader( header );\n\n\t\tif ( header.id_length + offset > buffer.length ) {\n\n\t\t\tconsole.error( 'THREE.TGALoader: No data.' );\n\n\t\t}\n\n\t\t// skip the needn't data\n\n\t\toffset += header.id_length;\n\n\t\t// get targa information about RLE compression and palette\n\n\t\tvar use_rle = false,\n\t\t\tuse_pal = false,\n\t\t\tuse_grey = false;\n\n\t\tswitch ( header.image_type ) {\n\n\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\tuse_rle = true;\n\t\t\t\tuse_pal = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\tuse_pal = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\tuse_rle = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\tuse_rle = true;\n\t\t\t\tuse_grey = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\tuse_grey = true;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t//\n\n\t\tvar useOffscreen = typeof OffscreenCanvas !== 'undefined';\n\n\t\tvar canvas = useOffscreen ? new OffscreenCanvas( header.width, header.height ) : document.createElement( 'canvas' );\n\t\tcanvas.width = header.width;\n\t\tcanvas.height = header.height;\n\n\t\tvar context = canvas.getContext( '2d' );\n\t\tvar imageData = context.createImageData( header.width, header.height );\n\n\t\tvar result = tgaParse( use_rle, use_pal, header, offset, content );\n\t\tgetTgaRGBA( imageData.data, header.width, header.height, result.pixel_data, result.palettes );\n\n\t\tcontext.putImageData( imageData, 0, 0 );\n\n\t\treturn canvas;\n\n\t}\n\n} );\n\nvar ColladaLoader = function ( manager ) {\n\n\t_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n};\n\nColladaLoader.prototype = Object.assign( Object.create( _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\tconstructor: ColladaLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar path = ( scope.path === '' ) ? _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.f.extractUrlBase( url ) : scope.path;\n\n\t\tvar loader = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.F( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text, path ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\toptions: {\n\n\t\tset convertUpAxis( value ) {\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.' );\n\n\t\t}\n\n\t},\n\n\tparse: function ( text, path ) {\n\n\t\tfunction getElementsByTagName( xml, name ) {\n\n\t\t\t// Non recursive xml.getElementsByTagName() ...\n\n\t\t\tvar array = [];\n\t\t\tvar childNodes = xml.childNodes;\n\n\t\t\tfor ( var i = 0, l = childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = childNodes[ i ];\n\n\t\t\t\tif ( child.nodeName === name ) {\n\n\t\t\t\t\tarray.push( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseStrings( text ) {\n\n\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\tvar parts = text.trim().split( /\\s+/ );\n\t\t\tvar array = new Array( parts.length );\n\n\t\t\tfor ( var i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ] = parts[ i ];\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseFloats( text ) {\n\n\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\tvar parts = text.trim().split( /\\s+/ );\n\t\t\tvar array = new Array( parts.length );\n\n\t\t\tfor ( var i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ] = parseFloat( parts[ i ] );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseInts( text ) {\n\n\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\tvar parts = text.trim().split( /\\s+/ );\n\t\t\tvar array = new Array( parts.length );\n\n\t\t\tfor ( var i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ] = parseInt( parts[ i ] );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseId( text ) {\n\n\t\t\treturn text.substring( 1 );\n\n\t\t}\n\n\t\tfunction generateId() {\n\n\t\t\treturn 'three_default_' + ( count ++ );\n\n\t\t}\n\n\t\tfunction isEmpty( object ) {\n\n\t\t\treturn Object.keys( object ).length === 0;\n\n\t\t}\n\n\t\t// asset\n\n\t\tfunction parseAsset( xml ) {\n\n\t\t\treturn {\n\t\t\t\tunit: parseAssetUnit( getElementsByTagName( xml, 'unit' )[ 0 ] ),\n\t\t\t\tupAxis: parseAssetUpAxis( getElementsByTagName( xml, 'up_axis' )[ 0 ] )\n\t\t\t};\n\n\t\t}\n\n\t\tfunction parseAssetUnit( xml ) {\n\n\t\t\tif ( ( xml !== undefined ) && ( xml.hasAttribute( 'meter' ) === true ) ) {\n\n\t\t\t\treturn parseFloat( xml.getAttribute( 'meter' ) );\n\n\t\t\t} else {\n\n\t\t\t\treturn 1; // default 1 meter\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseAssetUpAxis( xml ) {\n\n\t\t\treturn xml !== undefined ? xml.textContent : 'Y_UP';\n\n\t\t}\n\n\t\t// library\n\n\t\tfunction parseLibrary( xml, libraryName, nodeName, parser ) {\n\n\t\t\tvar library = getElementsByTagName( xml, libraryName )[ 0 ];\n\n\t\t\tif ( library !== undefined ) {\n\n\t\t\t\tvar elements = getElementsByTagName( library, nodeName );\n\n\t\t\t\tfor ( var i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\t\tparser( elements[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildLibrary( data, builder ) {\n\n\t\t\tfor ( var name in data ) {\n\n\t\t\t\tvar object = data[ name ];\n\t\t\t\tobject.build = builder( data[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// get\n\n\t\tfunction getBuild( data, builder ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\tdata.build = builder( data );\n\n\t\t\treturn data.build;\n\n\t\t}\n\n\t\t// animation\n\n\t\tfunction parseAnimation( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tsources: {},\n\t\t\t\tsamplers: {},\n\t\t\t\tchannels: {}\n\t\t\t};\n\n\t\t\tvar hasChildren = false;\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tvar id;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tid = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'sampler':\n\t\t\t\t\t\tid = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.samplers[ id ] = parseAnimationSampler( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'channel':\n\t\t\t\t\t\tid = child.getAttribute( 'target' );\n\t\t\t\t\t\tdata.channels[ id ] = parseAnimationChannel( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'animation':\n\t\t\t\t\t\t// hierarchy of related animations\n\t\t\t\t\t\tparseAnimation( child );\n\t\t\t\t\t\thasChildren = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasChildren === false ) {\n\n\t\t\t\t// since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment\n\n\t\t\t\tlibrary.animations[ xml.getAttribute( 'id' ) || _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.H.generateUUID() ] = data;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseAnimationSampler( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tinputs: {},\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tdata.inputs[ semantic ] = id;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseAnimationChannel( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tvar target = xml.getAttribute( 'target' );\n\n\t\t\t// parsing SID Addressing Syntax\n\n\t\t\tvar parts = target.split( '/' );\n\n\t\t\tvar id = parts.shift();\n\t\t\tvar sid = parts.shift();\n\n\t\t\t// check selection syntax\n\n\t\t\tvar arraySyntax = ( sid.indexOf( '(' ) !== - 1 );\n\t\t\tvar memberSyntax = ( sid.indexOf( '.' ) !== - 1 );\n\n\t\t\tif ( memberSyntax ) {\n\n\t\t\t\t//  member selection access\n\n\t\t\t\tparts = sid.split( '.' );\n\t\t\t\tsid = parts.shift();\n\t\t\t\tdata.member = parts.shift();\n\n\t\t\t} else if ( arraySyntax ) {\n\n\t\t\t\t// array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n\n\t\t\t\tvar indices = sid.split( '(' );\n\t\t\t\tsid = indices.shift();\n\n\t\t\t\tfor ( var i = 0; i < indices.length; i ++ ) {\n\n\t\t\t\t\tindices[ i ] = parseInt( indices[ i ].replace( /\\)/, '' ) );\n\n\t\t\t\t}\n\n\t\t\t\tdata.indices = indices;\n\n\t\t\t}\n\n\t\t\tdata.id = id;\n\t\t\tdata.sid = sid;\n\n\t\t\tdata.arraySyntax = arraySyntax;\n\t\t\tdata.memberSyntax = memberSyntax;\n\n\t\t\tdata.sampler = parseId( xml.getAttribute( 'source' ) );\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildAnimation( data ) {\n\n\t\t\tvar tracks = [];\n\n\t\t\tvar channels = data.channels;\n\t\t\tvar samplers = data.samplers;\n\t\t\tvar sources = data.sources;\n\n\t\t\tfor ( var target in channels ) {\n\n\t\t\t\tif ( channels.hasOwnProperty( target ) ) {\n\n\t\t\t\t\tvar channel = channels[ target ];\n\t\t\t\t\tvar sampler = samplers[ channel.sampler ];\n\n\t\t\t\t\tvar inputId = sampler.inputs.INPUT;\n\t\t\t\t\tvar outputId = sampler.inputs.OUTPUT;\n\n\t\t\t\t\tvar inputSource = sources[ inputId ];\n\t\t\t\t\tvar outputSource = sources[ outputId ];\n\n\t\t\t\t\tvar animation = buildAnimationChannel( channel, inputSource, outputSource );\n\n\t\t\t\t\tcreateKeyframeTracks( animation, tracks );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn tracks;\n\n\t\t}\n\n\t\tfunction getAnimation( id ) {\n\n\t\t\treturn getBuild( library.animations[ id ], buildAnimation );\n\n\t\t}\n\n\t\tfunction buildAnimationChannel( channel, inputSource, outputSource ) {\n\n\t\t\tvar node = library.nodes[ channel.id ];\n\t\t\tvar object3D = getNode( node.id );\n\n\t\t\tvar transform = node.transforms[ channel.sid ];\n\t\t\tvar defaultMatrix = node.matrix.clone().transpose();\n\n\t\t\tvar time, stride;\n\t\t\tvar i, il, j, jl;\n\n\t\t\tvar data = {};\n\n\t\t\t// the collada spec allows the animation of data in various ways.\n\t\t\t// depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n\t\t\tswitch ( transform ) {\n\n\t\t\t\tcase 'matrix':\n\n\t\t\t\t\tfor ( i = 0, il = inputSource.array.length; i < il; i ++ ) {\n\n\t\t\t\t\t\ttime = inputSource.array[ i ];\n\t\t\t\t\t\tstride = i * outputSource.stride;\n\n\t\t\t\t\t\tif ( data[ time ] === undefined ) data[ time ] = {};\n\n\t\t\t\t\t\tif ( channel.arraySyntax === true ) {\n\n\t\t\t\t\t\t\tvar value = outputSource.array[ stride ];\n\t\t\t\t\t\t\tvar index = channel.indices[ 0 ] + 4 * channel.indices[ 1 ];\n\n\t\t\t\t\t\t\tdata[ time ][ index ] = value;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( j = 0, jl = outputSource.stride; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tdata[ time ][ j ] = outputSource.array[ stride + j ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'translate':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'scale':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tvar keyframes = prepareAnimationData( data, defaultMatrix );\n\n\t\t\tvar animation = {\n\t\t\t\tname: object3D.uuid,\n\t\t\t\tkeyframes: keyframes\n\t\t\t};\n\n\t\t\treturn animation;\n\n\t\t}\n\n\t\tfunction prepareAnimationData( data, defaultMatrix ) {\n\n\t\t\tvar keyframes = [];\n\n\t\t\t// transfer data into a sortable array\n\n\t\t\tfor ( var time in data ) {\n\n\t\t\t\tkeyframes.push( { time: parseFloat( time ), value: data[ time ] } );\n\n\t\t\t}\n\n\t\t\t// ensure keyframes are sorted by time\n\n\t\t\tkeyframes.sort( ascending );\n\n\t\t\t// now we clean up all animation data, so we can use them for keyframe tracks\n\n\t\t\tfor ( var i = 0; i < 16; i ++ ) {\n\n\t\t\t\ttransformAnimationData( keyframes, i, defaultMatrix.elements[ i ] );\n\n\t\t\t}\n\n\t\t\treturn keyframes;\n\n\t\t\t// array sort function\n\n\t\t\tfunction ascending( a, b ) {\n\n\t\t\t\treturn a.time - b.time;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar position = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\tvar scale = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\tvar quaternion = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.Q();\n\n\t\tfunction createKeyframeTracks( animation, tracks ) {\n\n\t\t\tvar keyframes = animation.keyframes;\n\t\t\tvar name = animation.name;\n\n\t\t\tvar times = [];\n\t\t\tvar positionData = [];\n\t\t\tvar quaternionData = [];\n\t\t\tvar scaleData = [];\n\n\t\t\tfor ( var i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\tvar keyframe = keyframes[ i ];\n\n\t\t\t\tvar time = keyframe.time;\n\t\t\t\tvar value = keyframe.value;\n\n\t\t\t\tmatrix.fromArray( value ).transpose();\n\t\t\t\tmatrix.decompose( position, quaternion, scale );\n\n\t\t\t\ttimes.push( time );\n\t\t\t\tpositionData.push( position.x, position.y, position.z );\n\t\t\t\tquaternionData.push( quaternion.x, quaternion.y, quaternion.z, quaternion.w );\n\t\t\t\tscaleData.push( scale.x, scale.y, scale.z );\n\n\t\t\t}\n\n\t\t\tif ( positionData.length > 0 ) tracks.push( new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.ac( name + '.position', times, positionData ) );\n\t\t\tif ( quaternionData.length > 0 ) tracks.push( new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.ad( name + '.quaternion', times, quaternionData ) );\n\t\t\tif ( scaleData.length > 0 ) tracks.push( new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.ac( name + '.scale', times, scaleData ) );\n\n\t\t\treturn tracks;\n\n\t\t}\n\n\t\tfunction transformAnimationData( keyframes, property, defaultValue ) {\n\n\t\t\tvar keyframe;\n\n\t\t\tvar empty = true;\n\t\t\tvar i, l;\n\n\t\t\t// check, if values of a property are missing in our keyframes\n\n\t\t\tfor ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\tkeyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] === undefined ) {\n\n\t\t\t\t\tkeyframe.value[ property ] = null; // mark as missing\n\n\t\t\t\t} else {\n\n\t\t\t\t\tempty = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( empty === true ) {\n\n\t\t\t\t// no values at all, so we set a default value\n\n\t\t\t\tfor ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\t\tkeyframe = keyframes[ i ];\n\n\t\t\t\t\tkeyframe.value[ property ] = defaultValue;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// filling gaps\n\n\t\t\t\tcreateMissingKeyframes( keyframes, property );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createMissingKeyframes( keyframes, property ) {\n\n\t\t\tvar prev, next;\n\n\t\t\tfor ( var i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\tvar keyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] === null ) {\n\n\t\t\t\t\tprev = getPrev( keyframes, i, property );\n\t\t\t\t\tnext = getNext( keyframes, i, property );\n\n\t\t\t\t\tif ( prev === null ) {\n\n\t\t\t\t\t\tkeyframe.value[ property ] = next.value[ property ];\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( next === null ) {\n\n\t\t\t\t\t\tkeyframe.value[ property ] = prev.value[ property ];\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tinterpolate( keyframe, prev, next, property );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getPrev( keyframes, i, property ) {\n\n\t\t\twhile ( i >= 0 ) {\n\n\t\t\t\tvar keyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] !== null ) return keyframe;\n\n\t\t\t\ti --;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfunction getNext( keyframes, i, property ) {\n\n\t\t\twhile ( i < keyframes.length ) {\n\n\t\t\t\tvar keyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] !== null ) return keyframe;\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfunction interpolate( key, prev, next, property ) {\n\n\t\t\tif ( ( next.time - prev.time ) === 0 ) {\n\n\t\t\t\tkey.value[ property ] = prev.value[ property ];\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tkey.value[ property ] = ( ( key.time - prev.time ) * ( next.value[ property ] - prev.value[ property ] ) / ( next.time - prev.time ) ) + prev.value[ property ];\n\n\t\t}\n\n\t\t// animation clips\n\n\t\tfunction parseAnimationClip( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute( 'id' ) || 'default',\n\t\t\t\tstart: parseFloat( xml.getAttribute( 'start' ) || 0 ),\n\t\t\t\tend: parseFloat( xml.getAttribute( 'end' ) || 0 ),\n\t\t\t\tanimations: []\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'instance_animation':\n\t\t\t\t\t\tdata.animations.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.clips[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildAnimationClip( data ) {\n\n\t\t\tvar tracks = [];\n\n\t\t\tvar name = data.name;\n\t\t\tvar duration = ( data.end - data.start ) || - 1;\n\t\t\tvar animations = data.animations;\n\n\t\t\tfor ( var i = 0, il = animations.length; i < il; i ++ ) {\n\n\t\t\t\tvar animationTracks = getAnimation( animations[ i ] );\n\n\t\t\t\tfor ( var j = 0, jl = animationTracks.length; j < jl; j ++ ) {\n\n\t\t\t\t\ttracks.push( animationTracks[ j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.K( name, duration, tracks );\n\n\t\t}\n\n\t\tfunction getAnimationClip( id ) {\n\n\t\t\treturn getBuild( library.clips[ id ], buildAnimationClip );\n\n\t\t}\n\n\t\t// controller\n\n\t\tfunction parseController( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'skin':\n\t\t\t\t\t\t// there is exactly one skin per controller\n\t\t\t\t\t\tdata.id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tdata.skin = parseSkin( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'morph':\n\t\t\t\t\t\tdata.id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Morph target animation not supported yet.' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.controllers[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseSkin( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tsources: {}\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_shape_matrix':\n\t\t\t\t\t\tdata.bindShapeMatrix = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tvar id = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'joints':\n\t\t\t\t\t\tdata.joints = parseJoints( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vertex_weights':\n\t\t\t\t\t\tdata.vertexWeights = parseVertexWeights( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseJoints( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tinputs: {}\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tdata.inputs[ semantic ] = id;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseVertexWeights( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tinputs: {}\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tvar offset = parseInt( child.getAttribute( 'offset' ) );\n\t\t\t\t\t\tdata.inputs[ semantic ] = { id: id, offset: offset };\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\tdata.vcount = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tdata.v = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildController( data ) {\n\n\t\t\tvar build = {\n\t\t\t\tid: data.id\n\t\t\t};\n\n\t\t\tvar geometry = library.geometries[ build.id ];\n\n\t\t\tif ( data.skin !== undefined ) {\n\n\t\t\t\tbuild.skin = buildSkin( data.skin );\n\n\t\t\t\t// we enhance the 'sources' property of the corresponding geometry with our skin data\n\n\t\t\t\tgeometry.sources.skinIndices = build.skin.indices;\n\t\t\t\tgeometry.sources.skinWeights = build.skin.weights;\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildSkin( data ) {\n\n\t\t\tvar BONE_LIMIT = 4;\n\n\t\t\tvar build = {\n\t\t\t\tjoints: [], // this must be an array to preserve the joint order\n\t\t\t\tindices: {\n\t\t\t\t\tarray: [],\n\t\t\t\t\tstride: BONE_LIMIT\n\t\t\t\t},\n\t\t\t\tweights: {\n\t\t\t\t\tarray: [],\n\t\t\t\t\tstride: BONE_LIMIT\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar sources = data.sources;\n\t\t\tvar vertexWeights = data.vertexWeights;\n\n\t\t\tvar vcount = vertexWeights.vcount;\n\t\t\tvar v = vertexWeights.v;\n\t\t\tvar jointOffset = vertexWeights.inputs.JOINT.offset;\n\t\t\tvar weightOffset = vertexWeights.inputs.WEIGHT.offset;\n\n\t\t\tvar jointSource = data.sources[ data.joints.inputs.JOINT ];\n\t\t\tvar inverseSource = data.sources[ data.joints.inputs.INV_BIND_MATRIX ];\n\n\t\t\tvar weights = sources[ vertexWeights.inputs.WEIGHT.id ].array;\n\t\t\tvar stride = 0;\n\n\t\t\tvar i, j, l;\n\n\t\t\t// procces skin data for each vertex\n\n\t\t\tfor ( i = 0, l = vcount.length; i < l; i ++ ) {\n\n\t\t\t\tvar jointCount = vcount[ i ]; // this is the amount of joints that affect a single vertex\n\t\t\t\tvar vertexSkinData = [];\n\n\t\t\t\tfor ( j = 0; j < jointCount; j ++ ) {\n\n\t\t\t\t\tvar skinIndex = v[ stride + jointOffset ];\n\t\t\t\t\tvar weightId = v[ stride + weightOffset ];\n\t\t\t\t\tvar skinWeight = weights[ weightId ];\n\n\t\t\t\t\tvertexSkinData.push( { index: skinIndex, weight: skinWeight } );\n\n\t\t\t\t\tstride += 2;\n\n\t\t\t\t}\n\n\t\t\t\t// we sort the joints in descending order based on the weights.\n\t\t\t\t// this ensures, we only procced the most important joints of the vertex\n\n\t\t\t\tvertexSkinData.sort( descending );\n\n\t\t\t\t// now we provide for each vertex a set of four index and weight values.\n\t\t\t\t// the order of the skin data matches the order of vertices\n\n\t\t\t\tfor ( j = 0; j < BONE_LIMIT; j ++ ) {\n\n\t\t\t\t\tvar d = vertexSkinData[ j ];\n\n\t\t\t\t\tif ( d !== undefined ) {\n\n\t\t\t\t\t\tbuild.indices.array.push( d.index );\n\t\t\t\t\t\tbuild.weights.array.push( d.weight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbuild.indices.array.push( 0 );\n\t\t\t\t\t\tbuild.weights.array.push( 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// setup bind matrix\n\n\t\t\tif ( data.bindShapeMatrix ) {\n\n\t\t\t\tbuild.bindMatrix = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W().fromArray( data.bindShapeMatrix ).transpose();\n\n\t\t\t} else {\n\n\t\t\t\tbuild.bindMatrix = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W().identity();\n\n\t\t\t}\n\n\t\t\t// process bones and inverse bind matrix data\n\n\t\t\tfor ( i = 0, l = jointSource.array.length; i < l; i ++ ) {\n\n\t\t\t\tvar name = jointSource.array[ i ];\n\t\t\t\tvar boneInverse = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W().fromArray( inverseSource.array, i * inverseSource.stride ).transpose();\n\n\t\t\t\tbuild.joints.push( { name: name, boneInverse: boneInverse } );\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t\t// array sort function\n\n\t\t\tfunction descending( a, b ) {\n\n\t\t\t\treturn b.weight - a.weight;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getController( id ) {\n\n\t\t\treturn getBuild( library.controllers[ id ], buildController );\n\n\t\t}\n\n\t\t// image\n\n\t\tfunction parseImage( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tinit_from: getElementsByTagName( xml, 'init_from' )[ 0 ].textContent\n\t\t\t};\n\n\t\t\tlibrary.images[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildImage( data ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\treturn data.init_from;\n\n\t\t}\n\n\t\tfunction getImage( id ) {\n\n\t\t\tvar data = library.images[ id ];\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\treturn getBuild( data, buildImage );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find image with ID:', id );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// effect\n\n\t\tfunction parseEffect( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'profile_COMMON':\n\t\t\t\t\t\tdata.profile = parseEffectProfileCOMMON( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.effects[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseEffectProfileCOMMON( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tsurfaces: {},\n\t\t\t\tsamplers: {}\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'newparam':\n\t\t\t\t\t\tparseEffectNewparam( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tdata.technique = parseEffectTechnique( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tdata.extra = parseEffectExtra( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectNewparam( xml, data ) {\n\n\t\t\tvar sid = xml.getAttribute( 'sid' );\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'surface':\n\t\t\t\t\t\tdata.surfaces[ sid ] = parseEffectSurface( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'sampler2D':\n\t\t\t\t\t\tdata.samplers[ sid ] = parseEffectSampler( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseEffectSurface( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'init_from':\n\t\t\t\t\t\tdata.init_from = child.textContent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectSampler( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tdata.source = child.textContent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectTechnique( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'constant':\n\t\t\t\t\tcase 'lambert':\n\t\t\t\t\tcase 'blinn':\n\t\t\t\t\tcase 'phong':\n\t\t\t\t\t\tdata.type = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseEffectParameters( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameters( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'emission':\n\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\tcase 'specular':\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\tcase 'ambient':\n\t\t\t\t\tcase 'shininess':\n\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseEffectParameter( child );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'transparent':\n\t\t\t\t\t\tdata[ child.nodeName ] = {\n\t\t\t\t\t\t\topaque: child.getAttribute( 'opaque' ),\n\t\t\t\t\t\t\tdata: parseEffectParameter( child )\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameter( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'float':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\tdata[ child.nodeName ] = { id: child.getAttribute( 'texture' ), extra: parseEffectParameterTexture( child ) };\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameterTexture( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\ttechnique: {}\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tparseEffectParameterTextureExtra( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameterTextureExtra( xml, data ) {\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tparseEffectParameterTextureExtraTechnique( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseEffectParameterTextureExtraTechnique( xml, data ) {\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'repeatU':\n\t\t\t\t\tcase 'repeatV':\n\t\t\t\t\tcase 'offsetU':\n\t\t\t\t\tcase 'offsetV':\n\t\t\t\t\t\tdata.technique[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'wrapU':\n\t\t\t\t\tcase 'wrapV':\n\n\t\t\t\t\t\t// some files have values for wrapU/wrapV which become NaN via parseInt\n\n\t\t\t\t\t\tif ( child.textContent.toUpperCase() === 'TRUE' ) {\n\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = 1;\n\n\t\t\t\t\t\t} else if ( child.textContent.toUpperCase() === 'FALSE' ) {\n\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = 0;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = parseInt( child.textContent );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseEffectExtra( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tdata.technique = parseEffectExtraTechnique( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectExtraTechnique( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'double_sided':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseInt( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildEffect( data ) {\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction getEffect( id ) {\n\n\t\t\treturn getBuild( library.effects[ id ], buildEffect );\n\n\t\t}\n\n\t\t// material\n\n\t\tfunction parseMaterial( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute( 'name' )\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'instance_effect':\n\t\t\t\t\t\tdata.url = parseId( child.getAttribute( 'url' ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.materials[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction getTextureLoader( image ) {\n\n\t\t\tvar loader;\n\n\t\t\tvar extension = image.slice( ( image.lastIndexOf( '.' ) - 1 >>> 0 ) + 2 ); // http://www.jstips.co/en/javascript/get-file-extension/\n\t\t\textension = extension.toLowerCase();\n\n\t\t\tswitch ( extension ) {\n\n\t\t\t\tcase 'tga':\n\t\t\t\t\tloader = tgaLoader;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tloader = textureLoader;\n\n\t\t\t}\n\n\t\t\treturn loader;\n\n\t\t}\n\n\t\tfunction buildMaterial( data ) {\n\n\t\t\tvar effect = getEffect( data.url );\n\t\t\tvar technique = effect.profile.technique;\n\t\t\tvar extra = effect.profile.extra;\n\n\t\t\tvar material;\n\n\t\t\tswitch ( technique.type ) {\n\n\t\t\t\tcase 'phong':\n\t\t\t\tcase 'blinn':\n\t\t\t\t\tmaterial = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.al();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'lambert':\n\t\t\t\t\tmaterial = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.ak();\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tmaterial = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.g();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tmaterial.name = data.name || '';\n\n\t\t\tfunction getTexture( textureObject ) {\n\n\t\t\t\tvar sampler = effect.profile.samplers[ textureObject.id ];\n\t\t\t\tvar image = null;\n\n\t\t\t\t// get image\n\n\t\t\t\tif ( sampler !== undefined ) {\n\n\t\t\t\t\tvar surface = effect.profile.surfaces[ sampler.source ];\n\t\t\t\t\timage = getImage( surface.init_from );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).' );\n\t\t\t\t\timage = getImage( textureObject.id );\n\n\t\t\t\t}\n\n\t\t\t\t// create texture if image is avaiable\n\n\t\t\t\tif ( image !== null ) {\n\n\t\t\t\t\tvar loader = getTextureLoader( image );\n\n\t\t\t\t\tif ( loader !== undefined ) {\n\n\t\t\t\t\t\tvar texture = loader.load( image );\n\n\t\t\t\t\t\tvar extra = textureObject.extra;\n\n\t\t\t\t\t\tif ( extra !== undefined && extra.technique !== undefined && isEmpty( extra.technique ) === false ) {\n\n\t\t\t\t\t\t\tvar technique = extra.technique;\n\n\t\t\t\t\t\t\ttexture.wrapS = technique.wrapU ? _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.o : _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a5;\n\t\t\t\t\t\t\ttexture.wrapT = technique.wrapV ? _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.o : _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a5;\n\n\t\t\t\t\t\t\ttexture.offset.set( technique.offsetU || 0, technique.offsetV || 0 );\n\t\t\t\t\t\t\ttexture.repeat.set( technique.repeatU || 1, technique.repeatV || 1 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttexture.wrapS = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.o;\n\t\t\t\t\t\t\ttexture.wrapT = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.o;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn texture;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Loader for texture %s not found.', image );\n\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t create texture with ID:', textureObject.id );\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar parameters = technique.parameters;\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tvar parameter = parameters[ key ];\n\n\t\t\t\tswitch ( key ) {\n\n\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\t\tif ( parameter.color ) material.color.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.map = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'specular':\n\t\t\t\t\t\tif ( parameter.color && material.specular ) material.specular.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.specularMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\tif ( parameter.texture ) material.normalMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'ambient':\n\t\t\t\t\t\tif ( parameter.texture ) material.lightMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'shininess':\n\t\t\t\t\t\tif ( parameter.float && material.shininess ) material.shininess = parameter.float;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'emission':\n\t\t\t\t\t\tif ( parameter.color && material.emissive ) material.emissive.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.emissiveMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar transparent = parameters[ 'transparent' ];\n\t\t\tvar transparency = parameters[ 'transparency' ];\n\n\t\t\t// <transparency> does not exist but <transparent>\n\n\t\t\tif ( transparency === undefined && transparent ) {\n\n\t\t\t\ttransparency = {\n\t\t\t\t\tfloat: 1\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t// <transparent> does not exist but <transparency>\n\n\t\t\tif ( transparent === undefined && transparency ) {\n\n\t\t\t\ttransparent = {\n\t\t\t\t\topaque: 'A_ONE',\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tcolor: [ 1, 1, 1, 1 ]\n\t\t\t\t\t} };\n\n\t\t\t}\n\n\t\t\tif ( transparent && transparency ) {\n\n\t\t\t\t// handle case if a texture exists but no color\n\n\t\t\t\tif ( transparent.data.texture ) {\n\n\t\t\t\t\t// we do not set an alpha map (see #13792)\n\n\t\t\t\t\tmaterial.transparent = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar color = transparent.data.color;\n\n\t\t\t\t\tswitch ( transparent.opaque ) {\n\n\t\t\t\t\t\tcase 'A_ONE':\n\t\t\t\t\t\t\tmaterial.opacity = color[ 3 ] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'RGB_ZERO':\n\t\t\t\t\t\t\tmaterial.opacity = 1 - ( color[ 0 ] * transparency.float );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A_ZERO':\n\t\t\t\t\t\t\tmaterial.opacity = 1 - ( color[ 3 ] * transparency.float );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'RGB_ONE':\n\t\t\t\t\t\t\tmaterial.opacity = color[ 0 ] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( material.opacity < 1 ) material.transparent = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( extra !== undefined && extra.technique !== undefined && extra.technique.double_sided === 1 ) {\n\n\t\t\t\tmaterial.side = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.D;\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t\tfunction getMaterial( id ) {\n\n\t\t\treturn getBuild( library.materials[ id ], buildMaterial );\n\n\t\t}\n\n\t\t// camera\n\n\t\tfunction parseCamera( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute( 'name' )\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'optics':\n\t\t\t\t\t\tdata.optics = parseCameraOptics( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.cameras[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseCameraOptics( xml ) {\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\treturn parseCameraTechnique( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {};\n\n\t\t}\n\n\t\tfunction parseCameraTechnique( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'perspective':\n\t\t\t\t\tcase 'orthographic':\n\n\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseCameraParameters( child );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseCameraParameters( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'xfov':\n\t\t\t\t\tcase 'yfov':\n\t\t\t\t\tcase 'xmag':\n\t\t\t\t\tcase 'ymag':\n\t\t\t\t\tcase 'znear':\n\t\t\t\t\tcase 'zfar':\n\t\t\t\t\tcase 'aspect_ratio':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildCamera( data ) {\n\n\t\t\tvar camera;\n\n\t\t\tswitch ( data.optics.technique ) {\n\n\t\t\t\tcase 'perspective':\n\t\t\t\t\tcamera = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.A(\n\t\t\t\t\t\tdata.optics.parameters.yfov,\n\t\t\t\t\t\tdata.optics.parameters.aspect_ratio,\n\t\t\t\t\t\tdata.optics.parameters.znear,\n\t\t\t\t\t\tdata.optics.parameters.zfar\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'orthographic':\n\t\t\t\t\tvar ymag = data.optics.parameters.ymag;\n\t\t\t\t\tvar xmag = data.optics.parameters.xmag;\n\t\t\t\t\tvar aspectRatio = data.optics.parameters.aspect_ratio;\n\n\t\t\t\t\txmag = ( xmag === undefined ) ? ( ymag * aspectRatio ) : xmag;\n\t\t\t\t\tymag = ( ymag === undefined ) ? ( xmag / aspectRatio ) : ymag;\n\n\t\t\t\t\txmag *= 0.5;\n\t\t\t\t\tymag *= 0.5;\n\n\t\t\t\t\tcamera = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.O(\n\t\t\t\t\t\t- xmag, xmag, ymag, - ymag, // left, right, top, bottom\n\t\t\t\t\t\tdata.optics.parameters.znear,\n\t\t\t\t\t\tdata.optics.parameters.zfar\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tcamera = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.A();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcamera.name = data.name || '';\n\n\t\t\treturn camera;\n\n\t\t}\n\n\t\tfunction getCamera( id ) {\n\n\t\t\tvar data = library.cameras[ id ];\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\treturn getBuild( data, buildCamera );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find camera with ID:', id );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// light\n\n\t\tfunction parseLight( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tdata = parseLightTechnique( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.lights[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseLightTechnique( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'directional':\n\t\t\t\t\tcase 'point':\n\t\t\t\t\tcase 'spot':\n\t\t\t\t\tcase 'ambient':\n\n\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseLightParameters( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseLightParameters( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.color = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( array );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'falloff_angle':\n\t\t\t\t\t\tdata.falloffAngle = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'quadratic_attenuation':\n\t\t\t\t\t\tvar f = parseFloat( child.textContent );\n\t\t\t\t\t\tdata.distance = f ? Math.sqrt( 1 / f ) : 0;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildLight( data ) {\n\n\t\t\tvar light;\n\n\t\t\tswitch ( data.technique ) {\n\n\t\t\t\tcase 'directional':\n\t\t\t\t\tlight = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__._();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'point':\n\t\t\t\t\tlight = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.Z();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'spot':\n\t\t\t\t\tlight = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.Y();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ambient':\n\t\t\t\t\tlight = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.am();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( data.parameters.color ) light.color.copy( data.parameters.color );\n\t\t\tif ( data.parameters.distance ) light.distance = data.parameters.distance;\n\n\t\t\treturn light;\n\n\t\t}\n\n\t\tfunction getLight( id ) {\n\n\t\t\tvar data = library.lights[ id ];\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\treturn getBuild( data, buildLight );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find light with ID:', id );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// geometry\n\n\t\tfunction parseGeometry( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute( 'name' ),\n\t\t\t\tsources: {},\n\t\t\t\tvertices: {},\n\t\t\t\tprimitives: []\n\t\t\t};\n\n\t\t\tvar mesh = getElementsByTagName( xml, 'mesh' )[ 0 ];\n\n\t\t\t// the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\t\t\tif ( mesh === undefined ) return;\n\n\t\t\tfor ( var i = 0; i < mesh.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = mesh.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tvar id = child.getAttribute( 'id' );\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vertices':\n\t\t\t\t\t\t// data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n\t\t\t\t\t\tdata.vertices = parseGeometryVertices( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polygons':\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\tcase 'polylist':\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\tdata.primitives.push( parseGeometryPrimitive( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.geometries[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseSource( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tarray: [],\n\t\t\t\tstride: 3\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'float_array':\n\t\t\t\t\t\tdata.array = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Name_array':\n\t\t\t\t\t\tdata.array = parseStrings( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tvar accessor = getElementsByTagName( child, 'accessor' )[ 0 ];\n\n\t\t\t\t\t\tif ( accessor !== undefined ) {\n\n\t\t\t\t\t\t\tdata.stride = parseInt( accessor.getAttribute( 'stride' ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseGeometryVertices( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tdata[ child.getAttribute( 'semantic' ) ] = parseId( child.getAttribute( 'source' ) );\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseGeometryPrimitive( xml ) {\n\n\t\t\tvar primitive = {\n\t\t\t\ttype: xml.nodeName,\n\t\t\t\tmaterial: xml.getAttribute( 'material' ),\n\t\t\t\tcount: parseInt( xml.getAttribute( 'count' ) ),\n\t\t\t\tinputs: {},\n\t\t\t\tstride: 0,\n\t\t\t\thasUV: false\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tvar offset = parseInt( child.getAttribute( 'offset' ) );\n\t\t\t\t\t\tvar set = parseInt( child.getAttribute( 'set' ) );\n\t\t\t\t\t\tvar inputname = ( set > 0 ? semantic + set : semantic );\n\t\t\t\t\t\tprimitive.inputs[ inputname ] = { id: id, offset: offset };\n\t\t\t\t\t\tprimitive.stride = Math.max( primitive.stride, offset + 1 );\n\t\t\t\t\t\tif ( semantic === 'TEXCOORD' ) primitive.hasUV = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\tprimitive.vcount = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'p':\n\t\t\t\t\t\tprimitive.p = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn primitive;\n\n\t\t}\n\n\t\tfunction groupPrimitives( primitives ) {\n\n\t\t\tvar build = {};\n\n\t\t\tfor ( var i = 0; i < primitives.length; i ++ ) {\n\n\t\t\t\tvar primitive = primitives[ i ];\n\n\t\t\t\tif ( build[ primitive.type ] === undefined ) build[ primitive.type ] = [];\n\n\t\t\t\tbuild[ primitive.type ].push( primitive );\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction checkUVCoordinates( primitives ) {\n\n\t\t\tvar count = 0;\n\n\t\t\tfor ( var i = 0, l = primitives.length; i < l; i ++ ) {\n\n\t\t\t\tvar primitive = primitives[ i ];\n\n\t\t\t\tif ( primitive.hasUV === true ) {\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( count > 0 && count < primitives.length ) {\n\n\t\t\t\tprimitives.uvsNeedsFix = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildGeometry( data ) {\n\n\t\t\tvar build = {};\n\n\t\t\tvar sources = data.sources;\n\t\t\tvar vertices = data.vertices;\n\t\t\tvar primitives = data.primitives;\n\n\t\t\tif ( primitives.length === 0 ) return {};\n\n\t\t\t// our goal is to create one buffer geometry for a single type of primitives\n\t\t\t// first, we group all primitives by their type\n\n\t\t\tvar groupedPrimitives = groupPrimitives( primitives );\n\n\t\t\tfor ( var type in groupedPrimitives ) {\n\n\t\t\t\tvar primitiveType = groupedPrimitives[ type ];\n\n\t\t\t\t// second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n\t\t\t\tcheckUVCoordinates( primitiveType );\n\n\t\t\t\t// third, create a buffer geometry for each type of primitives\n\n\t\t\t\tbuild[ type ] = buildGeometryType( primitiveType, sources, vertices );\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildGeometryType( primitives, sources, vertices ) {\n\n\t\t\tvar build = {};\n\n\t\t\tvar position = { array: [], stride: 0 };\n\t\t\tvar normal = { array: [], stride: 0 };\n\t\t\tvar uv = { array: [], stride: 0 };\n\t\t\tvar uv2 = { array: [], stride: 0 };\n\t\t\tvar color = { array: [], stride: 0 };\n\n\t\t\tvar skinIndex = { array: [], stride: 4 };\n\t\t\tvar skinWeight = { array: [], stride: 4 };\n\n\t\t\tvar geometry = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\t\tvar materialKeys = [];\n\n\t\t\tvar start = 0;\n\n\t\t\tfor ( var p = 0; p < primitives.length; p ++ ) {\n\n\t\t\t\tvar primitive = primitives[ p ];\n\t\t\t\tvar inputs = primitive.inputs;\n\n\t\t\t\t// groups\n\n\t\t\t\tvar count = 0;\n\n\t\t\t\tswitch ( primitive.type ) {\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\tcount = primitive.count * 2;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\tcount = primitive.count * 3;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polylist':\n\n\t\t\t\t\t\tfor ( var g = 0; g < primitive.count; g ++ ) {\n\n\t\t\t\t\t\t\tvar vc = primitive.vcount[ g ];\n\n\t\t\t\t\t\t\tswitch ( vc ) {\n\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\tcount += 3; // single triangle\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\tcount += 6; // quad, subdivided into two triangles\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tcount += ( vc - 2 ) * 3; // polylist with more than four vertices\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unknow primitive type:', primitive.type );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.addGroup( start, count, p );\n\t\t\t\tstart += count;\n\n\t\t\t\t// material\n\n\t\t\t\tif ( primitive.material ) {\n\n\t\t\t\t\tmaterialKeys.push( primitive.material );\n\n\t\t\t\t}\n\n\t\t\t\t// geometry data\n\n\t\t\t\tfor ( var name in inputs ) {\n\n\t\t\t\t\tvar input = inputs[ name ];\n\n\t\t\t\t\tswitch ( name )\t{\n\n\t\t\t\t\t\tcase 'VERTEX':\n\t\t\t\t\t\t\tfor ( var key in vertices ) {\n\n\t\t\t\t\t\t\t\tvar id = vertices[ key ];\n\n\t\t\t\t\t\t\t\tswitch ( key ) {\n\n\t\t\t\t\t\t\t\t\tcase 'POSITION':\n\t\t\t\t\t\t\t\t\t\tvar prevLength = position.array.length;\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, position.array );\n\t\t\t\t\t\t\t\t\t\tposition.stride = sources[ id ].stride;\n\n\t\t\t\t\t\t\t\t\t\tif ( sources.skinWeights && sources.skinIndices ) {\n\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources.skinIndices, input.offset, skinIndex.array );\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources.skinWeights, input.offset, skinWeight.array );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// see #3803\n\n\t\t\t\t\t\t\t\t\t\tif ( primitive.hasUV === false && primitives.uvsNeedsFix === true ) {\n\n\t\t\t\t\t\t\t\t\t\t\tvar count = ( position.array.length - prevLength ) / position.stride;\n\n\t\t\t\t\t\t\t\t\t\t\tfor ( var i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// fill missing uv coordinates\n\n\t\t\t\t\t\t\t\t\t\t\t\tuv.array.push( 0, 0 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, normal.array );\n\t\t\t\t\t\t\t\t\t\tnormal.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, color.array );\n\t\t\t\t\t\t\t\t\t\tcolor.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, uv.array );\n\t\t\t\t\t\t\t\t\t\tuv.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'TEXCOORD1':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, uv2.array );\n\t\t\t\t\t\t\t\t\t\tuv.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, normal.array );\n\t\t\t\t\t\t\tnormal.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, color.array );\n\t\t\t\t\t\t\tcolor.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, uv.array );\n\t\t\t\t\t\t\tuv.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TEXCOORD1':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, uv2.array );\n\t\t\t\t\t\t\tuv2.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// build geometry\n\n\t\t\tif ( position.array.length > 0 ) geometry.setAttribute( 'position', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( position.array, position.stride ) );\n\t\t\tif ( normal.array.length > 0 ) geometry.setAttribute( 'normal', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( normal.array, normal.stride ) );\n\t\t\tif ( color.array.length > 0 ) geometry.setAttribute( 'color', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( color.array, color.stride ) );\n\t\t\tif ( uv.array.length > 0 ) geometry.setAttribute( 'uv', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( uv.array, uv.stride ) );\n\t\t\tif ( uv2.array.length > 0 ) geometry.setAttribute( 'uv2', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( uv2.array, uv2.stride ) );\n\n\t\t\tif ( skinIndex.array.length > 0 ) geometry.setAttribute( 'skinIndex', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( skinIndex.array, skinIndex.stride ) );\n\t\t\tif ( skinWeight.array.length > 0 ) geometry.setAttribute( 'skinWeight', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( skinWeight.array, skinWeight.stride ) );\n\n\t\t\tbuild.data = geometry;\n\t\t\tbuild.type = primitives[ 0 ].type;\n\t\t\tbuild.materialKeys = materialKeys;\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildGeometryData( primitive, source, offset, array ) {\n\n\t\t\tvar indices = primitive.p;\n\t\t\tvar stride = primitive.stride;\n\t\t\tvar vcount = primitive.vcount;\n\n\t\t\tfunction pushVector( i ) {\n\n\t\t\t\tvar index = indices[ i + offset ] * sourceStride;\n\t\t\t\tvar length = index + sourceStride;\n\n\t\t\t\tfor ( ; index < length; index ++ ) {\n\n\t\t\t\t\tarray.push( sourceArray[ index ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar sourceArray = source.array;\n\t\t\tvar sourceStride = source.stride;\n\n\t\t\tif ( primitive.vcount !== undefined ) {\n\n\t\t\t\tvar index = 0;\n\n\t\t\t\tfor ( var i = 0, l = vcount.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar count = vcount[ i ];\n\n\t\t\t\t\tif ( count === 4 ) {\n\n\t\t\t\t\t\tvar a = index + stride * 0;\n\t\t\t\t\t\tvar b = index + stride * 1;\n\t\t\t\t\t\tvar c = index + stride * 2;\n\t\t\t\t\t\tvar d = index + stride * 3;\n\n\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( d );\n\t\t\t\t\t\tpushVector( b ); pushVector( c ); pushVector( d );\n\n\t\t\t\t\t} else if ( count === 3 ) {\n\n\t\t\t\t\t\tvar a = index + stride * 0;\n\t\t\t\t\t\tvar b = index + stride * 1;\n\t\t\t\t\t\tvar c = index + stride * 2;\n\n\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( c );\n\n\t\t\t\t\t} else if ( count > 4 ) {\n\n\t\t\t\t\t\tfor ( var k = 1, kl = ( count - 2 ); k <= kl; k ++ ) {\n\n\t\t\t\t\t\t\tvar a = index + stride * 0;\n\t\t\t\t\t\t\tvar b = index + stride * k;\n\t\t\t\t\t\t\tvar c = index + stride * ( k + 1 );\n\n\t\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( c );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindex += stride * count;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += stride ) {\n\n\t\t\t\t\tpushVector( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getGeometry( id ) {\n\n\t\t\treturn getBuild( library.geometries[ id ], buildGeometry );\n\n\t\t}\n\n\t\t// kinematics\n\n\t\tfunction parseKinematicsModel( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\tjoints: {},\n\t\t\t\tlinks: []\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tparseKinematicsTechniqueCommon( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.kinematicsModels[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildKinematicsModel( data ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction getKinematicsModel( id ) {\n\n\t\t\treturn getBuild( library.kinematicsModels[ id ], buildKinematicsModel );\n\n\t\t}\n\n\t\tfunction parseKinematicsTechniqueCommon( xml, data ) {\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'joint':\n\t\t\t\t\t\tdata.joints[ child.getAttribute( 'sid' ) ] = parseKinematicsJoint( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'link':\n\t\t\t\t\t\tdata.links.push( parseKinematicsLink( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseKinematicsJoint( xml ) {\n\n\t\t\tvar data;\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\tdata = parseKinematicsJointParameter( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsJointParameter( xml, data ) {\n\n\t\t\tvar data = {\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\taxis: new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V(),\n\t\t\t\tlimits: {\n\t\t\t\t\tmin: 0,\n\t\t\t\t\tmax: 0\n\t\t\t\t},\n\t\t\t\ttype: xml.nodeName,\n\t\t\t\tstatic: false,\n\t\t\t\tzeroPosition: 0,\n\t\t\t\tmiddlePosition: 0\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.axis.fromArray( array );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'limits':\n\t\t\t\t\t\tvar max = child.getElementsByTagName( 'max' )[ 0 ];\n\t\t\t\t\t\tvar min = child.getElementsByTagName( 'min' )[ 0 ];\n\n\t\t\t\t\t\tdata.limits.max = parseFloat( max.textContent );\n\t\t\t\t\t\tdata.limits.min = parseFloat( min.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// if min is equal to or greater than max, consider the joint static\n\n\t\t\tif ( data.limits.min >= data.limits.max ) {\n\n\t\t\t\tdata.static = true;\n\n\t\t\t}\n\n\t\t\t// calculate middle position\n\n\t\t\tdata.middlePosition = ( data.limits.min + data.limits.max ) / 2.0;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsLink( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\tattachments: [],\n\t\t\t\ttransforms: []\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'attachment_full':\n\t\t\t\t\t\tdata.attachments.push( parseKinematicsAttachment( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tdata.transforms.push( parseKinematicsTransform( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsAttachment( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tjoint: xml.getAttribute( 'joint' ).split( '/' ).pop(),\n\t\t\t\ttransforms: [],\n\t\t\t\tlinks: []\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'link':\n\t\t\t\t\t\tdata.links.push( parseKinematicsLink( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tdata.transforms.push( parseKinematicsTransform( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsTransform( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\ttype: xml.nodeName\n\t\t\t};\n\n\t\t\tvar array = parseFloats( xml.textContent );\n\n\t\t\tswitch ( data.type ) {\n\n\t\t\t\tcase 'matrix':\n\t\t\t\t\tdata.obj = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\t\t\t\tdata.obj.fromArray( array ).transpose();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'translate':\n\t\t\t\t\tdata.obj = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\t\t\tdata.obj.fromArray( array );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tdata.obj = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\t\t\tdata.obj.fromArray( array );\n\t\t\t\t\tdata.angle = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad( array[ 3 ] );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// physics\n\n\t\tfunction parsePhysicsModel( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\trigidBodies: {}\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'rigid_body':\n\t\t\t\t\t\tdata.rigidBodies[ child.getAttribute( 'name' ) ] = {};\n\t\t\t\t\t\tparsePhysicsRigidBody( child, data.rigidBodies[ child.getAttribute( 'name' ) ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.physicsModels[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parsePhysicsRigidBody( xml, data ) {\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tparsePhysicsTechniqueCommon( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parsePhysicsTechniqueCommon( xml, data ) {\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'inertia':\n\t\t\t\t\t\tdata.inertia = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'mass':\n\t\t\t\t\t\tdata.mass = parseFloats( child.textContent )[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// scene\n\n\t\tfunction parseKinematicsScene( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tbindJointAxis: []\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_joint_axis':\n\t\t\t\t\t\tdata.bindJointAxis.push( parseKinematicsBindJointAxis( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.kinematicsScenes[ parseId( xml.getAttribute( 'url' ) ) ] = data;\n\n\t\t}\n\n\t\tfunction parseKinematicsBindJointAxis( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\ttarget: xml.getAttribute( 'target' ).split( '/' ).pop()\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\tvar param = child.getElementsByTagName( 'param' )[ 0 ];\n\t\t\t\t\t\tdata.axis = param.textContent;\n\t\t\t\t\t\tvar tmpJointIndex = data.axis.split( 'inst_' ).pop().split( 'axis' )[ 0 ];\n\t\t\t\t\t\tdata.jointIndex = tmpJointIndex.substr( 0, tmpJointIndex.length - 1 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildKinematicsScene( data ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction getKinematicsScene( id ) {\n\n\t\t\treturn getBuild( library.kinematicsScenes[ id ], buildKinematicsScene );\n\n\t\t}\n\n\t\tfunction setupKinematics() {\n\n\t\t\tvar kinematicsModelId = Object.keys( library.kinematicsModels )[ 0 ];\n\t\t\tvar kinematicsSceneId = Object.keys( library.kinematicsScenes )[ 0 ];\n\t\t\tvar visualSceneId = Object.keys( library.visualScenes )[ 0 ];\n\n\t\t\tif ( kinematicsModelId === undefined || kinematicsSceneId === undefined ) return;\n\n\t\t\tvar kinematicsModel = getKinematicsModel( kinematicsModelId );\n\t\t\tvar kinematicsScene = getKinematicsScene( kinematicsSceneId );\n\t\t\tvar visualScene = getVisualScene( visualSceneId );\n\n\t\t\tvar bindJointAxis = kinematicsScene.bindJointAxis;\n\t\t\tvar jointMap = {};\n\n\t\t\tfor ( var i = 0, l = bindJointAxis.length; i < l; i ++ ) {\n\n\t\t\t\tvar axis = bindJointAxis[ i ];\n\n\t\t\t\t// the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n\t\t\t\tvar targetElement = collada.querySelector( '[sid=\"' + axis.target + '\"]' );\n\n\t\t\t\tif ( targetElement ) {\n\n\t\t\t\t\t// get the parent of the transform element\n\n\t\t\t\t\tvar parentVisualElement = targetElement.parentElement;\n\n\t\t\t\t\t// connect the joint of the kinematics model with the element in the visual scene\n\n\t\t\t\t\tconnect( axis.jointIndex, parentVisualElement );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction connect( jointIndex, visualElement ) {\n\n\t\t\t\tvar visualElementName = visualElement.getAttribute( 'name' );\n\t\t\t\tvar joint = kinematicsModel.joints[ jointIndex ];\n\n\t\t\t\tvisualScene.traverse( function ( object ) {\n\n\t\t\t\t\tif ( object.name === visualElementName ) {\n\n\t\t\t\t\t\tjointMap[ jointIndex ] = {\n\t\t\t\t\t\t\tobject: object,\n\t\t\t\t\t\t\ttransforms: buildTransformList( visualElement ),\n\t\t\t\t\t\t\tjoint: joint,\n\t\t\t\t\t\t\tposition: joint.zeroPosition\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tvar m0 = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\n\t\t\tkinematics = {\n\n\t\t\t\tjoints: kinematicsModel && kinematicsModel.joints,\n\n\t\t\t\tgetJointValue: function ( jointIndex ) {\n\n\t\t\t\t\tvar jointData = jointMap[ jointIndex ];\n\n\t\t\t\t\tif ( jointData ) {\n\n\t\t\t\t\t\treturn jointData.position;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' doesn\\'t exist.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetJointValue: function ( jointIndex, value ) {\n\n\t\t\t\t\tvar jointData = jointMap[ jointIndex ];\n\n\t\t\t\t\tif ( jointData ) {\n\n\t\t\t\t\t\tvar joint = jointData.joint;\n\n\t\t\t\t\t\tif ( value > joint.limits.max || value < joint.limits.min ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').' );\n\n\t\t\t\t\t\t} else if ( joint.static ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' is static.' );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar object = jointData.object;\n\t\t\t\t\t\t\tvar axis = joint.axis;\n\t\t\t\t\t\t\tvar transforms = jointData.transforms;\n\n\t\t\t\t\t\t\tmatrix.identity();\n\n\t\t\t\t\t\t\t// each update, we have to apply all transforms in the correct order\n\n\t\t\t\t\t\t\tfor ( var i = 0; i < transforms.length; i ++ ) {\n\n\t\t\t\t\t\t\t\tvar transform = transforms[ i ];\n\n\t\t\t\t\t\t\t\t// if there is a connection of the transform node with a joint, apply the joint value\n\n\t\t\t\t\t\t\t\tif ( transform.sid && transform.sid.indexOf( jointIndex ) !== - 1 ) {\n\n\t\t\t\t\t\t\t\t\tswitch ( joint.type ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeRotationAxis( axis, _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad( value ) ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeTranslation( axis.x * value, axis.y * value, axis.z * value ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unknown joint type: ' + joint.type );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tswitch ( transform.type ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( transform.obj );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeTranslation( transform.obj.x, transform.obj.y, transform.obj.z ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.scale( transform.obj );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeRotationAxis( transform.obj, transform.angle ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tobject.matrix.copy( matrix );\n\t\t\t\t\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\t\t\t\t\tjointMap[ jointIndex ].position = value;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.log( 'THREE.ColladaLoader: ' + jointIndex + ' does not exist.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\tfunction buildTransformList( node ) {\n\n\t\t\tvar transforms = [];\n\n\t\t\tvar xml = collada.querySelector( '[id=\"' + node.id + '\"]' );\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tvar matrix = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W().fromArray( array ).transpose();\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: matrix\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tvar vector = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V().fromArray( array );\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: vector\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tvar vector = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V().fromArray( array );\n\t\t\t\t\t\tvar angle = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad( array[ 3 ] );\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: vector,\n\t\t\t\t\t\t\tangle: angle\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn transforms;\n\n\t\t}\n\n\t\t// nodes\n\n\t\tfunction prepareNodes( xml ) {\n\n\t\t\tvar elements = xml.getElementsByTagName( 'node' );\n\n\t\t\t// ensure all node elements have id attributes\n\n\t\t\tfor ( var i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\tvar element = elements[ i ];\n\n\t\t\t\tif ( element.hasAttribute( 'id' ) === false ) {\n\n\t\t\t\t\telement.setAttribute( 'id', generateId() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar matrix = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar vector = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t\tfunction parseNode( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\ttype: xml.getAttribute( 'type' ),\n\t\t\t\tid: xml.getAttribute( 'id' ),\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tmatrix: new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W(),\n\t\t\t\tnodes: [],\n\t\t\t\tinstanceCameras: [],\n\t\t\t\tinstanceControllers: [],\n\t\t\t\tinstanceLights: [],\n\t\t\t\tinstanceGeometries: [],\n\t\t\t\tinstanceNodes: [],\n\t\t\t\ttransforms: {}\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'node':\n\t\t\t\t\t\tdata.nodes.push( child.getAttribute( 'id' ) );\n\t\t\t\t\t\tparseNode( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_camera':\n\t\t\t\t\t\tdata.instanceCameras.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_controller':\n\t\t\t\t\t\tdata.instanceControllers.push( parseNodeInstance( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_light':\n\t\t\t\t\t\tdata.instanceLights.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_geometry':\n\t\t\t\t\t\tdata.instanceGeometries.push( parseNodeInstance( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_node':\n\t\t\t\t\t\tdata.instanceNodes.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.fromArray( array ).transpose() );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tvector.fromArray( array );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.makeTranslation( vector.x, vector.y, vector.z ) );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tvar angle = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad( array[ 3 ] );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.makeRotationAxis( vector.fromArray( array ), angle ) );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.matrix.scale( vector.fromArray( array ) );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasNode( data.id ) ) {\n\n\t\t\t\tconsole.warn( 'THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id );\n\n\t\t\t} else {\n\n\t\t\t\tlibrary.nodes[ data.id ] = data;\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseNodeInstance( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tid: parseId( xml.getAttribute( 'url' ) ),\n\t\t\t\tmaterials: {},\n\t\t\t\tskeletons: []\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_material':\n\t\t\t\t\t\tvar instances = child.getElementsByTagName( 'instance_material' );\n\n\t\t\t\t\t\tfor ( var j = 0; j < instances.length; j ++ ) {\n\n\t\t\t\t\t\t\tvar instance = instances[ j ];\n\t\t\t\t\t\t\tvar symbol = instance.getAttribute( 'symbol' );\n\t\t\t\t\t\t\tvar target = instance.getAttribute( 'target' );\n\n\t\t\t\t\t\t\tdata.materials[ symbol ] = parseId( target );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'skeleton':\n\t\t\t\t\t\tdata.skeletons.push( parseId( child.textContent ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildSkeleton( skeletons, joints ) {\n\n\t\t\tvar boneData = [];\n\t\t\tvar sortedBoneData = [];\n\n\t\t\tvar i, j, data;\n\n\t\t\t// a skeleton can have multiple root bones. collada expresses this\n\t\t\t// situtation with multiple \"skeleton\" tags per controller instance\n\n\t\t\tfor ( i = 0; i < skeletons.length; i ++ ) {\n\n\t\t\t\tvar skeleton = skeletons[ i ];\n\n\t\t\t\tvar root;\n\n\t\t\t\tif ( hasNode( skeleton ) ) {\n\n\t\t\t\t\troot = getNode( skeleton );\n\t\t\t\t\tbuildBoneHierarchy( root, joints, boneData );\n\n\t\t\t\t} else if ( hasVisualScene( skeleton ) ) {\n\n\t\t\t\t\t// handle case where the skeleton refers to the visual scene (#13335)\n\n\t\t\t\t\tvar visualScene = library.visualScenes[ skeleton ];\n\t\t\t\t\tvar children = visualScene.children;\n\n\t\t\t\t\tfor ( var j = 0; j < children.length; j ++ ) {\n\n\t\t\t\t\t\tvar child = children[ j ];\n\n\t\t\t\t\t\tif ( child.type === 'JOINT' ) {\n\n\t\t\t\t\t\t\tvar root = getNode( child.id );\n\t\t\t\t\t\t\tbuildBoneHierarchy( root, joints, boneData );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// sort bone data (the order is defined in the corresponding controller)\n\n\t\t\tfor ( i = 0; i < joints.length; i ++ ) {\n\n\t\t\t\tfor ( j = 0; j < boneData.length; j ++ ) {\n\n\t\t\t\t\tdata = boneData[ j ];\n\n\t\t\t\t\tif ( data.bone.name === joints[ i ].name ) {\n\n\t\t\t\t\t\tsortedBoneData[ i ] = data;\n\t\t\t\t\t\tdata.processed = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add unprocessed bone data at the end of the list\n\n\t\t\tfor ( i = 0; i < boneData.length; i ++ ) {\n\n\t\t\t\tdata = boneData[ i ];\n\n\t\t\t\tif ( data.processed === false ) {\n\n\t\t\t\t\tsortedBoneData.push( data );\n\t\t\t\t\tdata.processed = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// setup arrays for skeleton creation\n\n\t\t\tvar bones = [];\n\t\t\tvar boneInverses = [];\n\n\t\t\tfor ( i = 0; i < sortedBoneData.length; i ++ ) {\n\n\t\t\t\tdata = sortedBoneData[ i ];\n\n\t\t\t\tbones.push( data.bone );\n\t\t\t\tboneInverses.push( data.boneInverse );\n\n\t\t\t}\n\n\t\t\treturn new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.X( bones, boneInverses );\n\n\t\t}\n\n\t\tfunction buildBoneHierarchy( root, joints, boneData ) {\n\n\t\t\t// setup bone data from visual scene\n\n\t\t\troot.traverse( function ( object ) {\n\n\t\t\t\tif ( object.isBone === true ) {\n\n\t\t\t\t\tvar boneInverse;\n\n\t\t\t\t\t// retrieve the boneInverse from the controller data\n\n\t\t\t\t\tfor ( var i = 0; i < joints.length; i ++ ) {\n\n\t\t\t\t\t\tvar joint = joints[ i ];\n\n\t\t\t\t\t\tif ( joint.name === object.name ) {\n\n\t\t\t\t\t\t\tboneInverse = joint.boneInverse;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( boneInverse === undefined ) {\n\n\t\t\t\t\t\t// Unfortunately, there can be joints in the visual scene that are not part of the\n\t\t\t\t\t\t// corresponding controller. In this case, we have to create a dummy boneInverse matrix\n\t\t\t\t\t\t// for the respective bone. This bone won't affect any vertices, because there are no skin indices\n\t\t\t\t\t\t// and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n\t\t\t\t\t\t// ensure a correct animation of the model.\n\n\t\t\t\t\t\tboneInverse = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneData.push( { bone: object, boneInverse: boneInverse, processed: false } );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction buildNode( data ) {\n\n\t\t\tvar objects = [];\n\n\t\t\tvar matrix = data.matrix;\n\t\t\tvar nodes = data.nodes;\n\t\t\tvar type = data.type;\n\t\t\tvar instanceCameras = data.instanceCameras;\n\t\t\tvar instanceControllers = data.instanceControllers;\n\t\t\tvar instanceLights = data.instanceLights;\n\t\t\tvar instanceGeometries = data.instanceGeometries;\n\t\t\tvar instanceNodes = data.instanceNodes;\n\n\t\t\t// nodes\n\n\t\t\tfor ( var i = 0, l = nodes.length; i < l; i ++ ) {\n\n\t\t\t\tobjects.push( getNode( nodes[ i ] ) );\n\n\t\t\t}\n\n\t\t\t// instance cameras\n\n\t\t\tfor ( var i = 0, l = instanceCameras.length; i < l; i ++ ) {\n\n\t\t\t\tvar instanceCamera = getCamera( instanceCameras[ i ] );\n\n\t\t\t\tif ( instanceCamera !== null ) {\n\n\t\t\t\t\tobjects.push( instanceCamera.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance controllers\n\n\t\t\tfor ( var i = 0, l = instanceControllers.length; i < l; i ++ ) {\n\n\t\t\t\tvar instance = instanceControllers[ i ];\n\t\t\t\tvar controller = getController( instance.id );\n\t\t\t\tvar geometries = getGeometry( controller.id );\n\t\t\t\tvar newObjects = buildObjects( geometries, instance.materials );\n\n\t\t\t\tvar skeletons = instance.skeletons;\n\t\t\t\tvar joints = controller.skin.joints;\n\n\t\t\t\tvar skeleton = buildSkeleton( skeletons, joints );\n\n\t\t\t\tfor ( var j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar object = newObjects[ j ];\n\n\t\t\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\t\t\tobject.bind( skeleton, controller.skin.bindMatrix );\n\t\t\t\t\t\tobject.normalizeSkinWeights();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobjects.push( object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance lights\n\n\t\t\tfor ( var i = 0, l = instanceLights.length; i < l; i ++ ) {\n\n\t\t\t\tvar instanceLight = getLight( instanceLights[ i ] );\n\n\t\t\t\tif ( instanceLight !== null ) {\n\n\t\t\t\t\tobjects.push( instanceLight.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance geometries\n\n\t\t\tfor ( var i = 0, l = instanceGeometries.length; i < l; i ++ ) {\n\n\t\t\t\tvar instance = instanceGeometries[ i ];\n\n\t\t\t\t// a single geometry instance in collada can lead to multiple object3Ds.\n\t\t\t\t// this is the case when primitives are combined like triangles and lines\n\n\t\t\t\tvar geometries = getGeometry( instance.id );\n\t\t\t\tvar newObjects = buildObjects( geometries, instance.materials );\n\n\t\t\t\tfor ( var j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tobjects.push( newObjects[ j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance nodes\n\n\t\t\tfor ( var i = 0, l = instanceNodes.length; i < l; i ++ ) {\n\n\t\t\t\tobjects.push( getNode( instanceNodes[ i ] ).clone() );\n\n\t\t\t}\n\n\t\t\tvar object;\n\n\t\t\tif ( nodes.length === 0 && objects.length === 1 ) {\n\n\t\t\t\tobject = objects[ 0 ];\n\n\t\t\t} else {\n\n\t\t\t\tobject = ( type === 'JOINT' ) ? new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.N() : new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\n\t\t\t\tfor ( var i = 0; i < objects.length; i ++ ) {\n\n\t\t\t\t\tobject.add( objects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tobject.name = ( type === 'JOINT' ) ? data.sid : data.name;\n\t\t\tobject.matrix.copy( matrix );\n\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\treturn object;\n\n\t\t}\n\n\t\tvar fallbackMaterial = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.g( { color: 0xff00ff } );\n\n\t\tfunction resolveMaterialBinding( keys, instanceMaterials ) {\n\n\t\t\tvar materials = [];\n\n\t\t\tfor ( var i = 0, l = keys.length; i < l; i ++ ) {\n\n\t\t\t\tvar id = instanceMaterials[ keys[ i ] ];\n\n\t\t\t\tif ( id === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[ i ] );\n\t\t\t\t\tmaterials.push( fallbackMaterial );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterials.push( getMaterial( id ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn materials;\n\n\t\t}\n\n\t\tfunction buildObjects( geometries, instanceMaterials ) {\n\n\t\t\tvar objects = [];\n\n\t\t\tfor ( var type in geometries ) {\n\n\t\t\t\tvar geometry = geometries[ type ];\n\n\t\t\t\tvar materials = resolveMaterialBinding( geometry.materialKeys, instanceMaterials );\n\n\t\t\t\t// handle case if no materials are defined\n\n\t\t\t\tif ( materials.length === 0 ) {\n\n\t\t\t\t\tif ( type === 'lines' || type === 'linestrips' ) {\n\n\t\t\t\t\t\tmaterials.push( new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.q() );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterials.push( new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.al() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// regard skinning\n\n\t\t\t\tvar skinning = ( geometry.data.attributes.skinIndex !== undefined );\n\n\t\t\t\tif ( skinning ) {\n\n\t\t\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tmaterials[ i ].skinning = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// choose between a single or multi materials (material array)\n\n\t\t\t\tvar material = ( materials.length === 1 ) ? materials[ 0 ] : materials;\n\n\t\t\t\t// now create a specific 3D object\n\n\t\t\t\tvar object;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\t\tobject = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.w( geometry.data, material );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\tobject = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.x( geometry.data, material );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\tcase 'polylist':\n\t\t\t\t\t\tif ( skinning ) {\n\n\t\t\t\t\t\t\tobject = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.t( geometry.data, material );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tobject = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.v( geometry.data, material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tobjects.push( object );\n\n\t\t\t}\n\n\t\t\treturn objects;\n\n\t\t}\n\n\t\tfunction hasNode( id ) {\n\n\t\t\treturn library.nodes[ id ] !== undefined;\n\n\t\t}\n\n\t\tfunction getNode( id ) {\n\n\t\t\treturn getBuild( library.nodes[ id ], buildNode );\n\n\t\t}\n\n\t\t// visual scenes\n\n\t\tfunction parseVisualScene( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute( 'name' ),\n\t\t\t\tchildren: []\n\t\t\t};\n\n\t\t\tprepareNodes( xml );\n\n\t\t\tvar elements = getElementsByTagName( xml, 'node' );\n\n\t\t\tfor ( var i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\tdata.children.push( parseNode( elements[ i ] ) );\n\n\t\t\t}\n\n\t\t\tlibrary.visualScenes[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildVisualScene( data ) {\n\n\t\t\tvar group = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\t\t\tgroup.name = data.name;\n\n\t\t\tvar children = data.children;\n\n\t\t\tfor ( var i = 0; i < children.length; i ++ ) {\n\n\t\t\t\tvar child = children[ i ];\n\n\t\t\t\tgroup.add( getNode( child.id ) );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t}\n\n\t\tfunction hasVisualScene( id ) {\n\n\t\t\treturn library.visualScenes[ id ] !== undefined;\n\n\t\t}\n\n\t\tfunction getVisualScene( id ) {\n\n\t\t\treturn getBuild( library.visualScenes[ id ], buildVisualScene );\n\n\t\t}\n\n\t\t// scenes\n\n\t\tfunction parseScene( xml ) {\n\n\t\t\tvar instance = getElementsByTagName( xml, 'instance_visual_scene' )[ 0 ];\n\t\t\treturn getVisualScene( parseId( instance.getAttribute( 'url' ) ) );\n\n\t\t}\n\n\t\tfunction setupAnimations() {\n\n\t\t\tvar clips = library.clips;\n\n\t\t\tif ( isEmpty( clips ) === true ) {\n\n\t\t\t\tif ( isEmpty( library.animations ) === false ) {\n\n\t\t\t\t\t// if there are animations but no clips, we create a default clip for playback\n\n\t\t\t\t\tvar tracks = [];\n\n\t\t\t\t\tfor ( var id in library.animations ) {\n\n\t\t\t\t\t\tvar animationTracks = getAnimation( id );\n\n\t\t\t\t\t\tfor ( var i = 0, l = animationTracks.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\ttracks.push( animationTracks[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tanimations.push( new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.K( 'default', - 1, tracks ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( var id in clips ) {\n\n\t\t\t\t\tanimations.push( getAnimationClip( id ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// convert the parser error element into text with each child elements text\n\t\t// separated by new lines.\n\n\t\tfunction parserErrorToText( parserError ) {\n\n\t\t\tvar result = '';\n\t\t\tvar stack = [ parserError ];\n\n\t\t\twhile ( stack.length ) {\n\n\t\t\t\tvar node = stack.shift();\n\n\t\t\t\tif ( node.nodeType === Node.TEXT_NODE ) {\n\n\t\t\t\t\tresult += node.textContent;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresult += '\\n';\n\t\t\t\t\tstack.push.apply( stack, node.childNodes );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result.trim();\n\n\t\t}\n\n\t\tif ( text.length === 0 ) {\n\n\t\t\treturn { scene: new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.ai() };\n\n\t\t}\n\n\t\tvar xml = new DOMParser().parseFromString( text, 'application/xml' );\n\n\t\tvar collada = getElementsByTagName( xml, 'COLLADA' )[ 0 ];\n\n\t\tvar parserError = xml.getElementsByTagName( 'parsererror' )[ 0 ];\n\t\tif ( parserError !== undefined ) {\n\n\t\t\t// Chrome will return parser error with a div in it\n\n\t\t\tvar errorElement = getElementsByTagName( parserError, 'div' )[ 0 ];\n\t\t\tvar errorText;\n\n\t\t\tif ( errorElement ) {\n\n\t\t\t\terrorText = errorElement.textContent;\n\n\t\t\t} else {\n\n\t\t\t\terrorText = parserErrorToText( parserError );\n\n\t\t\t}\n\n\t\t\tconsole.error( 'THREE.ColladaLoader: Failed to parse collada file.\\n', errorText );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// metadata\n\n\t\tvar version = collada.getAttribute( 'version' );\n\t\tconsole.log( 'THREE.ColladaLoader: File version', version );\n\n\t\tvar asset = parseAsset( getElementsByTagName( collada, 'asset' )[ 0 ] );\n\t\tvar textureLoader = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.j( this.manager );\n\t\ttextureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\tvar tgaLoader;\n\n\t\tif ( TGALoader ) {\n\n\t\t\ttgaLoader = new TGALoader( this.manager );\n\t\t\ttgaLoader.setPath( this.resourcePath || path );\n\n\t\t}\n\n\t\t//\n\n\t\tvar animations = [];\n\t\tvar kinematics = {};\n\t\tvar count = 0;\n\n\t\t//\n\n\t\tvar library = {\n\t\t\tanimations: {},\n\t\t\tclips: {},\n\t\t\tcontrollers: {},\n\t\t\timages: {},\n\t\t\teffects: {},\n\t\t\tmaterials: {},\n\t\t\tcameras: {},\n\t\t\tlights: {},\n\t\t\tgeometries: {},\n\t\t\tnodes: {},\n\t\t\tvisualScenes: {},\n\t\t\tkinematicsModels: {},\n\t\t\tphysicsModels: {},\n\t\t\tkinematicsScenes: {}\n\t\t};\n\n\t\tparseLibrary( collada, 'library_animations', 'animation', parseAnimation );\n\t\tparseLibrary( collada, 'library_animation_clips', 'animation_clip', parseAnimationClip );\n\t\tparseLibrary( collada, 'library_controllers', 'controller', parseController );\n\t\tparseLibrary( collada, 'library_images', 'image', parseImage );\n\t\tparseLibrary( collada, 'library_effects', 'effect', parseEffect );\n\t\tparseLibrary( collada, 'library_materials', 'material', parseMaterial );\n\t\tparseLibrary( collada, 'library_cameras', 'camera', parseCamera );\n\t\tparseLibrary( collada, 'library_lights', 'light', parseLight );\n\t\tparseLibrary( collada, 'library_geometries', 'geometry', parseGeometry );\n\t\tparseLibrary( collada, 'library_nodes', 'node', parseNode );\n\t\tparseLibrary( collada, 'library_visual_scenes', 'visual_scene', parseVisualScene );\n\t\tparseLibrary( collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel );\n\t\tparseLibrary( collada, 'library_physics_models', 'physics_model', parsePhysicsModel );\n\t\tparseLibrary( collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene );\n\n\t\tbuildLibrary( library.animations, buildAnimation );\n\t\tbuildLibrary( library.clips, buildAnimationClip );\n\t\tbuildLibrary( library.controllers, buildController );\n\t\tbuildLibrary( library.images, buildImage );\n\t\tbuildLibrary( library.effects, buildEffect );\n\t\tbuildLibrary( library.materials, buildMaterial );\n\t\tbuildLibrary( library.cameras, buildCamera );\n\t\tbuildLibrary( library.lights, buildLight );\n\t\tbuildLibrary( library.geometries, buildGeometry );\n\t\tbuildLibrary( library.visualScenes, buildVisualScene );\n\n\t\tsetupAnimations();\n\t\tsetupKinematics();\n\n\t\tvar scene = parseScene( getElementsByTagName( collada, 'scene' )[ 0 ] );\n\t\tscene.animations = animations;\n\n\t\tif ( asset.upAxis === 'Z_UP' ) {\n\n\t\t\tscene.quaternion.setFromEuler( new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aj( - Math.PI / 2, 0, 0 ) );\n\n\t\t}\n\n\t\tscene.scale.multiplyScalar( asset.unit );\n\n\t\treturn {\n\t\t\tget animations() {\n\n\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Please access animations over scene.animations now.' );\n\t\t\t\treturn animations;\n\n\t\t\t},\n\t\t\tkinematics: kinematics,\n\t\t\tlibrary: library,\n\t\t\tscene: scene\n\t\t};\n\n\t}\n\n} );\n\nvar OBJLoader = ( function () {\n\n\t// o object_name | g group_name\n\tvar object_pattern = /^[og]\\s*(.+)?/;\n\t// mtllib file_reference\n\tvar material_library_pattern = /^mtllib /;\n\t// usemtl material_name\n\tvar material_use_pattern = /^usemtl /;\n\t// usemap map_name\n\tvar map_use_pattern = /^usemap /;\n\n\tvar vA = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\tvar vB = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\tvar vC = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\tvar ab = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\tvar cb = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\tfunction ParserState() {\n\n\t\tvar state = {\n\t\t\tobjects: [],\n\t\t\tobject: {},\n\n\t\t\tvertices: [],\n\t\t\tnormals: [],\n\t\t\tcolors: [],\n\t\t\tuvs: [],\n\n\t\t\tmaterials: {},\n\t\t\tmaterialLibraries: [],\n\n\t\t\tstartObject: function ( name, fromDeclaration ) {\n\n\t\t\t\t// If the current object (initial from reset) is not from a g/o declaration in the parsed\n\t\t\t\t// file. We need to use it for the first parsed g/o to keep things in sync.\n\t\t\t\tif ( this.object && this.object.fromDeclaration === false ) {\n\n\t\t\t\t\tthis.object.name = name;\n\t\t\t\t\tthis.object.fromDeclaration = ( fromDeclaration !== false );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tvar previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );\n\n\t\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {\n\n\t\t\t\t\tthis.object._finalize( true );\n\n\t\t\t\t}\n\n\t\t\t\tthis.object = {\n\t\t\t\t\tname: name || '',\n\t\t\t\t\tfromDeclaration: ( fromDeclaration !== false ),\n\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\tvertices: [],\n\t\t\t\t\t\tnormals: [],\n\t\t\t\t\t\tcolors: [],\n\t\t\t\t\t\tuvs: [],\n\t\t\t\t\t\thasUVIndices: false\n\t\t\t\t\t},\n\t\t\t\t\tmaterials: [],\n\t\t\t\t\tsmooth: true,\n\n\t\t\t\t\tstartMaterial: function ( name, libraries ) {\n\n\t\t\t\t\t\tvar previous = this._finalize( false );\n\n\t\t\t\t\t\t// New usemtl declaration overwrites an inherited material, except if faces were declared\n\t\t\t\t\t\t// after the material, then it must be preserved for proper MultiMaterial continuation.\n\t\t\t\t\t\tif ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {\n\n\t\t\t\t\t\t\tthis.materials.splice( previous.index, 1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar material = {\n\t\t\t\t\t\t\tindex: this.materials.length,\n\t\t\t\t\t\t\tname: name || '',\n\t\t\t\t\t\t\tmtllib: ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),\n\t\t\t\t\t\t\tsmooth: ( previous !== undefined ? previous.smooth : this.smooth ),\n\t\t\t\t\t\t\tgroupStart: ( previous !== undefined ? previous.groupEnd : 0 ),\n\t\t\t\t\t\t\tgroupEnd: - 1,\n\t\t\t\t\t\t\tgroupCount: - 1,\n\t\t\t\t\t\t\tinherited: false,\n\n\t\t\t\t\t\t\tclone: function ( index ) {\n\n\t\t\t\t\t\t\t\tvar cloned = {\n\t\t\t\t\t\t\t\t\tindex: ( typeof index === 'number' ? index : this.index ),\n\t\t\t\t\t\t\t\t\tname: this.name,\n\t\t\t\t\t\t\t\t\tmtllib: this.mtllib,\n\t\t\t\t\t\t\t\t\tsmooth: this.smooth,\n\t\t\t\t\t\t\t\t\tgroupStart: 0,\n\t\t\t\t\t\t\t\t\tgroupEnd: - 1,\n\t\t\t\t\t\t\t\t\tgroupCount: - 1,\n\t\t\t\t\t\t\t\t\tinherited: false\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tcloned.clone = this.clone.bind( cloned );\n\t\t\t\t\t\t\t\treturn cloned;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tthis.materials.push( material );\n\n\t\t\t\t\t\treturn material;\n\n\t\t\t\t\t},\n\n\t\t\t\t\tcurrentMaterial: function () {\n\n\t\t\t\t\t\tif ( this.materials.length > 0 ) {\n\n\t\t\t\t\t\t\treturn this.materials[ this.materials.length - 1 ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn undefined;\n\n\t\t\t\t\t},\n\n\t\t\t\t\t_finalize: function ( end ) {\n\n\t\t\t\t\t\tvar lastMultiMaterial = this.currentMaterial();\n\t\t\t\t\t\tif ( lastMultiMaterial && lastMultiMaterial.groupEnd === - 1 ) {\n\n\t\t\t\t\t\t\tlastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n\t\t\t\t\t\t\tlastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n\t\t\t\t\t\t\tlastMultiMaterial.inherited = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Ignore objects tail materials if no face declarations followed them before a new o/g started.\n\t\t\t\t\t\tif ( end && this.materials.length > 1 ) {\n\n\t\t\t\t\t\t\tfor ( var mi = this.materials.length - 1; mi >= 0; mi -- ) {\n\n\t\t\t\t\t\t\t\tif ( this.materials[ mi ].groupCount <= 0 ) {\n\n\t\t\t\t\t\t\t\t\tthis.materials.splice( mi, 1 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Guarantee at least one empty material, this makes the creation later more straight forward.\n\t\t\t\t\t\tif ( end && this.materials.length === 0 ) {\n\n\t\t\t\t\t\t\tthis.materials.push( {\n\t\t\t\t\t\t\t\tname: '',\n\t\t\t\t\t\t\t\tsmooth: this.smooth\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn lastMultiMaterial;\n\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// Inherit previous objects material.\n\t\t\t\t// Spec tells us that a declared material must be set to all objects until a new material is declared.\n\t\t\t\t// If a usemtl declaration is encountered while this new object is being parsed, it will\n\t\t\t\t// overwrite the inherited material. Exception being that there was already face declarations\n\t\t\t\t// to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n\n\t\t\t\tif ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function' ) {\n\n\t\t\t\t\tvar declared = previousMaterial.clone( 0 );\n\t\t\t\t\tdeclared.inherited = true;\n\t\t\t\t\tthis.object.materials.push( declared );\n\n\t\t\t\t}\n\n\t\t\t\tthis.objects.push( this.object );\n\n\t\t\t},\n\n\t\t\tfinalize: function () {\n\n\t\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {\n\n\t\t\t\t\tthis.object._finalize( true );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tparseVertexIndex: function ( value, len ) {\n\n\t\t\t\tvar index = parseInt( value, 10 );\n\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;\n\n\t\t\t},\n\n\t\t\tparseNormalIndex: function ( value, len ) {\n\n\t\t\t\tvar index = parseInt( value, 10 );\n\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;\n\n\t\t\t},\n\n\t\t\tparseUVIndex: function ( value, len ) {\n\n\t\t\t\tvar index = parseInt( value, 10 );\n\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 2 ) * 2;\n\n\t\t\t},\n\n\t\t\taddVertex: function ( a, b, c ) {\n\n\t\t\t\tvar src = this.vertices;\n\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\n\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\n\n\t\t\t},\n\n\t\t\taddVertexPoint: function ( a ) {\n\n\t\t\t\tvar src = this.vertices;\n\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\n\t\t\t},\n\n\t\t\taddVertexLine: function ( a ) {\n\n\t\t\t\tvar src = this.vertices;\n\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\n\t\t\t},\n\n\t\t\taddNormal: function ( a, b, c ) {\n\n\t\t\t\tvar src = this.normals;\n\t\t\t\tvar dst = this.object.geometry.normals;\n\n\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\n\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\n\n\t\t\t},\n\n\t\t\taddFaceNormal: function ( a, b, c ) {\n\n\t\t\t\tvar src = this.vertices;\n\t\t\t\tvar dst = this.object.geometry.normals;\n\n\t\t\t\tvA.fromArray( src, a );\n\t\t\t\tvB.fromArray( src, b );\n\t\t\t\tvC.fromArray( src, c );\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tcb.normalize();\n\n\t\t\t\tdst.push( cb.x, cb.y, cb.z );\n\t\t\t\tdst.push( cb.x, cb.y, cb.z );\n\t\t\t\tdst.push( cb.x, cb.y, cb.z );\n\n\t\t\t},\n\n\t\t\taddColor: function ( a, b, c ) {\n\n\t\t\t\tvar src = this.colors;\n\t\t\t\tvar dst = this.object.geometry.colors;\n\n\t\t\t\tif ( src[ a ] !== undefined ) dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\t\t\t\tif ( src[ b ] !== undefined ) dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\n\t\t\t\tif ( src[ c ] !== undefined ) dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\n\n\t\t\t},\n\n\t\t\taddUV: function ( a, b, c ) {\n\n\t\t\t\tvar src = this.uvs;\n\t\t\t\tvar dst = this.object.geometry.uvs;\n\n\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ] );\n\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ] );\n\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ] );\n\n\t\t\t},\n\n\t\t\taddDefaultUV: function () {\n\n\t\t\t\tvar dst = this.object.geometry.uvs;\n\n\t\t\t\tdst.push( 0, 0 );\n\t\t\t\tdst.push( 0, 0 );\n\t\t\t\tdst.push( 0, 0 );\n\n\t\t\t},\n\n\t\t\taddUVLine: function ( a ) {\n\n\t\t\t\tvar src = this.uvs;\n\t\t\t\tvar dst = this.object.geometry.uvs;\n\n\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ] );\n\n\t\t\t},\n\n\t\t\taddFace: function ( a, b, c, ua, ub, uc, na, nb, nc ) {\n\n\t\t\t\tvar vLen = this.vertices.length;\n\n\t\t\t\tvar ia = this.parseVertexIndex( a, vLen );\n\t\t\t\tvar ib = this.parseVertexIndex( b, vLen );\n\t\t\t\tvar ic = this.parseVertexIndex( c, vLen );\n\n\t\t\t\tthis.addVertex( ia, ib, ic );\n\t\t\t\tthis.addColor( ia, ib, ic );\n\n\t\t\t\t// normals\n\n\t\t\t\tif ( na !== undefined && na !== '' ) {\n\n\t\t\t\t\tvar nLen = this.normals.length;\n\n\t\t\t\t\tia = this.parseNormalIndex( na, nLen );\n\t\t\t\t\tib = this.parseNormalIndex( nb, nLen );\n\t\t\t\t\tic = this.parseNormalIndex( nc, nLen );\n\n\t\t\t\t\tthis.addNormal( ia, ib, ic );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.addFaceNormal( ia, ib, ic );\n\n\t\t\t\t}\n\n\t\t\t\t// uvs\n\n\t\t\t\tif ( ua !== undefined && ua !== '' ) {\n\n\t\t\t\t\tvar uvLen = this.uvs.length;\n\n\t\t\t\t\tia = this.parseUVIndex( ua, uvLen );\n\t\t\t\t\tib = this.parseUVIndex( ub, uvLen );\n\t\t\t\t\tic = this.parseUVIndex( uc, uvLen );\n\n\t\t\t\t\tthis.addUV( ia, ib, ic );\n\n\t\t\t\t\tthis.object.geometry.hasUVIndices = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// add placeholder values (for inconsistent face definitions)\n\n\t\t\t\t\tthis.addDefaultUV();\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\taddPointGeometry: function ( vertices ) {\n\n\t\t\t\tthis.object.geometry.type = 'Points';\n\n\t\t\t\tvar vLen = this.vertices.length;\n\n\t\t\t\tfor ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {\n\n\t\t\t\t\tvar index = this.parseVertexIndex( vertices[ vi ], vLen );\n\n\t\t\t\t\tthis.addVertexPoint( index );\n\t\t\t\t\tthis.addColor( index );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\taddLineGeometry: function ( vertices, uvs ) {\n\n\t\t\t\tthis.object.geometry.type = 'Line';\n\n\t\t\t\tvar vLen = this.vertices.length;\n\t\t\t\tvar uvLen = this.uvs.length;\n\n\t\t\t\tfor ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {\n\n\t\t\t\t\tthis.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {\n\n\t\t\t\t\tthis.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tstate.startObject( '', false );\n\n\t\treturn state;\n\n\t}\n\n\t//\n\n\tfunction OBJLoader( manager ) {\n\n\t\t_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n\t\tthis.materials = null;\n\n\t}\n\n\tOBJLoader.prototype = Object.assign( Object.create( _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\t\tconstructor: OBJLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.F( this.manager );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setRequestHeader( this.requestHeader );\n\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tif ( onError ) {\n\n\t\t\t\t\t\tonError( e );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetMaterials: function ( materials ) {\n\n\t\t\tthis.materials = materials;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tparse: function ( text ) {\n\n\t\t\tvar state = new ParserState();\n\n\t\t\tif ( text.indexOf( '\\r\\n' ) !== - 1 ) {\n\n\t\t\t\t// This is faster than String.split with regex that splits on both\n\t\t\t\ttext = text.replace( /\\r\\n/g, '\\n' );\n\n\t\t\t}\n\n\t\t\tif ( text.indexOf( '\\\\\\n' ) !== - 1 ) {\n\n\t\t\t\t// join lines separated by a line continuation character (\\)\n\t\t\t\ttext = text.replace( /\\\\\\n/g, '' );\n\n\t\t\t}\n\n\t\t\tvar lines = text.split( '\\n' );\n\t\t\tvar line = '', lineFirstChar = '';\n\t\t\tvar lineLength = 0;\n\t\t\tvar result = [];\n\n\t\t\t// Faster to just trim left side of the line. Use if available.\n\t\t\tvar trimLeft = ( typeof ''.trimLeft === 'function' );\n\n\t\t\tfor ( var i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\t\tline = lines[ i ];\n\n\t\t\t\tline = trimLeft ? line.trimLeft() : line.trim();\n\n\t\t\t\tlineLength = line.length;\n\n\t\t\t\tif ( lineLength === 0 ) continue;\n\n\t\t\t\tlineFirstChar = line.charAt( 0 );\n\n\t\t\t\t// @todo invoke passed in handler if any\n\t\t\t\tif ( lineFirstChar === '#' ) continue;\n\n\t\t\t\tif ( lineFirstChar === 'v' ) {\n\n\t\t\t\t\tvar data = line.split( /\\s+/ );\n\n\t\t\t\t\tswitch ( data[ 0 ] ) {\n\n\t\t\t\t\t\tcase 'v':\n\t\t\t\t\t\t\tstate.vertices.push(\n\t\t\t\t\t\t\t\tparseFloat( data[ 1 ] ),\n\t\t\t\t\t\t\t\tparseFloat( data[ 2 ] ),\n\t\t\t\t\t\t\t\tparseFloat( data[ 3 ] )\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif ( data.length >= 7 ) {\n\n\t\t\t\t\t\t\t\tstate.colors.push(\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 4 ] ),\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 5 ] ),\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 6 ] )\n\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// if no colors are defined, add placeholders so color and vertex indices match\n\n\t\t\t\t\t\t\t\tstate.colors.push( undefined, undefined, undefined );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'vn':\n\t\t\t\t\t\t\tstate.normals.push(\n\t\t\t\t\t\t\t\tparseFloat( data[ 1 ] ),\n\t\t\t\t\t\t\t\tparseFloat( data[ 2 ] ),\n\t\t\t\t\t\t\t\tparseFloat( data[ 3 ] )\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'vt':\n\t\t\t\t\t\t\tstate.uvs.push(\n\t\t\t\t\t\t\t\tparseFloat( data[ 1 ] ),\n\t\t\t\t\t\t\t\tparseFloat( data[ 2 ] )\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( lineFirstChar === 'f' ) {\n\n\t\t\t\t\tvar lineData = line.substr( 1 ).trim();\n\t\t\t\t\tvar vertexData = lineData.split( /\\s+/ );\n\t\t\t\t\tvar faceVertices = [];\n\n\t\t\t\t\t// Parse the face vertex data into an easy to work with format\n\n\t\t\t\t\tfor ( var j = 0, jl = vertexData.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar vertex = vertexData[ j ];\n\n\t\t\t\t\t\tif ( vertex.length > 0 ) {\n\n\t\t\t\t\t\t\tvar vertexParts = vertex.split( '/' );\n\t\t\t\t\t\t\tfaceVertices.push( vertexParts );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Draw an edge between the first vertex and all subsequent vertices to form an n-gon\n\n\t\t\t\t\tvar v1 = faceVertices[ 0 ];\n\n\t\t\t\t\tfor ( var j = 1, jl = faceVertices.length - 1; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar v2 = faceVertices[ j ];\n\t\t\t\t\t\tvar v3 = faceVertices[ j + 1 ];\n\n\t\t\t\t\t\tstate.addFace(\n\t\t\t\t\t\t\tv1[ 0 ], v2[ 0 ], v3[ 0 ],\n\t\t\t\t\t\t\tv1[ 1 ], v2[ 1 ], v3[ 1 ],\n\t\t\t\t\t\t\tv1[ 2 ], v2[ 2 ], v3[ 2 ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( lineFirstChar === 'l' ) {\n\n\t\t\t\t\tvar lineParts = line.substring( 1 ).trim().split( ' ' );\n\t\t\t\t\tvar lineVertices = [], lineUVs = [];\n\n\t\t\t\t\tif ( line.indexOf( '/' ) === - 1 ) {\n\n\t\t\t\t\t\tlineVertices = lineParts;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( var li = 0, llen = lineParts.length; li < llen; li ++ ) {\n\n\t\t\t\t\t\t\tvar parts = lineParts[ li ].split( '/' );\n\n\t\t\t\t\t\t\tif ( parts[ 0 ] !== '' ) lineVertices.push( parts[ 0 ] );\n\t\t\t\t\t\t\tif ( parts[ 1 ] !== '' ) lineUVs.push( parts[ 1 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.addLineGeometry( lineVertices, lineUVs );\n\n\t\t\t\t} else if ( lineFirstChar === 'p' ) {\n\n\t\t\t\t\tvar lineData = line.substr( 1 ).trim();\n\t\t\t\t\tvar pointData = lineData.split( ' ' );\n\n\t\t\t\t\tstate.addPointGeometry( pointData );\n\n\t\t\t\t} else if ( ( result = object_pattern.exec( line ) ) !== null ) {\n\n\t\t\t\t\t// o object_name\n\t\t\t\t\t// or\n\t\t\t\t\t// g group_name\n\n\t\t\t\t\t// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n\t\t\t\t\t// var name = result[ 0 ].substr( 1 ).trim();\n\t\t\t\t\tvar name = ( ' ' + result[ 0 ].substr( 1 ).trim() ).substr( 1 );\n\n\t\t\t\t\tstate.startObject( name );\n\n\t\t\t\t} else if ( material_use_pattern.test( line ) ) {\n\n\t\t\t\t\t// material\n\n\t\t\t\t\tstate.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );\n\n\t\t\t\t} else if ( material_library_pattern.test( line ) ) {\n\n\t\t\t\t\t// mtl file\n\n\t\t\t\t\tstate.materialLibraries.push( line.substring( 7 ).trim() );\n\n\t\t\t\t} else if ( map_use_pattern.test( line ) ) {\n\n\t\t\t\t\t// the line is parsed but ignored since the loader assumes textures are defined MTL files\n\t\t\t\t\t// (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)\n\n\t\t\t\t\tconsole.warn( 'THREE.OBJLoader: Rendering identifier \"usemap\" not supported. Textures must be defined in MTL files.' );\n\n\t\t\t\t} else if ( lineFirstChar === 's' ) {\n\n\t\t\t\t\tresult = line.split( ' ' );\n\n\t\t\t\t\t// smooth shading\n\n\t\t\t\t\t// @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n\t\t\t\t\t// but does not define a usemtl for each face set.\n\t\t\t\t\t// This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n\t\t\t\t\t// This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n\t\t\t\t\t// where explicit usemtl defines geometry groups.\n\t\t\t\t\t// Example asset: examples/models/obj/cerberus/Cerberus.obj\n\n\t\t\t\t\t/*\n\t\t\t\t\t * http://paulbourke.net/dataformats/obj/\n\t\t\t\t\t * or\n\t\t\t\t\t * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf\n\t\t\t\t\t *\n\t\t\t\t\t * From chapter \"Grouping\" Syntax explanation \"s group_number\":\n\t\t\t\t\t * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.\n\t\t\t\t\t * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form\n\t\t\t\t\t * surfaces, smoothing groups are either turned on or off; there is no difference between values greater\n\t\t\t\t\t * than 0.\"\n\t\t\t\t\t */\n\t\t\t\t\tif ( result.length > 1 ) {\n\n\t\t\t\t\t\tvar value = result[ 1 ].trim().toLowerCase();\n\t\t\t\t\t\tstate.object.smooth = ( value !== '0' && value !== 'off' );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// ZBrush can produce \"s\" lines #11707\n\t\t\t\t\t\tstate.object.smooth = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar material = state.object.currentMaterial();\n\t\t\t\t\tif ( material ) material.smooth = state.object.smooth;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Handle null terminated files without exception\n\t\t\t\t\tif ( line === '\\0' ) continue;\n\n\t\t\t\t\tconsole.warn( 'THREE.OBJLoader: Unexpected line: \"' + line + '\"' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.finalize();\n\n\t\t\tvar container = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\t\t\tcontainer.materialLibraries = [].concat( state.materialLibraries );\n\n\t\t\tvar hasPrimitives = ! ( state.objects.length === 1 && state.objects[ 0 ].geometry.vertices.length === 0 );\n\n\t\t\tif ( hasPrimitives === true ) {\n\n\t\t\t\tfor ( var i = 0, l = state.objects.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar object = state.objects[ i ];\n\t\t\t\t\tvar geometry = object.geometry;\n\t\t\t\t\tvar materials = object.materials;\n\t\t\t\t\tvar isLine = ( geometry.type === 'Line' );\n\t\t\t\t\tvar isPoints = ( geometry.type === 'Points' );\n\t\t\t\t\tvar hasVertexColors = false;\n\n\t\t\t\t\t// Skip o/g line declarations that did not follow with any faces\n\t\t\t\t\tif ( geometry.vertices.length === 0 ) continue;\n\n\t\t\t\t\tvar buffergeometry = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\t\t\t\tbuffergeometry.setAttribute( 'position', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( geometry.vertices, 3 ) );\n\n\t\t\t\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\t\t\t\tbuffergeometry.setAttribute( 'normal', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( geometry.normals, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\t\t\t\thasVertexColors = true;\n\t\t\t\t\t\tbuffergeometry.setAttribute( 'color', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( geometry.colors, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geometry.hasUVIndices === true ) {\n\n\t\t\t\t\t\tbuffergeometry.setAttribute( 'uv', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( geometry.uvs, 2 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create materials\n\n\t\t\t\t\tvar createdMaterials = [];\n\n\t\t\t\t\tfor ( var mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {\n\n\t\t\t\t\t\tvar sourceMaterial = materials[ mi ];\n\t\t\t\t\t\tvar materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;\n\t\t\t\t\t\tvar material = state.materials[ materialHash ];\n\n\t\t\t\t\t\tif ( this.materials !== null ) {\n\n\t\t\t\t\t\t\tmaterial = this.materials.create( sourceMaterial.name );\n\n\t\t\t\t\t\t\t// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\n\t\t\t\t\t\t\tif ( isLine && material && ! ( material instanceof _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.q ) ) {\n\n\t\t\t\t\t\t\t\tvar materialLine = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.q();\n\t\t\t\t\t\t\t\t_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.p.prototype.copy.call( materialLine, material );\n\t\t\t\t\t\t\t\tmaterialLine.color.copy( material.color );\n\t\t\t\t\t\t\t\tmaterial = materialLine;\n\n\t\t\t\t\t\t\t} else if ( isPoints && material && ! ( material instanceof _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.P ) ) {\n\n\t\t\t\t\t\t\t\tvar materialPoints = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.P( { size: 10, sizeAttenuation: false } );\n\t\t\t\t\t\t\t\t_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.p.prototype.copy.call( materialPoints, material );\n\t\t\t\t\t\t\t\tmaterialPoints.color.copy( material.color );\n\t\t\t\t\t\t\t\tmaterialPoints.map = material.map;\n\t\t\t\t\t\t\t\tmaterial = materialPoints;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( material === undefined ) {\n\n\t\t\t\t\t\t\tif ( isLine ) {\n\n\t\t\t\t\t\t\t\tmaterial = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.q();\n\n\t\t\t\t\t\t\t} else if ( isPoints ) {\n\n\t\t\t\t\t\t\t\tmaterial = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.P( { size: 1, sizeAttenuation: false } );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tmaterial = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.al();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmaterial.name = sourceMaterial.name;\n\t\t\t\t\t\t\tmaterial.flatShading = sourceMaterial.smooth ? false : true;\n\t\t\t\t\t\t\tmaterial.vertexColors = hasVertexColors;\n\n\t\t\t\t\t\t\tstate.materials[ materialHash ] = material;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcreatedMaterials.push( material );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create mesh\n\n\t\t\t\t\tvar mesh;\n\n\t\t\t\t\tif ( createdMaterials.length > 1 ) {\n\n\t\t\t\t\t\tfor ( var mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {\n\n\t\t\t\t\t\t\tvar sourceMaterial = materials[ mi ];\n\t\t\t\t\t\t\tbuffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( isLine ) {\n\n\t\t\t\t\t\t\tmesh = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.w( buffergeometry, createdMaterials );\n\n\t\t\t\t\t\t} else if ( isPoints ) {\n\n\t\t\t\t\t\t\tmesh = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.z( buffergeometry, createdMaterials );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmesh = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.v( buffergeometry, createdMaterials );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( isLine ) {\n\n\t\t\t\t\t\t\tmesh = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.w( buffergeometry, createdMaterials[ 0 ] );\n\n\t\t\t\t\t\t} else if ( isPoints ) {\n\n\t\t\t\t\t\t\tmesh = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.z( buffergeometry, createdMaterials[ 0 ] );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmesh = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.v( buffergeometry, createdMaterials[ 0 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.name = object.name;\n\n\t\t\t\t\tcontainer.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// if there is only the default parser state object with no geometry data, interpret data as point cloud\n\n\t\t\t\tif ( state.vertices.length > 0 ) {\n\n\t\t\t\t\tvar material = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.P( { size: 1, sizeAttenuation: false } );\n\n\t\t\t\t\tvar buffergeometry = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\t\t\t\tbuffergeometry.setAttribute( 'position', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( state.vertices, 3 ) );\n\n\t\t\t\t\tif ( state.colors.length > 0 && state.colors[ 0 ] !== undefined ) {\n\n\t\t\t\t\t\tbuffergeometry.setAttribute( 'color', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( state.colors, 3 ) );\n\t\t\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar points = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.z( buffergeometry, material );\n\t\t\t\t\tcontainer.add( points );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn container;\n\n\t\t}\n\n\t} );\n\n\treturn OBJLoader;\n\n} )();\n\n/**\n * Loads a Wavefront .mtl file specifying materials\n */\n\nvar MTLLoader = function ( manager ) {\n\n\t_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n};\n\nMTLLoader.prototype = Object.assign( Object.create( _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\tconstructor: MTLLoader,\n\n\t/**\n\t * Loads and parses a MTL asset from a URL.\n\t *\n\t * @param {String} url - URL to the MTL file.\n\t * @param {Function} [onLoad] - Callback invoked with the loaded object.\n\t * @param {Function} [onProgress] - Callback for download progress.\n\t * @param {Function} [onError] - Callback for download errors.\n\t *\n\t * @see setPath setResourcePath\n\t *\n\t * @note In order for relative texture references to resolve correctly\n\t * you must call setResourcePath() explicitly prior to load.\n\t */\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar path = ( this.path === '' ) ? _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.f.extractUrlBase( url ) : this.path;\n\n\t\tvar loader = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.F( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text, path ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetMaterialOptions: function ( value ) {\n\n\t\tthis.materialOptions = value;\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Parses a MTL file.\n\t *\n\t * @param {String} text - Content of MTL file\n\t * @return {MTLLoader.MaterialCreator}\n\t *\n\t * @see setPath setResourcePath\n\t *\n\t * @note In order for relative texture references to resolve correctly\n\t * you must call setResourcePath() explicitly prior to parse.\n\t */\n\tparse: function ( text, path ) {\n\n\t\tvar lines = text.split( '\\n' );\n\t\tvar info = {};\n\t\tvar delimiter_pattern = /\\s+/;\n\t\tvar materialsInfo = {};\n\n\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\tvar line = lines[ i ];\n\t\t\tline = line.trim();\n\n\t\t\tif ( line.length === 0 || line.charAt( 0 ) === '#' ) {\n\n\t\t\t\t// Blank line or comment ignore\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tvar pos = line.indexOf( ' ' );\n\n\t\t\tvar key = ( pos >= 0 ) ? line.substring( 0, pos ) : line;\n\t\t\tkey = key.toLowerCase();\n\n\t\t\tvar value = ( pos >= 0 ) ? line.substring( pos + 1 ) : '';\n\t\t\tvalue = value.trim();\n\n\t\t\tif ( key === 'newmtl' ) {\n\n\t\t\t\t// New material\n\n\t\t\t\tinfo = { name: value };\n\t\t\t\tmaterialsInfo[ value ] = info;\n\n\t\t\t} else {\n\n\t\t\t\tif ( key === 'ka' || key === 'kd' || key === 'ks' || key === 'ke' ) {\n\n\t\t\t\t\tvar ss = value.split( delimiter_pattern, 3 );\n\t\t\t\t\tinfo[ key ] = [ parseFloat( ss[ 0 ] ), parseFloat( ss[ 1 ] ), parseFloat( ss[ 2 ] ) ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tinfo[ key ] = value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar materialCreator = new MTLLoader.MaterialCreator( this.resourcePath || path, this.materialOptions );\n\t\tmaterialCreator.setCrossOrigin( this.crossOrigin );\n\t\tmaterialCreator.setManager( this.manager );\n\t\tmaterialCreator.setMaterials( materialsInfo );\n\t\treturn materialCreator;\n\n\t}\n\n} );\n\n/**\n * Create a new MTLLoader.MaterialCreator\n * @param baseUrl - Url relative to which textures are loaded\n * @param options - Set of options on how to construct the materials\n *                  side: Which side to apply the material\n *                        FrontSide (default), THREE.BackSide, THREE.DoubleSide\n *                  wrap: What type of wrapping to apply for textures\n *                        RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\n *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\n *                                Default: false, assumed to be already normalized\n *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\n *                                  Default: false\n * @constructor\n */\n\nMTLLoader.MaterialCreator = function ( baseUrl, options ) {\n\n\tthis.baseUrl = baseUrl || '';\n\tthis.options = options;\n\tthis.materialsInfo = {};\n\tthis.materials = {};\n\tthis.materialsArray = [];\n\tthis.nameLookup = {};\n\n\tthis.side = ( this.options && this.options.side ) ? this.options.side : _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a8;\n\tthis.wrap = ( this.options && this.options.wrap ) ? this.options.wrap : _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.o;\n\n};\n\nMTLLoader.MaterialCreator.prototype = {\n\n\tconstructor: MTLLoader.MaterialCreator,\n\n\tcrossOrigin: 'anonymous',\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tsetManager: function ( value ) {\n\n\t\tthis.manager = value;\n\n\t},\n\n\tsetMaterials: function ( materialsInfo ) {\n\n\t\tthis.materialsInfo = this.convert( materialsInfo );\n\t\tthis.materials = {};\n\t\tthis.materialsArray = [];\n\t\tthis.nameLookup = {};\n\n\t},\n\n\tconvert: function ( materialsInfo ) {\n\n\t\tif ( ! this.options ) return materialsInfo;\n\n\t\tvar converted = {};\n\n\t\tfor ( var mn in materialsInfo ) {\n\n\t\t\t// Convert materials info into normalized form based on options\n\n\t\t\tvar mat = materialsInfo[ mn ];\n\n\t\t\tvar covmat = {};\n\n\t\t\tconverted[ mn ] = covmat;\n\n\t\t\tfor ( var prop in mat ) {\n\n\t\t\t\tvar save = true;\n\t\t\t\tvar value = mat[ prop ];\n\t\t\t\tvar lprop = prop.toLowerCase();\n\n\t\t\t\tswitch ( lprop ) {\n\n\t\t\t\t\tcase 'kd':\n\t\t\t\t\tcase 'ka':\n\t\t\t\t\tcase 'ks':\n\n\t\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\t\tif ( this.options && this.options.normalizeRGB ) {\n\n\t\t\t\t\t\t\tvalue = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( this.options && this.options.ignoreZeroRGBs ) {\n\n\t\t\t\t\t\t\tif ( value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 2 ] === 0 ) {\n\n\t\t\t\t\t\t\t\t// ignore\n\n\t\t\t\t\t\t\t\tsave = false;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( save ) {\n\n\t\t\t\t\tcovmat[ lprop ] = value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn converted;\n\n\t},\n\n\tpreload: function () {\n\n\t\tfor ( var mn in this.materialsInfo ) {\n\n\t\t\tthis.create( mn );\n\n\t\t}\n\n\t},\n\n\tgetIndex: function ( materialName ) {\n\n\t\treturn this.nameLookup[ materialName ];\n\n\t},\n\n\tgetAsArray: function () {\n\n\t\tvar index = 0;\n\n\t\tfor ( var mn in this.materialsInfo ) {\n\n\t\t\tthis.materialsArray[ index ] = this.create( mn );\n\t\t\tthis.nameLookup[ mn ] = index;\n\t\t\tindex ++;\n\n\t\t}\n\n\t\treturn this.materialsArray;\n\n\t},\n\n\tcreate: function ( materialName ) {\n\n\t\tif ( this.materials[ materialName ] === undefined ) {\n\n\t\t\tthis.createMaterial_( materialName );\n\n\t\t}\n\n\t\treturn this.materials[ materialName ];\n\n\t},\n\n\tcreateMaterial_: function ( materialName ) {\n\n\t\t// Create material\n\n\t\tvar scope = this;\n\t\tvar mat = this.materialsInfo[ materialName ];\n\t\tvar params = {\n\n\t\t\tname: materialName,\n\t\t\tside: this.side\n\n\t\t};\n\n\t\tfunction resolveURL( baseUrl, url ) {\n\n\t\t\tif ( typeof url !== 'string' || url === '' )\n\t\t\t\treturn '';\n\n\t\t\t// Absolute URL\n\t\t\tif ( /^https?:\\/\\//i.test( url ) ) return url;\n\n\t\t\treturn baseUrl + url;\n\n\t\t}\n\n\t\tfunction setMapForType( mapType, value ) {\n\n\t\t\tif ( params[ mapType ] ) return; // Keep the first encountered texture\n\n\t\t\tvar texParams = scope.getTextureParams( value, params );\n\t\t\tvar map = scope.loadTexture( resolveURL( scope.baseUrl, texParams.url ) );\n\n\t\t\tmap.repeat.copy( texParams.scale );\n\t\t\tmap.offset.copy( texParams.offset );\n\n\t\t\tmap.wrapS = scope.wrap;\n\t\t\tmap.wrapT = scope.wrap;\n\n\t\t\tparams[ mapType ] = map;\n\n\t\t}\n\n\t\tfor ( var prop in mat ) {\n\n\t\t\tvar value = mat[ prop ];\n\t\t\tvar n;\n\n\t\t\tif ( value === '' ) continue;\n\n\t\t\tswitch ( prop.toLowerCase() ) {\n\n\t\t\t\t// Ns is material specular exponent\n\n\t\t\t\tcase 'kd':\n\n\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\tparams.color = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ks':\n\n\t\t\t\t\t// Specular color (color when light is reflected from shiny surface) using RGB values\n\t\t\t\t\tparams.specular = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ke':\n\n\t\t\t\t\t// Emissive using RGB values\n\t\t\t\t\tparams.emissive = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_kd':\n\n\t\t\t\t\t// Diffuse texture map\n\n\t\t\t\t\tsetMapForType( 'map', value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_ks':\n\n\t\t\t\t\t// Specular map\n\n\t\t\t\t\tsetMapForType( 'specularMap', value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_ke':\n\n\t\t\t\t\t// Emissive map\n\n\t\t\t\t\tsetMapForType( 'emissiveMap', value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'norm':\n\n\t\t\t\t\tsetMapForType( 'normalMap', value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_bump':\n\t\t\t\tcase 'bump':\n\n\t\t\t\t\t// Bump texture map\n\n\t\t\t\t\tsetMapForType( 'bumpMap', value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_d':\n\n\t\t\t\t\t// Alpha map\n\n\t\t\t\t\tsetMapForType( 'alphaMap', value );\n\t\t\t\t\tparams.transparent = true;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ns':\n\n\t\t\t\t\t// The specular exponent (defines the focus of the specular highlight)\n\t\t\t\t\t// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n\n\t\t\t\t\tparams.shininess = parseFloat( value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'd':\n\t\t\t\t\tn = parseFloat( value );\n\n\t\t\t\t\tif ( n < 1 ) {\n\n\t\t\t\t\t\tparams.opacity = n;\n\t\t\t\t\t\tparams.transparent = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'tr':\n\t\t\t\t\tn = parseFloat( value );\n\n\t\t\t\t\tif ( this.options && this.options.invertTrProperty ) n = 1 - n;\n\n\t\t\t\t\tif ( n > 0 ) {\n\n\t\t\t\t\t\tparams.opacity = 1 - n;\n\t\t\t\t\t\tparams.transparent = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.materials[ materialName ] = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.al( params );\n\t\treturn this.materials[ materialName ];\n\n\t},\n\n\tgetTextureParams: function ( value, matParams ) {\n\n\t\tvar texParams = {\n\n\t\t\tscale: new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a( 1, 1 ),\n\t\t\toffset: new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a( 0, 0 )\n\n\t\t };\n\n\t\tvar items = value.split( /\\s+/ );\n\t\tvar pos;\n\n\t\tpos = items.indexOf( '-bm' );\n\n\t\tif ( pos >= 0 ) {\n\n\t\t\tmatParams.bumpScale = parseFloat( items[ pos + 1 ] );\n\t\t\titems.splice( pos, 2 );\n\n\t\t}\n\n\t\tpos = items.indexOf( '-s' );\n\n\t\tif ( pos >= 0 ) {\n\n\t\t\ttexParams.scale.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );\n\t\t\titems.splice( pos, 4 ); // we expect 3 parameters here!\n\n\t\t}\n\n\t\tpos = items.indexOf( '-o' );\n\n\t\tif ( pos >= 0 ) {\n\n\t\t\ttexParams.offset.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );\n\t\t\titems.splice( pos, 4 ); // we expect 3 parameters here!\n\n\t\t}\n\n\t\ttexParams.url = items.join( ' ' ).trim();\n\t\treturn texParams;\n\n\t},\n\n\tloadTexture: function ( url, mapping, onLoad, onProgress, onError ) {\n\n\t\tvar texture;\n\t\tvar manager = ( this.manager !== undefined ) ? this.manager : _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.an;\n\t\tvar loader = manager.getHandler( url );\n\n\t\tif ( loader === null ) {\n\n\t\t\tloader = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.j( manager );\n\n\t\t}\n\n\t\tif ( loader.setCrossOrigin ) loader.setCrossOrigin( this.crossOrigin );\n\t\ttexture = loader.load( url, onLoad, onProgress, onError );\n\n\t\tif ( mapping !== undefined ) texture.mapping = mapping;\n\n\t\treturn texture;\n\n\t}\n\n};\n\n/*! chevrotain - v4.6.0 */\n!function(t,e){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(\"chevrotain\",[],e):\"object\"==typeof exports?exports.chevrotain=e():t.chevrotain=e();}(\"undefined\"!=typeof self?self:undefined,function(){return function(t){var e={};function n(r){if(e[r])return e[r].exports;var i=e[r]={i:r,l:!1,exports:{}};return t[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=t,n.c=e,n.d=function(t,e,r){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r});},n.r=function(t){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0});},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&\"object\"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:t}),2&e&&\"string\"!=typeof t)for(var i in t)n.d(r,i,function(e){return t[e]}.bind(null,i));return r},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,\"a\",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p=\"\",n(n.s=18)}([function(t,e,n){function r(t){return t&&0===t.length}function i(t){return null==t?[]:Object.keys(t)}function o(t){for(var e=[],n=Object.keys(t),r=0;r<n.length;r++)e.push(t[n[r]]);return e}function a(t,e){for(var n=[],r=i(t),o=0;o<r.length;o++){var a=r[o];n.push(e.call(null,t[a],a));}return n}function s(t,e){for(var n=[],r=0;r<t.length;r++)n.push(e.call(null,t[r],r));return n}function u(t){for(var e=[],n=0;n<t.length;n++){var r=t[n];Array.isArray(r)?e=e.concat(u(r)):e.push(r);}return e}function c(t){return r(t)?void 0:t[0]}function p(t){var e=t&&t.length;return e?t[e-1]:void 0}function l(t,e){if(Array.isArray(t))for(var n=0;n<t.length;n++)e.call(null,t[n],n);else {if(!C(t))throw Error(\"non exhaustive match\");var r=i(t);for(n=0;n<r.length;n++){var o=r[n],a=t[o];e.call(null,a,o);}}}function h(t){return \"string\"==typeof t}function f(t){return void 0===t}function d(t){return t instanceof Function}function E(t,e){return void 0===e&&(e=1),t.slice(e,t.length)}function m(t,e){return void 0===e&&(e=1),t.slice(0,t.length-e)}function y(t,e){var n=[];if(Array.isArray(t))for(var r=0;r<t.length;r++){var i=t[r];e.call(null,i)&&n.push(i);}return n}function T(t,e){return y(t,function(t){return !e(t)})}function v(t,e){for(var n=Object.keys(t),r={},i=0;i<n.length;i++){var o=n[i],a=t[o];e(a)&&(r[o]=a);}return r}function g(t,e){return !!C(t)&&t.hasOwnProperty(e)}function _(t,e){return void 0!==N(t,function(t){return t===e})}function R(t){for(var e=[],n=0;n<t.length;n++)e.push(t[n]);return e}function A(t){var e={};for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e}function N(t,e){for(var n=0;n<t.length;n++){var r=t[n];if(e.call(null,r))return r}}function O(t,e){for(var n=[],r=0;r<t.length;r++){var i=t[r];e.call(null,i)&&n.push(i);}return n}function S(t,e,n){for(var r=Array.isArray(t),a=r?t:o(t),s=r?[]:i(t),u=n,c=0;c<a.length;c++)u=e.call(null,u,a[c],r?c:s[c]);return u}function I(t){return T(t,function(t){return null==t})}function L(t,e){void 0===e&&(e=function(t){return t});var n=[];return S(t,function(t,r){var i=e(r);return _(n,i)?t:(n.push(i),t.concat(r))},[])}function k(t){for(var e=[],n=1;n<arguments.length;n++)e[n-1]=arguments[n];var r=[null].concat(e);return Function.bind.apply(t,r)}function P(t){return Array.isArray(t)}function x(t){return t instanceof RegExp}function C(t){return t instanceof Object}function M(t,e){for(var n=0;n<t.length;n++)if(!e(t[n],n))return !1;return !0}function F(t,e){return T(t,function(t){return _(e,t)})}function b(t,e){for(var n=0;n<t.length;n++)if(e(t[n]))return !0;return !1}function D(t,e){for(var n=0;n<t.length;n++)if(t[n]===e)return n;return -1}function w(t,e){var n=R(t);return n.sort(function(t,n){return e(t)-e(n)}),n}function U(t,e){if(t.length!==e.length)throw Error(\"can't zipObject with different number of keys and values!\");for(var n={},r=0;r<t.length;r++)n[t[r]]=e[r];return n}function G(t){for(var e=[],n=1;n<arguments.length;n++)e[n-1]=arguments[n];for(var r=0;r<e.length;r++)for(var o=e[r],a=i(o),s=0;s<a.length;s++){var u=a[s];t[u]=o[u];}return t}function B(t){for(var e=[],n=1;n<arguments.length;n++)e[n-1]=arguments[n];for(var r=0;r<e.length;r++){var o=e[r];if(!f(o))for(var a=i(o),s=0;s<a.length;s++){var u=a[s];g(t,u)||(t[u]=o[u]);}}return t}function K(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];return B.apply(null,[{}].concat(t))}function W(t,e){var n={};return l(t,function(t){var r=e(t),i=n[r];i?i.push(t):n[r]=[t];}),n}function j(t,e){for(var n=A(t),r=i(e),o=0;o<r.length;o++){var a=r[o],s=e[a];n[a]=s;}return n}function V(){}function Y(t){return t}function H(t){for(var e=[],n=0;n<t.length;n++){var r=t[n];e.push(void 0!==r?r:void 0);}return e}function X(t){console&&console.error&&console.error(\"Error: \"+t);}function z(t){console&&console.warn&&console.warn(\"Warning: \"+t);}function q(){return \"function\"==typeof Map}function $(t,e){e.forEach(function(e){var n=e.prototype;Object.getOwnPropertyNames(n).forEach(function(r){if(\"constructor\"!==r){var i=Object.getOwnPropertyDescriptor(n,r);i&&(i.get||i.set)?Object.defineProperty(t.prototype,r,i):t.prototype[r]=e.prototype[r];}});});}function Z(t){function e(){}e.prototype=t;var n=new e;function r(){return typeof n.bar}return r(),r(),t}Object.defineProperty(e,\"__esModule\",{value:!0}),e.isEmpty=r,e.keys=i,e.values=o,e.mapValues=a,e.map=s,e.flatten=u,e.first=c,e.last=p,e.forEach=l,e.isString=h,e.isUndefined=f,e.isFunction=d,e.drop=E,e.dropRight=m,e.filter=y,e.reject=T,e.pick=v,e.has=g,e.contains=_,e.cloneArr=R,e.cloneObj=A,e.find=N,e.findAll=O,e.reduce=S,e.compact=I,e.uniq=L,e.partial=k,e.isArray=P,e.isRegExp=x,e.isObject=C,e.every=M,e.difference=F,e.some=b,e.indexOf=D,e.sortBy=w,e.zipObject=U,e.assign=G,e.assignNoOverwrite=B,e.defaults=K,e.groupBy=W,e.merge=j,e.NOOP=V,e.IDENTITY=Y,e.packArray=H,e.PRINT_ERROR=X,e.PRINT_WARNING=z,e.isES2015MapSupported=q,e.applyMixins=$,e.toFastProperties=Z;},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(0),a=n(2),s=function(){function t(t){this.definition=t;}return t.prototype.accept=function(t){t.visit(this),o.forEach(this.definition,function(e){e.accept(t);});},t}();e.AbstractProduction=s;var u=function(t){function e(e){var n=t.call(this,[])||this;return n.idx=1,o.assign(n,o.pick(e,function(t){return void 0!==t})),n}return i(e,t),Object.defineProperty(e.prototype,\"definition\",{get:function(){return void 0!==this.referencedRule?this.referencedRule.definition:[]},set:function(t){},enumerable:!0,configurable:!0}),e.prototype.accept=function(t){t.visit(this);},e}(s);e.NonTerminal=u;var c=function(t){function e(e){var n=t.call(this,e.definition)||this;return n.orgText=\"\",o.assign(n,o.pick(e,function(t){return void 0!==t})),n}return i(e,t),e}(s);e.Rule=c;var p=function(t){function e(e){var n=t.call(this,e.definition)||this;return o.assign(n,o.pick(e,function(t){return void 0!==t})),n}return i(e,t),e}(s);e.Flat=p;var l=function(t){function e(e){var n=t.call(this,e.definition)||this;return n.idx=1,o.assign(n,o.pick(e,function(t){return void 0!==t})),n}return i(e,t),e}(s);e.Option=l;var h=function(t){function e(e){var n=t.call(this,e.definition)||this;return n.idx=1,o.assign(n,o.pick(e,function(t){return void 0!==t})),n}return i(e,t),e}(s);e.RepetitionMandatory=h;var f=function(t){function e(e){var n=t.call(this,e.definition)||this;return n.idx=1,o.assign(n,o.pick(e,function(t){return void 0!==t})),n}return i(e,t),e}(s);e.RepetitionMandatoryWithSeparator=f;var d=function(t){function e(e){var n=t.call(this,e.definition)||this;return n.idx=1,o.assign(n,o.pick(e,function(t){return void 0!==t})),n}return i(e,t),e}(s);e.Repetition=d;var E=function(t){function e(e){var n=t.call(this,e.definition)||this;return n.idx=1,o.assign(n,o.pick(e,function(t){return void 0!==t})),n}return i(e,t),e}(s);e.RepetitionWithSeparator=E;var m=function(t){function e(e){var n=t.call(this,e.definition)||this;return n.idx=1,o.assign(n,o.pick(e,function(t){return void 0!==t})),n}return i(e,t),e}(s);e.Alternation=m;var y=function(){function t(t){this.idx=1,o.assign(this,o.pick(t,function(t){return void 0!==t}));}return t.prototype.accept=function(t){t.visit(this);},t}();function T(t){function e(t){return o.map(t,T)}if(t instanceof u)return {type:\"NonTerminal\",name:t.nonTerminalName,idx:t.idx};if(t instanceof p)return {type:\"Flat\",definition:e(t.definition)};if(t instanceof l)return {type:\"Option\",idx:t.idx,definition:e(t.definition)};if(t instanceof h)return {type:\"RepetitionMandatory\",name:t.name,idx:t.idx,definition:e(t.definition)};if(t instanceof f)return {type:\"RepetitionMandatoryWithSeparator\",name:t.name,idx:t.idx,separator:T(new y({terminalType:t.separator})),definition:e(t.definition)};if(t instanceof E)return {type:\"RepetitionWithSeparator\",name:t.name,idx:t.idx,separator:T(new y({terminalType:t.separator})),definition:e(t.definition)};if(t instanceof d)return {type:\"Repetition\",name:t.name,idx:t.idx,definition:e(t.definition)};if(t instanceof m)return {type:\"Alternation\",name:t.name,idx:t.idx,definition:e(t.definition)};if(t instanceof y){var n={type:\"Terminal\",name:a.tokenName(t.terminalType),label:a.tokenLabel(t.terminalType),idx:t.idx},r=t.terminalType.PATTERN;return t.terminalType.PATTERN&&(n.pattern=o.isRegExp(r)?r.source:r),n}if(t instanceof c)return {type:\"Rule\",name:t.name,orgText:t.orgText,definition:e(t.definition)};throw Error(\"non exhaustive match\")}e.Terminal=y,e.serializeGrammar=function(t){return o.map(t,T)},e.serializeProduction=T;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0),i=n(4),o=n(15),a=n(7);function s(t){return r.isString(t.LABEL)&&\"\"!==t.LABEL}function u(t){return r.isObject(t)&&t.hasOwnProperty(\"tokenName\")&&r.isString(t.tokenName)?t.tokenName:i.functionName(t)}e.tokenLabel=function(t){return s(t)?t.LABEL:u(t)},e.hasTokenLabel=s,e.tokenName=u;var c=\"parent\",p=\"categories\",l=\"label\",h=\"group\",f=\"push_mode\",d=\"pop_mode\",E=\"longer_alt\",m=\"line_breaks\",y=\"start_chars_hint\";function T(t){return function(t){var e=t.name,n=t.pattern,o={};i.defineNameProp(o,e)||(o.tokenName=e);r.isUndefined(n)||(o.PATTERN=n);if(r.has(t,c))throw \"The parent property is no longer supported.\\nSee: https://github.com/SAP/chevrotain/issues/564#issuecomment-349062346 for details.\";r.has(t,p)&&(o.CATEGORIES=t[p]);a.augmentTokenTypes([o]),r.has(t,l)&&(o.LABEL=t[l]);r.has(t,h)&&(o.GROUP=t[h]);r.has(t,d)&&(o.POP_MODE=t[d]);r.has(t,f)&&(o.PUSH_MODE=t[f]);r.has(t,E)&&(o.LONGER_ALT=t[E]);r.has(t,m)&&(o.LINE_BREAKS=t[m]);r.has(t,y)&&(o.START_CHARS_HINT=t[y]);return o}(t)}e.createToken=T,e.EOF=T({name:\"EOF\",pattern:o.Lexer.NA}),a.augmentTokenTypes([e.EOF]),e.createTokenInstance=function(t,e,n,r,i,o,a,s){return {image:e,startOffset:n,endOffset:r,startLine:i,endLine:o,startColumn:a,endColumn:s,tokenTypeIdx:t.tokenTypeIdx,tokenType:t}},e.tokenMatcher=function(t,e){return a.tokenStructuredMatcher(t,e)};},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(4),a=n(0),s=n(26),u=n(2),c=n(23),p=n(16),l=n(10),h=n(24),f=n(25),d=n(31),E=n(32),m=n(34),y=n(35),T=n(36),v=n(37),g=n(38);e.END_OF_FILE=u.createTokenInstance(u.EOF,\"\",NaN,NaN,NaN,NaN,NaN,NaN),Object.freeze(e.END_OF_FILE),e.DEFAULT_PARSER_CONFIG=Object.freeze({recoveryEnabled:!1,maxLookahead:4,ignoredIssues:{},dynamicTokensEnabled:!1,outputCst:!0,errorMessageProvider:l.defaultParserErrorProvider,serializedGrammar:null}),e.DEFAULT_RULE_CONFIG=Object.freeze({recoveryValueFunc:function(){},resyncEnabled:!0}),function(t){t[t.INVALID_RULE_NAME=0]=\"INVALID_RULE_NAME\",t[t.DUPLICATE_RULE_NAME=1]=\"DUPLICATE_RULE_NAME\",t[t.INVALID_RULE_OVERRIDE=2]=\"INVALID_RULE_OVERRIDE\",t[t.DUPLICATE_PRODUCTIONS=3]=\"DUPLICATE_PRODUCTIONS\",t[t.UNRESOLVED_SUBRULE_REF=4]=\"UNRESOLVED_SUBRULE_REF\",t[t.LEFT_RECURSION=5]=\"LEFT_RECURSION\",t[t.NONE_LAST_EMPTY_ALT=6]=\"NONE_LAST_EMPTY_ALT\",t[t.AMBIGUOUS_ALTS=7]=\"AMBIGUOUS_ALTS\",t[t.CONFLICT_TOKENS_RULES_NAMESPACE=8]=\"CONFLICT_TOKENS_RULES_NAMESPACE\",t[t.INVALID_TOKEN_NAME=9]=\"INVALID_TOKEN_NAME\",t[t.INVALID_NESTED_RULE_NAME=10]=\"INVALID_NESTED_RULE_NAME\",t[t.DUPLICATE_NESTED_NAME=11]=\"DUPLICATE_NESTED_NAME\",t[t.NO_NON_EMPTY_LOOKAHEAD=12]=\"NO_NON_EMPTY_LOOKAHEAD\",t[t.AMBIGUOUS_PREFIX_ALTS=13]=\"AMBIGUOUS_PREFIX_ALTS\",t[t.TOO_MANY_ALTS=14]=\"TOO_MANY_ALTS\";}(e.ParserDefinitionErrorType||(e.ParserDefinitionErrorType={})),e.EMPTY_ALT=function(t){return void 0===t&&(t=void 0),function(){return t}};var _=function(){function t(t,n){void 0===n&&(n=e.DEFAULT_PARSER_CONFIG),this.ignoredIssues=e.DEFAULT_PARSER_CONFIG.ignoredIssues,this.definitionErrors=[],this.selfAnalysisDone=!1;this.initErrorHandler(n),this.initLexerAdapter(),this.initLooksAhead(n),this.initRecognizerEngine(t,n),this.initRecoverable(n),this.initTreeBuilder(n),this.initContentAssist(),this.ignoredIssues=a.has(n,\"ignoredIssues\")?n.ignoredIssues:e.DEFAULT_PARSER_CONFIG.ignoredIssues,a.toFastProperties(this);}return t.performSelfAnalysis=function(t){t.performSelfAnalysis();},t.prototype.performSelfAnalysis=function(){var e,n=this;this.selfAnalysisDone=!0;var r=o.classNameFromInstance(this),i=this.gastProductionsCache;if(this.serializedGrammar){var u=c.deserializeGrammar(this.serializedGrammar,this.tokensMap);a.forEach(u,function(t){n.gastProductionsCache.put(t.name,t);});}var f=h.resolveGrammar({rules:i.values()});if(this.definitionErrors.push.apply(this.definitionErrors,f),a.isEmpty(f)){var d=h.validateGrammar({rules:i.values(),maxLookahead:this.maxLookahead,tokenTypes:a.values(this.tokensMap),ignoredIssues:this.ignoredIssues,errMsgProvider:l.defaultGrammarValidatorErrorProvider,grammarName:r});this.definitionErrors.push.apply(this.definitionErrors,d);}if(a.isEmpty(this.definitionErrors)){var E=s.computeAllProdsFollows(i.values());this.resyncFollows=E;}var m=p.analyzeCst(i.values(),this.fullRuleNameToShort);if(this.allRuleNames=m.allRuleNames,!t.DEFER_DEFINITION_ERRORS_HANDLING&&!a.isEmpty(this.definitionErrors))throw e=a.map(this.definitionErrors,function(t){return t.message}),new Error(\"Parser Definition Errors detected:\\n \"+e.join(\"\\n-------------------------------\\n\"))},t.DEFER_DEFINITION_ERRORS_HANDLING=!1,t}();e.Parser=_,a.applyMixins(_,[f.Recoverable,d.LooksAhead,E.TreeBuilder,m.LexerAdapter,T.RecognizerEngine,y.RecognizerApi,v.ErrorHandler,g.ContentAssist]);var R=function(t){function n(n,r){void 0===r&&(r=e.DEFAULT_PARSER_CONFIG);var i=a.cloneObj(r);return i.outputCst=!0,t.call(this,n,i)||this}return i(n,t),n}(_);e.CstParser=R;var A=function(t){function n(n,r){void 0===r&&(r=e.DEFAULT_PARSER_CONFIG);var i=a.cloneObj(r);return i.outputCst=!1,t.call(this,n,i)||this}return i(n,t),n}(_);e.EmbeddedActionsParser=A;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0);e.classNameFromInstance=function(t){return a(t.constructor)};var i=/^\\s*function\\s*(\\S*)\\s*\\(/,o=\"name\";function a(t){var e=t.name;return e||t.toString().match(i)[1]}e.functionName=a,e.defineNameProp=function(t,e){var n=Object.getOwnPropertyDescriptor(t,o);return !(!r.isUndefined(n)&&!n.configurable||(Object.defineProperty(t,o,{enumerable:!1,configurable:!0,writable:!1,value:e}),0))};var s=function(){function t(){this._state={};}return t.prototype.keys=function(){return r.keys(this._state)},t.prototype.values=function(){return r.values(this._state)},t.prototype.put=function(t,e){this._state[t]=e;},t.prototype.putAll=function(t){this._state=r.assign(this._state,t._state);},t.prototype.get=function(t){return this._state[t]},t.prototype.containsKey=function(t){return r.has(this._state,t)},t.prototype.clear=function(){this._state={};},t}();e.HashTable=s;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(1),i=function(){function t(){}return t.prototype.visit=function(t){if(t instanceof r.NonTerminal)return this.visitNonTerminal(t);if(t instanceof r.Flat)return this.visitFlat(t);if(t instanceof r.Option)return this.visitOption(t);if(t instanceof r.RepetitionMandatory)return this.visitRepetitionMandatory(t);if(t instanceof r.RepetitionMandatoryWithSeparator)return this.visitRepetitionMandatoryWithSeparator(t);if(t instanceof r.RepetitionWithSeparator)return this.visitRepetitionWithSeparator(t);if(t instanceof r.Repetition)return this.visitRepetition(t);if(t instanceof r.Alternation)return this.visitAlternation(t);if(t instanceof r.Terminal)return this.visitTerminal(t);if(t instanceof r.Rule)return this.visitRule(t);throw Error(\"non exhaustive match\")},t.prototype.visitNonTerminal=function(t){},t.prototype.visitFlat=function(t){},t.prototype.visitOption=function(t){},t.prototype.visitRepetition=function(t){},t.prototype.visitRepetitionMandatory=function(t){},t.prototype.visitRepetitionMandatoryWithSeparator=function(t){},t.prototype.visitRepetitionWithSeparator=function(t){},t.prototype.visitAlternation=function(t){},t.prototype.visitTerminal=function(t){},t.prototype.visitRule=function(t){},t}();e.GAstVisitor=i;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0),i=\"MismatchedTokenException\",o=\"NoViableAltException\",a=\"EarlyExitException\",s=\"NotAllInputParsedException\",u=[i,o,a,s];function c(t,e,n){this.name=i,this.message=t,this.token=e,this.previousToken=n,this.resyncedTokens=[];}function p(t,e,n){this.name=o,this.message=t,this.token=e,this.previousToken=n,this.resyncedTokens=[];}function l(t,e){this.name=s,this.message=t,this.token=e,this.resyncedTokens=[];}function h(t,e,n){this.name=a,this.message=t,this.token=e,this.previousToken=n,this.resyncedTokens=[];}Object.freeze(u),e.isRecognitionException=function(t){return r.contains(u,t.name)},e.MismatchedTokenException=c,c.prototype=Error.prototype,e.NoViableAltException=p,p.prototype=Error.prototype,e.NotAllInputParsedException=l,l.prototype=Error.prototype,e.EarlyExitException=h,h.prototype=Error.prototype;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0),i=n(4),o=n(2);function a(t){for(var e=r.cloneArr(t),n=t,i=!0;i;){n=r.compact(r.flatten(r.map(n,function(t){return t.CATEGORIES})));var o=r.difference(n,e);e=e.concat(o),r.isEmpty(o)?i=!1:n=o;}return e}function s(t){r.forEach(t,function(t){l(t)||(e.tokenIdxToClass.put(e.tokenShortNameIdx,t),t.tokenTypeIdx=e.tokenShortNameIdx++),h(t)&&!r.isArray(t.CATEGORIES)&&(t.CATEGORIES=[t.CATEGORIES]),h(t)||(t.CATEGORIES=[]),f(t)||(t.categoryMatches=[]),d(t)||(t.categoryMatchesMap={}),E(t)||(t.tokenName=o.tokenName(t));});}function u(t){r.forEach(t,function(t){t.categoryMatches=[],r.forEach(t.categoryMatchesMap,function(n,r){t.categoryMatches.push(e.tokenIdxToClass.get(r).tokenTypeIdx);});});}function c(t){r.forEach(t,function(t){p([],t);});}function p(t,e){r.forEach(t,function(t){e.categoryMatchesMap[t.tokenTypeIdx]=!0;}),r.forEach(e.CATEGORIES,function(n){var i=t.concat(e);r.contains(i,n)||p(i,n);});}function l(t){return r.has(t,\"tokenTypeIdx\")}function h(t){return r.has(t,\"CATEGORIES\")}function f(t){return r.has(t,\"categoryMatches\")}function d(t){return r.has(t,\"categoryMatchesMap\")}function E(t){return r.has(t,\"tokenName\")}e.tokenStructuredMatcher=function(t,e){var n=t.tokenTypeIdx;return n===e.tokenTypeIdx||!0===e.isParent&&!0===e.categoryMatchesMap[n]},e.tokenStructuredMatcherNoCategories=function(t,e){return t.tokenTypeIdx===e.tokenTypeIdx},e.tokenShortNameIdx=1,e.tokenIdxToClass=new i.HashTable,e.augmentTokenTypes=function(t){var e=a(t);s(e),c(e),u(e),r.forEach(e,function(t){t.isParent=t.categoryMatches.length>0;});},e.expandCategories=a,e.assignTokenDefaultProps=s,e.assignCategoriesTokensProp=u,e.assignCategoriesMapProp=c,e.singleAssignCategoriesToksMap=p,e.hasShortKeyProperty=l,e.hasCategoriesProperty=h,e.hasExtendingTokensTypesProperty=f,e.hasExtendingTokensTypesMapProperty=d,e.hasTokenNameProperty=E,e.isTokenType=function(t){return r.has(t,\"tokenTypeIdx\")};},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(0),a=n(1),s=n(5),u=n(2);e.isSequenceProd=function(t){return t instanceof a.Flat||t instanceof a.Option||t instanceof a.Repetition||t instanceof a.RepetitionMandatory||t instanceof a.RepetitionMandatoryWithSeparator||t instanceof a.RepetitionWithSeparator||t instanceof a.Terminal||t instanceof a.Rule},e.isOptionalProd=function t(e,n){return void 0===n&&(n=[]),!!(e instanceof a.Option||e instanceof a.Repetition||e instanceof a.RepetitionWithSeparator)||(e instanceof a.Alternation?o.some(e.definition,function(e){return t(e,n)}):!(e instanceof a.NonTerminal&&o.contains(n,e))&&e instanceof a.AbstractProduction&&(e instanceof a.NonTerminal&&n.push(e),o.every(e.definition,function(e){return t(e,n)})))},e.isBranchingProd=function(t){return t instanceof a.Alternation},e.getProductionDslName=function(t){if(t instanceof a.NonTerminal)return \"SUBRULE\";if(t instanceof a.Option)return \"OPTION\";if(t instanceof a.Alternation)return \"OR\";if(t instanceof a.RepetitionMandatory)return \"AT_LEAST_ONE\";if(t instanceof a.RepetitionMandatoryWithSeparator)return \"AT_LEAST_ONE_SEP\";if(t instanceof a.RepetitionWithSeparator)return \"MANY_SEP\";if(t instanceof a.Repetition)return \"MANY\";if(t instanceof a.Terminal)return \"CONSUME\";throw Error(\"non exhaustive match\")};var c=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.separator=\"-\",e.dslMethods={option:[],alternation:[],repetition:[],repetitionWithSeparator:[],repetitionMandatory:[],repetitionMandatoryWithSeparator:[]},e}return i(e,t),e.prototype.visitTerminal=function(t){var e=u.tokenName(t.terminalType)+this.separator+\"Terminal\";o.has(this.dslMethods,e)||(this.dslMethods[e]=[]),this.dslMethods[e].push(t);},e.prototype.visitNonTerminal=function(t){var e=t.nonTerminalName+this.separator+\"Terminal\";o.has(this.dslMethods,e)||(this.dslMethods[e]=[]),this.dslMethods[e].push(t);},e.prototype.visitOption=function(t){this.dslMethods.option.push(t);},e.prototype.visitRepetitionWithSeparator=function(t){this.dslMethods.repetitionWithSeparator.push(t);},e.prototype.visitRepetitionMandatory=function(t){this.dslMethods.repetitionMandatory.push(t);},e.prototype.visitRepetitionMandatoryWithSeparator=function(t){this.dslMethods.repetitionMandatoryWithSeparator.push(t);},e.prototype.visitRepetition=function(t){this.dslMethods.repetition.push(t);},e.prototype.visitAlternation=function(t){this.dslMethods.alternation.push(t);},e}(s.GAstVisitor);e.DslMethodsCollectorVisitor=c;},function(t,e,n){function r(t,e,n){return n|e|t}Object.defineProperty(e,\"__esModule\",{value:!0}),e.BITS_FOR_METHOD_IDX=4,e.BITS_FOR_OCCURRENCE_IDX=4,e.BITS_FOR_RULE_IDX=24,e.BITS_FOR_ALT_IDX=8,e.OR_IDX=1<<e.BITS_FOR_METHOD_IDX,e.OPTION_IDX=2<<e.BITS_FOR_METHOD_IDX,e.MANY_IDX=3<<e.BITS_FOR_METHOD_IDX,e.AT_LEAST_ONE_IDX=4<<e.BITS_FOR_METHOD_IDX,e.MANY_SEP_IDX=5<<e.BITS_FOR_METHOD_IDX,e.AT_LEAST_ONE_SEP_IDX=6<<e.BITS_FOR_METHOD_IDX,e.getKeyForAutomaticLookahead=r;var i=32-e.BITS_FOR_ALT_IDX;e.getKeyForAltIndex=function(t,e,n,o){var a=o+1<<i;return r(t,e,n)|a};},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(2),i=n(0),o=n(0),a=n(1),s=n(8),u=n(11),c=n(17),p=n(3);e.defaultParserErrorProvider={buildMismatchTokenMessage:function(t){var e=t.expected,n=t.actual;t.previous,t.ruleName;return \"Expecting \"+(r.hasTokenLabel(e)?\"--\\x3e \"+r.tokenLabel(e)+\" <--\":\"token of type --\\x3e \"+r.tokenName(e)+\" <--\")+\" but found --\\x3e '\"+n.image+\"' <--\"},buildNotAllInputParsedMessage:function(t){var e=t.firstRedundant;t.ruleName;return \"Redundant input, expecting EOF but found: \"+e.image},buildNoViableAltMessage:function(t){var e=t.expectedPathsPerAlt,n=t.actual,i=(t.previous,t.customUserDescription),a=(t.ruleName,\"\\nbut found: '\"+o.first(n).image+\"'\");if(i)return \"Expecting: \"+i+a;var s=o.reduce(e,function(t,e){return t.concat(e)},[]),u=o.map(s,function(t){return \"[\"+o.map(t,function(t){return r.tokenLabel(t)}).join(\", \")+\"]\"});return \"Expecting: \"+(\"one of these possible Token sequences:\\n\"+o.map(u,function(t,e){return \"  \"+(e+1)+\". \"+t}).join(\"\\n\"))+a},buildEarlyExitMessage:function(t){var e=t.expectedIterationPaths,n=t.actual,i=t.customUserDescription,a=(t.ruleName,\"\\nbut found: '\"+o.first(n).image+\"'\");return i?\"Expecting: \"+i+a:\"Expecting: \"+(\"expecting at least one iteration which starts with one of these possible Token sequences::\\n  <\"+o.map(e,function(t){return \"[\"+o.map(t,function(t){return r.tokenLabel(t)}).join(\",\")+\"]\"}).join(\" ,\")+\">\")+a}},Object.freeze(e.defaultParserErrorProvider),e.defaultGrammarResolverErrorProvider={buildRuleNotFoundError:function(t,e){return \"Invalid grammar, reference to a rule which is not defined: ->\"+e.nonTerminalName+\"<-\\ninside top level rule: ->\"+t.name+\"<-\"}},e.defaultGrammarValidatorErrorProvider={buildDuplicateFoundError:function(t,e){var n,i=t.name,u=o.first(e),c=u.idx,p=s.getProductionDslName(u),l=(n=u)instanceof a.Terminal?r.tokenName(n.terminalType):n instanceof a.NonTerminal?n.nonTerminalName:\"\",h=\"->\"+p+\"<- with numerical suffix: ->\"+c+\"<-\\n                  \"+(l?\"and argument: ->\"+l+\"<-\":\"\")+\"\\n                  appears more than once (\"+e.length+\" times) in the top level rule: ->\"+i+\"<-.\\n                  \"+(0===c?\"Also note that numerical suffix 0 means \"+p+\" without any suffix.\":\"\")+\"\\n                  To fix this make sure each usage of \"+p+\" \"+(l?\"with the argument: ->\"+l+\"<-\":\"\")+\"\\n                  in the rule ->\"+i+\"<- has a different occurrence index (0-5), as that combination acts as a unique\\n                  position key in the grammar, which is needed by the parsing engine.\\n                  \\n                  For further details see: https://sap.github.io/chevrotain/docs/FAQ.html#NUMERICAL_SUFFIXES \\n                  \";return h=(h=h.replace(/[ \\t]+/g,\" \")).replace(/\\s\\s+/g,\"\\n\")},buildInvalidNestedRuleNameError:function(t,e){return \"Invalid nested rule name: ->\"+e.name+\"<- inside rule: ->\"+t.name+\"<-\\nit must match the pattern: ->\"+u.validNestedRuleName.toString()+\"<-.\\nNote that this means a nested rule name must start with the '$'(dollar) sign.\"},buildDuplicateNestedRuleNameError:function(t,e){return \"Duplicate nested rule name: ->\"+o.first(e).name+\"<- inside rule: ->\"+t.name+\"<-\\nA nested name must be unique in the scope of a top level grammar rule.\"},buildNamespaceConflictError:function(t){return \"Namespace conflict found in grammar.\\nThe grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <\"+t.name+\">.\\nTo resolve this make sure each Terminal and Non-Terminal names are unique\\nThis is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\nand Non-Terminal names start with a lower case letter.\"},buildAlternationPrefixAmbiguityError:function(t){var e=o.map(t.prefixPath,function(t){return r.tokenLabel(t)}).join(\", \"),n=0===t.alternation.idx?\"\":t.alternation.idx;return \"Ambiguous alternatives: <\"+t.ambiguityIndices.join(\" ,\")+\"> due to common lookahead prefix\\nin <OR\"+n+\"> inside <\"+t.topLevelRule.name+\"> Rule,\\n<\"+e+\"> may appears as a prefix path in all these alternatives.\\nhttps://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\nFor Further details.\"},buildAlternationAmbiguityError:function(t){var e=o.map(t.prefixPath,function(t){return r.tokenLabel(t)}).join(\", \"),n=0===t.alternation.idx?\"\":t.alternation.idx,i=\"Ambiguous alternatives: <\"+t.ambiguityIndices.join(\" ,\")+\"> in <OR\"+n+\"> inside <\"+t.topLevelRule.name+\"> Rule,\\n<\"+e+\"> may appears as a prefix path in all these alternatives.\\n\",a=c.VERSION.replace(/\\./g,\"_\");return i=i+\"To Resolve this, try one of of the following: \\n1. Refactor your grammar to be LL(K) for the current value of k (by default k=\"+p.DEFAULT_PARSER_CONFIG.maxLookahead+\"})\\n2. Increase the value of K for your grammar by providing a larger 'maxLookahead' value in the parser's config\\n3. This issue can be ignored (if you know what you are doing...), see https://sap.github.io/chevrotain/documentation/\"+a+\"/interfaces/iparserconfig.html#ignoredissues for more details\\n\"},buildEmptyRepetitionError:function(t){var e=s.getProductionDslName(t.repetition);return 0!==t.repetition.idx&&(e+=t.repetition.idx),\"The repetition <\"+e+\"> within Rule <\"+t.topLevelRule.name+\"> can never consume any tokens.\\nThis could lead to an infinite loop.\"},buildTokenNameError:function(t){return \"Invalid Grammar Token name: ->\"+r.tokenName(t.tokenType)+\"<- it must match the pattern: ->\"+t.expectedPattern.toString()+\"<-\"},buildEmptyAlternationError:function(t){return \"Ambiguous empty alternative: <\"+(t.emptyChoiceIdx+1)+\"> in <OR\"+t.alternation.idx+\"> inside <\"+t.topLevelRule.name+\"> Rule.\\nOnly the last alternative may be an empty alternative.\"},buildTooManyAlternativesError:function(t){return \"An Alternation cannot have more than 256 alternatives:\\n<OR\"+t.alternation.idx+\"> inside <\"+t.topLevelRule.name+\"> Rule.\\n has \"+(t.alternation.definition.length+1)+\" alternatives.\"},buildLeftRecursionError:function(t){var e=t.topLevelRule.name;return \"Left Recursion found in grammar.\\nrule: <\"+e+\"> can be invoked from itself (directly or indirectly)\\nwithout consuming any Tokens. The grammar path that causes this is: \\n \"+(e+\" --\\x3e \"+i.map(t.leftRecursionPath,function(t){return t.name}).concat([e]).join(\" --\\x3e \"))+\"\\n To fix this refactor your grammar to remove the left recursion.\\nsee: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring.\"},buildInvalidRuleNameError:function(t){return \"Invalid grammar rule name: ->\"+t.topLevelRule.name+\"<- it must match the pattern: ->\"+t.expectedPattern.toString()+\"<-\"},buildDuplicateRuleNameError:function(t){return \"Duplicate definition, rule: ->\"+(t.topLevelRule instanceof a.Rule?t.topLevelRule.name:t.topLevelRule)+\"<- is already defined in the grammar: ->\"+t.grammarName+\"<-\"}};},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(0),a=n(0),s=n(3),u=n(8),c=n(2),p=n(12),l=n(16),h=n(13),f=n(1),d=n(5);function E(t){return u.getProductionDslName(t)+\"_#_\"+t.idx+\"_#_\"+m(t)}function m(t){return t instanceof f.Terminal?c.tokenName(t.terminalType):t instanceof f.NonTerminal?t.nonTerminalName:\"\"}e.validateGrammar=function(t,e,n,r,i,p){var h=o.map(t,function(t){return function(t,e){var n=new y;t.accept(n);var r=n.allProductions,i=o.groupBy(r,E),a=o.pick(i,function(t){return t.length>1});return o.map(o.values(a),function(n){var r=o.first(n),i=e.buildDuplicateFoundError(t,n),a=u.getProductionDslName(r),c={message:i,type:s.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,ruleName:t.name,dslName:a,occurrence:r.idx},p=m(r);return p&&(c.parameter=p),c})}(t,i)}),f=o.map(t,function(t){return R(t,t,i)}),d=[],A=[],N=[];a.every(f,a.isEmpty)&&(d=a.map(t,function(t){return O(t,i)}),A=a.map(t,function(t){return S(t,e,r,i)}),N=k(t,e,i));var I=function(t,e,n){var r=[],i=a.map(e,function(t){return c.tokenName(t)});return a.forEach(t,function(t){var e=t.name;if(a.contains(i,e)){var o=n.buildNamespaceConflictError(t);r.push({message:o,type:s.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,ruleName:e});}}),r}(t,n,i),P=o.map(n,function(t){return g(t,i)}),x=function(t,e){var n=[];return a.forEach(t,function(t){var r=new l.NamedDSLMethodsCollectorVisitor(\"\");t.accept(r);var i=a.map(r.result,function(t){return t.orgProd});n.push(a.map(i,function(n){return v(t,n,e)}));}),a.flatten(n)}(t,i),C=function(t,e){var n=[];return a.forEach(t,function(t){var r=new l.NamedDSLMethodsCollectorVisitor(\"\");t.accept(r);var i=a.groupBy(r.result,function(t){return t.name}),o=a.pick(i,function(t){return t.length>1});a.forEach(a.values(o),function(r){var i=a.map(r,function(t){return t.orgProd}),o=e.buildDuplicateNestedRuleNameError(t,i);n.push({message:o,type:s.ParserDefinitionErrorType.DUPLICATE_NESTED_NAME,ruleName:t.name});});}),n}(t,i),M=a.map(t,function(t){return L(t,i)}),F=a.map(t,function(t){return T(t,i)}),b=a.map(t,function(e){return _(e,t,p,i)});return o.flatten(h.concat(P,x,C,N,f,d,A,I,M,F,b))},e.identifyProductionForDuplicates=E;var y=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.allProductions=[],e}return i(e,t),e.prototype.visitNonTerminal=function(t){this.allProductions.push(t);},e.prototype.visitOption=function(t){this.allProductions.push(t);},e.prototype.visitRepetitionWithSeparator=function(t){this.allProductions.push(t);},e.prototype.visitRepetitionMandatory=function(t){this.allProductions.push(t);},e.prototype.visitRepetitionMandatoryWithSeparator=function(t){this.allProductions.push(t);},e.prototype.visitRepetition=function(t){this.allProductions.push(t);},e.prototype.visitAlternation=function(t){this.allProductions.push(t);},e.prototype.visitTerminal=function(t){this.allProductions.push(t);},e}(d.GAstVisitor);function T(t,n){var r=[],i=t.name;return i.match(e.validTermsPattern)||r.push({message:n.buildInvalidRuleNameError({topLevelRule:t,expectedPattern:e.validTermsPattern}),type:s.ParserDefinitionErrorType.INVALID_RULE_NAME,ruleName:i}),r}function v(t,n,r){var i,o=[];return n.name.match(e.validNestedRuleName)||(i=r.buildInvalidNestedRuleNameError(t,n),o.push({message:i,type:s.ParserDefinitionErrorType.INVALID_NESTED_RULE_NAME,ruleName:t.name})),o}function g(t,n){var r=[];return c.tokenName(t).match(e.validTermsPattern)||r.push({message:n.buildTokenNameError({tokenType:t,expectedPattern:e.validTermsPattern}),type:s.ParserDefinitionErrorType.INVALID_TOKEN_NAME}),r}function _(t,e,n,r){var i=[];if(a.reduce(e,function(e,n){return n.name===t.name?e+1:e},0)>1){var o=r.buildDuplicateRuleNameError({topLevelRule:t,grammarName:n});i.push({message:o,type:s.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,ruleName:t.name});}return i}function R(t,e,n,r){void 0===r&&(r=[]);var i=[],a=A(e.definition);if(o.isEmpty(a))return [];var u=t.name;o.contains(a,t)&&i.push({message:n.buildLeftRecursionError({topLevelRule:t,leftRecursionPath:r}),type:s.ParserDefinitionErrorType.LEFT_RECURSION,ruleName:u});var c=o.difference(a,r.concat([t])),p=o.map(c,function(e){var i=o.cloneArr(r);return i.push(e),R(t,e,n,i)});return i.concat(o.flatten(p))}function A(t){var e=[];if(o.isEmpty(t))return e;var n=o.first(t);if(n instanceof f.NonTerminal)e.push(n.referencedRule);else if(n instanceof f.Flat||n instanceof f.Option||n instanceof f.RepetitionMandatory||n instanceof f.RepetitionMandatoryWithSeparator||n instanceof f.RepetitionWithSeparator||n instanceof f.Repetition)e=e.concat(A(n.definition));else if(n instanceof f.Alternation)e=o.flatten(o.map(n.definition,function(t){return A(t.definition)}));else if(!(n instanceof f.Terminal))throw Error(\"non exhaustive match\");var r=u.isOptionalProd(n),i=t.length>1;if(r&&i){var a=o.drop(t);return e.concat(A(a))}return e}e.OccurrenceValidationCollector=y,e.validTermsPattern=/^[a-zA-Z_]\\w*$/,e.validNestedRuleName=new RegExp(e.validTermsPattern.source.replace(\"^\",\"^\\\\$\")),e.validateRuleName=T,e.validateNestedRuleName=v,e.validateTokenName=g,e.validateRuleDoesNotAlreadyExist=_,e.validateRuleIsOverridden=function(t,e,n){var r,i=[];return o.contains(e,t)||(r=\"Invalid rule override, rule: ->\"+t+\"<- cannot be overridden in the grammar: ->\"+n+\"<-as it is not defined in any of the super grammars \",i.push({message:r,type:s.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,ruleName:t})),i},e.validateNoLeftRecursion=R,e.getFirstNoneTerminal=A;var N=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.alternations=[],e}return i(e,t),e.prototype.visitAlternation=function(t){this.alternations.push(t);},e}(d.GAstVisitor);function O(t,e){var n=new N;t.accept(n);var r=n.alternations;return o.reduce(r,function(n,r){var i=o.dropRight(r.definition),a=o.map(i,function(n,i){var a=h.nextPossibleTokensAfter([n],[],null,1);return o.isEmpty(a)?{message:e.buildEmptyAlternationError({topLevelRule:t,alternation:r,emptyChoiceIdx:i}),type:s.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,ruleName:t.name,occurrence:r.idx,alternative:i+1}:null});return n.concat(o.compact(a))},[])}function S(t,e,n,r){var i=new N;t.accept(i);var c=i.alternations,l=n[t.name];return l&&(c=a.reject(c,function(t){return l[u.getProductionDslName(t)+(0===t.idx?\"\":t.idx)]})),o.reduce(c,function(n,i){var u=i.idx,c=p.getLookaheadPathsForOr(u,t,e),l=function(t,e,n,r){var i=[],u=a.reduce(t,function(e,n,r){return a.forEach(n,function(n){var o=[r];a.forEach(t,function(t,e){r!==e&&p.containsPath(t,n)&&o.push(e);}),o.length>1&&!p.containsPath(i,n)&&(i.push(n),e.push({alts:o,path:n}));}),e},[]);return o.map(u,function(t){var i=a.map(t.alts,function(t){return t+1}),o=r.buildAlternationAmbiguityError({topLevelRule:n,alternation:e,ambiguityIndices:i,prefixPath:t.path});return {message:o,type:s.ParserDefinitionErrorType.AMBIGUOUS_ALTS,ruleName:n.name,occurrence:e.idx,alternatives:[t.alts]}})}(c,i,t,r),h=P(c,i,t,r);return n.concat(l,h)},[])}e.validateEmptyOrAlternative=O,e.validateAmbiguousAlternationAlternatives=S;var I=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.allProductions=[],e}return i(e,t),e.prototype.visitRepetitionWithSeparator=function(t){this.allProductions.push(t);},e.prototype.visitRepetitionMandatory=function(t){this.allProductions.push(t);},e.prototype.visitRepetitionMandatoryWithSeparator=function(t){this.allProductions.push(t);},e.prototype.visitRepetition=function(t){this.allProductions.push(t);},e}(d.GAstVisitor);function L(t,e){var n=new N;t.accept(n);var r=n.alternations;return o.reduce(r,function(n,r){return r.definition.length>255&&n.push({message:e.buildTooManyAlternativesError({topLevelRule:t,alternation:r}),type:s.ParserDefinitionErrorType.TOO_MANY_ALTS,ruleName:t.name,occurrence:r.idx}),n},[])}function k(t,e,n){var r=[];return a.forEach(t,function(t){var i=new I;t.accept(i);var o=i.allProductions;a.forEach(o,function(i){var o=p.getProdType(i),u=i.idx,c=p.getLookaheadPathsForOptionalProd(u,t,o,e)[0];if(a.isEmpty(a.flatten(c))){var l=n.buildEmptyRepetitionError({topLevelRule:t,repetition:i});r.push({message:l,type:s.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,ruleName:t.name});}});}),r}function P(t,e,n,r){var i=[],o=a.reduce(t,function(t,e,n){var r=a.map(e,function(t){return {idx:n,path:t}});return t.concat(r)},[]);return a.forEach(o,function(t){var u=t.idx,c=t.path,l=a.findAll(o,function(t){return t.idx<u&&p.isStrictPrefixOfPath(t.path,c)}),h=a.map(l,function(t){var i=[t.idx+1,u+1],o=0===e.idx?\"\":e.idx;return {message:r.buildAlternationPrefixAmbiguityError({topLevelRule:n,alternation:e,ambiguityIndices:i,prefixPath:t.path}),type:s.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,ruleName:n.name,occurrence:o,alternatives:i}});i=i.concat(h);}),i}e.RepetionCollector=I,e.validateTooManyAlts=L,e.validateSomeNonEmptyLookaheadPath=k,e.checkPrefixAlternativesAmbiguities=P;},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o,a=n(0),s=n(13),u=n(14),c=n(7),p=n(1),l=n(5);!function(t){t[t.OPTION=0]=\"OPTION\",t[t.REPETITION=1]=\"REPETITION\",t[t.REPETITION_MANDATORY=2]=\"REPETITION_MANDATORY\",t[t.REPETITION_MANDATORY_WITH_SEPARATOR=3]=\"REPETITION_MANDATORY_WITH_SEPARATOR\",t[t.REPETITION_WITH_SEPARATOR=4]=\"REPETITION_WITH_SEPARATOR\",t[t.ALTERNATION=5]=\"ALTERNATION\";}(o=e.PROD_TYPE||(e.PROD_TYPE={})),e.getProdType=function(t){if(t instanceof p.Option)return o.OPTION;if(t instanceof p.Repetition)return o.REPETITION;if(t instanceof p.RepetitionMandatory)return o.REPETITION_MANDATORY;if(t instanceof p.RepetitionMandatoryWithSeparator)return o.REPETITION_MANDATORY_WITH_SEPARATOR;if(t instanceof p.RepetitionWithSeparator)return o.REPETITION_WITH_SEPARATOR;if(t instanceof p.Alternation)return o.ALTERNATION;throw Error(\"non exhaustive match\")},e.buildLookaheadFuncForOr=function(t,e,n,r,i,o){var a=E(t,e,n);return o(a,r,T(a)?c.tokenStructuredMatcherNoCategories:c.tokenStructuredMatcher,i)},e.buildLookaheadFuncForOptionalProd=function(t,e,n,r,i,o){var a=m(t,e,i,n),s=T(a)?c.tokenStructuredMatcherNoCategories:c.tokenStructuredMatcher;return o(a[0],s,r)},e.buildAlternativesLookAheadFunc=function(t,e,n,r){var i=t.length,o=a.every(t,function(t){return a.every(t,function(t){return 1===t.length})});if(e)return function(e){for(var r=a.map(e,function(t){return t.GATE}),o=0;o<i;o++){var s=t[o],u=s.length,c=r[o];if(void 0===c||!1!==c.call(this))t:for(var p=0;p<u;p++){for(var l=s[p],h=l.length,f=0;f<h;f++){var d=this.LA(f+1);if(!1===n(d,l[f]))continue t}return o}}};if(o&&!r){var s=a.map(t,function(t){return a.flatten(t)}),u=a.reduce(s,function(t,e,n){return a.forEach(e,function(e){a.has(t,e.tokenTypeIdx)||(t[e.tokenTypeIdx]=n),a.forEach(e.categoryMatches,function(e){a.has(t,e)||(t[e]=n);});}),t},[]);return function(){var t=this.LA(1);return u[t.tokenTypeIdx]}}return function(){for(var e=0;e<i;e++){var r=t[e],o=r.length;t:for(var a=0;a<o;a++){for(var s=r[a],u=s.length,c=0;c<u;c++){var p=this.LA(c+1);if(!1===n(p,s[c]))continue t}return e}}}},e.buildSingleAlternativeLookaheadFunction=function(t,e,n){var r=a.every(t,function(t){return 1===t.length}),i=t.length;if(r&&!n){var o=a.flatten(t);if(1===o.length&&a.isEmpty(o[0].categoryMatches)){var s=o[0].tokenTypeIdx;return function(){return this.LA(1).tokenTypeIdx===s}}var u=a.reduce(o,function(t,e,n){return t[e.tokenTypeIdx]=!0,a.forEach(e.categoryMatches,function(e){t[e]=!0;}),t},[]);return function(){var t=this.LA(1);return !0===u[t.tokenTypeIdx]}}return function(){t:for(var n=0;n<i;n++){for(var r=t[n],o=r.length,a=0;a<o;a++){var s=this.LA(a+1);if(!1===e(s,r[a]))continue t}return !0}return !1}};var h=function(t){function e(e,n,r){var i=t.call(this)||this;return i.topProd=e,i.targetOccurrence=n,i.targetProdType=r,i}return i(e,t),e.prototype.startWalking=function(){return this.walk(this.topProd),this.restDef},e.prototype.checkIsTarget=function(t,e,n,r){return t.idx===this.targetOccurrence&&this.targetProdType===e&&(this.restDef=n.concat(r),!0)},e.prototype.walkOption=function(e,n,r){this.checkIsTarget(e,o.OPTION,n,r)||t.prototype.walkOption.call(this,e,n,r);},e.prototype.walkAtLeastOne=function(e,n,r){this.checkIsTarget(e,o.REPETITION_MANDATORY,n,r)||t.prototype.walkOption.call(this,e,n,r);},e.prototype.walkAtLeastOneSep=function(e,n,r){this.checkIsTarget(e,o.REPETITION_MANDATORY_WITH_SEPARATOR,n,r)||t.prototype.walkOption.call(this,e,n,r);},e.prototype.walkMany=function(e,n,r){this.checkIsTarget(e,o.REPETITION,n,r)||t.prototype.walkOption.call(this,e,n,r);},e.prototype.walkManySep=function(e,n,r){this.checkIsTarget(e,o.REPETITION_WITH_SEPARATOR,n,r)||t.prototype.walkOption.call(this,e,n,r);},e}(u.RestWalker),f=function(t){function e(e,n){var r=t.call(this)||this;return r.targetOccurrence=e,r.targetProdType=n,r.result=[],r}return i(e,t),e.prototype.checkIsTarget=function(t,e){t.idx===this.targetOccurrence&&this.targetProdType===e&&(this.result=t.definition);},e.prototype.visitOption=function(t){this.checkIsTarget(t,o.OPTION);},e.prototype.visitRepetition=function(t){this.checkIsTarget(t,o.REPETITION);},e.prototype.visitRepetitionMandatory=function(t){this.checkIsTarget(t,o.REPETITION_MANDATORY);},e.prototype.visitRepetitionMandatoryWithSeparator=function(t){this.checkIsTarget(t,o.REPETITION_MANDATORY_WITH_SEPARATOR);},e.prototype.visitRepetitionWithSeparator=function(t){this.checkIsTarget(t,o.REPETITION_WITH_SEPARATOR);},e.prototype.visitAlternation=function(t){this.checkIsTarget(t,o.ALTERNATION);},e}(l.GAstVisitor);function d(t,e){function n(t,e){return a.reduce(t,function(t,n,r){if(r!==e){var i=a.map(n,function(t){return t.partialPath});return t.concat(i)}return t},[])}function r(t,e){return void 0===a.find(t,function(t){return a.every(e,function(e,n){return r=e,i=t[n],r===i||r&&i&&(r.categoryMatchesMap[i.tokenTypeIdx]||i.categoryMatchesMap[r.tokenTypeIdx]);var r,i;})})}function i(t){for(var e=[],n=0;n<t;n++)e.push([]);return e}for(var o=a.map(t,function(t){return s.possiblePathsFrom([t],1)}),u=i(o.length),c=o,p=1;p<=e;p++){var l=c;c=i(l.length);for(var h=0;h<l.length;h++)for(var f=l[h],d=n(l,h),E=0;E<f.length;E++){var m=f[E].partialPath,T=f[E].suffixDef;if(r(d,m)||a.isEmpty(T)||m.length===e){var v=u[h];y(v,m)||v.push(m);}else {var g=s.possiblePathsFrom(T,p+1,m);c[h]=c[h].concat(g);}}}return u}function E(t,e,n){var r=new f(t,o.ALTERNATION);return e.accept(r),d(r.result,n)}function m(t,e,n,r){var i=new f(t,n);e.accept(i);var o=i.result,a=new h(e,t,n).startWalking();return d([new p.Flat({definition:o}),new p.Flat({definition:a})],r)}function y(t,e){return void 0!==a.find(t,function(t){return e.length===t.length&&a.every(e,function(e,n){return e===t[n]||t[n].categoryMatchesMap[e.tokenTypeIdx]})})}function T(t){return a.every(t,function(t){return a.every(t,function(t){return a.every(t,function(t){return a.isEmpty(t.categoryMatches)})})})}e.lookAheadSequenceFromAlternatives=d,e.getLookaheadPathsForOr=E,e.getLookaheadPathsForOptionalProd=m,e.containsPath=y,e.isStrictPrefixOfPath=function(t,e){return t.length<e.length&&a.every(t,function(t,n){var r=e[n];return t===r||r.categoryMatchesMap[t.tokenTypeIdx]})},e.areTokenCategoriesNotUsed=T;},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(14),a=n(0),s=n(2),u=n(21),c=n(1),p=function(t){function e(e,n){var r=t.call(this)||this;return r.topProd=e,r.path=n,r.possibleTokTypes=[],r.nextProductionName=\"\",r.nextProductionOccurrence=0,r.found=!1,r.isAtEndOfPath=!1,r}return i(e,t),e.prototype.startWalking=function(){if(this.found=!1,this.path.ruleStack[0]!==this.topProd.name)throw Error(\"The path does not start with the walker's top Rule!\");return this.ruleStack=a.cloneArr(this.path.ruleStack).reverse(),this.occurrenceStack=a.cloneArr(this.path.occurrenceStack).reverse(),this.ruleStack.pop(),this.occurrenceStack.pop(),this.updateExpectedNext(),this.walk(this.topProd),this.possibleTokTypes},e.prototype.walk=function(e,n){void 0===n&&(n=[]),this.found||t.prototype.walk.call(this,e,n);},e.prototype.walkProdRef=function(t,e,n){if(t.referencedRule.name===this.nextProductionName&&t.idx===this.nextProductionOccurrence){var r=e.concat(n);this.updateExpectedNext(),this.walk(t.referencedRule,r);}},e.prototype.updateExpectedNext=function(){a.isEmpty(this.ruleStack)?(this.nextProductionName=\"\",this.nextProductionOccurrence=0,this.isAtEndOfPath=!0):(this.nextProductionName=this.ruleStack.pop(),this.nextProductionOccurrence=this.occurrenceStack.pop());},e}(o.RestWalker);e.AbstractNextPossibleTokensWalker=p;var l=function(t){function e(e,n){var r=t.call(this,e,n)||this;return r.path=n,r.nextTerminalName=\"\",r.nextTerminalOccurrence=0,r.nextTerminalName=s.tokenName(r.path.lastTok),r.nextTerminalOccurrence=r.path.lastTokOccurrence,r}return i(e,t),e.prototype.walkTerminal=function(t,e,n){if(this.isAtEndOfPath&&s.tokenName(t.terminalType)===this.nextTerminalName&&t.idx===this.nextTerminalOccurrence&&!this.found){var r=e.concat(n),i=new c.Flat({definition:r});this.possibleTokTypes=u.first(i),this.found=!0;}},e}(p);e.NextAfterTokenWalker=l;var h=function(t){function e(e,n){var r=t.call(this)||this;return r.topRule=e,r.occurrence=n,r.result={token:void 0,occurrence:void 0,isEndOfRule:void 0},r}return i(e,t),e.prototype.startWalking=function(){return this.walk(this.topRule),this.result},e}(o.RestWalker);e.AbstractNextTerminalAfterProductionWalker=h;var f=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return i(e,t),e.prototype.walkMany=function(e,n,r){if(e.idx===this.occurrence){var i=a.first(n.concat(r));this.result.isEndOfRule=void 0===i,i instanceof c.Terminal&&(this.result.token=i.terminalType,this.result.occurrence=i.idx);}else t.prototype.walkMany.call(this,e,n,r);},e}(h);e.NextTerminalAfterManyWalker=f;var d=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return i(e,t),e.prototype.walkManySep=function(e,n,r){if(e.idx===this.occurrence){var i=a.first(n.concat(r));this.result.isEndOfRule=void 0===i,i instanceof c.Terminal&&(this.result.token=i.terminalType,this.result.occurrence=i.idx);}else t.prototype.walkManySep.call(this,e,n,r);},e}(h);e.NextTerminalAfterManySepWalker=d;var E=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return i(e,t),e.prototype.walkAtLeastOne=function(e,n,r){if(e.idx===this.occurrence){var i=a.first(n.concat(r));this.result.isEndOfRule=void 0===i,i instanceof c.Terminal&&(this.result.token=i.terminalType,this.result.occurrence=i.idx);}else t.prototype.walkAtLeastOne.call(this,e,n,r);},e}(h);e.NextTerminalAfterAtLeastOneWalker=E;var m=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return i(e,t),e.prototype.walkAtLeastOneSep=function(e,n,r){if(e.idx===this.occurrence){var i=a.first(n.concat(r));this.result.isEndOfRule=void 0===i,i instanceof c.Terminal&&(this.result.token=i.terminalType,this.result.occurrence=i.idx);}else t.prototype.walkAtLeastOneSep.call(this,e,n,r);},e}(h);function y(t,e,n,r){var i=a.cloneArr(n);i.push(t.name);var o=a.cloneArr(r);return o.push(1),{idx:e,def:t.definition,ruleStack:i,occurrenceStack:o}}e.NextTerminalAfterAtLeastOneSepWalker=m,e.possiblePathsFrom=function t(e,n,r){void 0===r&&(r=[]),r=a.cloneArr(r);var i=[],o=0;function s(s){var u=t(s.concat(a.drop(e,o+1)),n,r);return i.concat(u)}for(;r.length<n&&o<e.length;){var u=e[o];if(u instanceof c.Flat)return s(u.definition);if(u instanceof c.NonTerminal)return s(u.definition);if(u instanceof c.Option)i=s(u.definition);else {if(u instanceof c.RepetitionMandatory)return s(p=u.definition.concat([new c.Repetition({definition:u.definition})]));if(u instanceof c.RepetitionMandatoryWithSeparator)return s(p=[new c.Flat({definition:u.definition}),new c.Repetition({definition:[new c.Terminal({terminalType:u.separator})].concat(u.definition)})]);if(u instanceof c.RepetitionWithSeparator){var p=u.definition.concat([new c.Repetition({definition:[new c.Terminal({terminalType:u.separator})].concat(u.definition)})]);i=s(p);}else if(u instanceof c.Repetition)p=u.definition.concat([new c.Repetition({definition:u.definition})]),i=s(p);else {if(u instanceof c.Alternation)return a.forEach(u.definition,function(t){i=s(t.definition);}),i;if(!(u instanceof c.Terminal))throw Error(\"non exhaustive match\");r.push(u.terminalType);}}o++;}return i.push({partialPath:r,suffixDef:a.drop(e,o)}),i},e.nextPossibleTokensAfter=function(t,e,n,r){var i=[\"EXIT_NONE_TERMINAL\"],o=!1,s=e.length,u=s-r-1,p=[],l=[];for(l.push({idx:-1,def:t,ruleStack:[],occurrenceStack:[]});!a.isEmpty(l);){var h=l.pop();if(\"EXIT_ALTERNATIVE\"!==h){var f=h.def,d=h.idx,E=h.ruleStack,m=h.occurrenceStack;if(!a.isEmpty(f)){var T=f[0];if(\"EXIT_NONE_TERMINAL\"===T){var v={idx:d,def:a.drop(f),ruleStack:a.dropRight(E),occurrenceStack:a.dropRight(m)};l.push(v);}else if(T instanceof c.Terminal)if(d<s-1){var g=d+1;n(e[g],T.terminalType)&&(v={idx:g,def:a.drop(f),ruleStack:E,occurrenceStack:m},l.push(v));}else {if(d!==s-1)throw Error(\"non exhaustive match\");p.push({nextTokenType:T.terminalType,nextTokenOccurrence:T.idx,ruleStack:E,occurrenceStack:m}),o=!0;}else if(T instanceof c.NonTerminal){var _=a.cloneArr(E);_.push(T.nonTerminalName);var R=a.cloneArr(m);R.push(T.idx),v={idx:d,def:T.definition.concat(i,a.drop(f)),ruleStack:_,occurrenceStack:R},l.push(v);}else if(T instanceof c.Option){var A={idx:d,def:a.drop(f),ruleStack:E,occurrenceStack:m};l.push(A),l.push(\"EXIT_ALTERNATIVE\");var N={idx:d,def:T.definition.concat(a.drop(f)),ruleStack:E,occurrenceStack:m};l.push(N);}else if(T instanceof c.RepetitionMandatory){var O=new c.Repetition({definition:T.definition,idx:T.idx});v={idx:d,def:T.definition.concat([O],a.drop(f)),ruleStack:E,occurrenceStack:m},l.push(v);}else if(T instanceof c.RepetitionMandatoryWithSeparator){var S=new c.Terminal({terminalType:T.separator});O=new c.Repetition({definition:[S].concat(T.definition),idx:T.idx}),v={idx:d,def:T.definition.concat([O],a.drop(f)),ruleStack:E,occurrenceStack:m},l.push(v);}else if(T instanceof c.RepetitionWithSeparator){A={idx:d,def:a.drop(f),ruleStack:E,occurrenceStack:m},l.push(A),l.push(\"EXIT_ALTERNATIVE\"),S=new c.Terminal({terminalType:T.separator});var I=new c.Repetition({definition:[S].concat(T.definition),idx:T.idx});N={idx:d,def:T.definition.concat([I],a.drop(f)),ruleStack:E,occurrenceStack:m},l.push(N);}else if(T instanceof c.Repetition)A={idx:d,def:a.drop(f),ruleStack:E,occurrenceStack:m},l.push(A),l.push(\"EXIT_ALTERNATIVE\"),I=new c.Repetition({definition:T.definition,idx:T.idx}),N={idx:d,def:T.definition.concat([I],a.drop(f)),ruleStack:E,occurrenceStack:m},l.push(N);else if(T instanceof c.Alternation)for(var L=T.definition.length-1;L>=0;L--){var k={idx:d,def:T.definition[L].definition.concat(a.drop(f)),ruleStack:E,occurrenceStack:m};l.push(k),l.push(\"EXIT_ALTERNATIVE\");}else if(T instanceof c.Flat)l.push({idx:d,def:T.definition.concat(a.drop(f)),ruleStack:E,occurrenceStack:m});else {if(!(T instanceof c.Rule))throw Error(\"non exhaustive match\");l.push(y(T,d,E,m));}}}else o&&a.last(l).idx<=u&&l.pop();}return p};},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0),i=n(1),o=function(){function t(){}return t.prototype.walk=function(t,e){var n=this;void 0===e&&(e=[]),r.forEach(t.definition,function(o,a){var s=r.drop(t.definition,a+1);if(o instanceof i.NonTerminal)n.walkProdRef(o,s,e);else if(o instanceof i.Terminal)n.walkTerminal(o,s,e);else if(o instanceof i.Flat)n.walkFlat(o,s,e);else if(o instanceof i.Option)n.walkOption(o,s,e);else if(o instanceof i.RepetitionMandatory)n.walkAtLeastOne(o,s,e);else if(o instanceof i.RepetitionMandatoryWithSeparator)n.walkAtLeastOneSep(o,s,e);else if(o instanceof i.RepetitionWithSeparator)n.walkManySep(o,s,e);else if(o instanceof i.Repetition)n.walkMany(o,s,e);else {if(!(o instanceof i.Alternation))throw Error(\"non exhaustive match\");n.walkOr(o,s,e);}});},t.prototype.walkTerminal=function(t,e,n){},t.prototype.walkProdRef=function(t,e,n){},t.prototype.walkFlat=function(t,e,n){var r=e.concat(n);this.walk(t,r);},t.prototype.walkOption=function(t,e,n){var r=e.concat(n);this.walk(t,r);},t.prototype.walkAtLeastOne=function(t,e,n){var r=[new i.Option({definition:t.definition})].concat(e,n);this.walk(t,r);},t.prototype.walkAtLeastOneSep=function(t,e,n){var r=a(t,e,n);this.walk(t,r);},t.prototype.walkMany=function(t,e,n){var r=[new i.Option({definition:t.definition})].concat(e,n);this.walk(t,r);},t.prototype.walkManySep=function(t,e,n){var r=a(t,e,n);this.walk(t,r);},t.prototype.walkOr=function(t,e,n){var o=this,a=e.concat(n);r.forEach(t.definition,function(t){var e=new i.Flat({definition:[t]});o.walk(e,a);});},t}();function a(t,e,n){return [new i.Option({definition:[new i.Terminal({terminalType:t.separator})].concat(t.definition)})].concat(e,n)}e.RestWalker=o;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(27),i=n(0),o=n(7),a=n(20);!function(t){t[t.MISSING_PATTERN=0]=\"MISSING_PATTERN\",t[t.INVALID_PATTERN=1]=\"INVALID_PATTERN\",t[t.EOI_ANCHOR_FOUND=2]=\"EOI_ANCHOR_FOUND\",t[t.UNSUPPORTED_FLAGS_FOUND=3]=\"UNSUPPORTED_FLAGS_FOUND\",t[t.DUPLICATE_PATTERNS_FOUND=4]=\"DUPLICATE_PATTERNS_FOUND\",t[t.INVALID_GROUP_TYPE_FOUND=5]=\"INVALID_GROUP_TYPE_FOUND\",t[t.PUSH_MODE_DOES_NOT_EXIST=6]=\"PUSH_MODE_DOES_NOT_EXIST\",t[t.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE=7]=\"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\",t[t.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY=8]=\"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\",t[t.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST=9]=\"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\",t[t.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED=10]=\"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\",t[t.SOI_ANCHOR_FOUND=11]=\"SOI_ANCHOR_FOUND\",t[t.EMPTY_MATCH_PATTERN=12]=\"EMPTY_MATCH_PATTERN\",t[t.NO_LINE_BREAKS_FLAGS=13]=\"NO_LINE_BREAKS_FLAGS\",t[t.UNREACHABLE_PATTERN=14]=\"UNREACHABLE_PATTERN\",t[t.IDENTIFY_TERMINATOR=15]=\"IDENTIFY_TERMINATOR\",t[t.CUSTOM_LINE_BREAK=16]=\"CUSTOM_LINE_BREAK\";}(e.LexerDefinitionErrorType||(e.LexerDefinitionErrorType={}));var s={deferDefinitionErrorsHandling:!1,positionTracking:\"full\",lineTerminatorsPattern:/\\n|\\r\\n?/g,lineTerminatorCharacters:[\"\\n\",\"\\r\"],ensureOptimizations:!1,safeMode:!1,errorMessageProvider:a.defaultLexerErrorProvider};Object.freeze(s);var u=function(){function t(t,e){var n=this;if(void 0===e&&(e=s),this.lexerDefinition=t,this.lexerDefinitionErrors=[],this.lexerDefinitionWarning=[],this.patternIdxToConfig={},this.charCodeToPatternIdxToConfig={},this.modes=[],this.emptyGroups={},this.config=void 0,this.trackStartLines=!0,this.trackEndLines=!0,this.hasCustom=!1,this.canModeBeOptimized={},\"boolean\"==typeof e)throw Error(\"The second argument to the Lexer constructor is now an ILexerConfig Object.\\na boolean 2nd argument is no longer supported\");if(this.config=i.merge(s,e),this.config.lineTerminatorsPattern===s.lineTerminatorsPattern)this.config.lineTerminatorsPattern=r.LineTerminatorOptimizedTester;else if(this.config.lineTerminatorCharacters===s.lineTerminatorCharacters)throw Error(\"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\");if(e.safeMode&&e.ensureOptimizations)throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.');this.trackStartLines=/full|onlyStart/i.test(this.config.positionTracking),this.trackEndLines=/full/i.test(this.config.positionTracking);var a,u=!0;i.isArray(t)?((a={modes:{}}).modes[r.DEFAULT_MODE]=i.cloneArr(t),a[r.DEFAULT_MODE]=r.DEFAULT_MODE):(u=!1,a=i.cloneObj(t)),this.lexerDefinitionErrors=this.lexerDefinitionErrors.concat(r.performRuntimeChecks(a,this.trackStartLines,this.config.lineTerminatorCharacters)),this.lexerDefinitionWarning=this.lexerDefinitionWarning.concat(r.performWarningRuntimeChecks(a,this.trackStartLines,this.config.lineTerminatorCharacters)),a.modes=a.modes?a.modes:{},i.forEach(a.modes,function(t,e){a.modes[e]=i.reject(t,function(t){return i.isUndefined(t)});});var c=i.keys(a.modes);if(i.forEach(a.modes,function(t,a){if(n.modes.push(a),n.lexerDefinitionErrors=n.lexerDefinitionErrors.concat(r.validatePatterns(t,c)),i.isEmpty(n.lexerDefinitionErrors)){o.augmentTokenTypes(t);var s=r.analyzeTokenTypes(t,{lineTerminatorCharacters:n.config.lineTerminatorCharacters,positionTracking:e.positionTracking,ensureOptimizations:e.ensureOptimizations,safeMode:e.safeMode});n.patternIdxToConfig[a]=s.patternIdxToConfig,n.charCodeToPatternIdxToConfig[a]=s.charCodeToPatternIdxToConfig,n.emptyGroups=i.merge(n.emptyGroups,s.emptyGroups),n.hasCustom=s.hasCustom||n.hasCustom,n.canModeBeOptimized[a]=s.canBeOptimized;}}),this.defaultMode=a.defaultMode,!i.isEmpty(this.lexerDefinitionErrors)&&!this.config.deferDefinitionErrorsHandling){var p=i.map(this.lexerDefinitionErrors,function(t){return t.message}).join(\"-----------------------\\n\");throw new Error(\"Errors detected in definition of Lexer:\\n\"+p)}if(i.forEach(this.lexerDefinitionWarning,function(t){i.PRINT_WARNING(t.message);}),r.SUPPORT_STICKY?(this.chopInput=i.IDENTITY,this.match=this.matchWithTest):(this.updateLastIndex=i.NOOP,this.match=this.matchWithExec),u&&(this.handleModes=i.NOOP),!1===this.trackStartLines&&(this.computeNewColumn=i.IDENTITY),!1===this.trackEndLines&&(this.updateTokenEndLineColumnLocation=i.NOOP),/full/i.test(this.config.positionTracking))this.createTokenInstance=this.createFullToken;else if(/onlyStart/i.test(this.config.positionTracking))this.createTokenInstance=this.createStartOnlyToken;else {if(!/onlyOffset/i.test(this.config.positionTracking))throw Error('Invalid <positionTracking> config option: \"'+this.config.positionTracking+'\"');this.createTokenInstance=this.createOffsetOnlyToken;}this.hasCustom?this.addToken=this.addTokenUsingPush:this.addToken=this.addTokenUsingMemberAccess;var l=i.reduce(this.canModeBeOptimized,function(t,e,n){return !1===e&&t.push(n),t},[]);if(e.ensureOptimizations&&!i.isEmpty(l))throw Error(\"Lexer Modes: < \"+l.join(\", \")+' > cannot be optimized.\\n\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n\\t Or inspect the console log for details on how to resolve these issues.')}return t.prototype.tokenize=function(t,e){if(void 0===e&&(e=this.defaultMode),!i.isEmpty(this.lexerDefinitionErrors)){var n=i.map(this.lexerDefinitionErrors,function(t){return t.message}).join(\"-----------------------\\n\");throw new Error(\"Unable to Tokenize because Errors detected in definition of Lexer:\\n\"+n)}return this.tokenizeInternal(t,e)},t.prototype.tokenizeInternal=function(t,e){var n,o,a,s,u,c,p,l,h,f,d,E,m=this,y=t,T=y.length,v=0,g=0,_=this.hasCustom?0:Math.floor(t.length/10),R=new Array(_),A=[],N=this.trackStartLines?1:void 0,O=this.trackStartLines?1:void 0,S=r.cloneEmptyGroups(this.emptyGroups),I=this.trackStartLines,L=this.config.lineTerminatorsPattern,k=0,P=[],x=[],C=[],M=[];Object.freeze(M);var F,b=void 0,D=function(t){if(1===C.length&&void 0===t.tokenType.PUSH_MODE){var e=m.config.errorMessageProvider.buildUnableToPopLexerModeMessage(t);A.push({offset:t.startOffset,line:void 0!==t.startLine?t.startLine:void 0,column:void 0!==t.startColumn?t.startColumn:void 0,length:t.image.length,message:e});}else {C.pop();var n=i.last(C);P=m.patternIdxToConfig[n],x=m.charCodeToPatternIdxToConfig[n],k=P.length;var r=m.canModeBeOptimized[n]&&!1===m.config.safeMode;b=x&&r?function(t){var e=x[t];return void 0===e?M:e}:function(){return P};}};function w(t){C.push(t),x=this.charCodeToPatternIdxToConfig[t],P=this.patternIdxToConfig[t],k=P.length,k=P.length;var e=this.canModeBeOptimized[t]&&!1===this.config.safeMode;b=x&&e?function(t){var e=x[t];return void 0===e?M:e}:function(){return P};}for(w.call(this,e);v<T;){u=null;var U=y.charCodeAt(v),G=b(U),B=G.length;for(n=0;n<B;n++){var K=(F=G[n]).pattern;if(!1!==(Z=F.short)?U===Z&&(u=K):!0===F.isCustom?u=null!==(E=K.exec(y,v,R,S))?E[0]:E:(this.updateLastIndex(K,v),u=this.match(K,t,v)),null!==u){if(void 0!==(s=F.longerAlt)){var W=P[s],j=W.pattern;!0===W.isCustom?a=null!==(E=j.exec(y,v,R,S))?E[0]:E:(this.updateLastIndex(j,v),a=this.match(j,t,v)),a&&a.length>u.length&&(u=a,F=W);}break}}if(null!==u){if(c=u.length,void 0!==(p=F.group)&&(l=F.tokenTypeIdx,h=this.createTokenInstance(u,v,l,F.tokenType,N,O,c),!1===p?g=this.addToken(R,g,h):S[p].push(h)),t=this.chopInput(t,c),v+=c,O=this.computeNewColumn(O,c),!0===I&&!0===F.canLineTerminator){var V=0,Y=void 0,H=void 0;L.lastIndex=0;do{!0===(Y=L.test(u))&&(H=L.lastIndex-1,V++);}while(Y);0!==V&&(N+=V,O=c-H,this.updateTokenEndLineColumnLocation(h,p,H,V,N,O,c));}this.handleModes(F,D,w,h);}else {for(var X=v,z=N,q=O,$=!1;!$&&v<T;)for(y.charCodeAt(v),t=this.chopInput(t,1),v++,o=0;o<k;o++){var Z,Q=P[o];K=Q.pattern;if(!1!==(Z=Q.short)?y.charCodeAt(v)===Z&&($=!0):!0===Q.isCustom?$=null!==K.exec(y,v,R,S):(this.updateLastIndex(K,v),$=null!==K.exec(t)),!0===$)break}f=v-X,d=this.config.errorMessageProvider.buildUnexpectedCharactersMessage(y,X,f,z,q),A.push({offset:X,line:z,column:q,length:f,message:d});}}return this.hasCustom||(R.length=g),{tokens:R,groups:S,errors:A}},t.prototype.handleModes=function(t,e,n,r){if(!0===t.pop){var i=t.push;e(r),void 0!==i&&n.call(this,i);}else void 0!==t.push&&n.call(this,t.push);},t.prototype.chopInput=function(t,e){return t.substring(e)},t.prototype.updateLastIndex=function(t,e){t.lastIndex=e;},t.prototype.updateTokenEndLineColumnLocation=function(t,e,n,r,i,o,a){var s,u;void 0!==e&&(u=(s=n===a-1)?-1:0,1===r&&!0===s||(t.endLine=i+u,t.endColumn=o-1-u));},t.prototype.computeNewColumn=function(t,e){return t+e},t.prototype.createTokenInstance=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];return null},t.prototype.createOffsetOnlyToken=function(t,e,n,r){return {image:t,startOffset:e,tokenTypeIdx:n,tokenType:r}},t.prototype.createStartOnlyToken=function(t,e,n,r,i,o){return {image:t,startOffset:e,startLine:i,startColumn:o,tokenTypeIdx:n,tokenType:r}},t.prototype.createFullToken=function(t,e,n,r,i,o,a){return {image:t,startOffset:e,endOffset:e+a-1,startLine:i,endLine:i,startColumn:o,endColumn:o+a-1,tokenTypeIdx:n,tokenType:r}},t.prototype.addToken=function(t,e,n){return 666},t.prototype.addTokenUsingPush=function(t,e,n){return t.push(n),e},t.prototype.addTokenUsingMemberAccess=function(t,e,n){return t[e]=n,++e},t.prototype.match=function(t,e,n){return null},t.prototype.matchWithTest=function(t,e,n){return !0===t.test(e)?e.substring(n,t.lastIndex):null},t.prototype.matchWithExec=function(t,e){var n=t.exec(e);return null!==n?n[0]:n},t.SKIPPED=\"This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\",t.NA=/NOT_APPLICABLE/,t}();e.Lexer=u;},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(0),a=n(4),s=n(9),u=n(1),c=n(5);e.addTerminalToCst=function(t,e,n){void 0===t.children[n]?t.children[n]=[e]:t.children[n].push(e);},e.addNoneTerminalToCst=function(t,e,n){void 0===t.children[e]?t.children[e]=[n]:t.children[e].push(n);};var p=function(t){function e(e){var n=t.call(this)||this;return n.result=[],n.ruleIdx=e,n}return i(e,t),e.prototype.collectNamedDSLMethod=function(t,e,n){if(!o.isUndefined(t.name)){var r=void 0;if(t instanceof u.Option||t instanceof u.Repetition||t instanceof u.RepetitionMandatory||t instanceof u.Alternation)r=new e({definition:t.definition,idx:t.idx});else {if(!(t instanceof u.RepetitionMandatoryWithSeparator||t instanceof u.RepetitionWithSeparator))throw Error(\"non exhaustive match\");r=new e({definition:t.definition,idx:t.idx,separator:t.separator});}var i=[r],a=s.getKeyForAutomaticLookahead(this.ruleIdx,n,t.idx);this.result.push({def:i,key:a,name:t.name,orgProd:t});}},e.prototype.visitOption=function(t){this.collectNamedDSLMethod(t,u.Option,s.OPTION_IDX);},e.prototype.visitRepetition=function(t){this.collectNamedDSLMethod(t,u.Repetition,s.MANY_IDX);},e.prototype.visitRepetitionMandatory=function(t){this.collectNamedDSLMethod(t,u.RepetitionMandatory,s.AT_LEAST_ONE_IDX);},e.prototype.visitRepetitionMandatoryWithSeparator=function(t){this.collectNamedDSLMethod(t,u.RepetitionMandatoryWithSeparator,s.AT_LEAST_ONE_SEP_IDX);},e.prototype.visitRepetitionWithSeparator=function(t){this.collectNamedDSLMethod(t,u.RepetitionWithSeparator,s.MANY_SEP_IDX);},e.prototype.visitAlternation=function(t){var e=this;this.collectNamedDSLMethod(t,u.Alternation,s.OR_IDX);var n=t.definition.length>1;o.forEach(t.definition,function(r,i){if(!o.isUndefined(r.name)){var a=r.definition;a=n?[new u.Option({definition:r.definition})]:r.definition;var c=s.getKeyForAltIndex(e.ruleIdx,s.OR_IDX,t.idx,i);e.result.push({def:a,key:c,name:r.name,orgProd:r});}});},e}(c.GAstVisitor);e.NamedDSLMethodsCollectorVisitor=p,e.analyzeCst=function(t,e){var n={dictDef:new a.HashTable,allRuleNames:[]};return o.forEach(t,function(t){var r=e.get(t.name);n.allRuleNames.push(t.name);var i=new p(r);t.accept(i),o.forEach(i.result,function(e){e.def,e.key;var r=e.name;n.allRuleNames.push(t.name+r);});}),n};},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0}),e.VERSION=\"4.6.0\";},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(3),i=n(15),o=n(2),a=n(6),s=n(17),u=n(10),c=n(39),p=n(5),l=n(1),h=n(24),f=n(40),d=n(20),E={};E.VERSION=s.VERSION,E.Parser=r.Parser,E.CstParser=r.CstParser,E.EmbeddedActionsParser=r.EmbeddedActionsParser;E.ParserDefinitionErrorType=r.ParserDefinitionErrorType,E.Lexer=i.Lexer,E.LexerDefinitionErrorType=i.LexerDefinitionErrorType,E.EOF=o.EOF,E.tokenName=o.tokenName,E.tokenLabel=o.tokenLabel,E.tokenMatcher=o.tokenMatcher,E.createToken=o.createToken,E.createTokenInstance=o.createTokenInstance,E.EMPTY_ALT=r.EMPTY_ALT,E.defaultParserErrorProvider=u.defaultParserErrorProvider,E.isRecognitionException=a.isRecognitionException,E.EarlyExitException=a.EarlyExitException,E.MismatchedTokenException=a.MismatchedTokenException,E.NotAllInputParsedException=a.NotAllInputParsedException,E.NoViableAltException=a.NoViableAltException,E.defaultLexerErrorProvider=d.defaultLexerErrorProvider,E.Flat=l.Flat,E.Repetition=l.Repetition,E.RepetitionWithSeparator=l.RepetitionWithSeparator,E.RepetitionMandatory=l.RepetitionMandatory,E.RepetitionMandatoryWithSeparator=l.RepetitionMandatoryWithSeparator,E.Option=l.Option,E.Alternation=l.Alternation,E.NonTerminal=l.NonTerminal,E.Terminal=l.Terminal,E.Rule=l.Rule,E.GAstVisitor=p.GAstVisitor,E.serializeGrammar=l.serializeGrammar,E.serializeProduction=l.serializeProduction,E.resolveGrammar=h.resolveGrammar,E.defaultGrammarResolverErrorProvider=u.defaultGrammarResolverErrorProvider,E.validateGrammar=h.validateGrammar,E.defaultGrammarValidatorErrorProvider=u.defaultGrammarValidatorErrorProvider,E.assignOccurrenceIndices=h.assignOccurrenceIndices,E.clearCache=function(){console.warn(\"The clearCache function was 'soft' removed from the Chevrotain API.\\n\\t It performs no action other than printing this message.\\n\\t Please avoid using it as it will be completely removed in the future\");},E.createSyntaxDiagramsCode=c.createSyntaxDiagramsCode,E.generateParserFactory=f.generateParserFactory,E.generateParserModule=f.generateParserModule,t.exports=E;},function(t,e,n){var r,i,o;i=[],void 0===(o=\"function\"==typeof(r=function(){function t(){}t.prototype.saveState=function(){return {idx:this.idx,input:this.input,groupIdx:this.groupIdx}},t.prototype.restoreState=function(t){this.idx=t.idx,this.input=t.input,this.groupIdx=t.groupIdx;},t.prototype.pattern=function(t){this.idx=0,this.input=t,this.groupIdx=0,this.consumeChar(\"/\");var e=this.disjunction();this.consumeChar(\"/\");for(var n={type:\"Flags\",global:!1,ignoreCase:!1,multiLine:!1,unicode:!1,sticky:!1};this.isRegExpFlag();)switch(this.popChar()){case\"g\":s(n,\"global\");break;case\"i\":s(n,\"ignoreCase\");break;case\"m\":s(n,\"multiLine\");break;case\"u\":s(n,\"unicode\");break;case\"y\":s(n,\"sticky\");}if(this.idx!==this.input.length)throw Error(\"Redundant input: \"+this.input.substring(this.idx));return {type:\"Pattern\",flags:n,value:e}},t.prototype.disjunction=function(){var t=[];for(t.push(this.alternative());\"|\"===this.peekChar();)this.consumeChar(\"|\"),t.push(this.alternative());return {type:\"Disjunction\",value:t}},t.prototype.alternative=function(){for(var t=[];this.isTerm();)t.push(this.term());return {type:\"Alternative\",value:t}},t.prototype.term=function(){return this.isAssertion()?this.assertion():this.atom()},t.prototype.assertion=function(){switch(this.popChar()){case\"^\":return {type:\"StartAnchor\"};case\"$\":return {type:\"EndAnchor\"};case\"\\\\\":switch(this.popChar()){case\"b\":return {type:\"WordBoundary\"};case\"B\":return {type:\"NonWordBoundary\"}}throw Error(\"Invalid Assertion Escape\");case\"(\":var t;switch(this.consumeChar(\"?\"),this.popChar()){case\"=\":t=\"Lookahead\";break;case\"!\":t=\"NegativeLookahead\";}u(t);var e=this.disjunction();return this.consumeChar(\")\"),{type:t,value:e}}!function(){throw Error(\"Internal Error - Should never get here!\")}();},t.prototype.quantifier=function(t){var e;switch(this.popChar()){case\"*\":e={atLeast:0,atMost:1/0};break;case\"+\":e={atLeast:1,atMost:1/0};break;case\"?\":e={atLeast:0,atMost:1};break;case\"{\":var n=this.integerIncludingZero();switch(this.popChar()){case\"}\":e={atLeast:n,atMost:n};break;case\",\":var r;this.isDigit()?(r=this.integerIncludingZero(),e={atLeast:n,atMost:r}):e={atLeast:n,atMost:1/0},this.consumeChar(\"}\");}if(!0===t&&void 0===e)return;u(e);}if(!0!==t||void 0!==e)return u(e),\"?\"===this.peekChar(0)?(this.consumeChar(\"?\"),e.greedy=!1):e.greedy=!0,e.type=\"Quantifier\",e},t.prototype.atom=function(){var t;switch(this.peekChar()){case\".\":t=this.dotAll();break;case\"\\\\\":t=this.atomEscape();break;case\"[\":t=this.characterClass();break;case\"(\":t=this.group();}return void 0===t&&this.isPatternCharacter()&&(t=this.patternCharacter()),u(t),this.isQuantifier()&&(t.quantifier=this.quantifier()),t},t.prototype.dotAll=function(){return this.consumeChar(\".\"),{type:\"Set\",complement:!0,value:[o(\"\\n\"),o(\"\\r\"),o(\"\\u2028\"),o(\"\\u2029\")]}},t.prototype.atomEscape=function(){switch(this.consumeChar(\"\\\\\"),this.peekChar()){case\"1\":case\"2\":case\"3\":case\"4\":case\"5\":case\"6\":case\"7\":case\"8\":case\"9\":return this.decimalEscapeAtom();case\"d\":case\"D\":case\"s\":case\"S\":case\"w\":case\"W\":return this.characterClassEscape();case\"f\":case\"n\":case\"r\":case\"t\":case\"v\":return this.controlEscapeAtom();case\"c\":return this.controlLetterEscapeAtom();case\"0\":return this.nulCharacterAtom();case\"x\":return this.hexEscapeSequenceAtom();case\"u\":return this.regExpUnicodeEscapeSequenceAtom();default:return this.identityEscapeAtom()}},t.prototype.decimalEscapeAtom=function(){var t=this.positiveInteger();return {type:\"GroupBackReference\",value:t}},t.prototype.characterClassEscape=function(){var t,e=!1;switch(this.popChar()){case\"d\":t=c;break;case\"D\":t=c,e=!0;break;case\"s\":t=l;break;case\"S\":t=l,e=!0;break;case\"w\":t=p;break;case\"W\":t=p,e=!0;}return u(t),{type:\"Set\",value:t,complement:e}},t.prototype.controlEscapeAtom=function(){var t;switch(this.popChar()){case\"f\":t=o(\"\\f\");break;case\"n\":t=o(\"\\n\");break;case\"r\":t=o(\"\\r\");break;case\"t\":t=o(\"\\t\");break;case\"v\":t=o(\"\\v\");}return u(t),{type:\"Character\",value:t}},t.prototype.controlLetterEscapeAtom=function(){this.consumeChar(\"c\");var t=this.popChar();if(!1===/[a-zA-Z]/.test(t))throw Error(\"Invalid \");var e=t.toUpperCase().charCodeAt(0)-64;return {type:\"Character\",value:e}},t.prototype.nulCharacterAtom=function(){return this.consumeChar(\"0\"),{type:\"Character\",value:o(\"\\0\")}},t.prototype.hexEscapeSequenceAtom=function(){return this.consumeChar(\"x\"),this.parseHexDigits(2)},t.prototype.regExpUnicodeEscapeSequenceAtom=function(){return this.consumeChar(\"u\"),this.parseHexDigits(4)},t.prototype.identityEscapeAtom=function(){var t=this.popChar();return {type:\"Character\",value:o(t)}},t.prototype.classPatternCharacterAtom=function(){switch(this.peekChar()){case\"\\n\":case\"\\r\":case\"\\u2028\":case\"\\u2029\":case\"\\\\\":case\"]\":throw Error(\"TBD\");default:var t=this.popChar();return {type:\"Character\",value:o(t)}}},t.prototype.characterClass=function(){var t=[],e=!1;for(this.consumeChar(\"[\"),\"^\"===this.peekChar(0)&&(this.consumeChar(\"^\"),e=!0);this.isClassAtom();){var n=this.classAtom(),r=\"Character\"===n.type;if(r&&this.isRangeDash()){this.consumeChar(\"-\");var i=this.classAtom(),s=\"Character\"===i.type;if(s){if(i.value<n.value)throw Error(\"Range out of order in character class\");t.push({from:n.value,to:i.value});}else a(n.value,t),t.push(o(\"-\")),a(i.value,t);}else a(n.value,t);}return this.consumeChar(\"]\"),{type:\"Set\",complement:e,value:t}},t.prototype.classAtom=function(){switch(this.peekChar()){case\"]\":case\"\\n\":case\"\\r\":case\"\\u2028\":case\"\\u2029\":throw Error(\"TBD\");case\"\\\\\":return this.classEscape();default:return this.classPatternCharacterAtom()}},t.prototype.classEscape=function(){switch(this.consumeChar(\"\\\\\"),this.peekChar()){case\"b\":return this.consumeChar(\"b\"),{type:\"Character\",value:o(\"\\b\")};case\"d\":case\"D\":case\"s\":case\"S\":case\"w\":case\"W\":return this.characterClassEscape();case\"f\":case\"n\":case\"r\":case\"t\":case\"v\":return this.controlEscapeAtom();case\"c\":return this.controlLetterEscapeAtom();case\"0\":return this.nulCharacterAtom();case\"x\":return this.hexEscapeSequenceAtom();case\"u\":return this.regExpUnicodeEscapeSequenceAtom();default:return this.identityEscapeAtom()}},t.prototype.group=function(){var t=!0;switch(this.consumeChar(\"(\"),this.peekChar(0)){case\"?\":this.consumeChar(\"?\"),this.consumeChar(\":\"),t=!1;break;default:this.groupIdx++;}var e=this.disjunction();this.consumeChar(\")\");var n={type:\"Group\",capturing:t,value:e};return t&&(n.idx=this.groupIdx),n},t.prototype.positiveInteger=function(){var t=this.popChar();if(!1===i.test(t))throw Error(\"Expecting a positive integer\");for(;r.test(this.peekChar(0));)t+=this.popChar();return parseInt(t,10)},t.prototype.integerIncludingZero=function(){var t=this.popChar();if(!1===r.test(t))throw Error(\"Expecting an integer\");for(;r.test(this.peekChar(0));)t+=this.popChar();return parseInt(t,10)},t.prototype.patternCharacter=function(){var t=this.popChar();switch(t){case\"\\n\":case\"\\r\":case\"\\u2028\":case\"\\u2029\":case\"^\":case\"$\":case\"\\\\\":case\".\":case\"*\":case\"+\":case\"?\":case\"(\":case\")\":case\"[\":case\"|\":throw Error(\"TBD\");default:return {type:\"Character\",value:o(t)}}},t.prototype.isRegExpFlag=function(){switch(this.peekChar(0)){case\"g\":case\"i\":case\"m\":case\"u\":case\"y\":return !0;default:return !1}},t.prototype.isRangeDash=function(){return \"-\"===this.peekChar()&&this.isClassAtom(1)},t.prototype.isDigit=function(){return r.test(this.peekChar(0))},t.prototype.isClassAtom=function(t){switch(void 0===t&&(t=0),this.peekChar(t)){case\"]\":case\"\\n\":case\"\\r\":case\"\\u2028\":case\"\\u2029\":return !1;default:return !0}},t.prototype.isTerm=function(){return this.isAtom()||this.isAssertion()},t.prototype.isAtom=function(){if(this.isPatternCharacter())return !0;switch(this.peekChar(0)){case\".\":case\"\\\\\":case\"[\":case\"(\":return !0;default:return !1}},t.prototype.isAssertion=function(){switch(this.peekChar(0)){case\"^\":case\"$\":return !0;case\"\\\\\":switch(this.peekChar(1)){case\"b\":case\"B\":return !0;default:return !1}case\"(\":return \"?\"===this.peekChar(1)&&(\"=\"===this.peekChar(2)||\"!\"===this.peekChar(2));default:return !1}},t.prototype.isQuantifier=function(){var t=this.saveState();try{return void 0!==this.quantifier(!0)}catch(t){return !1}finally{this.restoreState(t);}},t.prototype.isPatternCharacter=function(){switch(this.peekChar()){case\"^\":case\"$\":case\"\\\\\":case\".\":case\"*\":case\"+\":case\"?\":case\"(\":case\")\":case\"[\":case\"|\":case\"/\":case\"\\n\":case\"\\r\":case\"\\u2028\":case\"\\u2029\":return !1;default:return !0}},t.prototype.parseHexDigits=function(t){for(var e=\"\",r=0;r<t;r++){var i=this.popChar();if(!1===n.test(i))throw Error(\"Expecting a HexDecimal digits\");e+=i;}var o=parseInt(e,16);return {type:\"Character\",value:o}},t.prototype.peekChar=function(t){return void 0===t&&(t=0),this.input[this.idx+t]},t.prototype.popChar=function(){var t=this.peekChar(0);return this.consumeChar(),t},t.prototype.consumeChar=function(t){if(void 0!==t&&this.input[this.idx]!==t)throw Error(\"Expected: '\"+t+\"' but found: '\"+this.input[this.idx]+\"' at offset: \"+this.idx);if(this.idx>=this.input.length)throw Error(\"Unexpected end of input\");this.idx++;};var e,n=/[0-9a-fA-F]/,r=/[0-9]/,i=/[1-9]/;function o(t){return t.charCodeAt(0)}function a(t,e){void 0!==t.length?t.forEach(function(t){e.push(t);}):e.push(t);}function s(t,e){if(!0===t[e])throw \"duplicate flag \"+e;t[e]=!0;}function u(t){if(void 0===t)throw Error(\"Internal Error - Should never get here!\")}var c=[];for(e=o(\"0\");e<=o(\"9\");e++)c.push(e);var p=[o(\"_\")].concat(c);for(e=o(\"a\");e<=o(\"z\");e++)p.push(e);for(e=o(\"A\");e<=o(\"Z\");e++)p.push(e);var l=[o(\" \"),o(\"\\f\"),o(\"\\n\"),o(\"\\r\"),o(\"\\t\"),o(\"\\v\"),o(\"\\t\"),o(\"\"),o(\"\"),o(\"\"),o(\"\"),o(\"\"),o(\"\"),o(\"\"),o(\"\"),o(\"\"),o(\"\"),o(\"\"),o(\"\"),o(\"\"),o(\"\\u2028\"),o(\"\\u2029\"),o(\"\"),o(\"\"),o(\"\"),o(\"\\ufeff\")];function h(){}return h.prototype.visitChildren=function(t){for(var e in t){var n=t[e];t.hasOwnProperty(e)&&(void 0!==n.type?this.visit(n):Array.isArray(n)&&n.forEach(function(t){this.visit(t);},this));}},h.prototype.visit=function(t){switch(t.type){case\"Pattern\":this.visitPattern(t);break;case\"Flags\":this.visitFlags(t);break;case\"Disjunction\":this.visitDisjunction(t);break;case\"Alternative\":this.visitAlternative(t);break;case\"StartAnchor\":this.visitStartAnchor(t);break;case\"EndAnchor\":this.visitEndAnchor(t);break;case\"WordBoundary\":this.visitWordBoundary(t);break;case\"NonWordBoundary\":this.visitNonWordBoundary(t);break;case\"Lookahead\":this.visitLookahead(t);break;case\"NegativeLookahead\":this.visitNegativeLookahead(t);break;case\"Character\":this.visitCharacter(t);break;case\"Set\":this.visitSet(t);break;case\"Group\":this.visitGroup(t);break;case\"GroupBackReference\":this.visitGroupBackReference(t);break;case\"Quantifier\":this.visitQuantifier(t);}this.visitChildren(t);},h.prototype.visitPattern=function(t){},h.prototype.visitFlags=function(t){},h.prototype.visitDisjunction=function(t){},h.prototype.visitAlternative=function(t){},h.prototype.visitStartAnchor=function(t){},h.prototype.visitEndAnchor=function(t){},h.prototype.visitWordBoundary=function(t){},h.prototype.visitNonWordBoundary=function(t){},h.prototype.visitLookahead=function(t){},h.prototype.visitNegativeLookahead=function(t){},h.prototype.visitCharacter=function(t){},h.prototype.visitSet=function(t){},h.prototype.visitGroup=function(t){},h.prototype.visitGroupBackReference=function(t){},h.prototype.visitQuantifier=function(t){},{RegExpParser:t,BaseRegExpVisitor:h,VERSION:\"0.4.0\"}})?r.apply(e,i):r)||(t.exports=o);},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0}),e.defaultLexerErrorProvider={buildUnableToPopLexerModeMessage:function(t){return \"Unable to pop Lexer Mode after encountering Token ->\"+t.image+\"<- The Mode Stack is empty\"},buildUnexpectedCharactersMessage:function(t,e,n,r,i){return \"unexpected character: ->\"+t.charAt(e)+\"<- at offset: \"+e+\", skipped \"+n+\" characters.\"}};},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0),i=n(1),o=n(8);function a(t){if(t instanceof i.NonTerminal)return a(t.referencedRule);if(t instanceof i.Terminal)return c(t);if(o.isSequenceProd(t))return s(t);if(o.isBranchingProd(t))return u(t);throw Error(\"non exhaustive match\")}function s(t){for(var e,n=[],i=t.definition,s=0,u=i.length>s,c=!0;u&&c;)e=i[s],c=o.isOptionalProd(e),n=n.concat(a(e)),s+=1,u=i.length>s;return r.uniq(n)}function u(t){var e=r.map(t.definition,function(t){return a(t)});return r.uniq(r.flatten(e))}function c(t){return [t.terminalType]}e.first=a,e.firstForSequence=s,e.firstForBranching=u,e.firstForTerminal=c;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0}),e.IN=\"_~IN~_\";},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r,i=n(29),o=n(0),a=n(1);!function(t){t[t.OPTION=0]=\"OPTION\",t[t.OR=1]=\"OR\",t[t.MANY=2]=\"MANY\",t[t.MANY_SEP=3]=\"MANY_SEP\",t[t.AT_LEAST_ONE=4]=\"AT_LEAST_ONE\",t[t.AT_LEAST_ONE_SEP=5]=\"AT_LEAST_ONE_SEP\",t[t.REF=6]=\"REF\",t[t.TERMINAL=7]=\"TERMINAL\",t[t.FLAT=8]=\"FLAT\";}(r=e.ProdType||(e.ProdType={}));var s=/(?:\\s*{\\s*NAME\\s*:\\s*[\"'`]([\\w$]*)[\"'`])?/,u=new RegExp(s.source.replace(\"{\",\"\").replace(\")?\",\"\\\\s*,)?\")),c=/\\.\\s*CONSUME(\\d+)?\\s*\\(\\s*(?:[a-zA-Z_$]\\w*\\s*\\.\\s*)*([a-zA-Z_$]\\w*)/,p=new RegExp(c.source,\"g\"),l=/\\.\\s*SUBRULE(\\d+)?\\s*\\(\\s*(?:[a-zA-Z_$]\\w*\\s*\\.\\s*)*([a-zA-Z_$]\\w*)/,h=new RegExp(l.source,\"g\"),f=/\\.\\s*OPTION(\\d+)?\\s*\\(/,d=new RegExp(f.source+s.source),E=new RegExp(f.source,\"g\"),m=/\\.\\s*MANY(\\d+)?\\s*\\(/,y=new RegExp(m.source+s.source),T=new RegExp(m.source,\"g\"),v=/\\s*SEP\\s*:\\s*(?:[a-zA-Z_$]\\w*\\s*\\.\\s*)*([a-zA-Z_$]\\w*)/,g=new RegExp(/\\.\\s*MANY_SEP(\\d+)?\\s*\\(\\s*{/.source+u.source+v.source),_=new RegExp(g.source,\"g\"),R=new RegExp(/\\.\\s*AT_LEAST_ONE_SEP(\\d+)?\\s*\\(\\s*{/.source+u.source+v.source),A=new RegExp(R.source,\"g\"),N=/\\.\\s*AT_LEAST_ONE(\\d+)?\\s*\\(/,O=new RegExp(N.source+s.source),S=new RegExp(N.source,\"g\"),I=/\\.\\s*OR(\\d+)?\\s*\\(/,L=new RegExp(I.source+s.source),k=new RegExp(I.source,\"g\"),P=new RegExp(u.source+/\\s*(ALT)\\s*:/.source),x=new RegExp(P.source,\"g\");function C(t,n,i){switch(t.type){case r.AT_LEAST_ONE:return function(t,e,n){return M(O,new a.RepetitionMandatory({definition:[]}),t,e,n)}(t,n,i);case r.AT_LEAST_ONE_SEP:return function(t,e,n){return F(t,e,a.RepetitionMandatoryWithSeparator,R,n)}(t,n,i);case r.MANY_SEP:return function(t,e,n){return F(t,e,a.RepetitionWithSeparator,g,n)}(t,n,i);case r.MANY:return function(t,e,n){return M(y,new a.Repetition({definition:[]}),t,e,n)}(t,n,i);case r.OPTION:return function(t,e,n){return M(d,new a.Option({definition:[]}),t,e,n)}(t,n,i);case r.OR:return function(t,e,n){return M(L,new a.Alternation({definition:[]}),t,e,n)}(t,n,i);case r.FLAT:return function(t,e,n){var r=new a.Flat({definition:[]}),i=P.exec(t.text)[1];o.isUndefined(i)||(r.name=i);return b(r,t.range,e,n)}(t,n,i);case r.REF:return function(t){var e=l.exec(t.text),n=void 0===e[1]?0:parseInt(e[1],10),r=e[2];return new a.NonTerminal({nonTerminalName:r,idx:n})}(t);case r.TERMINAL:return function(t,n){var r=c.exec(t.text),i=void 0===r[1]?0:parseInt(r[1],10),o=r[2],s=e.terminalNameToConstructor[o];if(!s)throw Error(\"Terminal Token name: <\"+o+\"> not found in rule: <\"+n+\">  \\n\\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#TERMINAL_NAME_NOT_FOUND\\n\\tFor Further details.\");return new a.Terminal({terminalType:s,idx:i})}(t,i);default:throw Error(\"non exhaustive match\")}}function M(t,e,n,r,i){var a=t.exec(n.text),s=void 0===a[1];e.idx=s?0:parseInt(a[1],10);var u=a[2];return o.isUndefined(u)||(e.name=u),b(e,n.range,r,i)}function F(t,n,r,i,a){var s=i.exec(t.text),u=void 0===s[1]?0:parseInt(s[1],10),c=s[3],p=e.terminalNameToConstructor[c];if(!p)throw Error(\"Separator Terminal Token name: \"+c+\" not found\");var l=new r({definition:[],separator:p,idx:u}),h=s[2];return o.isUndefined(h)||(l.name=h),b(l,t.range,n,a)}function b(t,e,n,r){var i=D(e,n),a=o.sortBy(i,function(t){return t.range.start}),s=[];return o.forEach(a,function(t){s.push(C(t,n,r));}),t.definition=s,t}function D(t,e){return o.filter(e,function(n){var r=t.strictlyContainsRange(n.range),i=o.every(e,function(e){var r=e.range.strictlyContainsRange(n.range),i=e.range.isStrictlyContainedInRange(t);return !(r&&i)});return r&&i})}e.terminalNameToConstructor={},e.buildTopProduction=function(t,n,r){e.terminalNameToConstructor=r;var o=V(j(K(\"  \"+t)));return function(t,e,n,r){return b(new a.Rule({name:t,definition:[],orgText:r}),e,n,t)}(n,new i.Range(0,t.length+2),o,t)},e.buildProdGast=C,e.getDirectlyContainedRanges=D;var w=/\\/\\/.*/g,U=/\\/\\*([^*]|[\\r\\n]|(\\*+([^*\\/]|[\\r\\n])))*\\*+\\//g,G=/(NAME\\s*:\\s*)?\"([^\\\\\"]|\\\\([bfnrtv\"\\\\\\/]|u[0-9a-fA-F]{4}))*\"/g,B=/(NAME\\s*:\\s*)?'([^\\\\']|\\\\([bfnrtv'\\\\\\/]|u[0-9a-fA-F]{4}))*'/g;function K(t){return t.replace(w,\"\").replace(U,\"\")}function W(t,e){return void 0!==e?t:\"\"}function j(t){return t.replace(G,W).replace(B,W)}function V(t){var e=Y(t),n=H(t),r=X(t),i=z(t),o=q(t),a=$(t),s=Z(t),u=Q(t);return [].concat(e,n,r,i,o,a,s,u)}function Y(t){return nt(t,r.TERMINAL,p)}function H(t){return nt(t,r.REF,h)}function X(t){return rt(t,r.AT_LEAST_ONE,S)}function z(t){return rt(t,r.AT_LEAST_ONE_SEP,A)}function q(t){return rt(t,r.MANY,T)}function $(t){return rt(t,r.MANY_SEP,_)}function Z(t){return rt(t,r.OPTION,E)}function Q(t){var e=rt(t,r.OR,k),n=et(e);return e.concat(n)}e.removeComments=K,e.removeStringLiterals=j,e.createRanges=V,e.createTerminalRanges=Y,e.createRefsRanges=H,e.createAtLeastOneRanges=X,e.createAtLeastOneSepRanges=z,e.createManyRanges=q,e.createManySepRanges=$,e.createOptionRanges=Z,e.createOrRanges=Q;var J=o.partial(ot,\"{\",\"}\"),tt=o.partial(ot,\"(\",\")\");function et(t){var e=[];return o.forEach(t,function(t){var n=it(t.text,r.FLAT,x,J),i=t.range.start;o.forEach(n,function(t){t.range.start+=i,t.range.end+=i;}),e=e.concat(n);}),o.uniq(e,function(t){return t.type+\"~\"+t.range.start+\"~\"+t.range.end+\"~\"+t.text})}function nt(t,e,n){for(var r,o=[];r=n.exec(t);){var a=r.index,s=n.lastIndex,u=new i.Range(a,s),c=r[0];o.push({range:u,text:c,type:e});}return o}function rt(t,e,n){return it(t,e,n,tt)}function it(t,e,n,r){for(var o,a=[];o=n.exec(t);){var s=o.index,u=r(s+o[0].length,t),c=new i.Range(s,u),p=t.substr(s,u-s+1);a.push({range:c,text:p,type:e});}return a}function ot(t,e,n,r){for(var i=[1],a=-1;!o.isEmpty(i)&&a+n<r.length;){a++;var s=r.charAt(n+a);s===t?i.push(1):s===e&&i.pop();}if(o.isEmpty(i))return a+n;throw new Error(\"INVALID INPUT TEXT, UNTERMINATED PARENTHESIS\")}function at(t,e){return o.map(t,function(t){return st(t,e)})}function st(t,e){switch(t.type){case\"NonTerminal\":return new a.NonTerminal({nonTerminalName:t.name,idx:t.idx});case\"Flat\":return new a.Flat({name:t.name,definition:at(t.definition,e)});case\"Option\":return new a.Option({name:t.name,idx:t.idx,definition:at(t.definition,e)});case\"RepetitionMandatory\":return new a.RepetitionMandatory({name:t.name,idx:t.idx,definition:at(t.definition,e)});case\"RepetitionMandatoryWithSeparator\":return new a.RepetitionMandatoryWithSeparator({name:t.name,idx:t.idx,separator:e[t.separator.name],definition:at(t.definition,e)});case\"RepetitionWithSeparator\":return new a.RepetitionWithSeparator({name:t.name,idx:t.idx,separator:e[t.separator.name],definition:at(t.definition,e)});case\"Repetition\":return new a.Repetition({name:t.name,idx:t.idx,definition:at(t.definition,e)});case\"Alternation\":return new a.Alternation({name:t.name,idx:t.idx,definition:at(t.definition,e)});case\"Terminal\":return new a.Terminal({terminalType:e[t.name],idx:t.idx});case\"Rule\":return new a.Rule({name:t.name,orgText:t.orgText,definition:at(t.definition,e)});}}e.createOrPartRanges=et,e.findClosingOffset=ot,e.deserializeGrammar=at,e.deserializeProduction=st;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0),i=n(4),o=n(30),a=n(11),s=n(10),u=n(8);e.resolveGrammar=function(t){t=r.defaults(t,{errMsgProvider:s.defaultGrammarResolverErrorProvider});var e=new i.HashTable;return r.forEach(t.rules,function(t){e.put(t.name,t);}),o.resolveGrammar(e,t.errMsgProvider)},e.validateGrammar=function(t){return t=r.defaults(t,{errMsgProvider:s.defaultGrammarValidatorErrorProvider,ignoredIssues:{}}),a.validateGrammar(t.rules,t.maxLookahead,t.tokenTypes,t.ignoredIssues,t.errMsgProvider,t.grammarName)},e.assignOccurrenceIndices=function(t){r.forEach(t.rules,function(t){var e=new u.DslMethodsCollectorVisitor;t.accept(e),r.forEach(e.dslMethods,function(t){r.forEach(t,function(t,e){t.idx=e+1;});});});};},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(2),i=n(0),o=n(6),a=n(22),s=n(4),u=n(3);function c(t){this.name=e.IN_RULE_RECOVERY_EXCEPTION,this.message=t;}e.EOF_FOLLOW_KEY={},e.IN_RULE_RECOVERY_EXCEPTION=\"InRuleRecoveryException\",e.InRuleRecoveryException=c,c.prototype=Error.prototype;var p=function(){function t(){}return t.prototype.initRecoverable=function(t){this.firstAfterRepMap=new s.HashTable,this.resyncFollows=new s.HashTable,this.recoveryEnabled=i.has(t,\"recoveryEnabled\")?t.recoveryEnabled:u.DEFAULT_PARSER_CONFIG.recoveryEnabled,this.recoveryEnabled&&(this.attemptInRepetitionRecovery=l);},t.prototype.getTokenToInsert=function(t){var e=r.createTokenInstance(t,\"\",NaN,NaN,NaN,NaN,NaN,NaN);return e.isInsertedInRecovery=!0,e},t.prototype.canTokenTypeBeInsertedInRecovery=function(t){return !0},t.prototype.tryInRepetitionRecovery=function(t,e,n,r){for(var a=this,s=this.findReSyncTokenType(),u=this.exportLexerState(),c=[],p=!1,l=this.LA(1),h=this.LA(1),f=function(){var t=a.LA(0),e=a.errorMessageProvider.buildMismatchTokenMessage({expected:r,actual:l,previous:t,ruleName:a.getCurrRuleFullName()}),n=new o.MismatchedTokenException(e,l,a.LA(0));n.resyncedTokens=i.dropRight(c),a.SAVE_ERROR(n);};!p;){if(this.tokenMatcher(h,r))return void f();if(n.call(this))return f(),void t.apply(this,e);this.tokenMatcher(h,s)?p=!0:(h=this.SKIP_TOKEN(),this.addToResyncTokens(h,c));}this.importLexerState(u);},t.prototype.shouldInRepetitionRecoveryBeTried=function(t,e){return void 0!==t&&void 0!==e&&(!this.tokenMatcher(this.LA(1),t)&&(!this.isBackTracking()&&!this.canPerformInRuleRecovery(t,this.getFollowsForInRuleRecovery(t,e))))},t.prototype.getFollowsForInRuleRecovery=function(t,e){var n=this.getCurrentGrammarPath(t,e);return this.getNextPossibleTokenTypes(n)},t.prototype.tryInRuleRecovery=function(t,e){if(this.canRecoverWithSingleTokenInsertion(t,e))return this.getTokenToInsert(t);if(this.canRecoverWithSingleTokenDeletion(t)){var n=this.SKIP_TOKEN();return this.consumeToken(),n}throw new c(\"sad sad panda\")},t.prototype.canPerformInRuleRecovery=function(t,e){return this.canRecoverWithSingleTokenInsertion(t,e)||this.canRecoverWithSingleTokenDeletion(t)},t.prototype.canRecoverWithSingleTokenInsertion=function(t,e){var n=this;if(!this.canTokenTypeBeInsertedInRecovery(t))return !1;if(i.isEmpty(e))return !1;var r=this.LA(1);return void 0!==i.find(e,function(t){return n.tokenMatcher(r,t)})},t.prototype.canRecoverWithSingleTokenDeletion=function(t){return this.tokenMatcher(this.LA(2),t)},t.prototype.isInCurrentRuleReSyncSet=function(t){var e=this.getCurrFollowKey(),n=this.getFollowSetFromFollowKey(e);return i.contains(n,t)},t.prototype.findReSyncTokenType=function(){for(var t=this.flattenFollowSet(),e=this.LA(1),n=2;;){var r=e.tokenType;if(i.contains(t,r))return r;e=this.LA(n),n++;}},t.prototype.getCurrFollowKey=function(){if(1===this.RULE_STACK.length)return e.EOF_FOLLOW_KEY;var t=this.getLastExplicitRuleShortName(),n=this.getLastExplicitRuleOccurrenceIndex(),r=this.getPreviousExplicitRuleShortName();return {ruleName:this.shortRuleNameToFullName(t),idxInCallingRule:n,inRule:this.shortRuleNameToFullName(r)}},t.prototype.buildFullFollowKeyStack=function(){var t=this,n=this.RULE_STACK,r=this.RULE_OCCURRENCE_STACK;return i.isEmpty(this.LAST_EXPLICIT_RULE_STACK)||(n=i.map(this.LAST_EXPLICIT_RULE_STACK,function(e){return t.RULE_STACK[e]}),r=i.map(this.LAST_EXPLICIT_RULE_STACK,function(e){return t.RULE_OCCURRENCE_STACK[e]})),i.map(n,function(i,o){return 0===o?e.EOF_FOLLOW_KEY:{ruleName:t.shortRuleNameToFullName(i),idxInCallingRule:r[o],inRule:t.shortRuleNameToFullName(n[o-1])}})},t.prototype.flattenFollowSet=function(){var t=this,e=i.map(this.buildFullFollowKeyStack(),function(e){return t.getFollowSetFromFollowKey(e)});return i.flatten(e)},t.prototype.getFollowSetFromFollowKey=function(t){if(t===e.EOF_FOLLOW_KEY)return [r.EOF];var n=t.ruleName+t.idxInCallingRule+a.IN+t.inRule;return this.resyncFollows.get(n)},t.prototype.addToResyncTokens=function(t,e){return this.tokenMatcher(t,r.EOF)||e.push(t),e},t.prototype.reSyncTo=function(t){for(var e=[],n=this.LA(1);!1===this.tokenMatcher(n,t);)n=this.SKIP_TOKEN(),this.addToResyncTokens(n,e);return i.dropRight(e)},t.prototype.attemptInRepetitionRecovery=function(t,e,n,r,i,o){},t.prototype.getCurrentGrammarPath=function(t,e){return {ruleStack:this.getHumanReadableRuleStack(),occurrenceStack:i.cloneArr(this.RULE_OCCURRENCE_STACK),lastTok:t,lastTokOccurrence:e}},t.prototype.getHumanReadableRuleStack=function(){var t=this;return i.isEmpty(this.LAST_EXPLICIT_RULE_STACK)?i.map(this.RULE_STACK,function(e){return t.shortRuleNameToFullName(e)}):i.map(this.LAST_EXPLICIT_RULE_STACK,function(e){return t.shortRuleNameToFullName(t.RULE_STACK[e])})},t}();function l(t,e,n,i,o,a){var s=this.getKeyForAutomaticLookahead(i,o),u=this.firstAfterRepMap.get(s);if(void 0===u){var c=this.getCurrRuleFullName();u=new a(this.getGAstProductions().get(c),o).startWalking(),this.firstAfterRepMap.put(s,u);}var p=u.token,l=u.occurrence,h=u.isEndOfRule;1===this.RULE_STACK.length&&h&&void 0===p&&(p=r.EOF,l=1),this.shouldInRepetitionRecoveryBeTried(p,l)&&this.tryInRepetitionRecovery(t,e,n,p);}e.Recoverable=p,e.attemptInRepetitionRecovery=l;},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(14),a=n(4),s=n(21),u=n(0),c=n(22),p=n(2),l=n(1),h=function(t){function e(e){var n=t.call(this)||this;return n.topProd=e,n.follows=new a.HashTable,n}return i(e,t),e.prototype.startWalking=function(){return this.walk(this.topProd),this.follows},e.prototype.walkTerminal=function(t,e,n){},e.prototype.walkProdRef=function(t,e,n){var r=f(t.referencedRule,t.idx)+this.topProd.name,i=e.concat(n),o=new l.Flat({definition:i}),a=s.first(o);this.follows.put(r,a);},e}(o.RestWalker);function f(t,e){return t.name+e+c.IN}e.ResyncFollowsWalker=h,e.computeAllProdsFollows=function(t){var e=new a.HashTable;return u.forEach(t,function(t){var n=new h(t).startWalking();e.putAll(n);}),e},e.buildBetweenProdsFollowPrefix=f,e.buildInProdFollowPrefix=function(t){return p.tokenName(t.terminalType)+t.idx+c.IN};},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(19),a=n(2),s=n(15),u=n(0),c=n(28),p=new o.RegExpParser,l=\"PATTERN\";function h(t){var e=u.filter(t,function(t){return !u.has(t,l)});return {errors:u.map(e,function(t){return {message:\"Token Type: ->\"+a.tokenName(t)+\"<- missing static 'PATTERN' property\",type:s.LexerDefinitionErrorType.MISSING_PATTERN,tokenTypes:[t]}}),valid:u.difference(t,e)}}function f(t){var e=u.filter(t,function(t){var e=t[l];return !(u.isRegExp(e)||u.isFunction(e)||u.has(e,\"exec\")||u.isString(e))});return {errors:u.map(e,function(t){return {message:\"Token Type: ->\"+a.tokenName(t)+\"<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",type:s.LexerDefinitionErrorType.INVALID_PATTERN,tokenTypes:[t]}}),valid:u.difference(t,e)}}e.DEFAULT_MODE=\"defaultMode\",e.MODES=\"modes\",e.SUPPORT_STICKY=\"boolean\"==typeof new RegExp(\"(?:)\").sticky,e.disableSticky=function(){e.SUPPORT_STICKY=!1;},e.enableSticky=function(){e.SUPPORT_STICKY=!0;},e.analyzeTokenTypes=function(t,n){n=u.defaults(n,{useSticky:e.SUPPORT_STICKY,debug:!1,safeMode:!1,positionTracking:\"full\",lineTerminatorCharacters:[\"\\r\",\"\\n\"]});var r=u.reject(t,function(t){return t[l]===s.Lexer.NA}),i=!1,o=u.map(r,function(t){var e=t[l];if(u.isRegExp(e)){var r=e.source;return 1===r.length&&\"^\"!==r&&\"$\"!==r&&\".\"!==r?r:2!==r.length||\"\\\\\"!==r[0]||u.contains([\"d\",\"D\",\"s\",\"S\",\"t\",\"r\",\"n\",\"t\",\"0\",\"c\",\"b\",\"B\",\"f\",\"v\",\"w\",\"W\"],r[1])?n.useSticky?O(e):N(e):r[1]}if(u.isFunction(e))return i=!0,{exec:e};if(u.has(e,\"exec\"))return i=!0,e;if(\"string\"==typeof e){if(1===e.length)return e;var o=e.replace(/[\\\\^$.*+?()[\\]{}|]/g,\"\\\\$&\"),a=new RegExp(o);return n.useSticky?O(a):N(a)}throw Error(\"non exhaustive match\")}),p=u.map(r,function(t){return t.tokenTypeIdx}),h=u.map(r,function(t){var e=t.GROUP;if(e!==s.Lexer.SKIPPED){if(u.isString(e))return e;if(u.isUndefined(e))return !1;throw Error(\"non exhaustive match\")}}),f=u.map(r,function(t){var e=t.LONGER_ALT;if(e)return u.indexOf(r,e)}),d=u.map(r,function(t){return t.PUSH_MODE}),E=u.map(r,function(t){return u.has(t,\"POP_MODE\")}),m=P(n.lineTerminatorCharacters),y=u.map(r,function(t){return !1});\"onlyOffset\"!==n.positionTracking&&(y=u.map(r,function(t){return u.has(t,\"LINE_BREAKS\")?t.LINE_BREAKS:!1===L(t,m)?c.canMatchCharCode(m,t.PATTERN):void 0}));var T=u.map(r,S),v=u.map(o,I),g=u.reduce(r,function(t,e){var n=e.GROUP;return u.isString(n)&&n!==s.Lexer.SKIPPED&&(t[n]=[]),t},{}),_=u.map(o,function(t,e){return {pattern:o[e],longerAlt:f[e],canLineTerminator:y[e],isCustom:T[e],short:v[e],group:h[e],push:d[e],pop:E[e],tokenTypeIdx:p[e],tokenType:r[e]}});function R(t,e,n){void 0===t[e]&&(t[e]=[]),t[e].push(n);}var A=!0,k=[];return n.safeMode||(k=u.reduce(r,function(t,e,r){if(\"string\"==typeof e.PATTERN){var i=e.PATTERN.charCodeAt(0);R(t,i,_[r]);}else if(u.isArray(e.START_CHARS_HINT))u.forEach(e.START_CHARS_HINT,function(e){var n=\"string\"==typeof e?e.charCodeAt(0):e;R(t,n,_[r]);});else if(u.isRegExp(e.PATTERN))if(e.PATTERN.unicode)A=!1,n.ensureOptimizations&&u.PRINT_ERROR(c.failedOptimizationPrefixMsg+\"\\tUnable to analyze < \"+e.PATTERN.toString()+\" > pattern.\\n\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n\\tThis will disable the lexer's first char optimizations.\\n\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE\");else {var o=c.getStartCodes(e.PATTERN,n.ensureOptimizations);u.isEmpty(o)&&(A=!1),u.forEach(o,function(e){R(t,e,_[r]);});}else n.ensureOptimizations&&u.PRINT_ERROR(c.failedOptimizationPrefixMsg+\"\\tTokenType: <\"+a.tokenName(e)+\"> is using a custom token pattern without providing <start_chars_hint> parameter.\\n\\tThis will disable the lexer's first char optimizations.\\n\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE\"),A=!1;return t},[])),A&&k.length<65536&&(k=u.packArray(k)),{emptyGroups:g,patternIdxToConfig:_,charCodeToPatternIdxToConfig:k,hasCustom:i,canBeOptimized:A}},e.validatePatterns=function(t,e){var n=[],r=h(t);n=n.concat(r.errors);var i=f(r.valid),o=i.valid;return n=(n=(n=(n=(n=n.concat(i.errors)).concat(function(t){var e=[],n=u.filter(t,function(t){return u.isRegExp(t[l])});return e=(e=(e=(e=(e=e.concat(E(n))).concat(T(n))).concat(v(n))).concat(g(n))).concat(m(n))}(o))).concat(_(o))).concat(R(o,e))).concat(A(o))},e.findMissingPatterns=h,e.findInvalidPatterns=f;var d=/[^\\\\][\\$]/;function E(t){var e=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.found=!1,e}return i(e,t),e.prototype.visitEndAnchor=function(t){this.found=!0;},e}(o.BaseRegExpVisitor),n=u.filter(t,function(t){var n=t[l];try{var r=p.pattern(n.toString()),i=new e;return i.visit(r),i.found}catch(t){return d.test(n.source)}});return u.map(n,function(t){return {message:\"Unexpected RegExp Anchor Error:\\n\\tToken Type: ->\"+a.tokenName(t)+\"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\\tSee sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS\\tfor details.\",type:s.LexerDefinitionErrorType.EOI_ANCHOR_FOUND,tokenTypes:[t]}})}function m(t){var e=u.filter(t,function(t){return t[l].test(\"\")});return u.map(e,function(t){return {message:\"Token Type: ->\"+a.tokenName(t)+\"<- static 'PATTERN' must not match an empty string\",type:s.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,tokenTypes:[t]}})}e.findEndOfInputAnchor=E,e.findEmptyMatchRegExps=m;var y=/[^\\\\[][\\^]|^\\^/;function T(t){var e=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.found=!1,e}return i(e,t),e.prototype.visitStartAnchor=function(t){this.found=!0;},e}(o.BaseRegExpVisitor),n=u.filter(t,function(t){var n=t[l];try{var r=p.pattern(n.toString()),i=new e;return i.visit(r),i.found}catch(t){return y.test(n.source)}});return u.map(n,function(t){return {message:\"Unexpected RegExp Anchor Error:\\n\\tToken Type: ->\"+a.tokenName(t)+\"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS\\tfor details.\",type:s.LexerDefinitionErrorType.SOI_ANCHOR_FOUND,tokenTypes:[t]}})}function v(t){var e=u.filter(t,function(t){var e=t[l];return e instanceof RegExp&&(e.multiline||e.global)});return u.map(e,function(t){return {message:\"Token Type: ->\"+a.tokenName(t)+\"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",type:s.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,tokenTypes:[t]}})}function g(t){var e=[],n=u.map(t,function(n){return u.reduce(t,function(t,r){return n.PATTERN.source!==r.PATTERN.source||u.contains(e,r)||r.PATTERN===s.Lexer.NA?t:(e.push(r),t.push(r),t)},[])});n=u.compact(n);var r=u.filter(n,function(t){return t.length>1});return u.map(r,function(t){var e=u.map(t,function(t){return a.tokenName(t)});return {message:\"The same RegExp pattern ->\"+u.first(t).PATTERN+\"<-has been used in all of the following Token Types: \"+e.join(\", \")+\" <-\",type:s.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,tokenTypes:t}})}function _(t){var e=u.filter(t,function(t){if(!u.has(t,\"GROUP\"))return !1;var e=t.GROUP;return e!==s.Lexer.SKIPPED&&e!==s.Lexer.NA&&!u.isString(e)});return u.map(e,function(t){return {message:\"Token Type: ->\"+a.tokenName(t)+\"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",type:s.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,tokenTypes:[t]}})}function R(t,e){var n=u.filter(t,function(t){return void 0!==t.PUSH_MODE&&!u.contains(e,t.PUSH_MODE)});return u.map(n,function(t){return {message:\"Token Type: ->\"+a.tokenName(t)+\"<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->\"+t.PUSH_MODE+\"<-which does not exist\",type:s.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,tokenTypes:[t]}})}function A(t){var e=[],n=u.reduce(t,function(t,e,n){var r,i=e.PATTERN;return i===s.Lexer.NA?t:(u.isString(i)?t.push({str:i,idx:n,tokenType:e}):u.isRegExp(i)&&(r=i,void 0===u.find([\".\",\"\\\\\",\"[\",\"]\",\"|\",\"^\",\"$\",\"(\",\")\",\"?\",\"*\",\"+\",\"{\"],function(t){return -1!==r.source.indexOf(t)}))&&t.push({str:i.source,idx:n,tokenType:e}),t)},[]);return u.forEach(t,function(t,r){u.forEach(n,function(n){var i=n.str,o=n.idx,c=n.tokenType;if(r<o&&function(t,e){if(u.isRegExp(e)){var n=e.exec(t);return null!==n&&0===n.index}if(u.isFunction(e))return e(t,0,[],{});if(u.has(e,\"exec\"))return e.exec(t,0,[],{});if(\"string\"==typeof e)return e===t;throw Error(\"non exhaustive match\")}(i,t.PATTERN)){var p=\"Token: ->\"+a.tokenName(c)+\"<- can never be matched.\\nBecause it appears AFTER the Token Type ->\"+a.tokenName(t)+\"<-in the lexer's definition.\\nSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNREACHABLE\";e.push({message:p,type:s.LexerDefinitionErrorType.UNREACHABLE_PATTERN,tokenTypes:[t,c]});}});}),e}function N(t){var e=t.ignoreCase?\"i\":\"\";return new RegExp(\"^(?:\"+t.source+\")\",e)}function O(t){var e=t.ignoreCase?\"iy\":\"y\";return new RegExp(\"\"+t.source,e)}function S(t){var e=t.PATTERN;if(u.isRegExp(e))return !1;if(u.isFunction(e))return !0;if(u.has(e,\"exec\"))return !0;if(u.isString(e))return !1;throw Error(\"non exhaustive match\")}function I(t){return !(!u.isString(t)||1!==t.length)&&t.charCodeAt(0)}function L(t,e){if(u.has(t,\"LINE_BREAKS\"))return !1;if(u.isRegExp(t.PATTERN)){try{c.canMatchCharCode(e,t.PATTERN);}catch(t){return {issue:s.LexerDefinitionErrorType.IDENTIFY_TERMINATOR,errMsg:t.message}}return !1}if(u.isString(t.PATTERN))return !1;if(S(t))return {issue:s.LexerDefinitionErrorType.CUSTOM_LINE_BREAK};throw Error(\"non exhaustive match\")}function k(t,e){if(e.issue===s.LexerDefinitionErrorType.IDENTIFY_TERMINATOR)return \"Warning: unable to identify line terminator usage in pattern.\\n\\tThe problem is in the <\"+t.name+\"> Token Type\\n\\t Root cause: \"+e.errMsg+\".\\n\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR\";if(e.issue===s.LexerDefinitionErrorType.CUSTOM_LINE_BREAK)return \"Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n\\tThe problem is in the <\"+t.name+\"> Token Type\\n\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK\";throw Error(\"non exhaustive match\")}function P(t){return u.map(t,function(t){return u.isString(t)&&t.length>0?t.charCodeAt(0):t})}e.findStartOfInputAnchor=T,e.findUnsupportedFlags=v,e.findDuplicatePatterns=g,e.findInvalidGroupType=_,e.findModesThatDoNotExist=R,e.findUnreachablePatterns=A,e.addStartOfInput=N,e.addStickyFlag=O,e.performRuntimeChecks=function(t,n,r){var i=[];return u.has(t,e.DEFAULT_MODE)||i.push({message:\"A MultiMode Lexer cannot be initialized without a <\"+e.DEFAULT_MODE+\"> property in its definition\\n\",type:s.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE}),u.has(t,e.MODES)||i.push({message:\"A MultiMode Lexer cannot be initialized without a <\"+e.MODES+\"> property in its definition\\n\",type:s.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY}),u.has(t,e.MODES)&&u.has(t,e.DEFAULT_MODE)&&!u.has(t.modes,t.defaultMode)&&i.push({message:\"A MultiMode Lexer cannot be initialized with a \"+e.DEFAULT_MODE+\": <\"+t.defaultMode+\">which does not exist\\n\",type:s.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST}),u.has(t,e.MODES)&&u.forEach(t.modes,function(t,e){u.forEach(t,function(t,n){u.isUndefined(t)&&i.push({message:\"A Lexer cannot be initialized using an undefined Token Type. Mode:<\"+e+\"> at index: <\"+n+\">\\n\",type:s.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED});});}),i},e.performWarningRuntimeChecks=function(t,e,n){var r=[],i=!1,o=u.compact(u.flatten(u.mapValues(t.modes,function(t){return t}))),a=u.reject(o,function(t){return t[l]===s.Lexer.NA}),p=P(n);return e&&u.forEach(a,function(t){var e=L(t,p);if(!1!==e){var n={message:k(t,e),type:e.issue,tokenType:t};r.push(n);}else u.has(t,\"LINE_BREAKS\")?!0===t.LINE_BREAKS&&(i=!0):c.canMatchCharCode(p,t.PATTERN)&&(i=!0);}),e&&!i&&r.push({message:\"Warning: No LINE_BREAKS Found.\\n\\tThis Lexer has been defined to track line and column information,\\n\\tBut none of the Token Types can be identified as matching a line terminator.\\n\\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\\tfor details.\",type:s.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS}),r},e.cloneEmptyGroups=function(t){var e={},n=u.keys(t);return u.forEach(n,function(n){var r=t[n];if(!u.isArray(r))throw Error(\"non exhaustive match\");e[n]=[];}),e},e.isCustomPattern=S,e.isShortPattern=I,e.LineTerminatorOptimizedTester={test:function(t){for(var e=t.length,n=this.lastIndex;n<e;n++){var r=t.charCodeAt(n);if(10===r)return this.lastIndex=n+1,!0;if(13===r)return 10===t.charCodeAt(n+1)?this.lastIndex=n+2:this.lastIndex=n+1,!0}return !1},lastIndex:0},e.buildLineBreakIssueMessage=k;},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(19),a=n(0),s=new o.RegExpParser,u=\"Complement Sets are not supported for first char optimization\";function c(t){switch(t.type){case\"Disjunction\":return a.flatten(a.map(t.value,c));case\"Alternative\":for(var e=[],n=t.value,r=0;r<n.length;r++){var i=n[r];if(!a.contains([\"GroupBackReference\",\"Lookahead\",\"NegativeLookahead\",\"StartAnchor\",\"EndAnchor\",\"WordBoundary\",\"NonWordBoundary\"],i.type)){var o=i;switch(o.type){case\"Character\":e.push(o.value);break;case\"Set\":if(!0===o.complement)throw Error(u);a.forEach(o.value,function(t){if(\"number\"==typeof t)e.push(t);else for(var n=t,r=n.from;r<=n.to;r++)e.push(r);});break;case\"Group\":var s=c(o.value);a.forEach(s,function(t){return e.push(t)});break;default:throw Error(\"Non Exhaustive Match\")}var p=void 0!==o.quantifier&&0===o.quantifier.atLeast;if(\"Group\"===o.type&&!1===h(o)||\"Group\"!==o.type&&!1===p)break}}return e;default:throw Error(\"non exhaustive match!\")}}function p(t){var e=[];return a.forEach(t,function(t){e.push(t);var n=String.fromCharCode(t);n.toUpperCase()!==n?e.push(n.toUpperCase().charCodeAt(0)):n.toLowerCase()!==n&&e.push(n.toLowerCase().charCodeAt(0));}),e}function l(t,e){return a.find(t.value,function(t){if(\"number\"==typeof t)return a.contains(e,t);var n=t;return void 0!==a.find(e,function(t){return n.from<=t&&t<=n.to})})}function h(t){return !(!t.quantifier||0!==t.quantifier.atLeast)||!!t.value&&(a.isArray(t.value)?a.every(t.value,h):h(t.value))}e.failedOptimizationPrefixMsg='Unable to use \"first char\" lexer optimizations:\\n',e.getStartCodes=function(t,n){void 0===n&&(n=!1);try{var r=s.pattern(t.toString()),i=c(r.value);return r.flags.ignoreCase&&(i=p(i)),i}catch(r){if(r.message===u)n&&a.PRINT_WARNING(e.failedOptimizationPrefixMsg+\"\\tUnable to optimize: < \"+t.toString()+\" >\\n\\tComplement Sets cannot be automatically optimized.\\n\\tThis will disable the lexer's first char optimizations.\\n\\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\");else {var l=\"\";n&&(l=\"\\n\\tThis will disable the lexer's first char optimizations.\\n\\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\"),a.PRINT_ERROR(e.failedOptimizationPrefixMsg+\"\\n\\tFailed parsing: < \"+t.toString()+\" >\\n\\tUsing the regexp-to-ast library version: \"+o.VERSION+\"\\n\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\"+l);}}return []},e.firstChar=c,e.applyIgnoreCase=p;var f=function(t){function e(e){var n=t.call(this)||this;return n.targetCharCodes=e,n.found=!1,n}return i(e,t),e.prototype.visitChildren=function(e){switch(e.type){case\"Lookahead\":return void this.visitLookahead(e);case\"NegativeLookahead\":return void this.visitNegativeLookahead(e)}t.prototype.visitChildren.call(this,e);},e.prototype.visitCharacter=function(t){a.contains(this.targetCharCodes,t.value)&&(this.found=!0);},e.prototype.visitSet=function(t){t.complement?void 0===l(t,this.targetCharCodes)&&(this.found=!0):void 0!==l(t,this.targetCharCodes)&&(this.found=!0);},e}(o.BaseRegExpVisitor);e.canMatchCharCode=function(t,e){if(e instanceof RegExp){var n=s.pattern(e.toString()),r=new f(t);return r.visit(n),r.found}return void 0!==a.find(e,function(e){return a.contains(t,e.charCodeAt(0))})};},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=function(){function t(t,e){if(this.start=t,this.end=e,!i(t,e))throw new Error(\"INVALID RANGE\")}return t.prototype.contains=function(t){return this.start<=t&&this.end>=t},t.prototype.containsRange=function(t){return this.start<=t.start&&this.end>=t.end},t.prototype.isContainedInRange=function(t){return t.containsRange(this)},t.prototype.strictlyContainsRange=function(t){return this.start<t.start&&this.end>t.end},t.prototype.isStrictlyContainedInRange=function(t){return t.strictlyContainsRange(this)},t}();function i(t,e){return !(t<0||e<t)}e.Range=r,e.isValidRange=i;},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(3),a=n(0),s=n(5);e.resolveGrammar=function(t,e){var n=new u(t,e);return n.resolveRefs(),n.errors};var u=function(t){function e(e,n){var r=t.call(this)||this;return r.nameToTopRule=e,r.errMsgProvider=n,r.errors=[],r}return i(e,t),e.prototype.resolveRefs=function(){var t=this;a.forEach(this.nameToTopRule.values(),function(e){t.currTopLevel=e,e.accept(t);});},e.prototype.visitNonTerminal=function(t){var e=this.nameToTopRule.get(t.nonTerminalName);if(e)t.referencedRule=e;else {var n=this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel,t);this.errors.push({message:n,type:o.ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,ruleName:this.currTopLevel.name,unresolvedRefName:t.nonTerminalName});}},e}(s.GAstVisitor);e.GastRefResolverVisitor=u;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(12),i=n(0),o=n(3),a=n(9),s=function(){function t(){}return t.prototype.initLooksAhead=function(t){this.dynamicTokensEnabled=i.has(t,\"dynamicTokensEnabled\")?t.dynamicTokensEnabled:o.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled,this.maxLookahead=i.has(t,\"maxLookahead\")?t.maxLookahead:o.DEFAULT_PARSER_CONFIG.maxLookahead,this.lookAheadFuncsCache=i.isES2015MapSupported()?new Map:[],i.isES2015MapSupported()?(this.getLaFuncFromCache=this.getLaFuncFromMap,this.setLaFuncCache=this.setLaFuncCacheUsingMap):(this.getLaFuncFromCache=this.getLaFuncFromObj,this.setLaFuncCache=this.setLaFuncUsingObj);},t.prototype.lookAheadBuilderForOptional=function(t,e,n){return r.buildSingleAlternativeLookaheadFunction(t,e,n)},t.prototype.lookAheadBuilderForAlternatives=function(t,e,n,i){return r.buildAlternativesLookAheadFunc(t,e,n,i)},t.prototype.getKeyForAutomaticLookahead=function(t,e){var n=this.getLastExplicitRuleShortName();return a.getKeyForAutomaticLookahead(n,t,e)},t.prototype.getLookaheadFuncForOr=function(t,e){var n=this.getKeyForAutomaticLookahead(a.OR_IDX,t),o=this.getLaFuncFromCache(n);if(void 0===o){var s=this.getCurrRuleFullName(),u=this.getGAstProductions().get(s),c=i.some(e,function(t){return i.isFunction(t.GATE)});return o=r.buildLookaheadFuncForOr(t,u,this.maxLookahead,c,this.dynamicTokensEnabled,this.lookAheadBuilderForAlternatives),this.setLaFuncCache(n,o),o}return o},t.prototype.getLookaheadFuncForOption=function(t,e){return this.getLookaheadFuncFor(t,e,this.maxLookahead,r.PROD_TYPE.OPTION)},t.prototype.getLookaheadFuncForMany=function(t,e){return this.getLookaheadFuncFor(t,e,this.maxLookahead,r.PROD_TYPE.REPETITION)},t.prototype.getLookaheadFuncForManySep=function(t,e){return this.getLookaheadFuncFor(t,e,this.maxLookahead,r.PROD_TYPE.REPETITION_WITH_SEPARATOR)},t.prototype.getLookaheadFuncForAtLeastOne=function(t,e){return this.getLookaheadFuncFor(t,e,this.maxLookahead,r.PROD_TYPE.REPETITION_MANDATORY)},t.prototype.getLookaheadFuncForAtLeastOneSep=function(t,e){return this.getLookaheadFuncFor(t,e,this.maxLookahead,r.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR)},t.prototype.getLookaheadFuncFor=function(t,e,n,i){var o=this.getLaFuncFromCache(t);if(void 0===o){var a=this.getCurrRuleFullName(),s=this.getGAstProductions().get(a);return o=r.buildLookaheadFuncForOptionalProd(e,s,n,this.dynamicTokensEnabled,i,this.lookAheadBuilderForOptional),this.setLaFuncCache(t,o),o}return o},t.prototype.getLaFuncFromCache=function(t){},t.prototype.getLaFuncFromMap=function(t){return this.lookAheadFuncsCache.get(t)},t.prototype.getLaFuncFromObj=function(t){return this.lookAheadFuncsCache[t]},t.prototype.setLaFuncCache=function(t,e){},t.prototype.setLaFuncCacheUsingMap=function(t,e){this.lookAheadFuncsCache.set(t,e);},t.prototype.setLaFuncUsingObj=function(t,e){this.lookAheadFuncsCache[t]=e;},t}();e.LooksAhead=s;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(16),i=n(0),o=n(33),a=n(9),s=n(3),u=function(){function t(){}return t.prototype.initTreeBuilder=function(t){this.LAST_EXPLICIT_RULE_STACK=[],this.CST_STACK=[],this.outputCst=i.has(t,\"outputCst\")?t.outputCst:s.DEFAULT_PARSER_CONFIG.outputCst,this.outputCst||(this.cstInvocationStateUpdate=i.NOOP,this.cstFinallyStateUpdate=i.NOOP,this.cstPostTerminal=i.NOOP,this.cstPostNonTerminal=i.NOOP,this.getLastExplicitRuleShortName=this.getLastExplicitRuleShortNameNoCst,this.getPreviousExplicitRuleShortName=this.getPreviousExplicitRuleShortNameNoCst,this.getLastExplicitRuleOccurrenceIndex=this.getLastExplicitRuleOccurrenceIndexNoCst,this.manyInternal=this.manyInternalNoCst,this.orInternal=this.orInternalNoCst,this.optionInternal=this.optionInternalNoCst,this.atLeastOneInternal=this.atLeastOneInternalNoCst,this.manySepFirstInternal=this.manySepFirstInternalNoCst,this.atLeastOneSepFirstInternal=this.atLeastOneSepFirstInternalNoCst);},t.prototype.cstNestedInvocationStateUpdate=function(t,e){this.CST_STACK.push({name:t,fullName:this.shortRuleNameToFull.get(this.getLastExplicitRuleShortName())+t,children:{}});},t.prototype.cstInvocationStateUpdate=function(t,e){this.LAST_EXPLICIT_RULE_STACK.push(this.RULE_STACK.length-1),this.CST_STACK.push({name:t,children:{}});},t.prototype.cstFinallyStateUpdate=function(){this.LAST_EXPLICIT_RULE_STACK.pop(),this.CST_STACK.pop();},t.prototype.cstNestedFinallyStateUpdate=function(){this.CST_STACK.pop();},t.prototype.cstPostTerminal=function(t,e){var n=this.CST_STACK[this.CST_STACK.length-1];r.addTerminalToCst(n,e,t);},t.prototype.cstPostNonTerminal=function(t,e){r.addNoneTerminalToCst(this.CST_STACK[this.CST_STACK.length-1],e,t);},t.prototype.getBaseCstVisitorConstructor=function(){if(i.isUndefined(this.baseCstVisitorConstructor)){var t=o.createBaseSemanticVisitorConstructor(this.className,this.allRuleNames);return this.baseCstVisitorConstructor=t,t}return this.baseCstVisitorConstructor},t.prototype.getBaseCstVisitorConstructorWithDefaults=function(){if(i.isUndefined(this.baseCstVisitorWithDefaultsConstructor)){var t=o.createBaseVisitorConstructorWithDefaults(this.className,this.allRuleNames,this.getBaseCstVisitorConstructor());return this.baseCstVisitorWithDefaultsConstructor=t,t}return this.baseCstVisitorWithDefaultsConstructor},t.prototype.nestedRuleBeforeClause=function(t,e){var n;return void 0!==t.NAME?(n=t.NAME,this.nestedRuleInvocationStateUpdate(n,e),n):void 0},t.prototype.nestedAltBeforeClause=function(t,e,n,r){var i,o=this.getLastExplicitRuleShortName(),s=a.getKeyForAltIndex(o,n,e,r);return void 0!==t.NAME?(i=t.NAME,this.nestedRuleInvocationStateUpdate(i,s),{shortName:s,nestedName:i}):void 0},t.prototype.nestedRuleFinallyClause=function(t,e){var n=this.CST_STACK,i=n[n.length-1];this.nestedRuleFinallyStateUpdate();var o=n[n.length-1];r.addNoneTerminalToCst(o,e,i);},t.prototype.getLastExplicitRuleShortName=function(){var t=this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length-1];return this.RULE_STACK[t]},t.prototype.getLastExplicitRuleShortNameNoCst=function(){var t=this.RULE_STACK;return t[t.length-1]},t.prototype.getPreviousExplicitRuleShortName=function(){var t=this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length-2];return this.RULE_STACK[t]},t.prototype.getPreviousExplicitRuleShortNameNoCst=function(){var t=this.RULE_STACK;return t[t.length-2]},t.prototype.getLastExplicitRuleOccurrenceIndex=function(){var t=this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length-1];return this.RULE_OCCURRENCE_STACK[t]},t.prototype.getLastExplicitRuleOccurrenceIndexNoCst=function(){var t=this.RULE_OCCURRENCE_STACK;return t[t.length-1]},t.prototype.nestedRuleInvocationStateUpdate=function(t,e){this.RULE_OCCURRENCE_STACK.push(1),this.RULE_STACK.push(e),this.cstNestedInvocationStateUpdate(t,e);},t.prototype.nestedRuleFinallyStateUpdate=function(){this.RULE_STACK.pop(),this.RULE_OCCURRENCE_STACK.pop(),this.cstNestedFinallyStateUpdate();},t}();e.TreeBuilder=u;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r,i=n(0),o=n(4),a=n(11);function s(t,e){for(var n=i.keys(t),r=n.length,o=0;o<r;o++)for(var a=t[n[o]],s=a.length,u=0;u<s;u++){var c=a[u];void 0===c.tokenTypeIdx&&(void 0!==c.fullName?this[c.fullName](c.children,e):this[c.name](c.children,e));}}function u(t,e){var n=c(t,e),r=l(t,e);return n.concat(r)}function c(t,e){var n=i.map(e,function(e){if(!i.isFunction(t[e]))return {msg:\"Missing visitor method: <\"+e+\"> on \"+o.functionName(t.constructor)+\" CST Visitor.\",type:r.MISSING_METHOD,methodName:e}});return i.compact(n)}e.defaultVisit=s,e.createBaseSemanticVisitorConstructor=function(t,e){var n=function(){};return o.defineNameProp(n,t+\"BaseSemantics\"),(n.prototype={visit:function(t,e){if(i.isArray(t)&&(t=t[0]),!i.isUndefined(t))return void 0!==t.fullName?this[t.fullName](t.children,e):this[t.name](t.children,e)},validateVisitor:function(){var t=u(this,e);if(!i.isEmpty(t)){var n=i.map(t,function(t){return t.msg});throw Error(\"Errors Detected in CST Visitor <\"+o.functionName(this.constructor)+\">:\\n\\t\"+n.join(\"\\n\\n\").replace(/\\n/g,\"\\n\\t\"))}}}).constructor=n,n._RULE_NAMES=e,n},e.createBaseVisitorConstructorWithDefaults=function(t,e,n){var r=function(){};o.defineNameProp(r,t+\"BaseSemanticsWithDefaults\");var a=Object.create(n.prototype);return i.forEach(e,function(t){a[t]=s;}),(r.prototype=a).constructor=r,r},function(t){t[t.REDUNDANT_METHOD=0]=\"REDUNDANT_METHOD\",t[t.MISSING_METHOD=1]=\"MISSING_METHOD\";}(r=e.CstVisitorDefinitionError||(e.CstVisitorDefinitionError={})),e.validateVisitor=u,e.validateMissingCstMethods=c;var p=[\"constructor\",\"visit\",\"validateVisitor\"];function l(t,e){var n=[];for(var s in t)a.validTermsPattern.test(s)&&i.isFunction(t[s])&&!i.contains(p,s)&&!i.contains(e,s)&&n.push({msg:\"Redundant visitor method: <\"+s+\"> on \"+o.functionName(t.constructor)+\" CST Visitor\\nThere is no Grammar Rule corresponding to this method's name.\\nFor utility methods on visitor classes use methods names that do not match /\"+a.validTermsPattern.source+\"/.\",type:r.REDUNDANT_METHOD,methodName:s});return n}e.validateRedundantMethods=l;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(3),i=function(){function t(){}return t.prototype.initLexerAdapter=function(){this.tokVector=[],this.tokVectorLength=0,this.currIdx=-1;},Object.defineProperty(t.prototype,\"input\",{get:function(){return this.tokVector},set:function(t){this.reset(),this.tokVector=t,this.tokVectorLength=t.length;},enumerable:!0,configurable:!0}),t.prototype.SKIP_TOKEN=function(){return this.currIdx<=this.tokVector.length-2?(this.consumeToken(),this.LA(1)):r.END_OF_FILE},t.prototype.LA=function(t){return this.currIdx+t<0||this.tokVectorLength<=this.currIdx+t?r.END_OF_FILE:this.tokVector[this.currIdx+t]},t.prototype.consumeToken=function(){this.currIdx++;},t.prototype.exportLexerState=function(){return this.currIdx},t.prototype.importLexerState=function(t){this.currIdx=t;},t.prototype.resetLexerState=function(){this.currIdx=-1;},t.prototype.moveToTerminatedState=function(){this.currIdx=this.tokVector.length-1;},t.prototype.getLexerPosition=function(){return this.exportLexerState()},t}();e.LexerAdapter=i;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0),i=n(6),o=n(3),a=n(10),s=n(23),u=n(11),c=n(1),p=function(){function t(){}return t.prototype.CONSUME=function(t,e){return this.consumeInternal(t,0,e)},t.prototype.CONSUME1=function(t,e){return this.consumeInternal(t,1,e)},t.prototype.CONSUME2=function(t,e){return this.consumeInternal(t,2,e)},t.prototype.CONSUME3=function(t,e){return this.consumeInternal(t,3,e)},t.prototype.CONSUME4=function(t,e){return this.consumeInternal(t,4,e)},t.prototype.CONSUME5=function(t,e){return this.consumeInternal(t,5,e)},t.prototype.CONSUME6=function(t,e){return this.consumeInternal(t,6,e)},t.prototype.CONSUME7=function(t,e){return this.consumeInternal(t,7,e)},t.prototype.CONSUME8=function(t,e){return this.consumeInternal(t,8,e)},t.prototype.CONSUME9=function(t,e){return this.consumeInternal(t,9,e)},t.prototype.SUBRULE=function(t,e){return this.subruleInternal(t,0,e)},t.prototype.SUBRULE1=function(t,e){return this.subruleInternal(t,1,e)},t.prototype.SUBRULE2=function(t,e){return this.subruleInternal(t,2,e)},t.prototype.SUBRULE3=function(t,e){return this.subruleInternal(t,3,e)},t.prototype.SUBRULE4=function(t,e){return this.subruleInternal(t,4,e)},t.prototype.SUBRULE5=function(t,e){return this.subruleInternal(t,5,e)},t.prototype.SUBRULE6=function(t,e){return this.subruleInternal(t,6,e)},t.prototype.SUBRULE7=function(t,e){return this.subruleInternal(t,7,e)},t.prototype.SUBRULE8=function(t,e){return this.subruleInternal(t,8,e)},t.prototype.SUBRULE9=function(t,e){return this.subruleInternal(t,9,e)},t.prototype.OPTION=function(t){return this.optionInternal(t,0)},t.prototype.OPTION1=function(t){return this.optionInternal(t,1)},t.prototype.OPTION2=function(t){return this.optionInternal(t,2)},t.prototype.OPTION3=function(t){return this.optionInternal(t,3)},t.prototype.OPTION4=function(t){return this.optionInternal(t,4)},t.prototype.OPTION5=function(t){return this.optionInternal(t,5)},t.prototype.OPTION6=function(t){return this.optionInternal(t,6)},t.prototype.OPTION7=function(t){return this.optionInternal(t,7)},t.prototype.OPTION8=function(t){return this.optionInternal(t,8)},t.prototype.OPTION9=function(t){return this.optionInternal(t,9)},t.prototype.OR=function(t){return this.orInternal(t,0)},t.prototype.OR1=function(t){return this.orInternal(t,1)},t.prototype.OR2=function(t){return this.orInternal(t,2)},t.prototype.OR3=function(t){return this.orInternal(t,3)},t.prototype.OR4=function(t){return this.orInternal(t,4)},t.prototype.OR5=function(t){return this.orInternal(t,5)},t.prototype.OR6=function(t){return this.orInternal(t,6)},t.prototype.OR7=function(t){return this.orInternal(t,7)},t.prototype.OR8=function(t){return this.orInternal(t,8)},t.prototype.OR9=function(t){return this.orInternal(t,9)},t.prototype.MANY=function(t){this.manyInternal(0,t);},t.prototype.MANY1=function(t){this.manyInternal(1,t);},t.prototype.MANY2=function(t){this.manyInternal(2,t);},t.prototype.MANY3=function(t){this.manyInternal(3,t);},t.prototype.MANY4=function(t){this.manyInternal(4,t);},t.prototype.MANY5=function(t){this.manyInternal(5,t);},t.prototype.MANY6=function(t){this.manyInternal(6,t);},t.prototype.MANY7=function(t){this.manyInternal(7,t);},t.prototype.MANY8=function(t){this.manyInternal(8,t);},t.prototype.MANY9=function(t){this.manyInternal(9,t);},t.prototype.MANY_SEP=function(t){this.manySepFirstInternal(0,t);},t.prototype.MANY_SEP1=function(t){this.manySepFirstInternal(1,t);},t.prototype.MANY_SEP2=function(t){this.manySepFirstInternal(2,t);},t.prototype.MANY_SEP3=function(t){this.manySepFirstInternal(3,t);},t.prototype.MANY_SEP4=function(t){this.manySepFirstInternal(4,t);},t.prototype.MANY_SEP5=function(t){this.manySepFirstInternal(5,t);},t.prototype.MANY_SEP6=function(t){this.manySepFirstInternal(6,t);},t.prototype.MANY_SEP7=function(t){this.manySepFirstInternal(7,t);},t.prototype.MANY_SEP8=function(t){this.manySepFirstInternal(8,t);},t.prototype.MANY_SEP9=function(t){this.manySepFirstInternal(9,t);},t.prototype.AT_LEAST_ONE=function(t){this.atLeastOneInternal(0,t);},t.prototype.AT_LEAST_ONE1=function(t){return this.atLeastOneInternal(1,t)},t.prototype.AT_LEAST_ONE2=function(t){this.atLeastOneInternal(2,t);},t.prototype.AT_LEAST_ONE3=function(t){this.atLeastOneInternal(3,t);},t.prototype.AT_LEAST_ONE4=function(t){this.atLeastOneInternal(4,t);},t.prototype.AT_LEAST_ONE5=function(t){this.atLeastOneInternal(5,t);},t.prototype.AT_LEAST_ONE6=function(t){this.atLeastOneInternal(6,t);},t.prototype.AT_LEAST_ONE7=function(t){this.atLeastOneInternal(7,t);},t.prototype.AT_LEAST_ONE8=function(t){this.atLeastOneInternal(8,t);},t.prototype.AT_LEAST_ONE9=function(t){this.atLeastOneInternal(9,t);},t.prototype.AT_LEAST_ONE_SEP=function(t){this.atLeastOneSepFirstInternal(0,t);},t.prototype.AT_LEAST_ONE_SEP1=function(t){this.atLeastOneSepFirstInternal(1,t);},t.prototype.AT_LEAST_ONE_SEP2=function(t){this.atLeastOneSepFirstInternal(2,t);},t.prototype.AT_LEAST_ONE_SEP3=function(t){this.atLeastOneSepFirstInternal(3,t);},t.prototype.AT_LEAST_ONE_SEP4=function(t){this.atLeastOneSepFirstInternal(4,t);},t.prototype.AT_LEAST_ONE_SEP5=function(t){this.atLeastOneSepFirstInternal(5,t);},t.prototype.AT_LEAST_ONE_SEP6=function(t){this.atLeastOneSepFirstInternal(6,t);},t.prototype.AT_LEAST_ONE_SEP7=function(t){this.atLeastOneSepFirstInternal(7,t);},t.prototype.AT_LEAST_ONE_SEP8=function(t){this.atLeastOneSepFirstInternal(8,t);},t.prototype.AT_LEAST_ONE_SEP9=function(t){this.atLeastOneSepFirstInternal(9,t);},t.prototype.RULE=function(t,e,n){if(void 0===n&&(n=o.DEFAULT_RULE_CONFIG),r.contains(this.definedRulesNames,t)){var i={message:a.defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({topLevelRule:t,grammarName:this.className}),type:o.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,ruleName:t};this.definitionErrors.push(i);}if(this.definedRulesNames.push(t),!this.gastProductionsCache.containsKey(t)&&!this.serializedGrammar){var u=s.buildTopProduction(e.toString(),t,this.tokensMap);this.gastProductionsCache.put(t,u);}var c=this.defineRule(t,e,n);return this[t]=c,c},t.prototype.OVERRIDE_RULE=function(t,e,n){void 0===n&&(n=o.DEFAULT_RULE_CONFIG);var r=[];if(r=r.concat(u.validateRuleIsOverridden(t,this.definedRulesNames,this.className)),this.definitionErrors.push.apply(this.definitionErrors,r),!this.serializedGrammar){var i=s.buildTopProduction(e.toString(),t,this.tokensMap);this.gastProductionsCache.put(t,i);}var a=this.defineRule(t,e,n);return this[t]=a,a},t.prototype.BACKTRACK=function(t,e){return function(){this.isBackTrackingStack.push(1);var n=this.saveRecogState();try{return t.apply(this,e),!0}catch(t){if(i.isRecognitionException(t))return !1;throw t}finally{this.reloadRecogState(n),this.isBackTrackingStack.pop();}}},t.prototype.getGAstProductions=function(){return this.gastProductionsCache},t.prototype.getSerializedGastProductions=function(){return c.serializeGrammar(this.gastProductionsCache.values())},t}();e.RecognizerApi=p;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0),i=n(9),o=n(6),a=n(12),s=n(13),u=n(3),c=n(25),p=n(2),l=n(7),h=n(4),f=function(){function t(){}return t.prototype.initRecognizerEngine=function(t,e){if(this.className=h.classNameFromInstance(this),this.shortRuleNameToFull=new h.HashTable,this.fullRuleNameToShort=new h.HashTable,this.ruleShortNameIdx=256,this.tokenMatcher=l.tokenStructuredMatcherNoCategories,this.definedRulesNames=[],this.tokensMap={},this.allRuleNames=[],this.isBackTrackingStack=[],this.RULE_STACK=[],this.RULE_OCCURRENCE_STACK=[],this.gastProductionsCache=new h.HashTable,this.serializedGrammar=r.has(e,\"serializedGrammar\")?e.serializedGrammar:u.DEFAULT_PARSER_CONFIG.serializedGrammar,r.isArray(t)){if(r.isEmpty(t))throw Error(\"A Token Vocabulary cannot be empty.\\n\\tNote that the first argument for the parser constructor\\n\\tis no longer a Token vector (since v4.0).\");if(\"number\"==typeof t[0].startOffset)throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\\tSee: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\\tFor Further details.\")}if(r.isArray(t))this.tokensMap=r.reduce(t,function(t,e){return t[p.tokenName(e)]=e,t},{});else if(r.has(t,\"modes\")&&r.every(r.flatten(r.values(t.modes)),l.isTokenType)){var n=r.flatten(r.values(t.modes)),i=r.uniq(n);this.tokensMap=r.reduce(i,function(t,e){return t[p.tokenName(e)]=e,t},{});}else {if(!r.isObject(t))throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition\");this.tokensMap=r.cloneObj(t);}this.tokensMap.EOF=p.EOF;var o=r.every(r.values(t),function(t){return r.isEmpty(t.categoryMatches)});this.tokenMatcher=o?l.tokenStructuredMatcherNoCategories:l.tokenStructuredMatcher,l.augmentTokenTypes(r.values(this.tokensMap));},t.prototype.defineRule=function(t,e,n){if(this.selfAnalysisDone)throw Error(\"Grammar rule <\"+t+\"> may not be defined after the 'performSelfAnalysis' method has been called'\\nMake sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.\");var a,s=r.has(n,\"resyncEnabled\")?n.resyncEnabled:u.DEFAULT_RULE_CONFIG.resyncEnabled,c=r.has(n,\"recoveryValueFunc\")?n.recoveryValueFunc:u.DEFAULT_RULE_CONFIG.recoveryValueFunc,p=this.ruleShortNameIdx<<i.BITS_FOR_METHOD_IDX+i.BITS_FOR_OCCURRENCE_IDX;this.ruleShortNameIdx++,this.shortRuleNameToFull.put(p,t),this.fullRuleNameToShort.put(t,p);return (a=function(n,r){return void 0===n&&(n=0),this.ruleInvocationStateUpdate(p,t,n),function(t){try{return !0===this.outputCst?(e.apply(this,t),this.CST_STACK[this.CST_STACK.length-1]):e.apply(this,t)}catch(t){var n=1===this.RULE_STACK.length,r=s&&!this.isBackTracking()&&this.recoveryEnabled;if(o.isRecognitionException(t)){if(r){var i,a=this.findReSyncTokenType();if(this.isInCurrentRuleReSyncSet(a))return t.resyncedTokens=this.reSyncTo(a),this.outputCst?((i=this.CST_STACK[this.CST_STACK.length-1]).recoveredNode=!0,i):c();throw this.outputCst&&((i=this.CST_STACK[this.CST_STACK.length-1]).recoveredNode=!0,t.partialCstResult=i),t}if(n)return this.moveToTerminatedState(),c();throw t}throw t}finally{this.ruleFinallyStateUpdate();}}.call(this,r)}).ruleName=t,a},t.prototype.optionInternal=function(t,e){var n=this.getKeyForAutomaticLookahead(i.OPTION_IDX,e),r=this.nestedRuleBeforeClause(t,n);try{return this.optionInternalLogic(t,e,n)}finally{void 0!==r&&this.nestedRuleFinallyClause(n,r);}},t.prototype.optionInternalNoCst=function(t,e){var n=this.getKeyForAutomaticLookahead(i.OPTION_IDX,e);return this.optionInternalLogic(t,e,n)},t.prototype.optionInternalLogic=function(t,e,n){var r,i,o=this,a=this.getLookaheadFuncForOption(n,e);if(void 0!==t.DEF){if(r=t.DEF,void 0!==(i=t.GATE)){var s=a;a=function(){return i.call(o)&&s.call(o)};}}else r=t;if(!0===a.call(this))return r.call(this)},t.prototype.atLeastOneInternal=function(t,e){var n=this.getKeyForAutomaticLookahead(i.AT_LEAST_ONE_IDX,t),r=this.nestedRuleBeforeClause(e,n);try{return this.atLeastOneInternalLogic(t,e,n)}finally{void 0!==r&&this.nestedRuleFinallyClause(n,r);}},t.prototype.atLeastOneInternalNoCst=function(t,e){var n=this.getKeyForAutomaticLookahead(i.AT_LEAST_ONE_IDX,t);this.atLeastOneInternalLogic(t,e,n);},t.prototype.atLeastOneInternalLogic=function(t,e,n){var r,o,u=this,c=this.getLookaheadFuncForAtLeastOne(n,t);if(void 0!==e.DEF){if(r=e.DEF,void 0!==(o=e.GATE)){var p=c;c=function(){return o.call(u)&&p.call(u)};}}else r=e;if(!0!==c.call(this))throw this.raiseEarlyExitException(t,a.PROD_TYPE.REPETITION_MANDATORY,e.ERR_MSG);for(var l=this.doSingleRepetition(r);!0===c.call(this)&&!0===l;)l=this.doSingleRepetition(r);this.attemptInRepetitionRecovery(this.atLeastOneInternal,[t,e],c,i.AT_LEAST_ONE_IDX,t,s.NextTerminalAfterAtLeastOneWalker);},t.prototype.atLeastOneSepFirstInternal=function(t,e){var n=this.getKeyForAutomaticLookahead(i.AT_LEAST_ONE_SEP_IDX,t),r=this.nestedRuleBeforeClause(e,n);try{this.atLeastOneSepFirstInternalLogic(t,e,n);}finally{void 0!==r&&this.nestedRuleFinallyClause(n,r);}},t.prototype.atLeastOneSepFirstInternalNoCst=function(t,e){var n=this.getKeyForAutomaticLookahead(i.AT_LEAST_ONE_SEP_IDX,t);this.atLeastOneSepFirstInternalLogic(t,e,n);},t.prototype.atLeastOneSepFirstInternalLogic=function(t,e,n){var r=this,o=e.DEF,u=e.SEP;if(!0!==this.getLookaheadFuncForAtLeastOneSep(n,t).call(this))throw this.raiseEarlyExitException(t,a.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,e.ERR_MSG);o.call(this);for(var c=function(){return r.tokenMatcher(r.LA(1),u)};!0===this.tokenMatcher(this.LA(1),u);)this.CONSUME(u),o.call(this);this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal,[t,u,c,o,s.NextTerminalAfterAtLeastOneSepWalker],c,i.AT_LEAST_ONE_SEP_IDX,t,s.NextTerminalAfterAtLeastOneSepWalker);},t.prototype.manyInternal=function(t,e){var n=this.getKeyForAutomaticLookahead(i.MANY_IDX,t),r=this.nestedRuleBeforeClause(e,n);try{return this.manyInternalLogic(t,e,n)}finally{void 0!==r&&this.nestedRuleFinallyClause(n,r);}},t.prototype.manyInternalNoCst=function(t,e){var n=this.getKeyForAutomaticLookahead(i.MANY_IDX,t);return this.manyInternalLogic(t,e,n)},t.prototype.manyInternalLogic=function(t,e,n){var r,o,a=this,u=this.getLookaheadFuncForMany(n,t);if(void 0!==e.DEF){if(r=e.DEF,void 0!==(o=e.GATE)){var c=u;u=function(){return o.call(a)&&c.call(a)};}}else r=e;for(var p=!0;!0===u.call(this)&&!0===p;)p=this.doSingleRepetition(r);this.attemptInRepetitionRecovery(this.manyInternal,[t,e],u,i.MANY_IDX,t,s.NextTerminalAfterManyWalker);},t.prototype.manySepFirstInternal=function(t,e){var n=this.getKeyForAutomaticLookahead(i.MANY_SEP_IDX,t),r=this.nestedRuleBeforeClause(e,n);try{this.manySepFirstInternalLogic(t,e,n);}finally{void 0!==r&&this.nestedRuleFinallyClause(n,r);}},t.prototype.manySepFirstInternalNoCst=function(t,e){var n=this.getKeyForAutomaticLookahead(i.MANY_SEP_IDX,t);this.manySepFirstInternalLogic(t,e,n);},t.prototype.manySepFirstInternalLogic=function(t,e,n){var r=this,o=e.DEF,a=e.SEP;if(!0===this.getLookaheadFuncForManySep(n,t).call(this)){o.call(this);for(var u=function(){return r.tokenMatcher(r.LA(1),a)};!0===this.tokenMatcher(this.LA(1),a);)this.CONSUME(a),o.call(this);this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal,[t,a,u,o,s.NextTerminalAfterManySepWalker],u,i.MANY_SEP_IDX,t,s.NextTerminalAfterManySepWalker);}},t.prototype.repetitionSepSecondInternal=function(t,e,n,r,o){for(;n();)this.CONSUME(e),r.call(this);this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal,[t,e,n,r,o],n,i.AT_LEAST_ONE_SEP_IDX,t,o);},t.prototype.doSingleRepetition=function(t){var e=this.getLexerPosition();return t.call(this),this.getLexerPosition()>e},t.prototype.orInternalNoCst=function(t,e){var n=r.isArray(t)?t:t.DEF,i=this.getLookaheadFuncForOr(e,n).call(this,n);if(void 0!==i)return n[i].ALT.call(this);this.raiseNoAltException(e,t.ERR_MSG);},t.prototype.orInternal=function(t,e){var n=this.getKeyForAutomaticLookahead(i.OR_IDX,e),o=this.nestedRuleBeforeClause(t,n);try{var a=r.isArray(t)?t:t.DEF,s=this.getLookaheadFuncForOr(e,a).call(this,a);if(void 0!==s){var u=a[s],c=this.nestedAltBeforeClause(u,e,i.OR_IDX,s);try{return u.ALT.call(this)}finally{void 0!==c&&this.nestedRuleFinallyClause(c.shortName,c.nestedName);}}this.raiseNoAltException(e,t.ERR_MSG);}finally{void 0!==o&&this.nestedRuleFinallyClause(n,o);}},t.prototype.ruleFinallyStateUpdate=function(){if(this.RULE_STACK.pop(),this.RULE_OCCURRENCE_STACK.pop(),this.cstFinallyStateUpdate(),0===this.RULE_STACK.length&&!this.isAtEndOfInput()){var t=this.LA(1),e=this.errorMessageProvider.buildNotAllInputParsedMessage({firstRedundant:t,ruleName:this.getCurrRuleFullName()});this.SAVE_ERROR(new o.NotAllInputParsedException(e,t));}},t.prototype.subruleInternal=function(t,e,n){var r;try{var i=void 0!==n?n.ARGS:void 0;return r=t.call(this,e,i),this.cstPostNonTerminal(r,void 0!==n&&void 0!==n.LABEL?n.LABEL:t.ruleName),r}catch(e){throw o.isRecognitionException(e)&&void 0!==e.partialCstResult&&(this.cstPostNonTerminal(e.partialCstResult,void 0!==n&&void 0!==n.LABEL?n.LABEL:t.ruleName),delete e.partialCstResult),e}},t.prototype.consumeInternal=function(t,e,n){var r;try{var i=this.LA(1);if(!0!==this.tokenMatcher(i,t)){var a=void 0,s=this.LA(0);throw a=void 0!==n&&n.ERR_MSG?n.ERR_MSG:this.errorMessageProvider.buildMismatchTokenMessage({expected:t,actual:i,previous:s,ruleName:this.getCurrRuleFullName()}),this.SAVE_ERROR(new o.MismatchedTokenException(a,i,s))}this.consumeToken(),r=i;}catch(n){if(!this.recoveryEnabled||\"MismatchedTokenException\"!==n.name||this.isBackTracking())throw n;var u=this.getFollowsForInRuleRecovery(t,e);try{r=this.tryInRuleRecovery(t,u);}catch(t){throw t.name===c.IN_RULE_RECOVERY_EXCEPTION?n:t}}return this.cstPostTerminal(void 0!==n&&void 0!==n.LABEL?n.LABEL:t.tokenName,r),r},t.prototype.saveRecogState=function(){var t=this.errors,e=r.cloneArr(this.RULE_STACK);return {errors:t,lexerState:this.exportLexerState(),RULE_STACK:e,CST_STACK:this.CST_STACK,LAST_EXPLICIT_RULE_STACK:this.LAST_EXPLICIT_RULE_STACK}},t.prototype.reloadRecogState=function(t){this.errors=t.errors,this.importLexerState(t.lexerState),this.RULE_STACK=t.RULE_STACK;},t.prototype.ruleInvocationStateUpdate=function(t,e,n){this.RULE_OCCURRENCE_STACK.push(n),this.RULE_STACK.push(t),this.cstInvocationStateUpdate(e,t);},t.prototype.isBackTracking=function(){return !r.isEmpty(this.isBackTrackingStack)},t.prototype.getCurrRuleFullName=function(){var t=this.getLastExplicitRuleShortName();return this.shortRuleNameToFull.get(t)},t.prototype.shortRuleNameToFullName=function(t){return this.shortRuleNameToFull.get(t)},t.prototype.isAtEndOfInput=function(){return this.tokenMatcher(this.LA(1),p.EOF)},t.prototype.reset=function(){this.resetLexerState(),this.isBackTrackingStack=[],this.errors=[],this.RULE_STACK=[],this.LAST_EXPLICIT_RULE_STACK=[],this.CST_STACK=[],this.RULE_OCCURRENCE_STACK=[];},t}();e.RecognizerEngine=f;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(6),i=n(0),o=n(12),a=n(3),s=function(){function t(){}return t.prototype.initErrorHandler=function(t){this._errors=[],this.errorMessageProvider=i.defaults(t.errorMessageProvider,a.DEFAULT_PARSER_CONFIG.errorMessageProvider);},t.prototype.SAVE_ERROR=function(t){if(r.isRecognitionException(t))return t.context={ruleStack:this.getHumanReadableRuleStack(),ruleOccurrenceStack:i.cloneArr(this.RULE_OCCURRENCE_STACK)},this._errors.push(t),t;throw Error(\"Trying to save an Error which is not a RecognitionException\")},Object.defineProperty(t.prototype,\"errors\",{get:function(){return i.cloneArr(this._errors)},set:function(t){this._errors=t;},enumerable:!0,configurable:!0}),t.prototype.raiseEarlyExitException=function(t,e,n){for(var i=this.getCurrRuleFullName(),a=this.getGAstProductions().get(i),s=o.getLookaheadPathsForOptionalProd(t,a,e,this.maxLookahead)[0],u=[],c=1;c<this.maxLookahead;c++)u.push(this.LA(c));var p=this.errorMessageProvider.buildEarlyExitMessage({expectedIterationPaths:s,actual:u,previous:this.LA(0),customUserDescription:n,ruleName:i});throw this.SAVE_ERROR(new r.EarlyExitException(p,this.LA(1),this.LA(0)))},t.prototype.raiseNoAltException=function(t,e){for(var n=this.getCurrRuleFullName(),i=this.getGAstProductions().get(n),a=o.getLookaheadPathsForOr(t,i,this.maxLookahead),s=[],u=1;u<=this.maxLookahead;u++)s.push(this.LA(u));var c=this.LA(0),p=this.errorMessageProvider.buildNoViableAltMessage({expectedPathsPerAlt:a,actual:s,previous:c,customUserDescription:e,ruleName:this.getCurrRuleFullName()});throw this.SAVE_ERROR(new r.NoViableAltException(p,this.LA(1),c))},t}();e.ErrorHandler=s;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(13),i=n(0),o=function(){function t(){}return t.prototype.initContentAssist=function(){},t.prototype.computeContentAssist=function(t,e){var n=this.gastProductionsCache.get(t);if(i.isUndefined(n))throw Error(\"Rule ->\"+t+\"<- does not exist in this grammar.\");return r.nextPossibleTokensAfter([n],e,this.tokenMatcher,this.maxLookahead)},t.prototype.getNextPossibleTokenTypes=function(t){var e=i.first(t.ruleStack),n=this.getGAstProductions().get(e);return new r.NextAfterTokenWalker(n,t).startWalking()},t}();e.ContentAssist=o;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(17);e.createSyntaxDiagramsCode=function(t,e){var n=void 0===e?{}:e,i=n.resourceBase,o=void 0===i?\"https://unpkg.com/chevrotain@\"+r.VERSION+\"/diagrams/\":i,a=n.css;return \"\\n\\x3c!-- This is a generated file --\\x3e\\n<!DOCTYPE html>\\n<meta charset=\\\"utf-8\\\">\\n<style>\\n  body {\\n    background-color: hsl(30, 20%, 95%)\\n  }\\n</style>\\n\\n\\n<link rel='stylesheet' href='\"+(void 0===a?\"https://unpkg.com/chevrotain@\"+r.VERSION+\"/diagrams/diagrams.css\":a)+\"'>\\n\\n<script src='\"+o+\"vendor/railroad-diagrams.js'><\\/script>\\n<script src='\"+o+\"src/diagrams_builder.js'><\\/script>\\n<script src='\"+o+\"src/diagrams_behavior.js'><\\/script>\\n<script src='\"+o+'src/main.js\\'><\\/script>\\n\\n<div id=\"diagrams\" align=\"center\"></div>    \\n\\n<script>\\n    window.serializedGrammar = '+JSON.stringify(t,null,\"  \")+';\\n<\\/script>\\n\\n<script>\\n    var diagramsDiv = document.getElementById(\"diagrams\");\\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\\n<\\/script>\\n'};},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(41);e.generateParserFactory=function(t){var e=r.genWrapperFunction({name:t.name,rules:t.rules}),i=new Function(\"tokenVocabulary\",\"config\",\"chevrotain\",e);return function(e){return i(t.tokenVocabulary,e,n(18))}},e.generateParserModule=function(t){return r.genUmdModule({name:t.name,rules:t.rules})};},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0),i=n(2),o=n(1),a=\"\\n\";function s(t){return \"\\nfunction \"+t.name+\"(tokenVocabulary, config) {\\n    // invoke super constructor\\n    // No support for embedded actions currently, so we can 'hardcode'\\n    // The use of CstParser.\\n    chevrotain.CstParser.call(this, tokenVocabulary, config)\\n\\n    const $ = this\\n\\n    \"+u(t.rules)+\"\\n\\n    // very important to call this after all the rules have been defined.\\n    // otherwise the parser may not work correctly as it will lack information\\n    // derived during the self analysis phase.\\n    this.performSelfAnalysis(this)\\n}\\n\\n// inheritance as implemented in javascript in the previous decade... :(\\n\"+t.name+\".prototype = Object.create(chevrotain.CstParser.prototype)\\n\"+t.name+\".prototype.constructor = \"+t.name+\"    \\n    \"}function u(t){return r.map(t,function(t){return c(t,1)}).join(\"\\n\")}function c(t,e){var n=y(e,'$.RULE(\"'+t.name+'\", function() {')+a;return n+=m(t.definition,e+1),n+=y(e+1,\"})\")+a}function p(t,e){var n=i.tokenName(t.terminalType);return y(e,\"$.CONSUME\"+t.idx+\"(this.tokensMap.\"+n+\")\"+a)}function l(t,e){return y(e,\"$.SUBRULE\"+t.idx+\"($.\"+t.nonTerminalName+\")\"+a)}function h(t,e){var n=y(e,\"$.OR\"+t.idx+\"([\")+a;return n+=r.map(t.definition,function(t){return f(t,e+1)}).join(\",\"+a),n+=a+y(e,\"])\"+a)}function f(t,e){var n=y(e,\"{\")+a;return t.name&&(n+=y(e+1,'NAME: \"'+t.name+'\",')+a),n+=y(e+1,\"ALT: function() {\")+a,n+=m(t.definition,e+1),n+=y(e+1,\"}\")+a,n+=y(e,\"}\")}function d(t,e,n){var r=y(n,\"$.\"+(t+e.idx)+\"(\");return e.name||e.separator?(r+=\"{\"+a,e.name&&(r+=y(n+1,'NAME: \"'+e.name+'\"')+\",\"+a),e.separator&&(r+=y(n+1,\"SEP: this.tokensMap.\"+i.tokenName(e.separator))+\",\"+a),r+=\"DEF: \"+E(e.definition,n+2)+a,r+=y(n,\"}\")+a):r+=E(e.definition,n+1),r+=y(n,\")\")+a}function E(t,e){var n=\"function() {\"+a;return n+=m(t,e),n+=y(e,\"}\")+a}function m(t,e){var n=\"\";return r.forEach(t,function(t){n+=function(t,e){if(t instanceof o.NonTerminal)return l(t,e);if(t instanceof o.Option)return d(\"OPTION\",t,e);if(t instanceof o.RepetitionMandatory)return d(\"AT_LEAST_ONE\",t,e);if(t instanceof o.RepetitionMandatoryWithSeparator)return d(\"AT_LEAST_ONE_SEP\",t,e);if(t instanceof o.RepetitionWithSeparator)return d(\"MANY_SEP\",t,e);if(t instanceof o.Repetition)return d(\"MANY\",t,e);if(t instanceof o.Alternation)return h(t,e);if(t instanceof o.Terminal)return p(t,e);if(t instanceof o.Flat)return m(t.definition,e);throw Error(\"non exhaustive match\")}(t,e+1);}),n}function y(t,e){return Array(4*t+1).join(\" \")+e}e.genUmdModule=function(t){return \"\\n(function (root, factory) {\\n    if (typeof define === 'function' && define.amd) {\\n        // AMD. Register as an anonymous module.\\n        define(['chevrotain'], factory);\\n    } else if (typeof module === 'object' && module.exports) {\\n        // Node. Does not work with strict CommonJS, but\\n        // only CommonJS-like environments that support module.exports,\\n        // like Node.\\n        module.exports = factory(require('chevrotain'));\\n    } else {\\n        // Browser globals (root is window)\\n        root.returnExports = factory(root.b);\\n    }\\n}(typeof self !== 'undefined' ? self : this, function (chevrotain) {\\n\\n\"+s(t)+\"\\n    \\nreturn {\\n    \"+t.name+\": \"+t.name+\" \\n}\\n}));\\n\"},e.genWrapperFunction=function(t){return \"    \\n\"+s(t)+\"\\nreturn new \"+t.name+\"(tokenVocabulary, config)    \\n\"},e.genClass=s,e.genAllRules=u,e.genRule=c,e.genTerminal=p,e.genNonTerminal=l,e.genAlternation=h,e.genSingleAlt=f;}])});\nvar chevrotain = window.chevrotain;\n\nvar VRMLLoader = ( function () {\n\n\t// dependency check\n\n\tif ( typeof chevrotain === 'undefined' ) { // eslint-disable-line no-undef\n\n\t\tthrow Error( 'THREE.VRMLLoader: External library chevrotain.min.js required.' );\n\n\t}\n\n\t// class definitions\n\n\tfunction VRMLLoader( manager ) {\n\n\t\t_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n\t}\n\n\tVRMLLoader.prototype = Object.assign( Object.create( _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\t\tconstructor: VRMLLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar path = ( scope.path === '' ) ? _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.f.extractUrlBase( url ) : scope.path;\n\n\t\t\tvar loader = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.F( scope.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.setRequestHeader( scope.requestHeader );\n\t\t\tloader.setWithCredentials( scope.withCredentials );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tonLoad( scope.parse( text, path ) );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tif ( onError ) {\n\n\t\t\t\t\t\tonError( e );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( data, path ) {\n\n\t\t\tvar nodeMap = {};\n\n\t\t\tfunction generateVRMLTree( data ) {\n\n\t\t\t\t// create lexer, parser and visitor\n\n\t\t\t\tvar tokenData = createTokens();\n\n\t\t\t\tvar lexer = new VRMLLexer( tokenData.tokens );\n\t\t\t\tvar parser = new VRMLParser( tokenData.tokenVocabulary );\n\t\t\t\tvar visitor = createVisitor( parser.getBaseCstVisitorConstructor() );\n\n\t\t\t\t// lexing\n\n\t\t\t\tvar lexingResult = lexer.lex( data );\n\t\t\t\tparser.input = lexingResult.tokens;\n\n\t\t\t\t// parsing\n\n\t\t\t\tvar cstOutput = parser.vrml();\n\n\t\t\t\tif ( parser.errors.length > 0 ) {\n\n\t\t\t\t\tconsole.error( parser.errors );\n\n\t\t\t\t\tthrow Error( 'THREE.VRMLLoader: Parsing errors detected.' );\n\n\t\t\t\t}\n\n\t\t\t\t// actions\n\n\t\t\t\tvar ast = visitor.visit( cstOutput );\n\n\t\t\t\treturn ast;\n\n\t\t\t}\n\n\t\t\tfunction createTokens() {\n\n\t\t\t\tvar createToken = chevrotain.createToken; // eslint-disable-line no-undef\n\n\t\t\t\t// from http://gun.teipir.gr/VRML-amgem/spec/part1/concepts.html#SyntaxBasics\n\n\t\t\t\tvar RouteIdentifier = createToken( { name: 'RouteIdentifier', pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/ } );\n\t\t\t\tvar Identifier = createToken( { name: 'Identifier', pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/, longer_alt: RouteIdentifier } );\n\n\t\t\t\t// from http://gun.teipir.gr/VRML-amgem/spec/part1/nodesRef.html\n\n\t\t\t\tvar nodeTypes = [\n\t\t\t\t\t'Anchor', 'Billboard', 'Collision', 'Group', 'Transform', // grouping nodes\n\t\t\t\t\t'Inline', 'LOD', 'Switch', // special groups\n\t\t\t\t\t'AudioClip', 'DirectionalLight', 'PointLight', 'Script', 'Shape', 'Sound', 'SpotLight', 'WorldInfo', // common nodes\n\t\t\t\t\t'CylinderSensor', 'PlaneSensor', 'ProximitySensor', 'SphereSensor', 'TimeSensor', 'TouchSensor', 'VisibilitySensor', // sensors\n\t\t\t\t\t'Box', 'Cone', 'Cylinder', 'ElevationGrid', 'Extrusion', 'IndexedFaceSet', 'IndexedLineSet', 'PointSet', 'Sphere', // geometries\n\t\t\t\t\t'Color', 'Coordinate', 'Normal', 'TextureCoordinate', // geometric properties\n\t\t\t\t\t'Appearance', 'FontStyle', 'ImageTexture', 'Material', 'MovieTexture', 'PixelTexture', 'TextureTransform', // appearance\n\t\t\t\t\t'ColorInterpolator', 'CoordinateInterpolator', 'NormalInterpolator', 'OrientationInterpolator', 'PositionInterpolator', 'ScalarInterpolator', // interpolators\n\t\t\t\t\t'Background', 'Fog', 'NavigationInfo', 'Viewpoint', // bindable nodes\n\t\t\t\t\t'Text' // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n\t\t\t\t];\n\n\t\t\t\t//\n\n\t\t\t\tvar Version = createToken( {\n\t\t\t\t\tname: 'Version',\n\t\t\t\t\tpattern: /#VRML.*/,\n\t\t\t\t\tlonger_alt: Identifier\n\t\t\t\t} );\n\n\t\t\t\tvar NodeName = createToken( {\n\t\t\t\t\tname: 'NodeName',\n\t\t\t\t\tpattern: new RegExp( nodeTypes.join( '|' ) ),\n\t\t\t\t\tlonger_alt: Identifier\n\t\t\t\t} );\n\n\t\t\t\tvar DEF = createToken( {\n\t\t\t\t\tname: 'DEF',\n\t\t\t\t\tpattern: /DEF/,\n\t\t\t\t\tlonger_alt: Identifier\n\t\t\t\t} );\n\n\t\t\t\tvar USE = createToken( {\n\t\t\t\t\tname: 'USE',\n\t\t\t\t\tpattern: /USE/,\n\t\t\t\t\tlonger_alt: Identifier\n\t\t\t\t} );\n\n\t\t\t\tvar ROUTE = createToken( {\n\t\t\t\t\tname: 'ROUTE',\n\t\t\t\t\tpattern: /ROUTE/,\n\t\t\t\t\tlonger_alt: Identifier\n\t\t\t\t} );\n\n\t\t\t\tvar TO = createToken( {\n\t\t\t\t\tname: 'TO',\n\t\t\t\t\tpattern: /TO/,\n\t\t\t\t\tlonger_alt: Identifier\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tvar StringLiteral = createToken( { name: 'StringLiteral', pattern: /\"(:?[^\\\\\"\\n\\r]+|\\\\(:?[bfnrtv\"\\\\/]|u[0-9a-fA-F]{4}))*\"/ } );\n\t\t\t\tvar HexLiteral = createToken( { name: 'HexLiteral', pattern: /0[xX][0-9a-fA-F]+/ } );\n\t\t\t\tvar NumberLiteral = createToken( { name: 'NumberLiteral', pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/ } );\n\t\t\t\tvar TrueLiteral = createToken( { name: 'TrueLiteral', pattern: /TRUE/ } );\n\t\t\t\tvar FalseLiteral = createToken( { name: 'FalseLiteral', pattern: /FALSE/ } );\n\t\t\t\tvar NullLiteral = createToken( { name: 'NullLiteral', pattern: /NULL/ } );\n\t\t\t\tvar LSquare = createToken( { name: 'LSquare', pattern: /\\[/ } );\n\t\t\t\tvar RSquare = createToken( { name: 'RSquare', pattern: /]/ } );\n\t\t\t\tvar LCurly = createToken( { name: 'LCurly', pattern: /{/ } );\n\t\t\t\tvar RCurly = createToken( { name: 'RCurly', pattern: /}/ } );\n\t\t\t\tvar Comment = createToken( {\n\t\t\t\t\tname: 'Comment',\n\t\t\t\t\tpattern: /#.*/,\n\t\t\t\t\tgroup: chevrotain.Lexer.SKIPPED // eslint-disable-line no-undef\n\t\t\t\t} );\n\n\t\t\t\t// commas, blanks, tabs, newlines and carriage returns are whitespace characters wherever they appear outside of string fields\n\n\t\t\t\tvar WhiteSpace = createToken( {\n\t\t\t\t\tname: 'WhiteSpace',\n\t\t\t\t\tpattern: /[ ,\\s]/,\n\t\t\t\t\tgroup: chevrotain.Lexer.SKIPPED // eslint-disable-line no-undef\n\t\t\t\t} );\n\n\t\t\t\tvar tokens = [\n\t\t\t\t\tWhiteSpace,\n\t\t\t\t\t// keywords appear before the Identifier\n\t\t\t\t\tNodeName,\n\t\t\t\t\tDEF,\n\t\t\t\t\tUSE,\n\t\t\t\t\tROUTE,\n\t\t\t\t\tTO,\n\t\t\t\t\tTrueLiteral,\n\t\t\t\t\tFalseLiteral,\n\t\t\t\t\tNullLiteral,\n\t\t\t\t\t// the Identifier must appear after the keywords because all keywords are valid identifiers\n\t\t\t\t\tVersion,\n\t\t\t\t\tIdentifier,\n\t\t\t\t\tRouteIdentifier,\n\t\t\t\t\tStringLiteral,\n\t\t\t\t\tHexLiteral,\n\t\t\t\t\tNumberLiteral,\n\t\t\t\t\tLSquare,\n\t\t\t\t\tRSquare,\n\t\t\t\t\tLCurly,\n\t\t\t\t\tRCurly,\n\t\t\t\t\tComment\n\t\t\t\t];\n\n\t\t\t\tvar tokenVocabulary = {};\n\n\t\t\t\tfor ( var i = 0, l = tokens.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar token = tokens[ i ];\n\n\t\t\t\t\ttokenVocabulary[ token.name ] = token;\n\n\t\t\t\t}\n\n\t\t\t\treturn { tokens: tokens, tokenVocabulary: tokenVocabulary };\n\n\t\t\t}\n\n\n\t\t\tfunction createVisitor( BaseVRMLVisitor ) {\n\n\t\t\t\t// the visitor is created dynmaically based on the given base class\n\n\t\t\t\tfunction VRMLToASTVisitor() {\n\n\t\t\t\t\tBaseVRMLVisitor.call( this );\n\n\t\t\t\t\tthis.validateVisitor();\n\n\t\t\t\t}\n\n\t\t\t\tVRMLToASTVisitor.prototype = Object.assign( Object.create( BaseVRMLVisitor.prototype ), {\n\n\t\t\t\t\tconstructor: VRMLToASTVisitor,\n\n\t\t\t\t\tvrml: function ( ctx ) {\n\n\t\t\t\t\t\tvar data = {\n\t\t\t\t\t\t\tversion: this.visit( ctx.version ),\n\t\t\t\t\t\t\tnodes: [],\n\t\t\t\t\t\t\troutes: []\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tfor ( var i = 0, l = ctx.node.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar node = ctx.node[ i ];\n\n\t\t\t\t\t\t\tdata.nodes.push( this.visit( node ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ctx.route ) {\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = ctx.route.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tvar route = ctx.route[ i ];\n\n\t\t\t\t\t\t\t\tdata.routes.push( this.visit( route ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn data;\n\n\t\t\t\t\t},\n\n\t\t\t\t\tversion: function ( ctx ) {\n\n\t\t\t\t\t\treturn ctx.Version[ 0 ].image;\n\n\t\t\t\t\t},\n\n\t\t\t\t\tnode: function ( ctx ) {\n\n\t\t\t\t\t\tvar data = {\n\t\t\t\t\t\t\tname: ctx.NodeName[ 0 ].image,\n\t\t\t\t\t\t\tfields: []\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif ( ctx.field ) {\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = ctx.field.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tvar field = ctx.field[ i ];\n\n\t\t\t\t\t\t\t\tdata.fields.push( this.visit( field ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// DEF\n\n\t\t\t\t\t\tif ( ctx.def ) {\n\n\t\t\t\t\t\t\tdata.DEF = this.visit( ctx.def[ 0 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn data;\n\n\t\t\t\t\t},\n\n\t\t\t\t\tfield: function ( ctx ) {\n\n\t\t\t\t\t\tvar data = {\n\t\t\t\t\t\t\tname: ctx.Identifier[ 0 ].image,\n\t\t\t\t\t\t\ttype: null,\n\t\t\t\t\t\t\tvalues: null\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tvar result;\n\n\t\t\t\t\t\t// SFValue\n\n\t\t\t\t\t\tif ( ctx.singleFieldValue ) {\n\n\t\t\t\t\t\t\tresult = this.visit( ctx.singleFieldValue[ 0 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// MFValue\n\n\t\t\t\t\t\tif ( ctx.multiFieldValue ) {\n\n\t\t\t\t\t\t\tresult = this.visit( ctx.multiFieldValue[ 0 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdata.type = result.type;\n\t\t\t\t\t\tdata.values = result.values;\n\n\t\t\t\t\t\treturn data;\n\n\t\t\t\t\t},\n\n\t\t\t\t\tdef: function ( ctx ) {\n\n\t\t\t\t\t\treturn ( ctx.Identifier || ctx.NodeName )[ 0 ].image;\n\n\t\t\t\t\t},\n\n\t\t\t\t\tuse: function ( ctx ) {\n\n\t\t\t\t\t\treturn { USE: ( ctx.Identifier || ctx.NodeName )[ 0 ].image };\n\n\t\t\t\t\t},\n\n\t\t\t\t\tsingleFieldValue: function ( ctx ) {\n\n\t\t\t\t\t\treturn processField( this, ctx );\n\n\t\t\t\t\t},\n\n\t\t\t\t\tmultiFieldValue: function ( ctx ) {\n\n\t\t\t\t\t\treturn processField( this, ctx );\n\n\t\t\t\t\t},\n\n\t\t\t\t\troute: function ( ctx ) {\n\n\t\t\t\t\t\tvar data = {\n\t\t\t\t\t\t\tFROM: ctx.RouteIdentifier[ 0 ].image,\n\t\t\t\t\t\t\tTO: ctx.RouteIdentifier[ 1 ].image\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\treturn data;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tfunction processField( scope, ctx ) {\n\n\t\t\t\t\tvar field = {\n\t\t\t\t\t\ttype: null,\n\t\t\t\t\t\tvalues: []\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( ctx.node ) {\n\n\t\t\t\t\t\tfield.type = 'node';\n\n\t\t\t\t\t\tfor ( var i = 0, l = ctx.node.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar node = ctx.node[ i ];\n\n\t\t\t\t\t\t\tfield.values.push( scope.visit( node ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ctx.use ) {\n\n\t\t\t\t\t\tfield.type = 'use';\n\n\t\t\t\t\t\tfor ( var i = 0, l = ctx.use.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar use = ctx.use[ i ];\n\n\t\t\t\t\t\t\tfield.values.push( scope.visit( use ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ctx.StringLiteral ) {\n\n\t\t\t\t\t\tfield.type = 'string';\n\n\t\t\t\t\t\tfor ( var i = 0, l = ctx.StringLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar stringLiteral = ctx.StringLiteral[ i ];\n\n\t\t\t\t\t\t\tfield.values.push( stringLiteral.image.replace( /'|\"/g, '' ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ctx.NumberLiteral ) {\n\n\t\t\t\t\t\tfield.type = 'number';\n\n\t\t\t\t\t\tfor ( var i = 0, l = ctx.NumberLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar numberLiteral = ctx.NumberLiteral[ i ];\n\n\t\t\t\t\t\t\tfield.values.push( parseFloat( numberLiteral.image ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ctx.HexLiteral ) {\n\n\t\t\t\t\t\tfield.type = 'hex';\n\n\t\t\t\t\t\tfor ( var i = 0, l = ctx.HexLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar hexLiteral = ctx.HexLiteral[ i ];\n\n\t\t\t\t\t\t\tfield.values.push( hexLiteral.image );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ctx.TrueLiteral ) {\n\n\t\t\t\t\t\tfield.type = 'boolean';\n\n\t\t\t\t\t\tfor ( var i = 0, l = ctx.TrueLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar trueLiteral = ctx.TrueLiteral[ i ];\n\n\t\t\t\t\t\t\tif ( trueLiteral.image === 'TRUE' ) field.values.push( true );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ctx.FalseLiteral ) {\n\n\t\t\t\t\t\tfield.type = 'boolean';\n\n\t\t\t\t\t\tfor ( var i = 0, l = ctx.FalseLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar falseLiteral = ctx.FalseLiteral[ i ];\n\n\t\t\t\t\t\t\tif ( falseLiteral.image === 'FALSE' ) field.values.push( false );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ctx.NullLiteral ) {\n\n\t\t\t\t\t\tfield.type = 'null';\n\n\t\t\t\t\t\tctx.NullLiteral.forEach( function () {\n\n\t\t\t\t\t\t\tfield.values.push( null );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn field;\n\n\t\t\t\t}\n\n\t\t\t\treturn new VRMLToASTVisitor();\n\n\t\t\t}\n\n\t\t\tfunction parseTree( tree ) {\n\n\t\t\t\t// console.log( JSON.stringify( tree, null, 2 ) );\n\n\t\t\t\tvar nodes = tree.nodes;\n\t\t\t\tvar scene = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.ai();\n\n\t\t\t\t// first iteration: build nodemap based on DEF statements\n\n\t\t\t\tfor ( var i = 0, l = nodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar node = nodes[ i ];\n\n\t\t\t\t\tbuildNodeMap( node );\n\n\t\t\t\t}\n\n\t\t\t\t// second iteration: build nodes\n\n\t\t\t\tfor ( var i = 0, l = nodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar node = nodes[ i ];\n\t\t\t\t\tvar object = getNode( node );\n\n\t\t\t\t\tif ( object instanceof _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.U ) scene.add( object );\n\n\t\t\t\t\tif ( node.name === 'WorldInfo' ) scene.userData.worldInfo = object;\n\n\t\t\t\t}\n\n\t\t\t\treturn scene;\n\n\t\t\t}\n\n\t\t\tfunction buildNodeMap( node ) {\n\n\t\t\t\tif ( node.DEF ) {\n\n\t\t\t\t\tnodeMap[ node.DEF ] = node;\n\n\t\t\t\t}\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\n\t\t\t\t\tif ( field.type === 'node' ) {\n\n\t\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\t\tfor ( var j = 0, jl = fieldValues.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tbuildNodeMap( fieldValues[ j ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tfunction getNode( node ) {\n\n\t\t\t\t// handle case where a node refers to a different one\n\n\t\t\t\tif ( node.USE ) {\n\n\t\t\t\t\treturn resolveUSE( node.USE );\n\n\t\t\t\t}\n\n\t\t\t\tif ( node.build !== undefined ) return node.build;\n\n\t\t\t\tnode.build = buildNode( node );\n\n\t\t\t\treturn node.build;\n\n\t\t\t}\n\n\t\t\t// node builder\n\n\t\t\tfunction buildNode( node ) {\n\n\t\t\t\tvar nodeName = node.name;\n\t\t\t\tvar build;\n\n\t\t\t\tswitch ( nodeName ) {\n\n\t\t\t\t\tcase 'Group':\n\t\t\t\t\tcase 'Transform':\n\t\t\t\t\tcase 'Collision':\n\t\t\t\t\t\tbuild = buildGroupingNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Background':\n\t\t\t\t\t\tbuild = buildBackgroundNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Shape':\n\t\t\t\t\t\tbuild = buildShapeNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Appearance':\n\t\t\t\t\t\tbuild = buildAppearanceNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Material':\n\t\t\t\t\t\tbuild = buildMaterialNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ImageTexture':\n\t\t\t\t\t\tbuild = buildImageTextureNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PixelTexture':\n\t\t\t\t\t\tbuild = buildPixelTextureNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TextureTransform':\n\t\t\t\t\t\tbuild = buildTextureTransformNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'IndexedFaceSet':\n\t\t\t\t\t\tbuild = buildIndexedFaceSetNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'IndexedLineSet':\n\t\t\t\t\t\tbuild = buildIndexedLineSetNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PointSet':\n\t\t\t\t\t\tbuild = buildPointSetNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Box':\n\t\t\t\t\t\tbuild = buildBoxNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Cone':\n\t\t\t\t\t\tbuild = buildConeNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Cylinder':\n\t\t\t\t\t\tbuild = buildCylinderNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Sphere':\n\t\t\t\t\t\tbuild = buildSphereNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ElevationGrid':\n\t\t\t\t\t\tbuild = buildElevationGridNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Extrusion':\n\t\t\t\t\t\tbuild = buildExtrusionNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Color':\n\t\t\t\t\tcase 'Coordinate':\n\t\t\t\t\tcase 'Normal':\n\t\t\t\t\tcase 'TextureCoordinate':\n\t\t\t\t\t\tbuild = buildGeometricNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'WorldInfo':\n\t\t\t\t\t\tbuild = buildWorldInfoNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Anchor':\n\t\t\t\t\tcase 'Billboard':\n\n\t\t\t\t\tcase 'Inline':\n\t\t\t\t\tcase 'LOD':\n\t\t\t\t\tcase 'Switch':\n\n\t\t\t\t\tcase 'AudioClip':\n\t\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\tcase 'PointLight':\n\t\t\t\t\tcase 'Script':\n\t\t\t\t\tcase 'Sound':\n\t\t\t\t\tcase 'SpotLight':\n\n\t\t\t\t\tcase 'CylinderSensor':\n\t\t\t\t\tcase 'PlaneSensor':\n\t\t\t\t\tcase 'ProximitySensor':\n\t\t\t\t\tcase 'SphereSensor':\n\t\t\t\t\tcase 'TimeSensor':\n\t\t\t\t\tcase 'TouchSensor':\n\t\t\t\t\tcase 'VisibilitySensor':\n\n\t\t\t\t\tcase 'Text':\n\n\t\t\t\t\tcase 'FontStyle':\n\t\t\t\t\tcase 'MovieTexture':\n\n\t\t\t\t\tcase 'ColorInterpolator':\n\t\t\t\t\tcase 'CoordinateInterpolator':\n\t\t\t\t\tcase 'NormalInterpolator':\n\t\t\t\t\tcase 'OrientationInterpolator':\n\t\t\t\t\tcase 'PositionInterpolator':\n\t\t\t\t\tcase 'ScalarInterpolator':\n\n\t\t\t\t\tcase 'Fog':\n\t\t\t\t\tcase 'NavigationInfo':\n\t\t\t\t\tcase 'Viewpoint':\n\t\t\t\t\t\t// node not supported yet\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown node:', nodeName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( build !== undefined && node.DEF !== undefined && build.hasOwnProperty( 'name' ) === true ) {\n\n\t\t\t\t\tbuild.name = node.DEF;\n\n\t\t\t\t}\n\n\t\t\t\treturn build;\n\n\t\t\t}\n\n\t\t\tfunction buildGroupingNode( node ) {\n\n\t\t\t\tvar object = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\n\t\t\t\t//\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'bboxCenter':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'bboxSize':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'center':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'children':\n\t\t\t\t\t\t\tparseFieldChildren( fieldValues, object );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'collide':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'rotation':\n\t\t\t\t\t\t\tvar axis = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\t\tvar angle = fieldValues[ 3 ];\n\t\t\t\t\t\t\tobject.quaternion.setFromAxisAngle( axis, angle );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\tobject.scale.set( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'scaleOrientation':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'translation':\n\t\t\t\t\t\t\tobject.position.set( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'proxy':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn object;\n\n\t\t\t}\n\n\t\t\tfunction buildBackgroundNode( node ) {\n\n\t\t\t\tvar group = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\n\t\t\t\tvar groundAngle, groundColor;\n\t\t\t\tvar skyAngle, skyColor;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'groundAngle':\n\t\t\t\t\t\t\tgroundAngle = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'groundColor':\n\t\t\t\t\t\t\tgroundColor = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'backUrl':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'bottomUrl':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'frontUrl':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'leftUrl':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'rightUrl':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'topUrl':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'skyAngle':\n\t\t\t\t\t\t\tskyAngle = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'skyColor':\n\t\t\t\t\t\t\tskyColor = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar radius = 10000;\n\n\t\t\t\t// sky\n\n\t\t\t\tif ( skyColor ) {\n\n\t\t\t\t\tvar skyGeometry = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.ao( radius, 32, 16 );\n\t\t\t\t\tvar skyMaterial = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.g( { fog: false, side: _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.ap, depthWrite: false, depthTest: false } );\n\n\t\t\t\t\tif ( skyColor.length > 3 ) {\n\n\t\t\t\t\t\tpaintFaces( skyGeometry, radius, skyAngle, toColorArray( skyColor ), true );\n\t\t\t\t\t\tskyMaterial.vertexColors = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tskyMaterial.color.setRGB( skyColor[ 0 ], skyColor[ 1 ], skyColor[ 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar sky = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.v( skyGeometry, skyMaterial );\n\t\t\t\t\tgroup.add( sky );\n\n\t\t\t\t}\n\n\t\t\t\t// ground\n\n\t\t\t\tif ( groundColor ) {\n\n\t\t\t\t\tif ( groundColor.length > 0 ) {\n\n\t\t\t\t\t\tvar groundGeometry = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.ao( radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI );\n\t\t\t\t\t\tvar groundMaterial = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.g( { fog: false, side: _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.ap, vertexColors: true, depthWrite: false, depthTest: false } );\n\n\t\t\t\t\t\tpaintFaces( groundGeometry, radius, groundAngle, toColorArray( groundColor ), false );\n\n\t\t\t\t\t\tvar ground = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.v( groundGeometry, groundMaterial );\n\t\t\t\t\t\tgroup.add( ground );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// render background group first\n\n\t\t\t\tgroup.renderOrder = - Infinity;\n\n\t\t\t\treturn group;\n\n\t\t\t}\n\n\t\t\tfunction buildShapeNode( node ) {\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\t// if the appearance field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n\t\t\t\tvar material = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.g( { color: 0x000000 } );\n\t\t\t\tvar geometry;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'appearance':\n\t\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\t\tmaterial = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'geometry':\n\t\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\t\tgeometry = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// build 3D object\n\n\t\t\t\tvar object;\n\n\t\t\t\tif ( geometry && geometry.attributes.position ) {\n\n\t\t\t\t\tvar type = geometry._type;\n\n\t\t\t\t\tif ( type === 'points' ) { // points\n\n\t\t\t\t\t\tvar pointsMaterial = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.P( { color: 0xffffff } );\n\n\t\t\t\t\t\tif ( geometry.attributes.color !== undefined ) {\n\n\t\t\t\t\t\t\tpointsMaterial.vertexColors = true;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the color field is NULL and there is a material defined for the appearance affecting this PointSet, then use the emissiveColor of the material to draw the points\n\n\t\t\t\t\t\t\tif ( material.isMeshPhongMaterial ) {\n\n\t\t\t\t\t\t\t\tpointsMaterial.color.copy( material.emissive );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobject = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.z( geometry, pointsMaterial );\n\n\t\t\t\t\t} else if ( type === 'line' ) { // lines\n\n\t\t\t\t\t\tvar lineMaterial = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.q( { color: 0xffffff } );\n\n\t\t\t\t\t\tif ( geometry.attributes.color !== undefined ) {\n\n\t\t\t\t\t\t\tlineMaterial.vertexColors = true;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the color field is NULL and there is a material defined for the appearance affecting this IndexedLineSet, then use the emissiveColor of the material to draw the lines\n\n\t\t\t\t\t\t\tif ( material.isMeshPhongMaterial ) {\n\n\t\t\t\t\t\t\t\tlineMaterial.color.copy( material.emissive );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobject = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.w( geometry, lineMaterial );\n\n\t\t\t\t\t} else { // consider meshes\n\n\t\t\t\t\t\t// check \"solid\" hint (it's placed in the geometry but affects the material)\n\n\t\t\t\t\t\tif ( geometry._solid !== undefined ) {\n\n\t\t\t\t\t\t\tmaterial.side = ( geometry._solid ) ? _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a8 : _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.D;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// check for vertex colors\n\n\t\t\t\t\t\tif ( geometry.attributes.color !== undefined ) {\n\n\t\t\t\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobject = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.v( geometry, material );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tobject = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.U();\n\n\t\t\t\t\t// if the geometry field is NULL or no vertices are defined the object is not drawn\n\n\t\t\t\t\tobject.visible = false;\n\n\t\t\t\t}\n\n\t\t\t\treturn object;\n\n\t\t\t}\n\n\t\t\tfunction buildAppearanceNode( node ) {\n\n\t\t\t\tvar material = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.al();\n\t\t\t\tvar transformData;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'material':\n\t\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\t\tvar materialData = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t\t\tif ( materialData.diffuseColor ) material.color.copy( materialData.diffuseColor );\n\t\t\t\t\t\t\t\tif ( materialData.emissiveColor ) material.emissive.copy( materialData.emissiveColor );\n\t\t\t\t\t\t\t\tif ( materialData.shininess ) material.shininess = materialData.shininess;\n\t\t\t\t\t\t\t\tif ( materialData.specularColor ) material.specular.copy( materialData.specularColor );\n\t\t\t\t\t\t\t\tif ( materialData.transparency ) material.opacity = 1 - materialData.transparency;\n\t\t\t\t\t\t\t\tif ( materialData.transparency > 0 ) material.transparent = true;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// if the material field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n\t\t\t\t\t\t\t\tmaterial = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.g( { color: 0x000000 } );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\t\tvar textureNode = fieldValues[ 0 ];\n\t\t\t\t\t\t\tif ( textureNode !== null ) {\n\n\t\t\t\t\t\t\t\tif ( textureNode.name === 'ImageTexture' || textureNode.name === 'PixelTexture' ) {\n\n\t\t\t\t\t\t\t\t\tmaterial.map = getNode( textureNode );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'textureTransform':\n\t\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\t\ttransformData = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// only apply texture transform data if a texture was defined\n\n\t\t\t\tif ( material.map ) {\n\n\t\t\t\t\t// respect VRML lighting model\n\n\t\t\t\t\tif ( material.map.__type ) {\n\n\t\t\t\t\t\tswitch ( material.map.__type ) {\n\n\t\t\t\t\t\t\tcase TEXTURE_TYPE.INTENSITY_ALPHA:\n\t\t\t\t\t\t\t\tmaterial.opacity = 1; // ignore transparency\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase TEXTURE_TYPE.RGB:\n\t\t\t\t\t\t\t\tmaterial.color.set( 0xffffff ); // ignore material color\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase TEXTURE_TYPE.RGBA:\n\t\t\t\t\t\t\t\tmaterial.color.set( 0xffffff ); // ignore material color\n\t\t\t\t\t\t\t\tmaterial.opacity = 1; // ignore transparency\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdelete material.map.__type;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// apply texture transform\n\n\t\t\t\t\tif ( transformData ) {\n\n\t\t\t\t\t\tmaterial.map.center.copy( transformData.center );\n\t\t\t\t\t\tmaterial.map.rotation = transformData.rotation;\n\t\t\t\t\t\tmaterial.map.repeat.copy( transformData.scale );\n\t\t\t\t\t\tmaterial.map.offset.copy( transformData.translation );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn material;\n\n\t\t\t}\n\n\t\t\tfunction buildMaterialNode( node ) {\n\n\t\t\t\tvar materialData = {};\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'ambientIntensity':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'diffuseColor':\n\t\t\t\t\t\t\tmaterialData.diffuseColor = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.C( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'emissiveColor':\n\t\t\t\t\t\t\tmaterialData.emissiveColor = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.C( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'shininess':\n\t\t\t\t\t\t\tmaterialData.shininess = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'specularColor':\n\t\t\t\t\t\t\tmaterialData.emissiveColor = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.C( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\t\tmaterialData.transparency = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn materialData;\n\n\t\t\t}\n\n\t\t\tfunction parseHexColor( hex, textureType, color ) {\n\n\t\t\t\tswitch ( textureType ) {\n\n\t\t\t\t\tcase TEXTURE_TYPE.INTENSITY:\n\t\t\t\t\t\t// Intensity texture: A one-component image specifies one-byte hexadecimal or integer values representing the intensity of the image\n\t\t\t\t\t\tvar value = parseInt( hex );\n\t\t\t\t\t\tcolor.r = value;\n\t\t\t\t\t\tcolor.g = value;\n\t\t\t\t\t\tcolor.b = value;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TEXTURE_TYPE.INTENSITY_ALPHA:\n\t\t\t\t\t\t// Intensity+Alpha texture: A two-component image specifies the intensity in the first (high) byte and the alpha opacity in the second (low) byte.\n\t\t\t\t\t\tvar value = parseInt( '0x' + hex.substring( 2, 4 ) );\n\t\t\t\t\t\tcolor.r = value;\n\t\t\t\t\t\tcolor.g = value;\n\t\t\t\t\t\tcolor.b = value;\n\t\t\t\t\t\tcolor.a = parseInt( '0x' + hex.substring( 4, 6 ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TEXTURE_TYPE.RGB:\n\t\t\t\t\t\t// RGB texture: Pixels in a three-component image specify the red component in the first (high) byte, followed by the green and blue components\n\t\t\t\t\t\tcolor.r = parseInt( '0x' + hex.substring( 2, 4 ) );\n\t\t\t\t\t\tcolor.g = parseInt( '0x' + hex.substring( 4, 6 ) );\n\t\t\t\t\t\tcolor.b = parseInt( '0x' + hex.substring( 6, 8 ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TEXTURE_TYPE.RGBA:\n\t\t\t\t\t\t// RGBA texture: Four-component images specify the alpha opacity byte after red/green/blue\n\t\t\t\t\t\tcolor.r = parseInt( '0x' + hex.substring( 2, 4 ) );\n\t\t\t\t\t\tcolor.g = parseInt( '0x' + hex.substring( 4, 6 ) );\n\t\t\t\t\t\tcolor.b = parseInt( '0x' + hex.substring( 6, 8 ) );\n\t\t\t\t\t\tcolor.a = parseInt( '0x' + hex.substring( 8, 10 ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction getTextureType( num_components ) {\n\n\t\t\t\tvar type;\n\n\t\t\t\tswitch ( num_components ) {\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\ttype = TEXTURE_TYPE.INTENSITY;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\ttype = TEXTURE_TYPE.INTENSITY_ALPHA;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\ttype = TEXTURE_TYPE.RGB;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\ttype = TEXTURE_TYPE.RGBA;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\treturn type;\n\n\t\t\t}\n\n\t\t\tfunction buildPixelTextureNode( node ) {\n\n\t\t\t\tvar texture;\n\t\t\t\tvar wrapS = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.o;\n\t\t\t\tvar wrapT = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.o;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'image':\n\t\t\t\t\t\t\tvar width = fieldValues[ 0 ];\n\t\t\t\t\t\t\tvar height = fieldValues[ 1 ];\n\t\t\t\t\t\t\tvar num_components = fieldValues[ 2 ];\n\n\t\t\t\t\t\t\tvar useAlpha = ( num_components === 2 || num_components === 4 );\n\t\t\t\t\t\t\tvar textureType = getTextureType( num_components );\n\n\t\t\t\t\t\t\tvar size = ( ( useAlpha === true ) ? 4 : 3 ) * ( width * height );\n\t\t\t\t\t\t\tvar data = new Uint8Array( size );\n\n\t\t\t\t\t\t\tvar color = { r: 0, g: 0, b: 0, a: 0 };\n\n\t\t\t\t\t\t\tfor ( var j = 3, k = 0, jl = fieldValues.length; j < jl; j ++, k ++ ) {\n\n\t\t\t\t\t\t\t\tparseHexColor( fieldValues[ j ], textureType, color );\n\n\t\t\t\t\t\t\t\tif ( useAlpha === true ) {\n\n\t\t\t\t\t\t\t\t\tvar stride = k * 4;\n\n\t\t\t\t\t\t\t\t\tdata[ stride + 0 ] = color.r;\n\t\t\t\t\t\t\t\t\tdata[ stride + 1 ] = color.g;\n\t\t\t\t\t\t\t\t\tdata[ stride + 2 ] = color.b;\n\t\t\t\t\t\t\t\t\tdata[ stride + 3 ] = color.a;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tvar stride = k * 3;\n\n\t\t\t\t\t\t\t\t\tdata[ stride + 0 ] = color.r;\n\t\t\t\t\t\t\t\t\tdata[ stride + 1 ] = color.g;\n\t\t\t\t\t\t\t\t\tdata[ stride + 2 ] = color.b;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttexture = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aq( data, width, height, ( useAlpha === true ) ? _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.ar : _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.R );\n\t\t\t\t\t\t\ttexture.__type = textureType; // needed for material modifications\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'repeatS':\n\t\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapS = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a5;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'repeatT':\n\t\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapT = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a5;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture ) {\n\n\t\t\t\t\ttexture.wrapS = wrapS;\n\t\t\t\t\ttexture.wrapT = wrapT;\n\n\t\t\t\t}\n\n\t\t\t\treturn texture;\n\n\t\t\t}\n\n\t\t\tfunction buildImageTextureNode( node ) {\n\n\t\t\t\tvar texture;\n\t\t\t\tvar wrapS = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.o;\n\t\t\t\tvar wrapT = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.o;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'url':\n\t\t\t\t\t\t\tvar url = fieldValues[ 0 ];\n\t\t\t\t\t\t\tif ( url ) texture = textureLoader.load( url );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'repeatS':\n\t\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapS = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a5;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'repeatT':\n\t\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapT = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a5;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture ) {\n\n\t\t\t\t\ttexture.wrapS = wrapS;\n\t\t\t\t\ttexture.wrapT = wrapT;\n\n\t\t\t\t}\n\n\t\t\t\treturn texture;\n\n\t\t\t}\n\n\t\t\tfunction buildTextureTransformNode( node ) {\n\n\t\t\t\tvar transformData = {\n\t\t\t\t\tcenter: new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a(),\n\t\t\t\t\trotation: new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a(),\n\t\t\t\t\tscale: new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a(),\n\t\t\t\t\ttranslation: new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a()\n\t\t\t\t};\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'center':\n\t\t\t\t\t\t\ttransformData.center.set( fieldValues[ 0 ], fieldValues[ 1 ] );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'rotation':\n\t\t\t\t\t\t\ttransformData.rotation = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\ttransformData.scale.set( fieldValues[ 0 ], fieldValues[ 1 ] );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'translation':\n\t\t\t\t\t\t\ttransformData.translation.set( fieldValues[ 0 ], fieldValues[ 1 ] );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn transformData;\n\n\t\t\t}\n\n\t\t\tfunction buildGeometricNode( node ) {\n\n\t\t\t\treturn node.fields[ 0 ].values;\n\n\t\t\t}\n\n\t\t\tfunction buildWorldInfoNode( node ) {\n\n\t\t\t\tvar worldInfo = {};\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'title':\n\t\t\t\t\t\t\tworldInfo.title = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'info':\n\t\t\t\t\t\t\tworldInfo.info = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn worldInfo;\n\n\t\t\t}\n\n\t\t\tfunction buildIndexedFaceSetNode( node ) {\n\n\t\t\t\tvar color, coord, normal, texCoord;\n\t\t\t\tvar ccw = true, solid = true, creaseAngle = 0;\n\t\t\t\tvar colorIndex, coordIndex, normalIndex, texCoordIndex;\n\t\t\t\tvar colorPerVertex = true, normalPerVertex = true;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'color':\n\t\t\t\t\t\t\tvar colorNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( colorNode !== null ) {\n\n\t\t\t\t\t\t\t\tcolor = getNode( colorNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'coord':\n\t\t\t\t\t\t\tvar coordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( coordNode !== null ) {\n\n\t\t\t\t\t\t\t\tcoord = getNode( coordNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'normal':\n\t\t\t\t\t\t\tvar normalNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( normalNode !== null ) {\n\n\t\t\t\t\t\t\t\tnormal = getNode( normalNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'texCoord':\n\t\t\t\t\t\t\tvar texCoordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( texCoordNode !== null ) {\n\n\t\t\t\t\t\t\t\ttexCoord = getNode( texCoordNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ccw':\n\t\t\t\t\t\t\tccw = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'colorIndex':\n\t\t\t\t\t\t\tcolorIndex = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'colorPerVertex':\n\t\t\t\t\t\t\tcolorPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'convex':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'coordIndex':\n\t\t\t\t\t\t\tcoordIndex = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'creaseAngle':\n\t\t\t\t\t\t\tcreaseAngle = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'normalIndex':\n\t\t\t\t\t\t\tnormalIndex = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'normalPerVertex':\n\t\t\t\t\t\t\tnormalPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'solid':\n\t\t\t\t\t\t\tsolid = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'texCoordIndex':\n\t\t\t\t\t\t\ttexCoordIndex = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( coordIndex === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Missing coordIndex.' );\n\n\t\t\t\t\treturn new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.B(); // handle VRML files with incomplete geometry definition\n\n\t\t\t\t}\n\n\t\t\t\tvar triangulatedCoordIndex = triangulateFaceIndex( coordIndex, ccw );\n\n\t\t\t\tvar positionAttribute;\n\t\t\t\tvar colorAttribute;\n\t\t\t\tvar normalAttribute;\n\t\t\t\tvar uvAttribute;\n\n\t\t\t\tif ( color ) {\n\n\t\t\t\t\tif ( colorPerVertex === true ) {\n\n\t\t\t\t\t\tif ( colorIndex && colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t\t// if the colorIndex field is not empty, then it is used to choose colors for each vertex of the IndexedFaceSet.\n\n\t\t\t\t\t\t\tvar triangulatedColorIndex = triangulateFaceIndex( colorIndex, ccw );\n\t\t\t\t\t\t\tcolorAttribute = computeAttributeFromIndexedData( triangulatedCoordIndex, triangulatedColorIndex, color, 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n\n\t\t\t\t\t\t\tcolorAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( color, 3 ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( colorIndex && colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t\t// if the colorIndex field is not empty, then they are used to choose one color for each face of the IndexedFaceSet\n\n\t\t\t\t\t\t\tvar flattenFaceColors = flattenData( color, colorIndex );\n\t\t\t\t\t\t\tvar triangulatedFaceColors = triangulateFaceData( flattenFaceColors, coordIndex );\n\t\t\t\t\t\t\tcolorAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceColors );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the colorIndex field is empty, then the color are applied to each face of the IndexedFaceSet in order\n\n\t\t\t\t\t\t\tvar triangulatedFaceColors = triangulateFaceData( color, coordIndex );\n\t\t\t\t\t\t\tcolorAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceColors );\n\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( normal ) {\n\n\t\t\t\t\tif ( normalPerVertex === true ) {\n\n\t\t\t\t\t\t// consider vertex normals\n\n\t\t\t\t\t\tif ( normalIndex && normalIndex.length > 0 ) {\n\n\t\t\t\t\t\t\t// if the normalIndex field is not empty, then it is used to choose normals for each vertex of the IndexedFaceSet.\n\n\t\t\t\t\t\t\tvar triangulatedNormalIndex = triangulateFaceIndex( normalIndex, ccw );\n\t\t\t\t\t\t\tnormalAttribute = computeAttributeFromIndexedData( triangulatedCoordIndex, triangulatedNormalIndex, normal, 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the normalIndex field is empty, then the coordIndex field is used to choose normals from the Normal node\n\n\t\t\t\t\t\t\tnormalAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( normal, 3 ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// consider face normals\n\n\t\t\t\t\t\tif ( normalIndex && normalIndex.length > 0 ) {\n\n\t\t\t\t\t\t\t// if the normalIndex field is not empty, then they are used to choose one normal for each face of the IndexedFaceSet\n\n\t\t\t\t\t\t\tvar flattenFaceNormals = flattenData( normal, normalIndex );\n\t\t\t\t\t\t\tvar triangulatedFaceNormals = triangulateFaceData( flattenFaceNormals, coordIndex );\n\t\t\t\t\t\t\tnormalAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceNormals );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the normalIndex field is empty, then the normals are applied to each face of the IndexedFaceSet in order\n\n\t\t\t\t\t\t\tvar triangulatedFaceNormals = triangulateFaceData( normal, coordIndex );\n\t\t\t\t\t\t\tnormalAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceNormals );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// if the normal field is NULL, then the loader should automatically generate normals, using creaseAngle to determine if and how normals are smoothed across shared vertices\n\n\t\t\t\t\tnormalAttribute = computeNormalAttribute( triangulatedCoordIndex, coord, creaseAngle );\n\n\t\t\t\t}\n\n\t\t\t\tif ( texCoord ) {\n\n\t\t\t\t\t// texture coordinates are always defined on vertex level\n\n\t\t\t\t\tif ( texCoordIndex && texCoordIndex.length > 0 ) {\n\n\t\t\t\t\t\t// if the texCoordIndex field is not empty, then it is used to choose texture coordinates for each vertex of the IndexedFaceSet.\n\n\t\t\t\t\t\tvar triangulatedTexCoordIndex = triangulateFaceIndex( texCoordIndex, ccw );\n\t\t\t\t\t\tuvAttribute = computeAttributeFromIndexedData( triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2 );\n\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the texCoordIndex field is empty, then the coordIndex array is used to choose texture coordinates from the TextureCoordinate node\n\n\t\t\t\t\t\tuvAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( texCoord, 2 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\t\t\t\tpositionAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( coord, 3 ) );\n\n\t\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\t\t\t\tgeometry.setAttribute( 'normal', normalAttribute );\n\n\t\t\t\t// optional attributes\n\n\t\t\t\tif ( colorAttribute ) geometry.setAttribute( 'color', colorAttribute );\n\t\t\t\tif ( uvAttribute ) geometry.setAttribute( 'uv', uvAttribute );\n\n\t\t\t\t// \"solid\" influences the material so let's store it for later use\n\n\t\t\t\tgeometry._solid = solid;\n\t\t\t\tgeometry._type = 'mesh';\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction buildIndexedLineSetNode( node ) {\n\n\t\t\t\tvar color, coord;\n\t\t\t\tvar colorIndex, coordIndex;\n\t\t\t\tvar colorPerVertex = true;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'color':\n\t\t\t\t\t\t\tvar colorNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( colorNode !== null ) {\n\n\t\t\t\t\t\t\t\tcolor = getNode( colorNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'coord':\n\t\t\t\t\t\t\tvar coordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( coordNode !== null ) {\n\n\t\t\t\t\t\t\t\tcoord = getNode( coordNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'colorIndex':\n\t\t\t\t\t\t\tcolorIndex = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'colorPerVertex':\n\t\t\t\t\t\t\tcolorPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'coordIndex':\n\t\t\t\t\t\t\tcoordIndex = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// build lines\n\n\t\t\t\tvar colorAttribute;\n\n\t\t\t\tvar expandedLineIndex = expandLineIndex( coordIndex ); // create an index for three.js's linesegment primitive\n\n\t\t\t\tif ( color ) {\n\n\t\t\t\t\tif ( colorPerVertex === true ) {\n\n\t\t\t\t\t\tif ( colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t\t// if the colorIndex field is not empty, then one color is used for each polyline of the IndexedLineSet.\n\n\t\t\t\t\t\t\tvar expandedColorIndex = expandLineIndex( colorIndex ); // compute colors for each line segment (rendering primitve)\n\t\t\t\t\t\t\tcolorAttribute = computeAttributeFromIndexedData( expandedLineIndex, expandedColorIndex, color, 3 ); // compute data on vertex level\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the colorIndex field is empty, then the colors are applied to each polyline of the IndexedLineSet in order.\n\n\t\t\t\t\t\t\tcolorAttribute = toNonIndexedAttribute( expandedLineIndex, new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( color, 3 ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t\t// if the colorIndex field is not empty, then colors are applied to each vertex of the IndexedLineSet\n\n\t\t\t\t\t\t\tvar flattenLineColors = flattenData( color, colorIndex ); // compute colors for each VRML primitve\n\t\t\t\t\t\t\tvar expandedLineColors = expandLineData( flattenLineColors, coordIndex ); // compute colors for each line segment (rendering primitve)\n\t\t\t\t\t\t\tcolorAttribute = computeAttributeFromLineData( expandedLineIndex, expandedLineColors ); // compute data on vertex level\n\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n\n\t\t\t\t\t\t\tvar expandedLineColors = expandLineData( color, coordIndex ); // compute colors for each line segment (rendering primitve)\n\t\t\t\t\t\t\tcolorAttribute = computeAttributeFromLineData( expandedLineIndex, expandedLineColors ); // compute data on vertex level\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tvar geometry = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\t\t\tvar positionAttribute = toNonIndexedAttribute( expandedLineIndex, new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( coord, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\n\t\t\t\tif ( colorAttribute ) geometry.setAttribute( 'color', colorAttribute );\n\n\t\t\t\tgeometry._type = 'line';\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction buildPointSetNode( node ) {\n\n\t\t\t\tvar geometry;\n\t\t\t\tvar color, coord;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'color':\n\t\t\t\t\t\t\tvar colorNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( colorNode !== null ) {\n\n\t\t\t\t\t\t\t\tcolor = getNode( colorNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'coord':\n\t\t\t\t\t\t\tvar coordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( coordNode !== null ) {\n\n\t\t\t\t\t\t\t\tcoord = getNode( coordNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\t\t\tgeometry.setAttribute( 'position', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( coord, 3 ) );\n\t\t\t\tif ( color ) geometry.setAttribute( 'color', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( color, 3 ) );\n\n\t\t\t\tgeometry._type = 'points';\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction buildBoxNode( node ) {\n\n\t\t\t\tvar size = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V( 2, 2, 2 );\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'size':\n\t\t\t\t\t\t\tsize.x = fieldValues[ 0 ];\n\t\t\t\t\t\t\tsize.y = fieldValues[ 1 ];\n\t\t\t\t\t\t\tsize.z = fieldValues[ 2 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.as( size.x, size.y, size.z );\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction buildConeNode( node ) {\n\n\t\t\t\tvar radius = 1, height = 2, openEnded = false;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'bottom':\n\t\t\t\t\t\t\topenEnded = ! fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'bottomRadius':\n\t\t\t\t\t\t\tradius = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'height':\n\t\t\t\t\t\t\theight = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'side':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.at( radius, height, 16, 1, openEnded );\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction buildCylinderNode( node ) {\n\n\t\t\t\tvar radius = 1, height = 2;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'bottom':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'radius':\n\t\t\t\t\t\t\tradius = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'height':\n\t\t\t\t\t\t\theight = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'side':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'top':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.au( radius, radius, height, 16, 1 );\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction buildSphereNode( node ) {\n\n\t\t\t\tvar radius = 1;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'radius':\n\t\t\t\t\t\t\tradius = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.ao( radius, 16, 16 );\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction buildElevationGridNode( node ) {\n\n\t\t\t\tvar color;\n\t\t\t\tvar normal;\n\t\t\t\tvar texCoord;\n\t\t\t\tvar height;\n\n\t\t\t\tvar colorPerVertex = true;\n\t\t\t\tvar normalPerVertex = true;\n\t\t\t\tvar solid = true;\n\t\t\t\tvar ccw = true;\n\t\t\t\tvar creaseAngle = 0;\n\t\t\t\tvar xDimension = 2;\n\t\t\t\tvar zDimension = 2;\n\t\t\t\tvar xSpacing = 1;\n\t\t\t\tvar zSpacing = 1;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'color':\n\t\t\t\t\t\t\tvar colorNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( colorNode !== null ) {\n\n\t\t\t\t\t\t\t\tcolor = getNode( colorNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'normal':\n\t\t\t\t\t\t\tvar normalNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( normalNode !== null ) {\n\n\t\t\t\t\t\t\t\tnormal = getNode( normalNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'texCoord':\n\t\t\t\t\t\t\tvar texCoordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( texCoordNode !== null ) {\n\n\t\t\t\t\t\t\t\ttexCoord = getNode( texCoordNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'height':\n\t\t\t\t\t\t\theight = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ccw':\n\t\t\t\t\t\t\tccw = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'colorPerVertex':\n\t\t\t\t\t\t\tcolorPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'creaseAngle':\n\t\t\t\t\t\t\tcreaseAngle = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'normalPerVertex':\n\t\t\t\t\t\t\tnormalPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'solid':\n\t\t\t\t\t\t\tsolid = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'xDimension':\n\t\t\t\t\t\t\txDimension = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'xSpacing':\n\t\t\t\t\t\t\txSpacing = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'zDimension':\n\t\t\t\t\t\t\tzDimension = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'zSpacing':\n\t\t\t\t\t\t\tzSpacing = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// vertex data\n\n\t\t\t\tvar vertices = [];\n\t\t\t\tvar normals = [];\n\t\t\t\tvar colors = [];\n\t\t\t\tvar uvs = [];\n\n\t\t\t\tfor ( var i = 0; i < zDimension; i ++ ) {\n\n\t\t\t\t\tfor ( var j = 0; j < xDimension; j ++ ) {\n\n\t\t\t\t\t\t// compute a row major index\n\n\t\t\t\t\t\tvar index = ( i * xDimension ) + j;\n\n\t\t\t\t\t\t// vertices\n\n\t\t\t\t\t\tvar x = xSpacing * i;\n\t\t\t\t\t\tvar y = height[ index ];\n\t\t\t\t\t\tvar z = zSpacing * j;\n\n\t\t\t\t\t\tvertices.push( x, y, z );\n\n\t\t\t\t\t\t// colors\n\n\t\t\t\t\t\tif ( color && colorPerVertex === true ) {\n\n\t\t\t\t\t\t\tvar r = color[ index * 3 + 0 ];\n\t\t\t\t\t\t\tvar g = color[ index * 3 + 1 ];\n\t\t\t\t\t\t\tvar b = color[ index * 3 + 2 ];\n\n\t\t\t\t\t\t\tcolors.push( r, g, b );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// normals\n\n\t\t\t\t\t\tif ( normal && normalPerVertex === true ) {\n\n\t\t\t\t\t\t\tvar xn = normal[ index * 3 + 0 ];\n\t\t\t\t\t\t\tvar yn = normal[ index * 3 + 1 ];\n\t\t\t\t\t\t\tvar zn = normal[ index * 3 + 2 ];\n\n\t\t\t\t\t\t\tnormals.push( xn, yn, zn );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// uvs\n\n\t\t\t\t\t\tif ( texCoord ) {\n\n\t\t\t\t\t\t\tvar s = texCoord[ index * 2 + 0 ];\n\t\t\t\t\t\t\tvar t = texCoord[ index * 2 + 1 ];\n\n\t\t\t\t\t\t\tuvs.push( s, t );\n\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tuvs.push( i / ( xDimension - 1 ), j / ( zDimension - 1 ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// indices\n\n\t\t\t\tvar indices = [];\n\n\t\t\t\tfor ( var i = 0; i < xDimension - 1; i ++ ) {\n\n\t\t\t\t\tfor ( var j = 0; j < zDimension - 1; j ++ ) {\n\n\t\t\t\t\t\t// from https://tecfa.unige.ch/guides/vrml/vrml97/spec/part1/nodesRef.html#ElevationGrid\n\n\t\t\t\t\t\tvar a = i + j * xDimension;\n\t\t\t\t\t\tvar b = i + ( j + 1 ) * xDimension;\n\t\t\t\t\t\tvar c = ( i + 1 ) + ( j + 1 ) * xDimension;\n\t\t\t\t\t\tvar d = ( i + 1 ) + j * xDimension;\n\n\t\t\t\t\t\t// faces\n\n\t\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\t\tindices.push( a, c, b );\n\t\t\t\t\t\t\tindices.push( c, a, d );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tindices.push( a, b, c );\n\t\t\t\t\t\t\tindices.push( c, d, a );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tvar positionAttribute = toNonIndexedAttribute( indices, new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( vertices, 3 ) );\n\t\t\t\tvar uvAttribute = toNonIndexedAttribute( indices, new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( uvs, 2 ) );\n\t\t\t\tvar colorAttribute;\n\t\t\t\tvar normalAttribute;\n\n\t\t\t\t// color attribute\n\n\t\t\t\tif ( color ) {\n\n\t\t\t\t\tif ( colorPerVertex === false ) {\n\n\t\t\t\t\t\tfor ( var i = 0; i < xDimension - 1; i ++ ) {\n\n\t\t\t\t\t\t\tfor ( var j = 0; j < zDimension - 1; j ++ ) {\n\n\t\t\t\t\t\t\t\tvar index = i + j * ( xDimension - 1 );\n\n\t\t\t\t\t\t\t\tvar r = color[ index * 3 + 0 ];\n\t\t\t\t\t\t\t\tvar g = color[ index * 3 + 1 ];\n\t\t\t\t\t\t\t\tvar b = color[ index * 3 + 2 ];\n\n\t\t\t\t\t\t\t\t// one color per quad\n\n\t\t\t\t\t\t\t\tcolors.push( r, g, b ); colors.push( r, g, b ); colors.push( r, g, b );\n\t\t\t\t\t\t\t\tcolors.push( r, g, b ); colors.push( r, g, b ); colors.push( r, g, b );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcolorAttribute = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( colors, 3 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcolorAttribute = toNonIndexedAttribute( indices, new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( colors, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// normal attribute\n\n\t\t\t\tif ( normal ) {\n\n\t\t\t\t\tif ( normalPerVertex === false ) {\n\n\t\t\t\t\t\tfor ( var i = 0; i < xDimension - 1; i ++ ) {\n\n\t\t\t\t\t\t\tfor ( var j = 0; j < zDimension - 1; j ++ ) {\n\n\t\t\t\t\t\t\t\tvar index = i + j * ( xDimension - 1 );\n\n\t\t\t\t\t\t\t\tvar xn = normal[ index * 3 + 0 ];\n\t\t\t\t\t\t\t\tvar yn = normal[ index * 3 + 1 ];\n\t\t\t\t\t\t\t\tvar zn = normal[ index * 3 + 2 ];\n\n\t\t\t\t\t\t\t\t// one normal per quad\n\n\t\t\t\t\t\t\t\tnormals.push( xn, yn, zn ); normals.push( xn, yn, zn ); normals.push( xn, yn, zn );\n\t\t\t\t\t\t\t\tnormals.push( xn, yn, zn ); normals.push( xn, yn, zn ); normals.push( xn, yn, zn );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnormalAttribute = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( normals, 3 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnormalAttribute = toNonIndexedAttribute( indices, new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( normals, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnormalAttribute = computeNormalAttribute( indices, vertices, creaseAngle );\n\n\t\t\t\t}\n\n\t\t\t\t// build geometry\n\n\t\t\t\tvar geometry = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\t\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\t\t\t\tgeometry.setAttribute( 'normal', normalAttribute );\n\t\t\t\tgeometry.setAttribute( 'uv', uvAttribute );\n\n\t\t\t\tif ( colorAttribute ) geometry.setAttribute( 'color', colorAttribute );\n\n\t\t\t\t// \"solid\" influences the material so let's store it for later use\n\n\t\t\t\tgeometry._solid = solid;\n\t\t\t\tgeometry._type = 'mesh';\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction buildExtrusionNode( node ) {\n\n\t\t\t\tvar crossSection = [ 1, 1, 1, - 1, - 1, - 1, - 1, 1, 1, 1 ];\n\t\t\t\tvar spine = [ 0, 0, 0, 0, 1, 0 ];\n\t\t\t\tvar scale;\n\t\t\t\tvar orientation;\n\n\t\t\t\tvar beginCap = true;\n\t\t\t\tvar ccw = true;\n\t\t\t\tvar creaseAngle = 0;\n\t\t\t\tvar endCap = true;\n\t\t\t\tvar solid = true;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'beginCap':\n\t\t\t\t\t\t\tbeginCap = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ccw':\n\t\t\t\t\t\t\tccw = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'convex':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'creaseAngle':\n\t\t\t\t\t\t\tcreaseAngle = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'crossSection':\n\t\t\t\t\t\t\tcrossSection = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'endCap':\n\t\t\t\t\t\t\tendCap = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'orientation':\n\t\t\t\t\t\t\torientation = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\tscale = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'solid':\n\t\t\t\t\t\t\tsolid = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'spine':\n\t\t\t\t\t\t\tspine = fieldValues; // only extrusion along the Y-axis are supported so far\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar crossSectionClosed = ( crossSection[ 0 ] === crossSection[ crossSection.length - 2 ] && crossSection[ 1 ] === crossSection[ crossSection.length - 1 ] );\n\n\t\t\t\t// vertices\n\n\t\t\t\tvar vertices = [];\n\t\t\t\tvar spineVector = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\t\tvar scaling = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t\t\t\tvar axis = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\t\tvar vertex = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\t\tvar quaternion = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.Q();\n\n\t\t\t\tfor ( var i = 0, j = 0, o = 0, il = spine.length; i < il; i += 3, j += 2, o += 4 ) {\n\n\t\t\t\t\tspineVector.fromArray( spine, i );\n\n\t\t\t\t\tscaling.x = scale ? scale[ j + 0 ] : 1;\n\t\t\t\t\tscaling.y = 1;\n\t\t\t\t\tscaling.z = scale ? scale[ j + 1 ] : 1;\n\n\t\t\t\t\taxis.x = orientation ? orientation[ o + 0 ] : 0;\n\t\t\t\t\taxis.y = orientation ? orientation[ o + 1 ] : 0;\n\t\t\t\t\taxis.z = orientation ? orientation[ o + 2 ] : 1;\n\t\t\t\t\tvar angle = orientation ? orientation[ o + 3 ] : 0;\n\n\t\t\t\t\tfor ( var k = 0, kl = crossSection.length; k < kl; k += 2 ) {\n\n\t\t\t\t\t\tvertex.x = crossSection[ k + 0 ];\n\t\t\t\t\t\tvertex.y = 0;\n\t\t\t\t\t\tvertex.z = crossSection[ k + 1 ];\n\n\t\t\t\t\t\t// scale\n\n\t\t\t\t\t\tvertex.multiply( scaling );\n\n\t\t\t\t\t\t// rotate\n\n\t\t\t\t\t\tquaternion.setFromAxisAngle( axis, angle );\n\t\t\t\t\t\tvertex.applyQuaternion( quaternion );\n\n\t\t\t\t\t\t// translate\n\n\t\t\t\t\t\tvertex.add( spineVector );\n\n\t\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// indices\n\n\t\t\t\tvar indices = [];\n\n\t\t\t\tvar spineCount = spine.length / 3;\n\t\t\t\tvar crossSectionCount = crossSection.length / 2;\n\n\t\t\t\tfor ( var i = 0; i < spineCount - 1; i ++ ) {\n\n\t\t\t\t\tfor ( var j = 0; j < crossSectionCount - 1; j ++ ) {\n\n\t\t\t\t\t\tvar a = j + i * crossSectionCount;\n\t\t\t\t\t\tvar b = ( j + 1 ) + i * crossSectionCount;\n\t\t\t\t\t\tvar c = j + ( i + 1 ) * crossSectionCount;\n\t\t\t\t\t\tvar d = ( j + 1 ) + ( i + 1 ) * crossSectionCount;\n\n\t\t\t\t\t\tif ( ( j === crossSectionCount - 2 ) && ( crossSectionClosed === true ) ) {\n\n\t\t\t\t\t\t\tb = i * crossSectionCount;\n\t\t\t\t\t\t\td = ( i + 1 ) * crossSectionCount;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\t\tindices.push( a, b, c );\n\t\t\t\t\t\t\tindices.push( c, b, d );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tindices.push( a, c, b );\n\t\t\t\t\t\t\tindices.push( c, d, b );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// triangulate cap\n\n\t\t\t\tif ( beginCap === true || endCap === true ) {\n\n\t\t\t\t\tvar contour = [];\n\n\t\t\t\t\tfor ( var i = 0, l = crossSection.length; i < l; i += 2 ) {\n\n\t\t\t\t\t\tcontour.push( new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a( crossSection[ i ], crossSection[ i + 1 ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar faces = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.av.triangulateShape( contour, [] );\n\t\t\t\t\tvar capIndices = [];\n\n\t\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\t\t\tcapIndices.push( face[ 0 ], face[ 1 ], face[ 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// begin cap\n\n\t\t\t\t\tif ( beginCap === true ) {\n\n\t\t\t\t\t\tfor ( var i = 0, l = capIndices.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\t\t\tindices.push( capIndices[ i + 0 ], capIndices[ i + 1 ], capIndices[ i + 2 ] );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tindices.push( capIndices[ i + 0 ], capIndices[ i + 2 ], capIndices[ i + 1 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// end cap\n\n\t\t\t\t\tif ( endCap === true ) {\n\n\t\t\t\t\t\tvar indexOffset = crossSectionCount * ( spineCount - 1 ); // references to the first vertex of the last cross section\n\n\t\t\t\t\t\tfor ( var i = 0, l = capIndices.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\t\t\tindices.push( indexOffset + capIndices[ i + 0 ], indexOffset + capIndices[ i + 2 ], indexOffset + capIndices[ i + 1 ] );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tindices.push( indexOffset + capIndices[ i + 0 ], indexOffset + capIndices[ i + 1 ], indexOffset + capIndices[ i + 2 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar positionAttribute = toNonIndexedAttribute( indices, new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( vertices, 3 ) );\n\t\t\t\tvar normalAttribute = computeNormalAttribute( indices, vertices, creaseAngle );\n\n\t\t\t\tvar geometry = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\t\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\t\t\t\tgeometry.setAttribute( 'normal', normalAttribute );\n\t\t\t\t// no uvs yet\n\n\t\t\t\t// \"solid\" influences the material so let's store it for later use\n\n\t\t\t\tgeometry._solid = solid;\n\t\t\t\tgeometry._type = 'mesh';\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\t// helper functions\n\n\t\t\tfunction resolveUSE( identifier ) {\n\n\t\t\t\tvar node = nodeMap[ identifier ];\n\t\t\t\tvar build = getNode( node );\n\n\t\t\t\t// because the same 3D objects can have different transformations, it's necessary to clone them.\n\t\t\t\t// materials can be influenced by the geometry (e.g. vertex normals). cloning is necessary to avoid\n\t\t\t\t// any side effects\n\n\t\t\t\treturn ( build.isObject3D || build.isMaterial ) ? build.clone() : build;\n\n\t\t\t}\n\n\t\t\tfunction parseFieldChildren( children, owner ) {\n\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar object = getNode( children[ i ] );\n\n\t\t\t\t\tif ( object instanceof _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.U ) owner.add( object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction triangulateFaceIndex( index, ccw ) {\n\n\t\t\t\tvar indices = [];\n\n\t\t\t\t// since face defintions can have more than three vertices, it's necessary to\n\t\t\t\t// perform a simple triangulation\n\n\t\t\t\tvar start = 0;\n\n\t\t\t\tfor ( var i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar i1 = index[ start ];\n\t\t\t\t\tvar i2 = index[ i + ( ccw ? 1 : 2 ) ];\n\t\t\t\t\tvar i3 = index[ i + ( ccw ? 2 : 1 ) ];\n\n\t\t\t\t\tindices.push( i1, i2, i3 );\n\n\t\t\t\t\t// an index of -1 indicates that the current face has ended and the next one begins\n\n\t\t\t\t\tif ( index[ i + 3 ] === - 1 || i + 3 >= l ) {\n\n\t\t\t\t\t\ti += 3;\n\t\t\t\t\t\tstart = i + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn indices;\n\n\t\t\t}\n\n\t\t\tfunction triangulateFaceData( data, index ) {\n\n\t\t\t\tvar triangulatedData = [];\n\n\t\t\t\tvar start = 0;\n\n\t\t\t\tfor ( var i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar stride = start * 3;\n\n\t\t\t\t\tvar x = data[ stride ];\n\t\t\t\t\tvar y = data[ stride + 1 ];\n\t\t\t\t\tvar z = data[ stride + 2 ];\n\n\t\t\t\t\ttriangulatedData.push( x, y, z );\n\n\t\t\t\t\t// an index of -1 indicates that the current face has ended and the next one begins\n\n\t\t\t\t\tif ( index[ i + 3 ] === - 1 || i + 3 >= l ) {\n\n\t\t\t\t\t\ti += 3;\n\t\t\t\t\t\tstart ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn triangulatedData;\n\n\t\t\t}\n\n\t\t\tfunction flattenData( data, index ) {\n\n\t\t\t\tvar flattenData = [];\n\n\t\t\t\tfor ( var i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar i1 = index[ i ];\n\n\t\t\t\t\tvar stride = i1 * 3;\n\n\t\t\t\t\tvar x = data[ stride ];\n\t\t\t\t\tvar y = data[ stride + 1 ];\n\t\t\t\t\tvar z = data[ stride + 2 ];\n\n\t\t\t\t\tflattenData.push( x, y, z );\n\n\t\t\t\t}\n\n\t\t\t\treturn flattenData;\n\n\t\t\t}\n\n\t\t\tfunction expandLineIndex( index ) {\n\n\t\t\t\tvar indices = [];\n\n\t\t\t\tfor ( var i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar i1 = index[ i ];\n\t\t\t\t\tvar i2 = index[ i + 1 ];\n\n\t\t\t\t\tindices.push( i1, i2 );\n\n\t\t\t\t\t// an index of -1 indicates that the current line has ended and the next one begins\n\n\t\t\t\t\tif ( index[ i + 2 ] === - 1 || i + 2 >= l ) {\n\n\t\t\t\t\t\ti += 2;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn indices;\n\n\t\t\t}\n\n\t\t\tfunction expandLineData( data, index ) {\n\n\t\t\t\tvar triangulatedData = [];\n\n\t\t\t\tvar start = 0;\n\n\t\t\t\tfor ( var i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar stride = start * 3;\n\n\t\t\t\t\tvar x = data[ stride ];\n\t\t\t\t\tvar y = data[ stride + 1 ];\n\t\t\t\t\tvar z = data[ stride + 2 ];\n\n\t\t\t\t\ttriangulatedData.push( x, y, z );\n\n\t\t\t\t\t// an index of -1 indicates that the current line has ended and the next one begins\n\n\t\t\t\t\tif ( index[ i + 2 ] === - 1 || i + 2 >= l ) {\n\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t\tstart ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn triangulatedData;\n\n\t\t\t}\n\n\t\t\tvar vA = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\tvar vB = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\tvar vC = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t\t\tvar uvA = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\t\t\tvar uvB = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\t\t\tvar uvC = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\n\t\t\tfunction computeAttributeFromIndexedData( coordIndex, index, data, itemSize ) {\n\n\t\t\t\tvar array = [];\n\n\t\t\t\t// we use the coordIndex.length as delimiter since normalIndex must contain at least as many indices\n\n\t\t\t\tfor ( var i = 0, l = coordIndex.length; i < l; i += 3 ) {\n\n\t\t\t\t\tvar a = index[ i ];\n\t\t\t\t\tvar b = index[ i + 1 ];\n\t\t\t\t\tvar c = index[ i + 2 ];\n\n\t\t\t\t\tif ( itemSize === 2 ) {\n\n\t\t\t\t\t\tuvA.fromArray( data, a * itemSize );\n\t\t\t\t\t\tuvB.fromArray( data, b * itemSize );\n\t\t\t\t\t\tuvC.fromArray( data, c * itemSize );\n\n\t\t\t\t\t\tarray.push( uvA.x, uvA.y );\n\t\t\t\t\t\tarray.push( uvB.x, uvB.y );\n\t\t\t\t\t\tarray.push( uvC.x, uvC.y );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvA.fromArray( data, a * itemSize );\n\t\t\t\t\t\tvB.fromArray( data, b * itemSize );\n\t\t\t\t\t\tvC.fromArray( data, c * itemSize );\n\n\t\t\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\t\t\tarray.push( vB.x, vB.y, vB.z );\n\t\t\t\t\t\tarray.push( vC.x, vC.y, vC.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( array, itemSize );\n\n\t\t\t}\n\n\t\t\tfunction computeAttributeFromFaceData( index, faceData ) {\n\n\t\t\t\tvar array = [];\n\n\t\t\t\tfor ( var i = 0, j = 0, l = index.length; i < l; i += 3, j ++ ) {\n\n\t\t\t\t\tvA.fromArray( faceData, j * 3 );\n\n\t\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\n\t\t\t\t}\n\n\t\t\t\treturn new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( array, 3 );\n\n\t\t\t}\n\n\t\t\tfunction computeAttributeFromLineData( index, lineData ) {\n\n\t\t\t\tvar array = [];\n\n\t\t\t\tfor ( var i = 0, j = 0, l = index.length; i < l; i += 2, j ++ ) {\n\n\t\t\t\t\tvA.fromArray( lineData, j * 3 );\n\n\t\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\n\t\t\t\t}\n\n\t\t\t\treturn new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( array, 3 );\n\n\t\t\t}\n\n\t\t\tfunction toNonIndexedAttribute( indices, attribute ) {\n\n\t\t\t\tvar array = attribute.array;\n\t\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\t\tvar index = 0, index2 = 0;\n\n\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( array2, itemSize );\n\n\t\t\t}\n\n\t\t\tvar ab = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\tvar cb = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t\t\tfunction computeNormalAttribute( index, coord, creaseAngle ) {\n\n\t\t\t\tvar faces = [];\n\t\t\t\tvar vertexNormals = {};\n\n\t\t\t\t// prepare face and raw vertex normals\n\n\t\t\t\tfor ( var i = 0, l = index.length; i < l; i += 3 ) {\n\n\t\t\t\t\tvar a = index[ i ];\n\t\t\t\t\tvar b = index[ i + 1 ];\n\t\t\t\t\tvar c = index[ i + 2 ];\n\n\t\t\t\t\tvar face = new Face( a, b, c );\n\n\t\t\t\t\tvA.fromArray( coord, a * 3 );\n\t\t\t\t\tvB.fromArray( coord, b * 3 );\n\t\t\t\t\tvC.fromArray( coord, c * 3 );\n\n\t\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tcb.normalize();\n\n\t\t\t\t\tface.normal.copy( cb );\n\n\t\t\t\t\tif ( vertexNormals[ a ] === undefined ) vertexNormals[ a ] = [];\n\t\t\t\t\tif ( vertexNormals[ b ] === undefined ) vertexNormals[ b ] = [];\n\t\t\t\t\tif ( vertexNormals[ c ] === undefined ) vertexNormals[ c ] = [];\n\n\t\t\t\t\tvertexNormals[ a ].push( face.normal );\n\t\t\t\t\tvertexNormals[ b ].push( face.normal );\n\t\t\t\t\tvertexNormals[ c ].push( face.normal );\n\n\t\t\t\t\tfaces.push( face );\n\n\t\t\t\t}\n\n\t\t\t\t// compute vertex normals and build final geometry\n\n\t\t\t\tvar normals = [];\n\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\t\tvar nA = weightedNormal( vertexNormals[ face.a ], face.normal, creaseAngle );\n\t\t\t\t\tvar nB = weightedNormal( vertexNormals[ face.b ], face.normal, creaseAngle );\n\t\t\t\t\tvar nC = weightedNormal( vertexNormals[ face.c ], face.normal, creaseAngle );\n\n\t\t\t\t\tvA.fromArray( coord, face.a * 3 );\n\t\t\t\t\tvB.fromArray( coord, face.b * 3 );\n\t\t\t\t\tvC.fromArray( coord, face.c * 3 );\n\n\t\t\t\t\tnormals.push( nA.x, nA.y, nA.z );\n\t\t\t\t\tnormals.push( nB.x, nB.y, nB.z );\n\t\t\t\t\tnormals.push( nC.x, nC.y, nC.z );\n\n\t\t\t\t}\n\n\t\t\t\treturn new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( normals, 3 );\n\n\t\t\t}\n\n\t\t\tfunction weightedNormal( normals, vector, creaseAngle ) {\n\n\t\t\t\tvar normal = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t\t\t\tif ( creaseAngle === 0 ) {\n\n\t\t\t\t\tnormal.copy( vector );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0, l = normals.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( normals[ i ].angleTo( vector ) < creaseAngle ) {\n\n\t\t\t\t\t\t\tnormal.add( normals[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn normal.normalize();\n\n\t\t\t}\n\n\t\t\tfunction toColorArray( colors ) {\n\n\t\t\t\tvar array = [];\n\n\t\t\t\tfor ( var i = 0, l = colors.length; i < l; i += 3 ) {\n\n\t\t\t\t\tarray.push( new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.C( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Vertically paints the faces interpolating between the\n\t\t\t * specified colors at the specified angels. This is used for the Background\n\t\t\t * node, but could be applied to other nodes with multiple faces as well.\n\t\t\t *\n\t\t\t * When used with the Background node, default is directionIsDown is true if\n\t\t\t * interpolating the skyColor down from the Zenith. When interpolationg up from\n\t\t\t * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.\n\t\t\t *\n\t\t\t * The first angle is never specified, it is the Zenith (0 rad). Angles are specified\n\t\t\t * in radians. The geometry is thought a sphere, but could be anything. The color interpolation\n\t\t\t * is linear along the Y axis in any case.\n\t\t\t *\n\t\t\t * You must specify one more color than you have angles at the beginning of the colors array.\n\t\t\t * This is the color of the Zenith (the top of the shape).\n\t\t\t *\n\t\t\t * @param {BufferGeometry} geometry\n\t\t\t * @param {number} radius\n\t\t\t * @param {array} angles\n\t\t\t * @param {array} colors\n\t\t\t * @param {boolean} topDown - Whether to work top down or bottom up.\n\t\t\t */\n\t\t\tfunction paintFaces( geometry, radius, angles, colors, topDown ) {\n\n\t\t\t\t// compute threshold values\n\n\t\t\t\tvar thresholds = [];\n\t\t\t\tvar startAngle = ( topDown === true ) ? 0 : Math.PI;\n\n\t\t\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar angle = ( i === 0 ) ? 0 : angles[ i - 1 ];\n\t\t\t\t\tangle = ( topDown === true ) ? angle : ( startAngle - angle );\n\n\t\t\t\t\tvar point = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\t\t\tpoint.setFromSphericalCoords( radius, angle, 0 );\n\n\t\t\t\t\tthresholds.push( point );\n\n\t\t\t\t}\n\n\t\t\t\t// generate vertex colors\n\n\t\t\t\tvar indices = geometry.index;\n\t\t\t\tvar positionAttribute = geometry.attributes.position;\n\t\t\t\tvar colorAttribute = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.c( new Float32Array( geometry.attributes.position.count * 3 ), 3 );\n\n\t\t\t\tvar position = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\t\tvar color = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.C();\n\n\t\t\t\tfor ( var i = 0; i < indices.count; i ++ ) {\n\n\t\t\t\t\tvar index = indices.getX( i );\n\t\t\t\t\tposition.fromBufferAttribute( positionAttribute, index );\n\n\t\t\t\t\tvar thresholdIndexA, thresholdIndexB;\n\t\t\t\t\tvar t = 1;\n\n\t\t\t\t\tfor ( var j = 1; j < thresholds.length; j ++ ) {\n\n\t\t\t\t\t\tthresholdIndexA = j - 1;\n\t\t\t\t\t\tthresholdIndexB = j;\n\n\t\t\t\t\t\tvar thresholdA = thresholds[ thresholdIndexA ];\n\t\t\t\t\t\tvar thresholdB = thresholds[ thresholdIndexB ];\n\n\t\t\t\t\t\tif ( topDown === true ) {\n\n\t\t\t\t\t\t\t// interpolation for sky color\n\n\t\t\t\t\t\t\tif ( position.y <= thresholdA.y && position.y > thresholdB.y ) {\n\n\t\t\t\t\t\t\t\tt = Math.abs( thresholdA.y - position.y ) / Math.abs( thresholdA.y - thresholdB.y );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// interpolation for ground color\n\n\t\t\t\t\t\t\tif ( position.y >= thresholdA.y && position.y < thresholdB.y ) {\n\n\t\t\t\t\t\t\t\tt = Math.abs( thresholdA.y - position.y ) / Math.abs( thresholdA.y - thresholdB.y );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar colorA = colors[ thresholdIndexA ];\n\t\t\t\t\tvar colorB = colors[ thresholdIndexB ];\n\n\t\t\t\t\tcolor.copy( colorA ).lerp( colorB, t );\n\n\t\t\t\t\tcolorAttribute.setXYZ( index, color.r, color.g, color.b );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'color', colorAttribute );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar textureLoader = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.j( this.manager );\n\t\t\ttextureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\t\t// check version (only 2.0 is supported)\n\n\t\t\tif ( data.indexOf( '#VRML V2.0' ) === - 1 ) {\n\n\t\t\t\tthrow Error( 'THREE.VRMLLexer: Version of VRML asset not supported.' );\n\n\t\t\t}\n\n\t\t\t// create JSON representing the tree structure of the VRML asset\n\n\t\t\tvar tree = generateVRMLTree( data );\n\n\t\t\t// parse the tree structure to a three.js scene\n\n\t\t\tvar scene = parseTree( tree );\n\n\t\t\treturn scene;\n\n\t\t}\n\n\t} );\n\n\tfunction VRMLLexer( tokens ) {\n\n\t\tthis.lexer = new chevrotain.Lexer( tokens ); // eslint-disable-line no-undef\n\n\t}\n\n\tVRMLLexer.prototype = {\n\n\t\tconstructor: VRMLLexer,\n\n\t\tlex: function ( inputText ) {\n\n\t\t\tvar lexingResult = this.lexer.tokenize( inputText );\n\n\t\t\tif ( lexingResult.errors.length > 0 ) {\n\n\t\t\t\tconsole.error( lexingResult.errors );\n\n\t\t\t\tthrow Error( 'THREE.VRMLLexer: Lexing errors detected.' );\n\n\t\t\t}\n\n\t\t\treturn lexingResult;\n\n\t\t}\n\n\t};\n\n\tfunction VRMLParser( tokenVocabulary ) {\n\n\t\tchevrotain.Parser.call( this, tokenVocabulary ); // eslint-disable-line no-undef\n\n\t\tvar $ = this;\n\n\t\tvar Version = tokenVocabulary[ 'Version' ];\n\t\tvar LCurly = tokenVocabulary[ 'LCurly' ];\n\t\tvar RCurly = tokenVocabulary[ 'RCurly' ];\n\t\tvar LSquare = tokenVocabulary[ 'LSquare' ];\n\t\tvar RSquare = tokenVocabulary[ 'RSquare' ];\n\t\tvar Identifier = tokenVocabulary[ 'Identifier' ];\n\t\tvar RouteIdentifier = tokenVocabulary[ 'RouteIdentifier' ];\n\t\tvar StringLiteral = tokenVocabulary[ 'StringLiteral' ];\n\t\tvar HexLiteral = tokenVocabulary[ 'HexLiteral' ];\n\t\tvar NumberLiteral = tokenVocabulary[ 'NumberLiteral' ];\n\t\tvar TrueLiteral = tokenVocabulary[ 'TrueLiteral' ];\n\t\tvar FalseLiteral = tokenVocabulary[ 'FalseLiteral' ];\n\t\tvar NullLiteral = tokenVocabulary[ 'NullLiteral' ];\n\t\tvar DEF = tokenVocabulary[ 'DEF' ];\n\t\tvar USE = tokenVocabulary[ 'USE' ];\n\t\tvar ROUTE = tokenVocabulary[ 'ROUTE' ];\n\t\tvar TO = tokenVocabulary[ 'TO' ];\n\t\tvar NodeName = tokenVocabulary[ 'NodeName' ];\n\n\t\t$.RULE( 'vrml', function () {\n\n\t\t\t$.SUBRULE( $.version );\n\t\t\t$.AT_LEAST_ONE( function () {\n\n\t\t\t\t$.SUBRULE( $.node );\n\n\t\t\t} );\n\t\t\t$.MANY( function () {\n\n\t\t\t\t$.SUBRULE( $.route );\n\n\t\t\t} );\n\n\t\t} );\n\n\t\t$.RULE( 'version', function () {\n\n\t\t\t$.CONSUME( Version );\n\n\t\t} );\n\n\t\t$.RULE( 'node', function () {\n\n\t\t\t$.OPTION( function () {\n\n\t\t\t\t$.SUBRULE( $.def );\n\n\t\t\t} );\n\n\t\t\t$.CONSUME( NodeName );\n\t\t\t$.CONSUME( LCurly );\n\t\t\t$.MANY( function () {\n\n\t\t\t\t$.SUBRULE( $.field );\n\n\t\t\t} );\n\t\t\t$.CONSUME( RCurly );\n\n\t\t} );\n\n\t\t$.RULE( 'field', function () {\n\n\t\t\t$.CONSUME( Identifier );\n\n\t\t\t$.OR2( [\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.SUBRULE( $.singleFieldValue );\n\n\t\t\t\t} },\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.SUBRULE( $.multiFieldValue );\n\n\t\t\t\t} }\n\t\t\t] );\n\n\t\t} );\n\n\t\t$.RULE( 'def', function () {\n\n\t\t\t$.CONSUME( DEF );\n\t\t\t$.OR( [\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.CONSUME( Identifier );\n\n\t\t\t\t} },\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.CONSUME( NodeName );\n\n\t\t\t\t} }\n\t\t\t] );\n\n\t\t} );\n\n\t\t$.RULE( 'use', function () {\n\n\t\t\t$.CONSUME( USE );\n\t\t\t$.OR( [\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.CONSUME( Identifier );\n\n\t\t\t\t} },\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.CONSUME( NodeName );\n\n\t\t\t\t} }\n\t\t\t] );\n\n\t\t} );\n\n\t\t$.RULE( 'singleFieldValue', function () {\n\n\t\t\t$.AT_LEAST_ONE( function () {\n\n\t\t\t\t$.OR( [\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.SUBRULE( $.node );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.SUBRULE( $.use );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( StringLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( HexLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( NumberLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( TrueLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( FalseLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( NullLiteral );\n\n\t\t\t\t\t} }\n\t\t\t\t] );\n\n\n\t\t\t} );\n\n\t\t} );\n\n\t\t$.RULE( 'multiFieldValue', function () {\n\n\t\t\t$.CONSUME( LSquare );\n\t\t\t$.MANY( function () {\n\n\t\t\t\t$.OR( [\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.SUBRULE( $.node );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.SUBRULE( $.use );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( StringLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( HexLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( NumberLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( NullLiteral );\n\n\t\t\t\t\t} }\n\t\t\t\t] );\n\n\t\t\t} );\n\t\t\t$.CONSUME( RSquare );\n\n\t\t} );\n\n\t\t$.RULE( 'route', function () {\n\n\t\t\t$.CONSUME( ROUTE );\n\t\t\t$.CONSUME( RouteIdentifier );\n\t\t\t$.CONSUME( TO );\n\t\t\t$.CONSUME2( RouteIdentifier );\n\n\t\t} );\n\n\t\tthis.performSelfAnalysis();\n\n\t}\n\n\tVRMLParser.prototype = Object.create( chevrotain.Parser.prototype ); // eslint-disable-line no-undef\n\tVRMLParser.prototype.constructor = VRMLParser;\n\n\tfunction Face( a, b, c ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t\tthis.normal = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t}\n\n\tvar TEXTURE_TYPE = {\n\t\tINTENSITY: 1,\n\t\tINTENSITY_ALPHA: 2,\n\t\tRGB: 3,\n\t\tRGBA: 4\n\t};\n\n\treturn VRMLLoader;\n\n} )();\n\nvar PCDLoader = function ( manager ) {\n\n\t_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n\tthis.littleEndian = true;\n\n};\n\n\nPCDLoader.prototype = Object.assign( Object.create( _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\tconstructor: PCDLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.F( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( data ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( data, url ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( data, url ) {\n\n\t\t// from https://gitlab.com/taketwo/three-pcd-loader/blob/master/decompress-lzf.js\n\n\t\tfunction decompressLZF( inData, outLength ) {\n\n\t\t\tvar inLength = inData.length;\n\t\t\tvar outData = new Uint8Array( outLength );\n\t\t\tvar inPtr = 0;\n\t\t\tvar outPtr = 0;\n\t\t\tvar ctrl;\n\t\t\tvar len;\n\t\t\tvar ref;\n\t\t\tdo {\n\n\t\t\t\tctrl = inData[ inPtr ++ ];\n\t\t\t\tif ( ctrl < ( 1 << 5 ) ) {\n\n\t\t\t\t\tctrl ++;\n\t\t\t\t\tif ( outPtr + ctrl > outLength ) throw new Error( 'Output buffer is not large enough' );\n\t\t\t\t\tif ( inPtr + ctrl > inLength ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\tdo {\n\n\t\t\t\t\t\toutData[ outPtr ++ ] = inData[ inPtr ++ ];\n\n\t\t\t\t\t} while ( -- ctrl );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlen = ctrl >> 5;\n\t\t\t\t\tref = outPtr - ( ( ctrl & 0x1f ) << 8 ) - 1;\n\t\t\t\t\tif ( inPtr >= inLength ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\tif ( len === 7 ) {\n\n\t\t\t\t\t\tlen += inData[ inPtr ++ ];\n\t\t\t\t\t\tif ( inPtr >= inLength ) throw new Error( 'Invalid compressed data' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tref -= inData[ inPtr ++ ];\n\t\t\t\t\tif ( outPtr + len + 2 > outLength ) throw new Error( 'Output buffer is not large enough' );\n\t\t\t\t\tif ( ref < 0 ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\tif ( ref >= outPtr ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\tdo {\n\n\t\t\t\t\t\toutData[ outPtr ++ ] = outData[ ref ++ ];\n\n\t\t\t\t\t} while ( -- len + 2 );\n\n\t\t\t\t}\n\n\t\t\t} while ( inPtr < inLength );\n\n\t\t\treturn outData;\n\n\t\t}\n\n\t\tfunction parseHeader( data ) {\n\n\t\t\tvar PCDheader = {};\n\t\t\tvar result1 = data.search( /[\\r\\n]DATA\\s(\\S*)\\s/i );\n\t\t\tvar result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec( data.substr( result1 - 1 ) );\n\n\t\t\tPCDheader.data = result2[ 1 ];\n\t\t\tPCDheader.headerLen = result2[ 0 ].length + result1;\n\t\t\tPCDheader.str = data.substr( 0, PCDheader.headerLen );\n\n\t\t\t// remove comments\n\n\t\t\tPCDheader.str = PCDheader.str.replace( /\\#.*/gi, '' );\n\n\t\t\t// parse\n\n\t\t\tPCDheader.version = /VERSION (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.fields = /FIELDS (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.size = /SIZE (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.type = /TYPE (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.count = /COUNT (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.width = /WIDTH (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.height = /HEIGHT (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.viewpoint = /VIEWPOINT (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.points = /POINTS (.*)/i.exec( PCDheader.str );\n\n\t\t\t// evaluate\n\n\t\t\tif ( PCDheader.version !== null )\n\t\t\t\tPCDheader.version = parseFloat( PCDheader.version[ 1 ] );\n\n\t\t\tif ( PCDheader.fields !== null )\n\t\t\t\tPCDheader.fields = PCDheader.fields[ 1 ].split( ' ' );\n\n\t\t\tif ( PCDheader.type !== null )\n\t\t\t\tPCDheader.type = PCDheader.type[ 1 ].split( ' ' );\n\n\t\t\tif ( PCDheader.width !== null )\n\t\t\t\tPCDheader.width = parseInt( PCDheader.width[ 1 ] );\n\n\t\t\tif ( PCDheader.height !== null )\n\t\t\t\tPCDheader.height = parseInt( PCDheader.height[ 1 ] );\n\n\t\t\tif ( PCDheader.viewpoint !== null )\n\t\t\t\tPCDheader.viewpoint = PCDheader.viewpoint[ 1 ];\n\n\t\t\tif ( PCDheader.points !== null )\n\t\t\t\tPCDheader.points = parseInt( PCDheader.points[ 1 ], 10 );\n\n\t\t\tif ( PCDheader.points === null )\n\t\t\t\tPCDheader.points = PCDheader.width * PCDheader.height;\n\n\t\t\tif ( PCDheader.size !== null ) {\n\n\t\t\t\tPCDheader.size = PCDheader.size[ 1 ].split( ' ' ).map( function ( x ) {\n\n\t\t\t\t\treturn parseInt( x, 10 );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( PCDheader.count !== null ) {\n\n\t\t\t\tPCDheader.count = PCDheader.count[ 1 ].split( ' ' ).map( function ( x ) {\n\n\t\t\t\t\treturn parseInt( x, 10 );\n\n\t\t\t\t} );\n\n\t\t\t} else {\n\n\t\t\t\tPCDheader.count = [];\n\n\t\t\t\tfor ( var i = 0, l = PCDheader.fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tPCDheader.count.push( 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tPCDheader.offset = {};\n\n\t\t\tvar sizeSum = 0;\n\n\t\t\tfor ( var i = 0, l = PCDheader.fields.length; i < l; i ++ ) {\n\n\t\t\t\tif ( PCDheader.data === 'ascii' ) {\n\n\t\t\t\t\tPCDheader.offset[ PCDheader.fields[ i ] ] = i;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tPCDheader.offset[ PCDheader.fields[ i ] ] = sizeSum;\n\t\t\t\t\tsizeSum += PCDheader.size[ i ] * PCDheader.count[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// for binary only\n\n\t\t\tPCDheader.rowSize = sizeSum;\n\n\t\t\treturn PCDheader;\n\n\t\t}\n\n\t\tvar textData = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.f.decodeText( new Uint8Array( data ) );\n\n\t\t// parse header (always ascii format)\n\n\t\tvar PCDheader = parseHeader( textData );\n\n\t\t// parse data\n\n\t\tvar position = [];\n\t\tvar normal = [];\n\t\tvar color = [];\n\n\t\t// ascii\n\n\t\tif ( PCDheader.data === 'ascii' ) {\n\n\t\t\tvar offset = PCDheader.offset;\n\t\t\tvar pcdData = textData.substr( PCDheader.headerLen );\n\t\t\tvar lines = pcdData.split( '\\n' );\n\n\t\t\tfor ( var i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\t\tif ( lines[ i ] === '' ) continue;\n\n\t\t\t\tvar line = lines[ i ].split( ' ' );\n\n\t\t\t\tif ( offset.x !== undefined ) {\n\n\t\t\t\t\tposition.push( parseFloat( line[ offset.x ] ) );\n\t\t\t\t\tposition.push( parseFloat( line[ offset.y ] ) );\n\t\t\t\t\tposition.push( parseFloat( line[ offset.z ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.rgb !== undefined ) {\n\n\t\t\t\t\tvar rgb = parseFloat( line[ offset.rgb ] );\n\t\t\t\t\tvar r = ( rgb >> 16 ) & 0x0000ff;\n\t\t\t\t\tvar g = ( rgb >> 8 ) & 0x0000ff;\n\t\t\t\t\tvar b = ( rgb >> 0 ) & 0x0000ff;\n\t\t\t\t\tcolor.push( r / 255, g / 255, b / 255 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.normal_x !== undefined ) {\n\n\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_x ] ) );\n\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_y ] ) );\n\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_z ] ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// binary-compressed\n\n\t\t// normally data in PCD files are organized as array of structures: XYZRGBXYZRGB\n\t\t// binary compressed PCD files organize their data as structure of arrays: XXYYZZRGBRGB\n\t\t// that requires a totally different parsing approach compared to non-compressed data\n\n\t\tif ( PCDheader.data === 'binary_compressed' ) {\n\n\t\t\tvar sizes = new Uint32Array( data.slice( PCDheader.headerLen, PCDheader.headerLen + 8 ) );\n\t\t\tvar compressedSize = sizes[ 0 ];\n\t\t\tvar decompressedSize = sizes[ 1 ];\n\t\t\tvar decompressed = decompressLZF( new Uint8Array( data, PCDheader.headerLen + 8, compressedSize ), decompressedSize );\n\t\t\tvar dataview = new DataView( decompressed.buffer );\n\n\t\t\tvar offset = PCDheader.offset;\n\n\t\t\tfor ( var i = 0; i < PCDheader.points; i ++ ) {\n\n\t\t\t\tif ( offset.x !== undefined ) {\n\n\t\t\t\t\tposition.push( dataview.getFloat32( ( PCDheader.points * offset.x ) + PCDheader.size[ 0 ] * i, this.littleEndian ) );\n\t\t\t\t\tposition.push( dataview.getFloat32( ( PCDheader.points * offset.y ) + PCDheader.size[ 1 ] * i, this.littleEndian ) );\n\t\t\t\t\tposition.push( dataview.getFloat32( ( PCDheader.points * offset.z ) + PCDheader.size[ 2 ] * i, this.littleEndian ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.rgb !== undefined ) {\n\n\t\t\t\t\tcolor.push( dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ 3 ] * i + 0 ) / 255.0 );\n\t\t\t\t\tcolor.push( dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ 3 ] * i + 1 ) / 255.0 );\n\t\t\t\t\tcolor.push( dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ 3 ] * i + 2 ) / 255.0 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.normal_x !== undefined ) {\n\n\t\t\t\t\tnormal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_x ) + PCDheader.size[ 4 ] * i, this.littleEndian ) );\n\t\t\t\t\tnormal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_y ) + PCDheader.size[ 5 ] * i, this.littleEndian ) );\n\t\t\t\t\tnormal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_z ) + PCDheader.size[ 6 ] * i, this.littleEndian ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// binary\n\n\t\tif ( PCDheader.data === 'binary' ) {\n\n\t\t\tvar dataview = new DataView( data, PCDheader.headerLen );\n\t\t\tvar offset = PCDheader.offset;\n\n\t\t\tfor ( var i = 0, row = 0; i < PCDheader.points; i ++, row += PCDheader.rowSize ) {\n\n\t\t\t\tif ( offset.x !== undefined ) {\n\n\t\t\t\t\tposition.push( dataview.getFloat32( row + offset.x, this.littleEndian ) );\n\t\t\t\t\tposition.push( dataview.getFloat32( row + offset.y, this.littleEndian ) );\n\t\t\t\t\tposition.push( dataview.getFloat32( row + offset.z, this.littleEndian ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.rgb !== undefined ) {\n\n\t\t\t\t\tcolor.push( dataview.getUint8( row + offset.rgb + 2 ) / 255.0 );\n\t\t\t\t\tcolor.push( dataview.getUint8( row + offset.rgb + 1 ) / 255.0 );\n\t\t\t\t\tcolor.push( dataview.getUint8( row + offset.rgb + 0 ) / 255.0 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.normal_x !== undefined ) {\n\n\t\t\t\t\tnormal.push( dataview.getFloat32( row + offset.normal_x, this.littleEndian ) );\n\t\t\t\t\tnormal.push( dataview.getFloat32( row + offset.normal_y, this.littleEndian ) );\n\t\t\t\t\tnormal.push( dataview.getFloat32( row + offset.normal_z, this.littleEndian ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tvar geometry = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\tif ( position.length > 0 ) geometry.setAttribute( 'position', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( position, 3 ) );\n\t\tif ( normal.length > 0 ) geometry.setAttribute( 'normal', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( normal, 3 ) );\n\t\tif ( color.length > 0 ) geometry.setAttribute( 'color', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( color, 3 ) );\n\n\t\tgeometry.computeBoundingSphere();\n\n\t\t// build material\n\n\t\tvar material = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.P( { size: 0.005 } );\n\n\t\tif ( color.length > 0 ) {\n\n\t\t\tmaterial.vertexColors = true;\n\n\t\t} else {\n\n\t\t\tmaterial.color.setHex( Math.random() * 0xffffff );\n\n\t\t}\n\n\t\t// build point cloud\n\n\t\tvar mesh = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.z( geometry, material );\n\t\tvar name = url.split( '' ).reverse().join( '' );\n\t\tname = /([^\\/]*)/.exec( name );\n\t\tname = name[ 1 ].split( '' ).reverse().join( '' );\n\t\tmesh.name = name;\n\n\t\treturn mesh;\n\n\t}\n\n} );\n\n/**\n * Description: A THREE loader for PLY ASCII files (known as the Polygon\n * File Format or the Stanford Triangle Format).\n *\n * Limitations: ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *\tvar loader = new PLYLoader();\n *\tloader.load('./models/ply/ascii/dolphins.ply', function (geometry) {\n *\n *\t\tscene.add( new THREE.Mesh( geometry ) );\n *\n *\t} );\n *\n * If the PLY file uses non standard property names, they can be mapped while\n * loading. For example, the following maps the properties\n * diffuse_(red|green|blue) in the file to standard color names.\n *\n * loader.setPropertyNameMapping( {\n *\tdiffuse_red: 'red',\n *\tdiffuse_green: 'green',\n *\tdiffuse_blue: 'blue'\n * } );\n *\n */\n\n\nvar PLYLoader = function ( manager ) {\n\n\t_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n\tthis.propertyNameMapping = {};\n\n};\n\nPLYLoader.prototype = Object.assign( Object.create( _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\tconstructor: PLYLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.F( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetPropertyNameMapping: function ( mapping ) {\n\n\t\tthis.propertyNameMapping = mapping;\n\n\t},\n\n\tparse: function ( data ) {\n\n\t\tfunction parseHeader( data ) {\n\n\t\t\tvar patternHeader = /ply([\\s\\S]*)end_header\\r?\\n/;\n\t\t\tvar headerText = '';\n\t\t\tvar headerLength = 0;\n\t\t\tvar result = patternHeader.exec( data );\n\n\t\t\tif ( result !== null ) {\n\n\t\t\t\theaderText = result[ 1 ];\n\t\t\t\theaderLength = new Blob( [ result[ 0 ] ] ).size;\n\n\t\t\t}\n\n\t\t\tvar header = {\n\t\t\t\tcomments: [],\n\t\t\t\telements: [],\n\t\t\t\theaderLength: headerLength,\n\t\t\t\tobjInfo: ''\n\t\t\t};\n\n\t\t\tvar lines = headerText.split( '\\n' );\n\t\t\tvar currentElement;\n\t\t\tvar lineType, lineValues;\n\n\t\t\tfunction make_ply_element_property( propertValues, propertyNameMapping ) {\n\n\t\t\t\tvar property = { type: propertValues[ 0 ] };\n\n\t\t\t\tif ( property.type === 'list' ) {\n\n\t\t\t\t\tproperty.name = propertValues[ 3 ];\n\t\t\t\t\tproperty.countType = propertValues[ 1 ];\n\t\t\t\t\tproperty.itemType = propertValues[ 2 ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tproperty.name = propertValues[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( property.name in propertyNameMapping ) {\n\n\t\t\t\t\tproperty.name = propertyNameMapping[ property.name ];\n\n\t\t\t\t}\n\n\t\t\t\treturn property;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\t\tvar line = lines[ i ];\n\t\t\t\tline = line.trim();\n\n\t\t\t\tif ( line === '' ) continue;\n\n\t\t\t\tlineValues = line.split( /\\s+/ );\n\t\t\t\tlineType = lineValues.shift();\n\t\t\t\tline = lineValues.join( ' ' );\n\n\t\t\t\tswitch ( lineType ) {\n\n\t\t\t\t\tcase 'format':\n\n\t\t\t\t\t\theader.format = lineValues[ 0 ];\n\t\t\t\t\t\theader.version = lineValues[ 1 ];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'comment':\n\n\t\t\t\t\t\theader.comments.push( line );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'element':\n\n\t\t\t\t\t\tif ( currentElement !== undefined ) {\n\n\t\t\t\t\t\t\theader.elements.push( currentElement );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentElement = {};\n\t\t\t\t\t\tcurrentElement.name = lineValues[ 0 ];\n\t\t\t\t\t\tcurrentElement.count = parseInt( lineValues[ 1 ] );\n\t\t\t\t\t\tcurrentElement.properties = [];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'property':\n\n\t\t\t\t\t\tcurrentElement.properties.push( make_ply_element_property( lineValues, scope.propertyNameMapping ) );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'obj_info':\n\n\t\t\t\t\t\theader.objInfo = line;\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.log( 'unhandled', lineType, lineValues );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( currentElement !== undefined ) {\n\n\t\t\t\theader.elements.push( currentElement );\n\n\t\t\t}\n\n\t\t\treturn header;\n\n\t\t}\n\n\t\tfunction parseASCIINumber( n, type ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'char': case 'uchar': case 'short': case 'ushort': case 'int': case 'uint':\n\t\t\t\tcase 'int8': case 'uint8': case 'int16': case 'uint16': case 'int32': case 'uint32':\n\n\t\t\t\t\treturn parseInt( n );\n\n\t\t\t\tcase 'float': case 'double': case 'float32': case 'float64':\n\n\t\t\t\t\treturn parseFloat( n );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseASCIIElement( properties, line ) {\n\n\t\t\tvar values = line.split( /\\s+/ );\n\n\t\t\tvar element = {};\n\n\t\t\tfor ( var i = 0; i < properties.length; i ++ ) {\n\n\t\t\t\tif ( properties[ i ].type === 'list' ) {\n\n\t\t\t\t\tvar list = [];\n\t\t\t\t\tvar n = parseASCIINumber( values.shift(), properties[ i ].countType );\n\n\t\t\t\t\tfor ( var j = 0; j < n; j ++ ) {\n\n\t\t\t\t\t\tlist.push( parseASCIINumber( values.shift(), properties[ i ].itemType ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\telement[ properties[ i ].name ] = list;\n\n\t\t\t\t} else {\n\n\t\t\t\t\telement[ properties[ i ].name ] = parseASCIINumber( values.shift(), properties[ i ].type );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn element;\n\n\t\t}\n\n\t\tfunction parseASCII( data, header ) {\n\n\t\t\t// PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n\n\t\t\tvar buffer = {\n\t\t\t\tindices: [],\n\t\t\t\tvertices: [],\n\t\t\t\tnormals: [],\n\t\t\t\tuvs: [],\n\t\t\t\tfaceVertexUvs: [],\n\t\t\t\tcolors: []\n\t\t\t};\n\n\t\t\tvar result;\n\n\t\t\tvar patternBody = /end_header\\s([\\s\\S]*)$/;\n\t\t\tvar body = '';\n\t\t\tif ( ( result = patternBody.exec( data ) ) !== null ) {\n\n\t\t\t\tbody = result[ 1 ];\n\n\t\t\t}\n\n\t\t\tvar lines = body.split( '\\n' );\n\t\t\tvar currentElement = 0;\n\t\t\tvar currentElementCount = 0;\n\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\t\tvar line = lines[ i ];\n\t\t\t\tline = line.trim();\n\t\t\t\tif ( line === '' ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif ( currentElementCount >= header.elements[ currentElement ].count ) {\n\n\t\t\t\t\tcurrentElement ++;\n\t\t\t\t\tcurrentElementCount = 0;\n\n\t\t\t\t}\n\n\t\t\t\tvar element = parseASCIIElement( header.elements[ currentElement ].properties, line );\n\n\t\t\t\thandleElement( buffer, header.elements[ currentElement ].name, element );\n\n\t\t\t\tcurrentElementCount ++;\n\n\t\t\t}\n\n\t\t\treturn postProcess( buffer );\n\n\t\t}\n\n\t\tfunction postProcess( buffer ) {\n\n\t\t\tvar geometry = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\t\t// mandatory buffer data\n\n\t\t\tif ( buffer.indices.length > 0 ) {\n\n\t\t\t\tgeometry.setIndex( buffer.indices );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'position', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( buffer.vertices, 3 ) );\n\n\t\t\t// optional buffer data\n\n\t\t\tif ( buffer.normals.length > 0 ) {\n\n\t\t\t\tgeometry.setAttribute( 'normal', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( buffer.normals, 3 ) );\n\n\t\t\t}\n\n\t\t\tif ( buffer.uvs.length > 0 ) {\n\n\t\t\t\tgeometry.setAttribute( 'uv', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( buffer.uvs, 2 ) );\n\n\t\t\t}\n\n\t\t\tif ( buffer.colors.length > 0 ) {\n\n\t\t\t\tgeometry.setAttribute( 'color', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( buffer.colors, 3 ) );\n\n\t\t\t}\n\n\t\t\tif ( buffer.faceVertexUvs.length > 0 ) {\n\n\t\t\t\tgeometry = geometry.toNonIndexed();\n\t\t\t\tgeometry.setAttribute( 'uv', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( buffer.faceVertexUvs, 2 ) );\n\n\t\t\t}\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction handleElement( buffer, elementName, element ) {\n\n\t\t\tif ( elementName === 'vertex' ) {\n\n\t\t\t\tbuffer.vertices.push( element.x, element.y, element.z );\n\n\t\t\t\tif ( 'nx' in element && 'ny' in element && 'nz' in element ) {\n\n\t\t\t\t\tbuffer.normals.push( element.nx, element.ny, element.nz );\n\n\t\t\t\t}\n\n\t\t\t\tif ( 's' in element && 't' in element ) {\n\n\t\t\t\t\tbuffer.uvs.push( element.s, element.t );\n\n\t\t\t\t}\n\n\t\t\t\tif ( 'red' in element && 'green' in element && 'blue' in element ) {\n\n\t\t\t\t\tbuffer.colors.push( element.red / 255.0, element.green / 255.0, element.blue / 255.0 );\n\n\t\t\t\t}\n\n\t\t\t} else if ( elementName === 'face' ) {\n\n\t\t\t\tvar vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338\n\t\t\t\tvar texcoord = element.texcoord;\n\n\t\t\t\tif ( vertex_indices.length === 3 ) {\n\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 2 ] );\n\n\t\t\t\t\tif ( texcoord && texcoord.length === 6 ) {\n\n\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 0 ], texcoord[ 1 ] );\n\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 2 ], texcoord[ 3 ] );\n\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 4 ], texcoord[ 5 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( vertex_indices.length === 4 ) {\n\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 3 ] );\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 1 ], vertex_indices[ 2 ], vertex_indices[ 3 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction binaryRead( dataview, at, type, little_endian ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\t// corespondences for non-specific length types here match rply:\n\t\t\t\tcase 'int8':\t\tcase 'char':\t return [ dataview.getInt8( at ), 1 ];\n\t\t\t\tcase 'uint8':\t\tcase 'uchar':\t return [ dataview.getUint8( at ), 1 ];\n\t\t\t\tcase 'int16':\t\tcase 'short':\t return [ dataview.getInt16( at, little_endian ), 2 ];\n\t\t\t\tcase 'uint16':\tcase 'ushort': return [ dataview.getUint16( at, little_endian ), 2 ];\n\t\t\t\tcase 'int32':\t\tcase 'int':\t\t return [ dataview.getInt32( at, little_endian ), 4 ];\n\t\t\t\tcase 'uint32':\tcase 'uint':\t return [ dataview.getUint32( at, little_endian ), 4 ];\n\t\t\t\tcase 'float32': case 'float':\t return [ dataview.getFloat32( at, little_endian ), 4 ];\n\t\t\t\tcase 'float64': case 'double': return [ dataview.getFloat64( at, little_endian ), 8 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction binaryReadElement( dataview, at, properties, little_endian ) {\n\n\t\t\tvar element = {};\n\t\t\tvar result, read = 0;\n\n\t\t\tfor ( var i = 0; i < properties.length; i ++ ) {\n\n\t\t\t\tif ( properties[ i ].type === 'list' ) {\n\n\t\t\t\t\tvar list = [];\n\n\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].countType, little_endian );\n\t\t\t\t\tvar n = result[ 0 ];\n\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t\tfor ( var j = 0; j < n; j ++ ) {\n\n\t\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].itemType, little_endian );\n\t\t\t\t\t\tlist.push( result[ 0 ] );\n\t\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\telement[ properties[ i ].name ] = list;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].type, little_endian );\n\t\t\t\t\telement[ properties[ i ].name ] = result[ 0 ];\n\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn [ element, read ];\n\n\t\t}\n\n\t\tfunction parseBinary( data, header ) {\n\n\t\t\tvar buffer = {\n\t\t\t\tindices: [],\n\t\t\t\tvertices: [],\n\t\t\t\tnormals: [],\n\t\t\t\tuvs: [],\n\t\t\t\tfaceVertexUvs: [],\n\t\t\t\tcolors: []\n\t\t\t};\n\n\t\t\tvar little_endian = ( header.format === 'binary_little_endian' );\n\t\t\tvar body = new DataView( data, header.headerLength );\n\t\t\tvar result, loc = 0;\n\n\t\t\tfor ( var currentElement = 0; currentElement < header.elements.length; currentElement ++ ) {\n\n\t\t\t\tfor ( var currentElementCount = 0; currentElementCount < header.elements[ currentElement ].count; currentElementCount ++ ) {\n\n\t\t\t\t\tresult = binaryReadElement( body, loc, header.elements[ currentElement ].properties, little_endian );\n\t\t\t\t\tloc += result[ 1 ];\n\t\t\t\t\tvar element = result[ 0 ];\n\n\t\t\t\t\thandleElement( buffer, header.elements[ currentElement ].name, element );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn postProcess( buffer );\n\n\t\t}\n\n\t\t//\n\n\t\tvar geometry;\n\t\tvar scope = this;\n\n\t\tif ( data instanceof ArrayBuffer ) {\n\n\t\t\tvar text = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.f.decodeText( new Uint8Array( data ) );\n\t\t\tvar header = parseHeader( text );\n\n\t\t\tgeometry = header.format === 'ascii' ? parseASCII( text, header ) : parseBinary( data, header );\n\n\t\t} else {\n\n\t\t\tgeometry = parseASCII( data, parseHeader( data ) );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n} );\n\n/*!\nfflate - fast JavaScript compression/decompression\n<https://101arrowz.github.io/fflate>\nLicensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE\n*/\nvar gn={},bn=function(n,r,t,e,i){var a=gn[r]||(gn[r]=URL.createObjectURL(new Blob([n],{type:\"text/javascript\"}))),o=new Worker(a);return o.onerror=function(f){return i(f.error,null)},o.onmessage=function(f){return i(null,f.data)},o.postMessage(t,e),o},A=Uint8Array,R=Uint16Array,nr=Uint32Array,ur=new A([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),lr=new A([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Mr=new A([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),wn=function(n,r){for(var t=new R(31),e=0;e<31;++e)t[e]=r+=1<<n[e-1];for(var i=new nr(t[30]),e=1;e<30;++e)for(var a=t[e];a<t[e+1];++a)i[a]=a-t[e]<<5|e;return [t,i]},yn=wn(ur,2),Nr=yn[0],Ir=yn[1];Nr[28]=258,Ir[258]=28;for(var mn=wn(lr,0),zn=mn[0],Qr=mn[1],Ur=new R(32768),T=0;T<32768;++T){var ir=(T&43690)>>>1|(T&21845)<<1;ir=(ir&52428)>>>2|(ir&13107)<<2,ir=(ir&61680)>>>4|(ir&3855)<<4,Ur[T]=((ir&65280)>>>8|(ir&255)<<8)>>>1;}for(var V=function(n,r,t){for(var e=n.length,i=0,a=new R(r);i<e;++i)++a[n[i]-1];var o=new R(r);for(i=0;i<r;++i)o[i]=o[i-1]+a[i-1]<<1;var f;if(t){f=new R(1<<r);var h=15-r;for(i=0;i<e;++i)if(n[i])for(var s=i<<4|n[i],u=r-n[i],l=o[n[i]-1]++<<u,p=l|(1<<u)-1;l<=p;++l)f[Ur[l]>>>h]=s;}else for(f=new R(e),i=0;i<e;++i)n[i]&&(f[i]=Ur[o[n[i]-1]++]>>>15-n[i]);return f},tr=new A(288),T=0;T<144;++T)tr[T]=8;for(var T=144;T<256;++T)tr[T]=9;for(var T=256;T<280;++T)tr[T]=7;for(var T=280;T<288;++T)tr[T]=8;for(var vr=new A(32),T=0;T<32;++T)vr[T]=5;var xn=V(tr,9,0),An=V(tr,9,1),Dn=V(vr,5,0),Mn=V(vr,5,1),Gr=function(n){for(var r=n[0],t=1;t<n.length;++t)n[t]>r&&(r=n[t]);return r},X=function(n,r,t){var e=r/8|0;return (n[e]|n[e+1]<<8)>>(r&7)&t},Or=function(n,r){var t=r/8|0;return (n[t]|n[t+1]<<8|n[t+2]<<16)>>(r&7)},Cr=function(n){return (n/8|0)+(n&7&&1)},$=function(n,r,t){(r==null||r<0)&&(r=0),(t==null||t>n.length)&&(t=n.length);var e=new(n instanceof R?R:n instanceof nr?nr:A)(t-r);return e.set(n.subarray(r,t)),e},Fr=function(n,r,t){var e=n.length;if(!e||t&&!t.l&&e<5)return r||new A(0);var i=!r||t,a=!t||t.i;t||(t={}),r||(r=new A(e*3));var o=function(Tr){var Dr=r.length;if(Tr>Dr){var hr=new A(Math.max(Dr*2,Tr));hr.set(r),r=hr;}},f=t.f||0,h=t.p||0,s=t.b||0,u=t.l,l=t.d,p=t.m,y=t.n,c=e*8;do{if(!u){t.f=f=X(n,h,1);var g=X(n,h+1,3);if(h+=3,g)if(g==1)u=An,l=Mn,p=9,y=5;else if(g==2){var m=X(n,h,31)+257,D=X(n,h+10,15)+4,C=m+X(n,h+5,31)+1;h+=14;for(var U=new A(C),x=new A(19),v=0;v<D;++v)x[Mr[v]]=X(n,h+v*3,7);h+=D*3;var E=Gr(x),S=(1<<E)-1;if(!a&&h+C*(E+7)>c)break;for(var K=V(x,E,1),v=0;v<C;){var I=K[X(n,h,S)];h+=I&15;var w=I>>>4;if(w<16)U[v++]=w;else {var Z=0,B=0;for(w==16?(B=3+X(n,h,3),h+=2,Z=U[v-1]):w==17?(B=3+X(n,h,7),h+=3):w==18&&(B=11+X(n,h,127),h+=7);B--;)U[v++]=Z;}}var G=U.subarray(0,m),k=U.subarray(m);p=Gr(G),y=Gr(k),u=V(G,p,1),l=V(k,y,1);}else throw \"invalid block type\";else {var w=Cr(h)+4,M=n[w-4]|n[w-3]<<8,z=w+M;if(z>e){if(a)throw \"unexpected EOF\";break}i&&o(s+M),r.set(n.subarray(w,z),s),t.b=s+=M,t.p=h=z*8;continue}if(h>c)throw \"unexpected EOF\"}i&&o(s+131072);for(var O=(1<<p)-1,H=(1<<y)-1,N=p+y+18;a||h+N<c;){var Z=u[Or(n,h)&O],Q=Z>>>4;if(h+=Z&15,h>c)throw \"unexpected EOF\";if(!Z)throw \"invalid length/literal\";if(Q<256)r[s++]=Q;else if(Q==256){u=null;break}else {var W=Q-254;if(Q>264){var v=Q-257,d=ur[v];W=X(n,h,(1<<d)-1)+Nr[v],h+=d;}var _=l[Or(n,h)&H],j=_>>>4;if(!_)throw \"invalid distance\";h+=_&15;var k=zn[j];if(j>3){var d=lr[j];k+=Or(n,h)&(1<<d)-1,h+=d;}if(h>c)throw \"unexpected EOF\";i&&o(s+131072);for(var q=s+W;s<q;s+=4)r[s]=r[s-k],r[s+1]=r[s+1-k],r[s+2]=r[s+2-k],r[s+3]=r[s+3-k];s=q;}}t.l=u,t.p=h,t.b=s,u&&(f=1,t.m=p,t.d=l,t.n=y);}while(!f);return s==r.length?r:$(r,0,s)},b=function(n,r,t){t<<=r&7;var e=r/8|0;n[e]|=t,n[e+1]|=t>>>8;},cr=function(n,r,t){t<<=r&7;var e=r/8|0;n[e]|=t,n[e+1]|=t>>>8,n[e+2]|=t>>>16;},Er=function(n,r){for(var t=[],e=0;e<n.length;++e)n[e]&&t.push({s:e,f:n[e]});var i=t.length,a=t.slice();if(!i)return [er,0];if(i==1){var o=new A(t[0].s+1);return o[t[0].s]=1,[o,1]}t.sort(function(C,U){return C.f-U.f}),t.push({s:-1,f:25001});var f=t[0],h=t[1],s=0,u=1,l=2;for(t[0]={s:-1,f:f.f+h.f,l:f,r:h};u!=i-1;)f=t[t[s].f<t[l].f?s++:l++],h=t[s!=u&&t[s].f<t[l].f?s++:l++],t[u++]={s:-1,f:f.f+h.f,l:f,r:h};for(var p=a[0].s,e=1;e<i;++e)a[e].s>p&&(p=a[e].s);var y=new R(p+1),c=Pr(t[u-1],y,0);if(c>r){var e=0,g=0,w=c-r,M=1<<w;for(a.sort(function(U,x){return y[x.s]-y[U.s]||U.f-x.f});e<i;++e){var z=a[e].s;if(y[z]>r)g+=M-(1<<c-y[z]),y[z]=r;else break}for(g>>>=w;g>0;){var m=a[e].s;y[m]<r?g-=1<<r-y[m]++-1:++e;}for(;e>=0&&g;--e){var D=a[e].s;y[D]==r&&(--y[D],++g);}c=r;}return [new A(y),c]},Pr=function(n,r,t){return n.s==-1?Math.max(Pr(n.l,r,t+1),Pr(n.r,r,t+1)):r[n.s]=t},Vr=function(n){for(var r=n.length;r&&!n[--r];);for(var t=new R(++r),e=0,i=n[0],a=1,o=function(h){t[e++]=h;},f=1;f<=r;++f)if(n[f]==i&&f!=r)++a;else {if(!i&&a>2){for(;a>138;a-=138)o(32754);a>2&&(o(a>10?a-11<<5|28690:a-3<<5|12305),a=0);}else if(a>3){for(o(i),--a;a>6;a-=6)o(8304);a>2&&(o(a-3<<5|8208),a=0);}for(;a--;)o(i);a=1,i=n[f];}return [t.subarray(0,e),r]},pr=function(n,r){for(var t=0,e=0;e<r.length;++e)t+=n[e]*r[e];return t},Sr=function(n,r,t){var e=t.length,i=Cr(r+2);n[i]=e&255,n[i+1]=e>>>8,n[i+2]=n[i]^255,n[i+3]=n[i+1]^255;for(var a=0;a<e;++a)n[i+a+4]=t[a];return (i+4+e)*8},Xr=function(n,r,t,e,i,a,o,f,h,s,u){b(r,u++,t),++i[256];for(var l=Er(i,15),p=l[0],y=l[1],c=Er(a,15),g=c[0],w=c[1],M=Vr(p),z=M[0],m=M[1],D=Vr(g),C=D[0],U=D[1],x=new R(19),v=0;v<z.length;++v)x[z[v]&31]++;for(var v=0;v<C.length;++v)x[C[v]&31]++;for(var E=Er(x,7),S=E[0],K=E[1],I=19;I>4&&!S[Mr[I-1]];--I);var Z=s+5<<3,B=pr(i,tr)+pr(a,vr)+o,G=pr(i,p)+pr(a,g)+o+14+3*I+pr(x,S)+(2*x[16]+3*x[17]+7*x[18]);if(Z<=B&&Z<=G)return Sr(r,u,n.subarray(h,h+s));var k,O,H,N;if(b(r,u,1+(G<B)),u+=2,G<B){k=V(p,y,0),O=p,H=V(g,w,0),N=g;var Q=V(S,K,0);b(r,u,m-257),b(r,u+5,U-1),b(r,u+10,I-4),u+=14;for(var v=0;v<I;++v)b(r,u+3*v,S[Mr[v]]);u+=3*I;for(var W=[z,C],d=0;d<2;++d)for(var _=W[d],v=0;v<_.length;++v){var j=_[v]&31;b(r,u,Q[j]),u+=S[j],j>15&&(b(r,u,_[v]>>>5&127),u+=_[v]>>>12);}}else k=xn,O=tr,H=Dn,N=vr;for(var v=0;v<f;++v)if(e[v]>255){var j=e[v]>>>18&31;cr(r,u,k[j+257]),u+=O[j+257],j>7&&(b(r,u,e[v]>>>23&31),u+=ur[j]);var q=e[v]&31;cr(r,u,H[q]),u+=N[q],q>3&&(cr(r,u,e[v]>>>5&8191),u+=lr[q]);}else cr(r,u,k[e[v]]),u+=O[e[v]];return cr(r,u,k[256]),u+O[256]},Un=new nr([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),er=new A(0),Cn=function(n,r,t,e,i,a){var o=n.length,f=new A(e+o+5*(1+Math.ceil(o/7e3))+i),h=f.subarray(e,f.length-i),s=0;if(!r||o<8)for(var u=0;u<=o;u+=65535){var l=u+65535;l<o?s=Sr(h,s,n.subarray(u,l)):(h[u]=a,s=Sr(h,s,n.subarray(u,o)));}else {for(var p=Un[r-1],y=p>>>13,c=p&8191,g=(1<<t)-1,w=new R(32768),M=new R(g+1),z=Math.ceil(t/3),m=2*z,D=function(Kr){return (n[Kr]^n[Kr+1]<<z^n[Kr+2]<<m)&g},C=new nr(25e3),U=new R(288),x=new R(32),v=0,E=0,u=0,S=0,K=0,I=0;u<o;++u){var Z=D(u),B=u&32767,G=M[Z];if(w[B]=G,M[Z]=B,K<=u){var k=o-u;if((v>7e3||S>24576)&&k>423){s=Xr(n,h,0,C,U,x,E,S,I,u-I,s),S=v=E=0,I=u;for(var O=0;O<286;++O)U[O]=0;for(var O=0;O<30;++O)x[O]=0;}var H=2,N=0,Q=c,W=B-G&32767;if(k>2&&Z==D(u-W))for(var d=Math.min(y,k)-1,_=Math.min(32767,u),j=Math.min(258,k);W<=_&&--Q&&B!=G;){if(n[u+H]==n[u+H-W]){for(var q=0;q<j&&n[u+q]==n[u+q-W];++q);if(q>H){if(H=q,N=W,q>d)break;for(var Tr=Math.min(W,q-2),Dr=0,O=0;O<Tr;++O){var hr=u-W+O+32768&32767,_n=w[hr],vn=hr-_n+32768&32767;vn>Dr&&(Dr=vn,G=hr);}}}B=G,G=w[B],W+=B-G+32768&32767;}if(N){C[S++]=268435456|Ir[H]<<18|Qr[N];var cn=Ir[H]&31,pn=Qr[N]&31;E+=ur[cn]+lr[pn],++U[257+cn],++x[pn],K=u+H,++v;}else C[S++]=n[u],++U[n[u]];}}s=Xr(n,h,a,C,U,x,E,S,I,u-I,s),!a&&s&7&&(s=Sr(h,s+1,er));}return $(f,0,e+Cr(s)+i)},Fn=function(){for(var n=new nr(256),r=0;r<256;++r){for(var t=r,e=9;--e;)t=(t&1&&3988292384)^t>>>1;n[r]=t;}return n}(),gr=function(){var n=-1;return {p:function(r){for(var t=n,e=0;e<r.length;++e)t=Fn[t&255^r[e]]^t>>>8;n=t;},d:function(){return ~n}}},$r=function(){var n=1,r=0;return {p:function(t){for(var e=n,i=r,a=t.length,o=0;o!=a;){for(var f=Math.min(o+2655,a);o<f;++o)i+=e+=t[o];e=(e&65535)+15*(e>>16),i=(i&65535)+15*(i>>16);}n=e,r=i;},d:function(){return n%=65521,r%=65521,(n>>>8<<16|(r&255)<<8|r>>>8)+((n&255)<<23)*2}}},sr=function(n,r,t,e,i){return Cn(n,r.level==null?6:r.level,r.mem==null?Math.ceil(Math.max(8,Math.min(13,Math.log(n.length)))*1.5):12+r.mem,t,e,!i)},Zr=function(n,r){var t={};for(var e in n)t[e]=n[e];for(var e in r)t[e]=r[e];return t},Sn=function(n,r,t){for(var e=n(),i=n.toString(),a=i.slice(i.indexOf(\"[\")+1,i.lastIndexOf(\"]\")).replace(/ /g,\"\").split(\",\"),o=0;o<e.length;++o){var f=e[o],h=a[o];if(typeof f==\"function\"){r+=\";\"+h+\"=\";var s=f.toString();if(f.prototype)if(s.indexOf(\"[native code]\")!=-1){var u=s.indexOf(\" \",8)+1;r+=s.slice(u,s.indexOf(\"(\",u));}else {r+=s;for(var l in f.prototype)r+=\";\"+h+\".prototype.\"+l+\"=\"+f.prototype[l].toString();}else r+=s;}else t[h]=f;}return [r,t]},Rr=[],rt=function(n){var r=[];for(var t in n)(n[t]instanceof A||n[t]instanceof R||n[t]instanceof nr)&&r.push((n[t]=new n[t].constructor(n[t])).buffer);return r},Zn=function(n,r,t,e){var i;if(!Rr[t]){for(var a=\"\",o={},f=n.length-1,h=0;h<f;++h)i=Sn(n[h],a,o),a=i[0],o=i[1];Rr[t]=Sn(n[f],a,o);}var s=Zr({},Rr[t][1]);return bn(Rr[t][0]+\";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=\"+r.toString()+\"}\",t,s,rt(s),e)},wr=function(){return [A,R,nr,ur,lr,Mr,Nr,zn,An,Mn,Ur,V,Gr,X,Or,Cr,$,Fr,xr,ar,Lr]},yr=function(){return [A,R,nr,ur,lr,Mr,Ir,Qr,xn,tr,Dn,vr,Ur,Un,er,V,b,cr,Er,Pr,Vr,pr,Sr,Xr,Cr,$,Cn,sr,kr,ar]},kn=function(){return [_r,rn,F,gr,Fn]},Bn=function(){return [br,Gn]},Tn=function(){return [nn,F,$r]},In=function(){return [On]},ar=function(n){return postMessage(n,[n.buffer])},Lr=function(n){return n&&n.size&&new A(n.size)},mr=function(n,r,t,e,i,a){var o=Zn(t,e,i,function(f,h){o.terminate(),a(f,h);});return o.postMessage([n,r],r.consume?[n.buffer]:[]),function(){o.terminate();}},L=function(n){return n.ondata=function(r,t){return postMessage([r,t],[r.buffer])},function(r){return n.push(r.data[0],r.data[1])}},zr=function(n,r,t,e,i){var a,o=Zn(n,e,i,function(f,h){f?(o.terminate(),r.ondata.call(r,f)):(h[1]&&o.terminate(),r.ondata.call(r,f,h[0],h[1]));});o.postMessage(t),r.push=function(f,h){if(a)throw \"stream finished\";if(!r.ondata)throw \"no stream handler\";o.postMessage([f,a=h],[f.buffer]);},r.terminate=function(){o.terminate();};},Y=function(n,r){return n[r]|n[r+1]<<8},P=function(n,r){return (n[r]|n[r+1]<<8|n[r+2]<<16)+(n[r+3]<<23)*2},dr=function(n,r){return P(n,r)|P(n,r)*4294967296},F=function(n,r,t){for(;t;++r)n[r]=t,t>>>=8;},_r=function(n,r){var t=r.filename;if(n[0]=31,n[1]=139,n[2]=8,n[8]=r.level<2?4:r.level==9?2:0,n[9]=3,r.mtime!=0&&F(n,4,Math.floor(new Date(r.mtime||Date.now())/1e3)),t){n[3]=8;for(var e=0;e<=t.length;++e)n[e+10]=t.charCodeAt(e);}},br=function(n){if(n[0]!=31||n[1]!=139||n[2]!=8)throw \"invalid gzip data\";var r=n[3],t=10;r&4&&(t+=n[10]|(n[11]<<8)+2);for(var e=(r>>3&1)+(r>>4&1);e>0;e-=!n[t++]);return t+(r&2)},Gn=function(n){var r=n.length;return (n[r-4]|n[r-3]<<8|n[r-2]<<16)+2*(n[r-1]<<23)},rn=function(n){return 10+(n.filename&&n.filename.length+1||0)},nn=function(n,r){var t=r.level,e=t==0?0:t<6?1:t==9?3:2;n[0]=120,n[1]=e<<6|(e?32-2*e:1);},On=function(n){if((n[0]&15)!=8||n[0]>>>4>7||(n[0]<<8|n[1])%31)throw \"invalid zlib data\";if(n[1]&32)throw \"invalid zlib data: preset dictionaries not supported\"};function tn(n,r){return !r&&typeof n==\"function\"&&(r=n,n={}),this.ondata=r,n}var rr=function(){function n(r,t){!t&&typeof r==\"function\"&&(t=r,r={}),this.ondata=t,this.o=r||{};}return n.prototype.p=function(r,t){this.ondata(sr(r,this.o,0,0,!t),t);},n.prototype.push=function(r,t){if(this.d)throw \"stream finished\";if(!this.ondata)throw \"no stream handler\";this.d=t,this.p(r,t||!1);},n}(),En=function(){function n(r,t){zr([yr,function(){return [L,rr]}],this,tn.call(this,r,t),function(e){var i=new rr(e.data);onmessage=L(i);},6);}return n}();function Pn(n,r,t){if(t||(t=r,r={}),typeof t!=\"function\")throw \"no callback\";return mr(n,r,[yr],function(e){return ar(kr(e.data[0],e.data[1]))},0,t)}function kr(n,r){return sr(n,r||{},0,0)}var J=function(){function n(r){this.s={},this.p=new A(0),this.ondata=r;}return n.prototype.e=function(r){if(this.d)throw \"stream finished\";if(!this.ondata)throw \"no stream handler\";var t=this.p.length,e=new A(t+r.length);e.set(this.p),e.set(r,t),this.p=e;},n.prototype.c=function(r){this.d=this.s.i=r||!1;var t=this.s.b,e=Fr(this.p,this.o,this.s);this.ondata($(e,t,this.s.b),this.d),this.o=$(e,this.s.b-32768),this.s.b=this.o.length,this.p=$(this.p,this.s.p/8|0),this.s.p&=7;},n.prototype.push=function(r,t){this.e(r),this.c(t);},n}(),en=function(){function n(r){this.ondata=r,zr([wr,function(){return [L,J]}],this,0,function(){var t=new J;onmessage=L(t);},7);}return n}();function an(n,r,t){if(t||(t=r,r={}),typeof t!=\"function\")throw \"no callback\";return mr(n,r,[wr],function(e){return ar(xr(e.data[0],Lr(e.data[1])))},1,t)}function xr(n,r){return Fr(n,r)}var qr=function(){function n(r,t){this.c=gr(),this.l=0,this.v=1,rr.call(this,r,t);}return n.prototype.push=function(r,t){rr.prototype.push.call(this,r,t);},n.prototype.p=function(r,t){this.c.p(r),this.l+=r.length;var e=sr(r,this.o,this.v&&rn(this.o),t&&8,!t);this.v&&(_r(e,this.o),this.v=0),t&&(F(e,e.length-8,this.c.d()),F(e,e.length-4,this.l)),this.ondata(e,t);},n}(),Rn=function(){function n(r,t){zr([yr,kn,function(){return [L,rr,qr]}],this,tn.call(this,r,t),function(e){var i=new qr(e.data);onmessage=L(i);},8);}return n}();function qn(n,r,t){if(t||(t=r,r={}),typeof t!=\"function\")throw \"no callback\";return mr(n,r,[yr,kn,function(){return [Hr]}],function(e){return ar(Hr(e.data[0],e.data[1]))},2,t)}function Hr(n,r){r||(r={});var t=gr(),e=n.length;t.p(n);var i=sr(n,r,rn(r),8),a=i.length;return _r(i,r),F(i,a-8,t.d()),F(i,a-4,e),i}var Wr=function(){function n(r){this.v=1,J.call(this,r);}return n.prototype.push=function(r,t){if(J.prototype.e.call(this,r),this.v){var e=this.p.length>3?br(this.p):4;if(e>=this.p.length&&!t)return;this.p=this.p.subarray(e),this.v=0;}if(t){if(this.p.length<8)throw \"invalid gzip stream\";this.p=this.p.subarray(0,-8);}J.prototype.c.call(this,t);},n}(),Hn=function(){function n(r){this.ondata=r,zr([wr,Bn,function(){return [L,J,Wr]}],this,0,function(){var t=new Wr;onmessage=L(t);},9);}return n}();function Wn(n,r,t){if(t||(t=r,r={}),typeof t!=\"function\")throw \"no callback\";return mr(n,r,[wr,Bn,function(){return [Yr]}],function(e){return ar(Yr(e.data[0]))},3,t)}function Yr(n,r){return Fr(n.subarray(br(n),-8),r||new A(Gn(n)))}var on=function(){function n(r,t){this.c=$r(),this.v=1,rr.call(this,r,t);}return n.prototype.push=function(r,t){rr.prototype.push.call(this,r,t);},n.prototype.p=function(r,t){this.c.p(r);var e=sr(r,this.o,this.v&&2,t&&4,!t);this.v&&(nn(e,this.o),this.v=0),t&&F(e,e.length-4,this.c.d()),this.ondata(e,t);},n}(),nt=function(){function n(r,t){zr([yr,Tn,function(){return [L,rr,on]}],this,tn.call(this,r,t),function(e){var i=new on(e.data);onmessage=L(i);},10);}return n}();function tt(n,r,t){if(t||(t=r,r={}),typeof t!=\"function\")throw \"no callback\";return mr(n,r,[yr,Tn,function(){return [fn]}],function(e){return ar(fn(e.data[0],e.data[1]))},4,t)}function fn(n,r){r||(r={});var t=$r();t.p(n);var e=sr(n,r,2,4);return nn(e,r),F(e,e.length-4,t.d()),e}var jr=function(){function n(r){this.v=1,J.call(this,r);}return n.prototype.push=function(r,t){if(J.prototype.e.call(this,r),this.v){if(this.p.length<2&&!t)return;this.p=this.p.subarray(2),this.v=0;}if(t){if(this.p.length<4)throw \"invalid zlib stream\";this.p=this.p.subarray(0,-4);}J.prototype.c.call(this,t);},n}(),Yn=function(){function n(r){this.ondata=r,zr([wr,In,function(){return [L,J,jr]}],this,0,function(){var t=new jr;onmessage=L(t);},11);}return n}();function jn(n,r,t){if(t||(t=r,r={}),typeof t!=\"function\")throw \"no callback\";return mr(n,r,[wr,In,function(){return [Jr]}],function(e){return ar(Jr(e.data[0],Lr(e.data[1])))},5,t)}function Jr(n,r){return Fr((On(n),n.subarray(2,-4)),r)}var Jn=function(){function n(r){this.G=Wr,this.I=J,this.Z=jr,this.ondata=r;}return n.prototype.push=function(r,t){if(!this.ondata)throw \"no stream handler\";if(this.s)this.s.push(r,t);else {if(this.p&&this.p.length){var e=new A(this.p.length+r.length);e.set(this.p),e.set(r,this.p.length);}else this.p=r;if(this.p.length>2){var i=this,a=function(){i.ondata.apply(i,arguments);};this.s=this.p[0]==31&&this.p[1]==139&&this.p[2]==8?new this.G(a):(this.p[0]&15)!=8||this.p[0]>>4>7||(this.p[0]<<8|this.p[1])%31?new this.I(a):new this.Z(a),this.s.push(this.p,t),this.p=null;}}},n}(),et=function(){function n(r){this.G=Hn,this.I=en,this.Z=Yn,this.ondata=r;}return n.prototype.push=function(r,t){Jn.prototype.push.call(this,r,t);},n}();function it(n,r,t){if(t||(t=r,r={}),typeof t!=\"function\")throw \"no callback\";return n[0]==31&&n[1]==139&&n[2]==8?Wn(n,r,t):(n[0]&15)!=8||n[0]>>4>7||(n[0]<<8|n[1])%31?an(n,r,t):jn(n,r,t)}function at(n,r){return n[0]==31&&n[1]==139&&n[2]==8?Yr(n,r):(n[0]&15)!=8||n[0]>>4>7||(n[0]<<8|n[1])%31?xr(n,r):Jr(n,r)}var sn=function(n,r,t,e){for(var i in n){var a=n[i],o=r+i;a instanceof A?t[o]=[a,e]:Array.isArray(a)?t[o]=[a[0],Zr(e,a[1])]:sn(a,o+\"/\",t,e);}},Kn=typeof TextEncoder!=\"undefined\"&&new TextEncoder,hn=typeof TextDecoder!=\"undefined\"&&new TextDecoder,Nn=0;try{hn.decode(er,{stream:!0}),Nn=1;}catch(n){}var Qn=function(n){for(var r=\"\",t=0;;){var e=n[t++],i=(e>127)+(e>223)+(e>239);if(t+i>n.length)return [r,$(n,t-1)];i?i==3?(e=((e&15)<<18|(n[t++]&63)<<12|(n[t++]&63)<<6|n[t++]&63)-65536,r+=String.fromCharCode(55296|e>>10,56320|e&1023)):i&1?r+=String.fromCharCode((e&31)<<6|n[t++]&63):r+=String.fromCharCode((e&15)<<12|(n[t++]&63)<<6|n[t++]&63):r+=String.fromCharCode(e);}},ot=function(){function n(r){this.ondata=r,Nn?this.t=new TextDecoder:this.p=er;}return n.prototype.push=function(r,t){if(!this.ondata)throw \"no callback\";if(t||(t=!1),this.t)return this.ondata(this.t.decode(r,{stream:!t}),t);var e=new A(this.p.length+r.length);e.set(this.p),e.set(r,this.p.length);var i=Qn(e),a=i[0],o=i[1];if(t&&o.length)throw \"invalid utf-8 data\";this.p=o,this.ondata(a,t);},n}(),ft=function(){function n(r){this.ondata=r;}return n.prototype.push=function(r,t){if(!this.ondata)throw \"no callback\";this.ondata(or(r),t||!1);},n}();function or(n,r){if(r){for(var t=new A(n.length),e=0;e<n.length;++e)t[e]=n.charCodeAt(e);return t}if(Kn)return Kn.encode(n);for(var i=n.length,a=new A(n.length+(n.length>>1)),o=0,f=function(u){a[o++]=u;},e=0;e<i;++e){if(o+5>a.length){var h=new A(o+8+(i-e<<1));h.set(a),a=h;}var s=n.charCodeAt(e);s<128||r?f(s):s<2048?(f(192|s>>>6),f(128|s&63)):s>55295&&s<57344?(s=65536+(s&1023<<10)|n.charCodeAt(++e)&1023,f(240|s>>>18),f(128|s>>>12&63),f(128|s>>>6&63),f(128|s&63)):(f(224|s>>>12),f(128|s>>>6&63),f(128|s&63));}return $(a,0,o)}function un(n,r){if(r){for(var t=\"\",e=0;e<n.length;e+=16384)t+=String.fromCharCode.apply(null,n.subarray(e,e+16384));return t}else {if(hn)return hn.decode(n);var i=Qn(n),a=i[0],o=i[1];if(o.length)throw \"invalid utf-8 data\";return a}}var Vn=function(n){return n==1?3:n<6?2:n==9?1:0},Xn=function(n,r){return r+30+Y(n,r+26)+Y(n,r+28)},$n=function(n,r,t){var e=Y(n,r+28),i=un(n.subarray(r+46,r+46+e),!(Y(n,r+8)&2048)),a=r+46+e,o=P(n,r+20),f=t&&o==4294967295?Ln(n,a):[o,P(n,r+24),P(n,r+42)],h=f[0],s=f[1],u=f[2];return [Y(n,r+10),h,s,i,a+Y(n,r+30)+Y(n,r+32),u]},Ln=function(n,r){for(;Y(n,r)!=1;r+=4+Y(n,r+2));return [dr(n,r+12),dr(n,r+4),dr(n,r+20)]},fr=function(n){var r=0;if(n)for(var t in n){var e=n[t].length;if(e>65535)throw \"extra field too long\";r+=e+4;}return r},Ar=function(n,r,t,e,i,a,o,f){var h=e.length,s=t.extra,u=f&&f.length,l=fr(s);F(n,r,o!=null?33639248:67324752),r+=4,o!=null&&(n[r++]=20,n[r++]=t.os),n[r]=20,r+=2,n[r++]=t.flag<<1|(a==null&&8),n[r++]=i&&8,n[r++]=t.compression&255,n[r++]=t.compression>>8;var p=new Date(t.mtime==null?Date.now():t.mtime),y=p.getFullYear()-1980;if(y<0||y>119)throw \"date not in range 1980-2099\";if(F(n,r,(y<<24)*2|p.getMonth()+1<<21|p.getDate()<<16|p.getHours()<<11|p.getMinutes()<<5|p.getSeconds()>>>1),r+=4,a!=null&&(F(n,r,t.crc),F(n,r+4,a),F(n,r+8,t.size)),F(n,r+12,h),F(n,r+14,l),r+=16,o!=null&&(F(n,r,u),F(n,r+6,t.attrs),F(n,r+10,o),r+=14),n.set(e,r),r+=h,l)for(var c in s){var g=s[c],w=g.length;F(n,r,+c),F(n,r+2,w),n.set(g,r+4),r+=4+w;}return u&&(n.set(f,r),r+=u),r},ln=function(n,r,t,e,i){F(n,r,101010256),F(n,r+8,t),F(n,r+10,t),F(n,r+12,e),F(n,r+16,i);},Br=function(){function n(r){this.filename=r,this.c=gr(),this.size=0,this.compression=0;}return n.prototype.process=function(r,t){this.ondata(null,r,t);},n.prototype.push=function(r,t){if(!this.ondata)throw \"no callback - add to ZIP archive before pushing\";this.c.p(r),this.size+=r.length,t&&(this.crc=this.c.d()),this.process(r,t||!1);},n}(),st=function(){function n(r,t){var e=this;t||(t={}),Br.call(this,r),this.d=new rr(t,function(i,a){e.ondata(null,i,a);}),this.compression=8,this.flag=Vn(t.level);}return n.prototype.process=function(r,t){try{this.d.push(r,t);}catch(e){this.ondata(e,null,t);}},n.prototype.push=function(r,t){Br.prototype.push.call(this,r,t);},n}(),ht=function(){function n(r,t){var e=this;t||(t={}),Br.call(this,r),this.d=new En(t,function(i,a,o){e.ondata(i,a,o);}),this.compression=8,this.flag=Vn(t.level),this.terminate=this.d.terminate;}return n.prototype.process=function(r,t){this.d.push(r,t);},n.prototype.push=function(r,t){Br.prototype.push.call(this,r,t);},n}(),ut=function(){function n(r){this.ondata=r,this.u=[],this.d=1;}return n.prototype.add=function(r){var t=this;if(this.d&2)throw \"stream finished\";var e=or(r.filename),i=e.length,a=r.comment,o=a&&or(a),f=i!=r.filename.length||o&&a.length!=o.length,h=i+fr(r.extra)+30;if(i>65535)throw \"filename too long\";var s=new A(h);Ar(s,0,r,e,f);var u=[s],l=function(){for(var w=0,M=u;w<M.length;w++){var z=M[w];t.ondata(null,z,!1);}u=[];},p=this.d;this.d=0;var y=this.u.length,c=Zr(r,{f:e,u:f,o,t:function(){r.terminate&&r.terminate();},r:function(){if(l(),p){var w=t.u[y+1];w?w.r():t.d=1;}p=1;}}),g=0;r.ondata=function(w,M,z){if(w)t.ondata(w,M,z),t.terminate();else if(g+=M.length,u.push(M),z){var m=new A(16);F(m,0,134695760),F(m,4,r.crc),F(m,8,g),F(m,12,r.size),u.push(m),c.c=g,c.b=h+g+16,c.crc=r.crc,c.size=r.size,p&&c.r(),p=1;}else p&&l();},this.u.push(c);},n.prototype.end=function(){var r=this;if(this.d&2)throw this.d&1?\"stream finishing\":\"stream finished\";this.d?this.e():this.u.push({r:function(){if(!(r.d&1))return;r.u.splice(-1,1),r.e();},t:function(){}}),this.d=3;},n.prototype.e=function(){for(var r=0,t=0,e=0,i=0,a=this.u;i<a.length;i++){var o=a[i];e+=46+o.f.length+fr(o.extra)+(o.o?o.o.length:0);}for(var f=new A(e+22),h=0,s=this.u;h<s.length;h++){var o=s[h];Ar(f,r,o,o.f,o.u,o.c,t,o.o),r+=46+o.f.length+fr(o.extra)+(o.o?o.o.length:0),t+=o.b;}ln(f,r,this.u.length,e,t),this.ondata(null,f,!0),this.d=2;},n.prototype.terminate=function(){for(var r=0,t=this.u;r<t.length;r++){var e=t[r];e.t();}this.d=2;},n}();function lt(n,r,t){if(t||(t=r,r={}),typeof t!=\"function\")throw \"no callback\";var e={};sn(n,\"\",e,r);var i=Object.keys(e),a=i.length,o=0,f=0,h=a,s=new Array(a),u=[],l=function(){for(var g=0;g<u.length;++g)u[g]();},p=function(){var g=new A(f+22),w=o,M=f-o;f=0;for(var z=0;z<h;++z){var m=s[z];try{var D=m.c.length;Ar(g,f,m,m.f,m.u,D);var C=30+m.f.length+fr(m.extra),U=f+C;g.set(m.c,U),Ar(g,o,m,m.f,m.u,D,f,m.m),o+=16+C+(m.m?m.m.length:0),f=U+D;}catch(x){return t(x,null)}}ln(g,o,s.length,M,w),t(null,g);};a||p();for(var y=function(g){var w=i[g],M=e[w],z=M[0],m=M[1],D=gr(),C=z.length;D.p(z);var U=or(w),x=U.length,v=m.comment,E=v&&or(v),S=E&&E.length,K=fr(m.extra),I=m.level==0?0:8,Z=function(B,G){if(B)l(),t(B,null);else {var k=G.length;s[g]=Zr(m,{size:C,crc:D.d(),c:G,f:U,m:E,u:x!=w.length||E&&v.length!=S,compression:I}),o+=30+x+K+k,f+=76+2*(x+K)+(S||0)+k,--a||p();}};if(x>65535&&Z(\"filename too long\",null),!I)Z(null,z);else if(C<16e4)try{Z(null,kr(z,m));}catch(B){Z(B,null);}else u.push(Pn(z,m,Z));},c=0;c<h;++c)y(c);return l}function vt(n,r){r||(r={});var t={},e=[];sn(n,\"\",t,r);var i=0,a=0;for(var o in t){var f=t[o],h=f[0],s=f[1],u=s.level==0?0:8,l=or(o),p=l.length,y=s.comment,c=y&&or(y),g=c&&c.length,w=fr(s.extra);if(p>65535)throw \"filename too long\";var M=u?kr(h,s):h,z=M.length,m=gr();m.p(h),e.push(Zr(s,{size:h.length,crc:m.d(),c:M,f:l,m:c,u:p!=o.length||c&&y.length!=g,o:i,compression:u})),i+=30+p+w+z,a+=76+2*(p+w)+(g||0)+z;}for(var D=new A(a+22),C=i,U=a-i,x=0;x<e.length;++x){var l=e[x];Ar(D,l.o,l,l.f,l.u,l.c.length);var v=30+l.f.length+fr(l.extra);D.set(l.c,l.o+v),Ar(D,i,l,l.f,l.u,l.c.length,l.o,l.m),i+=16+v+(l.m?l.m.length:0);}return ln(D,i,e.length,U,C),D}var dn=function(){function n(){}return n.prototype.push=function(r,t){this.ondata(null,r,t);},n.compression=0,n}(),ct=function(){function n(){var r=this;this.i=new J(function(t,e){r.ondata(null,t,e);});}return n.prototype.push=function(r,t){try{this.i.push(r,t);}catch(e){this.ondata(e,r,t);}},n.compression=8,n}(),pt=function(){function n(r,t){var e=this;t<32e4?this.i=new J(function(i,a){e.ondata(null,i,a);}):(this.i=new en(function(i,a,o){e.ondata(i,a,o);}),this.terminate=this.i.terminate);}return n.prototype.push=function(r,t){this.i.terminate&&(r=$(r,0)),this.i.push(r,t);},n.compression=8,n}(),gt=function(){function n(r){this.onfile=r,this.k=[],this.o={0:dn},this.p=er;}return n.prototype.push=function(r,t){var e=this;if(!this.onfile)throw \"no callback\";if(this.c>0){var i=Math.min(this.c,r.length),a=r.subarray(0,i);if(this.c-=i,this.d?this.d.push(a,!this.c):this.k[0].push(a),r=r.subarray(i),r.length)return this.push(r,t)}else {var o=0,f=0,h=void 0,s=void 0;this.p.length?r.length?(s=new A(this.p.length+r.length),s.set(this.p),s.set(r,this.p.length)):s=this.p:s=r;for(var u=s.length,l=this.c,p=l&&this.d,y=function(){var M,z=P(s,f);if(z==67324752){o=1,h=f,c.d=null,c.c=0;var m=Y(s,f+6),D=Y(s,f+8),C=m&2048,U=m&8,x=Y(s,f+26),v=Y(s,f+28);if(u>f+30+x+v){var E=[];c.k.unshift(E),o=2;var S=P(s,f+18),K=P(s,f+22),I=un(s.subarray(f+30,f+=30+x),!C);S==4294967295?(M=U?[-2]:Ln(s,f),S=M[0],K=M[1]):U&&(S=-1),f+=v,c.c=S;var Z={name:I,compression:D,start:function(){if(!Z.ondata)throw \"no callback\";if(!S)Z.ondata(null,er,!0);else {var B=e.o[D];if(!B)throw \"unknown compression type \"+D;var G=S<0?new B(I):new B(I,S,K);G.ondata=function(N,Q,W){Z.ondata(N,Q,W);};for(var k=0,O=E;k<O.length;k++){var H=O[k];G.push(H,!1);}e.k[0]==E?e.d=G:G.push(er,!0);}},terminate:function(){e.k[0]==E&&e.d.terminate&&e.d.terminate();}};S>=0&&(Z.size=S,Z.originalSize=K),c.onfile(Z);}return \"break\"}else if(l){if(z==134695760)return h=f+=12+(l==-2&&8),o=2,c.c=0,\"break\";if(z==33639248)return h=f-=4,o=2,c.c=0,\"break\"}},c=this;f<u-4;++f){var g=y();if(g===\"break\")break}if(this.p=er,l<0){var w=o?s.subarray(0,h-12-(l==-2&&8)-(P(s,h-16)==134695760&&4)):s.subarray(0,f);p?p.push(w,!!o):this.k[+(o==2)].push(w);}if(o&2)return this.push(s.subarray(f),t);this.p=s.subarray(f);}if(t&&this.c)throw \"invalid zip file\"},n.prototype.register=function(r){this.o[r.compression]=r;},n}();function wt(n,r){if(typeof r!=\"function\")throw \"no callback\";for(var t=[],e=function(){for(var p=0;p<t.length;++p)t[p]();},i={},a=n.length-22;P(n,a)!=101010256;--a)if(!a||n.length-a>65558){r(\"invalid zip file\",null);return}var o=Y(n,a+8);o||r(null,{});var f=o,h=P(n,a+16),s=h==4294967295;if(s){if(a=P(n,a-12),P(n,a)!=101075792){r(\"invalid zip file\",null);return}f=o=P(n,a+32),h=P(n,a+48);}for(var u=function(p){var y=$n(n,h,s),c=y[0],g=y[1],w=y[2],M=y[3],z=y[4],m=y[5],D=Xn(n,m);h=z;var C=function(x,v){x?(e(),r(x,null)):(i[M]=v,--o||r(null,i));};if(!c)C(null,$(n,D,D+g));else if(c==8){var U=n.subarray(D,D+g);if(g<32e4)try{C(null,xr(U,new A(w)));}catch(x){C(x,null);}else t.push(an(U,{size:w},C));}else C(\"unknown compression type \"+c,null);},l=0;l<f;++l)u();return e}function yt(n){for(var r={},t=n.length-22;P(n,t)!=101010256;--t)if(!t||n.length-t>65558)throw \"invalid zip file\";var e=Y(n,t+8);if(!e)return {};var i=P(n,t+16),a=i==4294967295;if(a){if(t=P(n,t-12),P(n,t)!=101075792)throw \"invalid zip file\";e=P(n,t+32),i=P(n,t+48);}for(var o=0;o<e;++o){var f=$n(n,i,a),h=f[0],s=f[1],u=f[2],l=f[3],p=f[4],y=f[5],c=Xn(n,y);if(i=p,!h)r[l]=$(n,c,c+s);else if(h==8)r[l]=xr(n.subarray(c,c+s),new A(u));else throw \"unknown compression type \"+h}return r}var fflate_module_min = null;\n\nvar fflate = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tAsyncCompress: Rn,\n\tAsyncDecompress: et,\n\tAsyncDeflate: En,\n\tAsyncGunzip: Hn,\n\tAsyncGzip: Rn,\n\tAsyncInflate: en,\n\tAsyncUnzipInflate: pt,\n\tAsyncUnzlib: Yn,\n\tAsyncZipDeflate: ht,\n\tAsyncZlib: nt,\n\tCompress: qr,\n\tDecodeUTF8: ot,\n\tDecompress: Jn,\n\tDeflate: rr,\n\tEncodeUTF8: ft,\n\tGunzip: Wr,\n\tGzip: qr,\n\tInflate: J,\n\tUnzip: gt,\n\tUnzipInflate: ct,\n\tUnzipPassThrough: dn,\n\tUnzlib: jr,\n\tZip: ut,\n\tZipDeflate: st,\n\tZipPassThrough: Br,\n\tZlib: on,\n\tcompress: qn,\n\tcompressSync: Hr,\n\tdecompress: it,\n\tdecompressSync: at,\n\tdeflate: Pn,\n\tdeflateSync: kr,\n\tgunzip: Wn,\n\tgunzipSync: Yr,\n\tgzip: qn,\n\tgzipSync: Hr,\n\tinflate: an,\n\tinflateSync: xr,\n\tstrFromU8: un,\n\tstrToU8: or,\n\tunzip: wt,\n\tunzipSync: yt,\n\tunzlib: jn,\n\tunzlibSync: Jr,\n\tzip: lt,\n\tzipSync: vt,\n\tzlib: tt,\n\tzlibSync: fn,\n\t'default': fflate_module_min\n});\n\n/**\n * NURBS utils\n *\n * See NURBSCurve and NURBSSurface.\n **/\n\n\n/**************************************************************\n *\tNURBS Utils\n **************************************************************/\n\nvar NURBSUtils = {\n\n\t/*\n\tFinds knot vector span.\n\n\tp : degree\n\tu : parametric value\n\tU : knot vector\n\n\treturns the span\n\t*/\n\tfindSpan: function ( p, u, U ) {\n\n\t\tvar n = U.length - p - 1;\n\n\t\tif ( u >= U[ n ] ) {\n\n\t\t\treturn n - 1;\n\n\t\t}\n\n\t\tif ( u <= U[ p ] ) {\n\n\t\t\treturn p;\n\n\t\t}\n\n\t\tvar low = p;\n\t\tvar high = n;\n\t\tvar mid = Math.floor( ( low + high ) / 2 );\n\n\t\twhile ( u < U[ mid ] || u >= U[ mid + 1 ] ) {\n\n\t\t\tif ( u < U[ mid ] ) {\n\n\t\t\t\thigh = mid;\n\n\t\t\t} else {\n\n\t\t\t\tlow = mid;\n\n\t\t\t}\n\n\t\t\tmid = Math.floor( ( low + high ) / 2 );\n\n\t\t}\n\n\t\treturn mid;\n\n\t},\n\n\n\t/*\n\tCalculate basis functions. See The NURBS Book, page 70, algorithm A2.2\n\n\tspan : span in which u lies\n\tu    : parametric point\n\tp    : degree\n\tU    : knot vector\n\n\treturns array[p+1] with basis functions values.\n\t*/\n\tcalcBasisFunctions: function ( span, u, p, U ) {\n\n\t\tvar N = [];\n\t\tvar left = [];\n\t\tvar right = [];\n\t\tN[ 0 ] = 1.0;\n\n\t\tfor ( var j = 1; j <= p; ++ j ) {\n\n\t\t\tleft[ j ] = u - U[ span + 1 - j ];\n\t\t\tright[ j ] = U[ span + j ] - u;\n\n\t\t\tvar saved = 0.0;\n\n\t\t\tfor ( var r = 0; r < j; ++ r ) {\n\n\t\t\t\tvar rv = right[ r + 1 ];\n\t\t\t\tvar lv = left[ j - r ];\n\t\t\t\tvar temp = N[ r ] / ( rv + lv );\n\t\t\t\tN[ r ] = saved + rv * temp;\n\t\t\t\tsaved = lv * temp;\n\n\t\t\t }\n\n\t\t\t N[ j ] = saved;\n\n\t\t }\n\n\t\t return N;\n\n\t},\n\n\n\t/*\n\tCalculate B-Spline curve points. See The NURBS Book, page 82, algorithm A3.1.\n\n\tp : degree of B-Spline\n\tU : knot vector\n\tP : control points (x, y, z, w)\n\tu : parametric point\n\n\treturns point for given u\n\t*/\n\tcalcBSplinePoint: function ( p, U, P, u ) {\n\n\t\tvar span = this.findSpan( p, u, U );\n\t\tvar N = this.calcBasisFunctions( span, u, p, U );\n\t\tvar C = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aw( 0, 0, 0, 0 );\n\n\t\tfor ( var j = 0; j <= p; ++ j ) {\n\n\t\t\tvar point = P[ span - p + j ];\n\t\t\tvar Nj = N[ j ];\n\t\t\tvar wNj = point.w * Nj;\n\t\t\tC.x += point.x * wNj;\n\t\t\tC.y += point.y * wNj;\n\t\t\tC.z += point.z * wNj;\n\t\t\tC.w += point.w * Nj;\n\n\t\t}\n\n\t\treturn C;\n\n\t},\n\n\n\t/*\n\tCalculate basis functions derivatives. See The NURBS Book, page 72, algorithm A2.3.\n\n\tspan : span in which u lies\n\tu    : parametric point\n\tp    : degree\n\tn    : number of derivatives to calculate\n\tU    : knot vector\n\n\treturns array[n+1][p+1] with basis functions derivatives\n\t*/\n\tcalcBasisFunctionDerivatives: function ( span, u, p, n, U ) {\n\n\t\tvar zeroArr = [];\n\t\tfor ( var i = 0; i <= p; ++ i )\n\t\t\tzeroArr[ i ] = 0.0;\n\n\t\tvar ders = [];\n\t\tfor ( var i = 0; i <= n; ++ i )\n\t\t\tders[ i ] = zeroArr.slice( 0 );\n\n\t\tvar ndu = [];\n\t\tfor ( var i = 0; i <= p; ++ i )\n\t\t\tndu[ i ] = zeroArr.slice( 0 );\n\n\t\tndu[ 0 ][ 0 ] = 1.0;\n\n\t\tvar left = zeroArr.slice( 0 );\n\t\tvar right = zeroArr.slice( 0 );\n\n\t\tfor ( var j = 1; j <= p; ++ j ) {\n\n\t\t\tleft[ j ] = u - U[ span + 1 - j ];\n\t\t\tright[ j ] = U[ span + j ] - u;\n\n\t\t\tvar saved = 0.0;\n\n\t\t\tfor ( var r = 0; r < j; ++ r ) {\n\n\t\t\t\tvar rv = right[ r + 1 ];\n\t\t\t\tvar lv = left[ j - r ];\n\t\t\t\tndu[ j ][ r ] = rv + lv;\n\n\t\t\t\tvar temp = ndu[ r ][ j - 1 ] / ndu[ j ][ r ];\n\t\t\t\tndu[ r ][ j ] = saved + rv * temp;\n\t\t\t\tsaved = lv * temp;\n\n\t\t\t}\n\n\t\t\tndu[ j ][ j ] = saved;\n\n\t\t}\n\n\t\tfor ( var j = 0; j <= p; ++ j ) {\n\n\t\t\tders[ 0 ][ j ] = ndu[ j ][ p ];\n\n\t\t}\n\n\t\tfor ( var r = 0; r <= p; ++ r ) {\n\n\t\t\tvar s1 = 0;\n\t\t\tvar s2 = 1;\n\n\t\t\tvar a = [];\n\t\t\tfor ( var i = 0; i <= p; ++ i ) {\n\n\t\t\t\ta[ i ] = zeroArr.slice( 0 );\n\n\t\t\t}\n\n\t\t\ta[ 0 ][ 0 ] = 1.0;\n\n\t\t\tfor ( var k = 1; k <= n; ++ k ) {\n\n\t\t\t\tvar d = 0.0;\n\t\t\t\tvar rk = r - k;\n\t\t\t\tvar pk = p - k;\n\n\t\t\t\tif ( r >= k ) {\n\n\t\t\t\t\ta[ s2 ][ 0 ] = a[ s1 ][ 0 ] / ndu[ pk + 1 ][ rk ];\n\t\t\t\t\td = a[ s2 ][ 0 ] * ndu[ rk ][ pk ];\n\n\t\t\t\t}\n\n\t\t\t\tvar j1 = ( rk >= - 1 ) ? 1 : - rk;\n\t\t\t\tvar j2 = ( r - 1 <= pk ) ? k - 1 : p - r;\n\n\t\t\t\tfor ( var j = j1; j <= j2; ++ j ) {\n\n\t\t\t\t\ta[ s2 ][ j ] = ( a[ s1 ][ j ] - a[ s1 ][ j - 1 ] ) / ndu[ pk + 1 ][ rk + j ];\n\t\t\t\t\td += a[ s2 ][ j ] * ndu[ rk + j ][ pk ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( r <= pk ) {\n\n\t\t\t\t\ta[ s2 ][ k ] = - a[ s1 ][ k - 1 ] / ndu[ pk + 1 ][ r ];\n\t\t\t\t\td += a[ s2 ][ k ] * ndu[ r ][ pk ];\n\n\t\t\t\t}\n\n\t\t\t\tders[ k ][ r ] = d;\n\n\t\t\t\tvar j = s1;\n\t\t\t\ts1 = s2;\n\t\t\t\ts2 = j;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar r = p;\n\n\t\tfor ( var k = 1; k <= n; ++ k ) {\n\n\t\t\tfor ( var j = 0; j <= p; ++ j ) {\n\n\t\t\t\tders[ k ][ j ] *= r;\n\n\t\t\t}\n\n\t\t\tr *= p - k;\n\n\t\t}\n\n\t\treturn ders;\n\n\t},\n\n\n\t/*\n\t\tCalculate derivatives of a B-Spline. See The NURBS Book, page 93, algorithm A3.2.\n\n\t\tp  : degree\n\t\tU  : knot vector\n\t\tP  : control points\n\t\tu  : Parametric points\n\t\tnd : number of derivatives\n\n\t\treturns array[d+1] with derivatives\n\t\t*/\n\tcalcBSplineDerivatives: function ( p, U, P, u, nd ) {\n\n\t\tvar du = nd < p ? nd : p;\n\t\tvar CK = [];\n\t\tvar span = this.findSpan( p, u, U );\n\t\tvar nders = this.calcBasisFunctionDerivatives( span, u, p, du, U );\n\t\tvar Pw = [];\n\n\t\tfor ( var i = 0; i < P.length; ++ i ) {\n\n\t\t\tvar point = P[ i ].clone();\n\t\t\tvar w = point.w;\n\n\t\t\tpoint.x *= w;\n\t\t\tpoint.y *= w;\n\t\t\tpoint.z *= w;\n\n\t\t\tPw[ i ] = point;\n\n\t\t}\n\n\t\tfor ( var k = 0; k <= du; ++ k ) {\n\n\t\t\tvar point = Pw[ span - p ].clone().multiplyScalar( nders[ k ][ 0 ] );\n\n\t\t\tfor ( var j = 1; j <= p; ++ j ) {\n\n\t\t\t\tpoint.add( Pw[ span - p + j ].clone().multiplyScalar( nders[ k ][ j ] ) );\n\n\t\t\t}\n\n\t\t\tCK[ k ] = point;\n\n\t\t}\n\n\t\tfor ( var k = du + 1; k <= nd + 1; ++ k ) {\n\n\t\t\tCK[ k ] = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aw( 0, 0, 0 );\n\n\t\t}\n\n\t\treturn CK;\n\n\t},\n\n\n\t/*\n\tCalculate \"K over I\"\n\n\treturns k!/(i!(k-i)!)\n\t*/\n\tcalcKoverI: function ( k, i ) {\n\n\t\tvar nom = 1;\n\n\t\tfor ( var j = 2; j <= k; ++ j ) {\n\n\t\t\tnom *= j;\n\n\t\t}\n\n\t\tvar denom = 1;\n\n\t\tfor ( var j = 2; j <= i; ++ j ) {\n\n\t\t\tdenom *= j;\n\n\t\t}\n\n\t\tfor ( var j = 2; j <= k - i; ++ j ) {\n\n\t\t\tdenom *= j;\n\n\t\t}\n\n\t\treturn nom / denom;\n\n\t},\n\n\n\t/*\n\tCalculate derivatives (0-nd) of rational curve. See The NURBS Book, page 127, algorithm A4.2.\n\n\tPders : result of function calcBSplineDerivatives\n\n\treturns array with derivatives for rational curve.\n\t*/\n\tcalcRationalCurveDerivatives: function ( Pders ) {\n\n\t\tvar nd = Pders.length;\n\t\tvar Aders = [];\n\t\tvar wders = [];\n\n\t\tfor ( var i = 0; i < nd; ++ i ) {\n\n\t\t\tvar point = Pders[ i ];\n\t\t\tAders[ i ] = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V( point.x, point.y, point.z );\n\t\t\twders[ i ] = point.w;\n\n\t\t}\n\n\t\tvar CK = [];\n\n\t\tfor ( var k = 0; k < nd; ++ k ) {\n\n\t\t\tvar v = Aders[ k ].clone();\n\n\t\t\tfor ( var i = 1; i <= k; ++ i ) {\n\n\t\t\t\tv.sub( CK[ k - i ].clone().multiplyScalar( this.calcKoverI( k, i ) * wders[ i ] ) );\n\n\t\t\t}\n\n\t\t\tCK[ k ] = v.divideScalar( wders[ 0 ] );\n\n\t\t}\n\n\t\treturn CK;\n\n\t},\n\n\n\t/*\n\tCalculate NURBS curve derivatives. See The NURBS Book, page 127, algorithm A4.2.\n\n\tp  : degree\n\tU  : knot vector\n\tP  : control points in homogeneous space\n\tu  : parametric points\n\tnd : number of derivatives\n\n\treturns array with derivatives.\n\t*/\n\tcalcNURBSDerivatives: function ( p, U, P, u, nd ) {\n\n\t\tvar Pders = this.calcBSplineDerivatives( p, U, P, u, nd );\n\t\treturn this.calcRationalCurveDerivatives( Pders );\n\n\t},\n\n\n\t/*\n\tCalculate rational B-Spline surface point. See The NURBS Book, page 134, algorithm A4.3.\n\n\tp1, p2 : degrees of B-Spline surface\n\tU1, U2 : knot vectors\n\tP      : control points (x, y, z, w)\n\tu, v   : parametric values\n\n\treturns point for given (u, v)\n\t*/\n\tcalcSurfacePoint: function ( p, q, U, V, P, u, v, target ) {\n\n\t\tvar uspan = this.findSpan( p, u, U );\n\t\tvar vspan = this.findSpan( q, v, V );\n\t\tvar Nu = this.calcBasisFunctions( uspan, u, p, U );\n\t\tvar Nv = this.calcBasisFunctions( vspan, v, q, V );\n\t\tvar temp = [];\n\n\t\tfor ( var l = 0; l <= q; ++ l ) {\n\n\t\t\ttemp[ l ] = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aw( 0, 0, 0, 0 );\n\t\t\tfor ( var k = 0; k <= p; ++ k ) {\n\n\t\t\t\tvar point = P[ uspan - p + k ][ vspan - q + l ].clone();\n\t\t\t\tvar w = point.w;\n\t\t\t\tpoint.x *= w;\n\t\t\t\tpoint.y *= w;\n\t\t\t\tpoint.z *= w;\n\t\t\t\ttemp[ l ].add( point.multiplyScalar( Nu[ k ] ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar Sw = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aw( 0, 0, 0, 0 );\n\t\tfor ( var l = 0; l <= q; ++ l ) {\n\n\t\t\tSw.add( temp[ l ].multiplyScalar( Nv[ l ] ) );\n\n\t\t}\n\n\t\tSw.divideScalar( Sw.w );\n\t\ttarget.set( Sw.x, Sw.y, Sw.z );\n\n\t}\n\n};\n\n/**\n * NURBS curve object\n *\n * Derives from Curve, overriding getPoint and getTangent.\n *\n * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\n *\n **/\n\nvar NURBSCurve = function ( degree, knots /* array of reals */, controlPoints /* array of Vector(2|3|4) */, startKnot /* index in knots */, endKnot /* index in knots */ ) {\n\n\t_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.ax.call( this );\n\n\tthis.degree = degree;\n\tthis.knots = knots;\n\tthis.controlPoints = [];\n\t// Used by periodic NURBS to remove hidden spans\n\tthis.startKnot = startKnot || 0;\n\tthis.endKnot = endKnot || ( this.knots.length - 1 );\n\tfor ( var i = 0; i < controlPoints.length; ++ i ) {\n\n\t\t// ensure Vector4 for control points\n\t\tvar point = controlPoints[ i ];\n\t\tthis.controlPoints[ i ] = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aw( point.x, point.y, point.z, point.w );\n\n\t}\n\n};\n\n\nNURBSCurve.prototype = Object.create( _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.ax.prototype );\nNURBSCurve.prototype.constructor = NURBSCurve;\n\n\nNURBSCurve.prototype.getPoint = function ( t, optionalTarget ) {\n\n\tvar point = optionalTarget || new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\tvar u = this.knots[ this.startKnot ] + t * ( this.knots[ this.endKnot ] - this.knots[ this.startKnot ] ); // linear mapping t->u\n\n\t// following results in (wx, wy, wz, w) homogeneous point\n\tvar hpoint = NURBSUtils.calcBSplinePoint( this.degree, this.knots, this.controlPoints, u );\n\n\tif ( hpoint.w != 1.0 ) {\n\n\t\t// project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\n\t\thpoint.divideScalar( hpoint.w );\n\n\t}\n\n\treturn point.set( hpoint.x, hpoint.y, hpoint.z );\n\n};\n\n\nNURBSCurve.prototype.getTangent = function ( t, optionalTarget ) {\n\n\tvar tangent = optionalTarget || new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\tvar u = this.knots[ 0 ] + t * ( this.knots[ this.knots.length - 1 ] - this.knots[ 0 ] );\n\tvar ders = NURBSUtils.calcNURBSDerivatives( this.degree, this.knots, this.controlPoints, u, 1 );\n\ttangent.copy( ders[ 1 ] ).normalize();\n\n\treturn tangent;\n\n};\n\n/**\n * Loader loads FBX file and generates Group representing FBX scene.\n * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format\n * Versions lower than this may load but will probably have errors\n *\n * Needs Support:\n *  Morph normals / blend shape normals\n *\n * FBX format references:\n * \thttps://wiki.blender.org/index.php/User:Mont29/Foundation/FBX_File_Structure\n * \thttp://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)\n *\n * \tBinary format specification:\n *\t\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\n */\n\n\nvar FBXLoader = ( function () {\n\n\tvar fbxTree;\n\tvar connections;\n\tvar sceneGraph;\n\n\tfunction FBXLoader( manager ) {\n\n\t\t_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n\t}\n\n\tFBXLoader.prototype = Object.assign( Object.create( _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\t\tconstructor: FBXLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar path = ( scope.path === '' ) ? _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.f.extractUrlBase( url ) : scope.path;\n\n\t\t\tvar loader = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.F( this.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.setRequestHeader( scope.requestHeader );\n\t\t\tloader.setWithCredentials( scope.withCredentials );\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tonLoad( scope.parse( buffer, path ) );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tif ( onError ) {\n\n\t\t\t\t\t\tonError( e );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( FBXBuffer, path ) {\n\n\t\t\tif ( isFbxFormatBinary( FBXBuffer ) ) {\n\n\t\t\t\tfbxTree = new BinaryParser().parse( FBXBuffer );\n\n\t\t\t} else {\n\n\t\t\t\tvar FBXText = convertArrayBufferToString( FBXBuffer );\n\n\t\t\t\tif ( ! isFbxFormatASCII( FBXText ) ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.FBXLoader: Unknown format.' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( getFbxVersion( FBXText ) < 7000 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion( FBXText ) );\n\n\t\t\t\t}\n\n\t\t\t\tfbxTree = new TextParser().parse( FBXText );\n\n\t\t\t}\n\n\t\t\t// console.log( fbxTree );\n\n\t\t\tvar textureLoader = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.j( this.manager ).setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\t\treturn new FBXTreeParser( textureLoader, this.manager ).parse( fbxTree );\n\n\t\t}\n\n\t} );\n\n\t// Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group\n\tfunction FBXTreeParser( textureLoader, manager ) {\n\n\t\tthis.textureLoader = textureLoader;\n\t\tthis.manager = manager;\n\n\t}\n\n\tFBXTreeParser.prototype = {\n\n\t\tconstructor: FBXTreeParser,\n\n\t\tparse: function () {\n\n\t\t\tconnections = this.parseConnections();\n\n\t\t\tvar images = this.parseImages();\n\t\t\tvar textures = this.parseTextures( images );\n\t\t\tvar materials = this.parseMaterials( textures );\n\t\t\tvar deformers = this.parseDeformers();\n\t\t\tvar geometryMap = new GeometryParser().parse( deformers );\n\n\t\t\tthis.parseScene( deformers, geometryMap, materials );\n\n\t\t\treturn sceneGraph;\n\n\t\t},\n\n\t\t// Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n\t\t// and details the connection type\n\t\tparseConnections: function () {\n\n\t\t\tvar connectionMap = new Map();\n\n\t\t\tif ( 'Connections' in fbxTree ) {\n\n\t\t\t\tvar rawConnections = fbxTree.Connections.connections;\n\n\t\t\t\trawConnections.forEach( function ( rawConnection ) {\n\n\t\t\t\t\tvar fromID = rawConnection[ 0 ];\n\t\t\t\t\tvar toID = rawConnection[ 1 ];\n\t\t\t\t\tvar relationship = rawConnection[ 2 ];\n\n\t\t\t\t\tif ( ! connectionMap.has( fromID ) ) {\n\n\t\t\t\t\t\tconnectionMap.set( fromID, {\n\t\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\t\tchildren: []\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar parentRelationship = { ID: toID, relationship: relationship };\n\t\t\t\t\tconnectionMap.get( fromID ).parents.push( parentRelationship );\n\n\t\t\t\t\tif ( ! connectionMap.has( toID ) ) {\n\n\t\t\t\t\t\tconnectionMap.set( toID, {\n\t\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\t\tchildren: []\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar childRelationship = { ID: fromID, relationship: relationship };\n\t\t\t\t\tconnectionMap.get( toID ).children.push( childRelationship );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn connectionMap;\n\n\t\t},\n\n\t\t// Parse FBXTree.Objects.Video for embedded image data\n\t\t// These images are connected to textures in FBXTree.Objects.Textures\n\t\t// via FBXTree.Connections.\n\t\tparseImages: function () {\n\n\t\t\tvar images = {};\n\t\t\tvar blobs = {};\n\n\t\t\tif ( 'Video' in fbxTree.Objects ) {\n\n\t\t\t\tvar videoNodes = fbxTree.Objects.Video;\n\n\t\t\t\tfor ( var nodeID in videoNodes ) {\n\n\t\t\t\t\tvar videoNode = videoNodes[ nodeID ];\n\n\t\t\t\t\tvar id = parseInt( nodeID );\n\n\t\t\t\t\timages[ id ] = videoNode.RelativeFilename || videoNode.Filename;\n\n\t\t\t\t\t// raw image data is in videoNode.Content\n\t\t\t\t\tif ( 'Content' in videoNode ) {\n\n\t\t\t\t\t\tvar arrayBufferContent = ( videoNode.Content instanceof ArrayBuffer ) && ( videoNode.Content.byteLength > 0 );\n\t\t\t\t\t\tvar base64Content = ( typeof videoNode.Content === 'string' ) && ( videoNode.Content !== '' );\n\n\t\t\t\t\t\tif ( arrayBufferContent || base64Content ) {\n\n\t\t\t\t\t\t\tvar image = this.parseImage( videoNodes[ nodeID ] );\n\n\t\t\t\t\t\t\tblobs[ videoNode.RelativeFilename || videoNode.Filename ] = image;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( var id in images ) {\n\n\t\t\t\tvar filename = images[ id ];\n\n\t\t\t\tif ( blobs[ filename ] !== undefined ) images[ id ] = blobs[ filename ];\n\t\t\t\telse images[ id ] = images[ id ].split( '\\\\' ).pop();\n\n\t\t\t}\n\n\t\t\treturn images;\n\n\t\t},\n\n\t\t// Parse embedded image data in FBXTree.Video.Content\n\t\tparseImage: function ( videoNode ) {\n\n\t\t\tvar content = videoNode.Content;\n\t\t\tvar fileName = videoNode.RelativeFilename || videoNode.Filename;\n\t\t\tvar extension = fileName.slice( fileName.lastIndexOf( '.' ) + 1 ).toLowerCase();\n\n\t\t\tvar type;\n\n\t\t\tswitch ( extension ) {\n\n\t\t\t\tcase 'bmp':\n\n\t\t\t\t\ttype = 'image/bmp';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'jpg':\n\t\t\t\tcase 'jpeg':\n\n\t\t\t\t\ttype = 'image/jpeg';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'png':\n\n\t\t\t\t\ttype = 'image/png';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'tif':\n\n\t\t\t\t\ttype = 'image/tiff';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'tga':\n\n\t\t\t\t\tif ( this.manager.getHandler( '.tga' ) === null ) {\n\n\t\t\t\t\t\tconsole.warn( 'FBXLoader: TGA loader not found, skipping ', fileName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttype = 'image/tga';\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tconsole.warn( 'FBXLoader: Image type \"' + extension + '\" is not supported.' );\n\t\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( typeof content === 'string' ) { // ASCII format\n\n\t\t\t\treturn 'data:' + type + ';base64,' + content;\n\n\t\t\t} else { // Binary Format\n\n\t\t\t\tvar array = new Uint8Array( content );\n\t\t\t\treturn window.URL.createObjectURL( new Blob( [ array ], { type: type } ) );\n\n\t\t\t}\n\n\t\t},\n\n\t\t// Parse nodes in FBXTree.Objects.Texture\n\t\t// These contain details such as UV scaling, cropping, rotation etc and are connected\n\t\t// to images in FBXTree.Objects.Video\n\t\tparseTextures: function ( images ) {\n\n\t\t\tvar textureMap = new Map();\n\n\t\t\tif ( 'Texture' in fbxTree.Objects ) {\n\n\t\t\t\tvar textureNodes = fbxTree.Objects.Texture;\n\t\t\t\tfor ( var nodeID in textureNodes ) {\n\n\t\t\t\t\tvar texture = this.parseTexture( textureNodes[ nodeID ], images );\n\t\t\t\t\ttextureMap.set( parseInt( nodeID ), texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn textureMap;\n\n\t\t},\n\n\t\t// Parse individual node in FBXTree.Objects.Texture\n\t\tparseTexture: function ( textureNode, images ) {\n\n\t\t\tvar texture = this.loadTexture( textureNode, images );\n\n\t\t\ttexture.ID = textureNode.id;\n\n\t\t\ttexture.name = textureNode.attrName;\n\n\t\t\tvar wrapModeU = textureNode.WrapModeU;\n\t\t\tvar wrapModeV = textureNode.WrapModeV;\n\n\t\t\tvar valueU = wrapModeU !== undefined ? wrapModeU.value : 0;\n\t\t\tvar valueV = wrapModeV !== undefined ? wrapModeV.value : 0;\n\n\t\t\t// http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\n\t\t\t// 0: repeat(default), 1: clamp\n\n\t\t\ttexture.wrapS = valueU === 0 ? _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.o : _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a5;\n\t\t\ttexture.wrapT = valueV === 0 ? _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.o : _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a5;\n\n\t\t\tif ( 'Scaling' in textureNode ) {\n\n\t\t\t\tvar values = textureNode.Scaling.value;\n\n\t\t\t\ttexture.repeat.x = values[ 0 ];\n\t\t\t\ttexture.repeat.y = values[ 1 ];\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\t// load a texture specified as a blob or data URI, or via an external URL using TextureLoader\n\t\tloadTexture: function ( textureNode, images ) {\n\n\t\t\tvar fileName;\n\n\t\t\tvar currentPath = this.textureLoader.path;\n\n\t\t\tvar children = connections.get( textureNode.id ).children;\n\n\t\t\tif ( children !== undefined && children.length > 0 && images[ children[ 0 ].ID ] !== undefined ) {\n\n\t\t\t\tfileName = images[ children[ 0 ].ID ];\n\n\t\t\t\tif ( fileName.indexOf( 'blob:' ) === 0 || fileName.indexOf( 'data:' ) === 0 ) {\n\n\t\t\t\t\tthis.textureLoader.setPath( undefined );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar texture;\n\n\t\t\tvar extension = textureNode.FileName.slice( - 3 ).toLowerCase();\n\n\t\t\tif ( extension === 'tga' ) {\n\n\t\t\t\tvar loader = this.manager.getHandler( '.tga' );\n\n\t\t\t\tif ( loader === null ) {\n\n\t\t\t\t\tconsole.warn( 'FBXLoader: TGA loader not found, creating placeholder texture for', textureNode.RelativeFilename );\n\t\t\t\t\ttexture = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.ah();\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture = loader.load( fileName );\n\n\t\t\t\t}\n\n\t\t\t} else if ( extension === 'psd' ) {\n\n\t\t\t\tconsole.warn( 'FBXLoader: PSD textures are not supported, creating placeholder texture for', textureNode.RelativeFilename );\n\t\t\t\ttexture = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.ah();\n\n\t\t\t} else {\n\n\t\t\t\ttexture = this.textureLoader.load( fileName );\n\n\t\t\t}\n\n\t\t\tthis.textureLoader.setPath( currentPath );\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\t// Parse nodes in FBXTree.Objects.Material\n\t\tparseMaterials: function ( textureMap ) {\n\n\t\t\tvar materialMap = new Map();\n\n\t\t\tif ( 'Material' in fbxTree.Objects ) {\n\n\t\t\t\tvar materialNodes = fbxTree.Objects.Material;\n\n\t\t\t\tfor ( var nodeID in materialNodes ) {\n\n\t\t\t\t\tvar material = this.parseMaterial( materialNodes[ nodeID ], textureMap );\n\n\t\t\t\t\tif ( material !== null ) materialMap.set( parseInt( nodeID ), material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn materialMap;\n\n\t\t},\n\n\t\t// Parse single node in FBXTree.Objects.Material\n\t\t// Materials are connected to texture maps in FBXTree.Objects.Textures\n\t\t// FBX format currently only supports Lambert and Phong shading models\n\t\tparseMaterial: function ( materialNode, textureMap ) {\n\n\t\t\tvar ID = materialNode.id;\n\t\t\tvar name = materialNode.attrName;\n\t\t\tvar type = materialNode.ShadingModel;\n\n\t\t\t// Case where FBX wraps shading model in property object.\n\t\t\tif ( typeof type === 'object' ) {\n\n\t\t\t\ttype = type.value;\n\n\t\t\t}\n\n\t\t\t// Ignore unused materials which don't have any connections.\n\t\t\tif ( ! connections.has( ID ) ) return null;\n\n\t\t\tvar parameters = this.parseParameters( materialNode, textureMap, ID );\n\n\t\t\tvar material;\n\n\t\t\tswitch ( type.toLowerCase() ) {\n\n\t\t\t\tcase 'phong':\n\t\t\t\t\tmaterial = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.al();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'lambert':\n\t\t\t\t\tmaterial = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.ak();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type );\n\t\t\t\t\tmaterial = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.al();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tmaterial.setValues( parameters );\n\t\t\tmaterial.name = name;\n\n\t\t\treturn material;\n\n\t\t},\n\n\t\t// Parse FBX material and return parameters suitable for a three.js material\n\t\t// Also parse the texture map and return any textures associated with the material\n\t\tparseParameters: function ( materialNode, textureMap, ID ) {\n\n\t\t\tvar parameters = {};\n\n\t\t\tif ( materialNode.BumpFactor ) {\n\n\t\t\t\tparameters.bumpScale = materialNode.BumpFactor.value;\n\n\t\t\t}\n\n\t\t\tif ( materialNode.Diffuse ) {\n\n\t\t\t\tparameters.color = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( materialNode.Diffuse.value );\n\n\t\t\t} else if ( materialNode.DiffuseColor && ( materialNode.DiffuseColor.type === 'Color' || materialNode.DiffuseColor.type === 'ColorRGB' ) ) {\n\n\t\t\t\t// The blender exporter exports diffuse here instead of in materialNode.Diffuse\n\t\t\t\tparameters.color = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( materialNode.DiffuseColor.value );\n\n\t\t\t}\n\n\t\t\tif ( materialNode.DisplacementFactor ) {\n\n\t\t\t\tparameters.displacementScale = materialNode.DisplacementFactor.value;\n\n\t\t\t}\n\n\t\t\tif ( materialNode.Emissive ) {\n\n\t\t\t\tparameters.emissive = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( materialNode.Emissive.value );\n\n\t\t\t} else if ( materialNode.EmissiveColor && ( materialNode.EmissiveColor.type === 'Color' || materialNode.EmissiveColor.type === 'ColorRGB' ) ) {\n\n\t\t\t\t// The blender exporter exports emissive color here instead of in materialNode.Emissive\n\t\t\t\tparameters.emissive = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( materialNode.EmissiveColor.value );\n\n\t\t\t}\n\n\t\t\tif ( materialNode.EmissiveFactor ) {\n\n\t\t\t\tparameters.emissiveIntensity = parseFloat( materialNode.EmissiveFactor.value );\n\n\t\t\t}\n\n\t\t\tif ( materialNode.Opacity ) {\n\n\t\t\t\tparameters.opacity = parseFloat( materialNode.Opacity.value );\n\n\t\t\t}\n\n\t\t\tif ( parameters.opacity < 1.0 ) {\n\n\t\t\t\tparameters.transparent = true;\n\n\t\t\t}\n\n\t\t\tif ( materialNode.ReflectionFactor ) {\n\n\t\t\t\tparameters.reflectivity = materialNode.ReflectionFactor.value;\n\n\t\t\t}\n\n\t\t\tif ( materialNode.Shininess ) {\n\n\t\t\t\tparameters.shininess = materialNode.Shininess.value;\n\n\t\t\t}\n\n\t\t\tif ( materialNode.Specular ) {\n\n\t\t\t\tparameters.specular = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( materialNode.Specular.value );\n\n\t\t\t} else if ( materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color' ) {\n\n\t\t\t\t// The blender exporter exports specular color here instead of in materialNode.Specular\n\t\t\t\tparameters.specular = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( materialNode.SpecularColor.value );\n\n\t\t\t}\n\n\t\t\tvar scope = this;\n\t\t\tconnections.get( ID ).children.forEach( function ( child ) {\n\n\t\t\t\tvar type = child.relationship;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'Bump':\n\t\t\t\t\t\tparameters.bumpMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Maya|TEX_ao_map':\n\t\t\t\t\t\tparameters.aoMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DiffuseColor':\n\t\t\t\t\tcase 'Maya|TEX_color_map':\n\t\t\t\t\t\tparameters.map = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\t\tparameters.map.encoding = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.s;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DisplacementColor':\n\t\t\t\t\t\tparameters.displacementMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'EmissiveColor':\n\t\t\t\t\t\tparameters.emissiveMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\t\tparameters.emissiveMap.encoding = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.s;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'NormalMap':\n\t\t\t\t\tcase 'Maya|TEX_normal_map':\n\t\t\t\t\t\tparameters.normalMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ReflectionColor':\n\t\t\t\t\t\tparameters.envMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\t\tparameters.envMap.mapping = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.ay;\n\t\t\t\t\t\tparameters.envMap.encoding = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.s;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SpecularColor':\n\t\t\t\t\t\tparameters.specularMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\t\tparameters.specularMap.encoding = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.s;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TransparentColor':\n\t\t\t\t\tcase 'TransparencyFactor':\n\t\t\t\t\t\tparameters.alphaMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\t\tparameters.transparent = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'AmbientColor':\n\t\t\t\t\tcase 'ShininessExponent': // AKA glossiness map\n\t\t\t\t\tcase 'SpecularFactor': // AKA specularLevel\n\t\t\t\t\tcase 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn parameters;\n\n\t\t},\n\n\t\t// get a texture from the textureMap for use by a material.\n\t\tgetTexture: function ( textureMap, id ) {\n\n\t\t\t// if the texture is a layered texture, just use the first layer and issue a warning\n\t\t\tif ( 'LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture ) {\n\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.' );\n\t\t\t\tid = connections.get( id ).children[ 0 ].ID;\n\n\t\t\t}\n\n\t\t\treturn textureMap.get( id );\n\n\t\t},\n\n\t\t// Parse nodes in FBXTree.Objects.Deformer\n\t\t// Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n\t\t// Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n\t\tparseDeformers: function () {\n\n\t\t\tvar skeletons = {};\n\t\t\tvar morphTargets = {};\n\n\t\t\tif ( 'Deformer' in fbxTree.Objects ) {\n\n\t\t\t\tvar DeformerNodes = fbxTree.Objects.Deformer;\n\n\t\t\t\tfor ( var nodeID in DeformerNodes ) {\n\n\t\t\t\t\tvar deformerNode = DeformerNodes[ nodeID ];\n\n\t\t\t\t\tvar relationships = connections.get( parseInt( nodeID ) );\n\n\t\t\t\t\tif ( deformerNode.attrType === 'Skin' ) {\n\n\t\t\t\t\t\tvar skeleton = this.parseSkeleton( relationships, DeformerNodes );\n\t\t\t\t\t\tskeleton.ID = nodeID;\n\n\t\t\t\t\t\tif ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: skeleton attached to more than one geometry is not supported.' );\n\t\t\t\t\t\tskeleton.geometryID = relationships.parents[ 0 ].ID;\n\n\t\t\t\t\t\tskeletons[ nodeID ] = skeleton;\n\n\t\t\t\t\t} else if ( deformerNode.attrType === 'BlendShape' ) {\n\n\t\t\t\t\t\tvar morphTarget = {\n\t\t\t\t\t\t\tid: nodeID,\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tmorphTarget.rawTargets = this.parseMorphTargets( relationships, DeformerNodes );\n\t\t\t\t\t\tmorphTarget.id = nodeID;\n\n\t\t\t\t\t\tif ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: morph target attached to more than one geometry is not supported.' );\n\n\t\t\t\t\t\tmorphTargets[ nodeID ] = morphTarget;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\n\t\t\t\tskeletons: skeletons,\n\t\t\t\tmorphTargets: morphTargets,\n\n\t\t\t};\n\n\t\t},\n\n\t\t// Parse single nodes in FBXTree.Objects.Deformer\n\t\t// The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\n\t\t// Each skin node represents a skeleton and each cluster node represents a bone\n\t\tparseSkeleton: function ( relationships, deformerNodes ) {\n\n\t\t\tvar rawBones = [];\n\n\t\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\t\tvar boneNode = deformerNodes[ child.ID ];\n\n\t\t\t\tif ( boneNode.attrType !== 'Cluster' ) return;\n\n\t\t\t\tvar rawBone = {\n\n\t\t\t\t\tID: child.ID,\n\t\t\t\t\tindices: [],\n\t\t\t\t\tweights: [],\n\t\t\t\t\ttransformLink: new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W().fromArray( boneNode.TransformLink.a ),\n\t\t\t\t\t// transform: new Matrix4().fromArray( boneNode.Transform.a ),\n\t\t\t\t\t// linkMode: boneNode.Mode,\n\n\t\t\t\t};\n\n\t\t\t\tif ( 'Indexes' in boneNode ) {\n\n\t\t\t\t\trawBone.indices = boneNode.Indexes.a;\n\t\t\t\t\trawBone.weights = boneNode.Weights.a;\n\n\t\t\t\t}\n\n\t\t\t\trawBones.push( rawBone );\n\n\t\t\t} );\n\n\t\t\treturn {\n\n\t\t\t\trawBones: rawBones,\n\t\t\t\tbones: []\n\n\t\t\t};\n\n\t\t},\n\n\t\t// The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\n\t\tparseMorphTargets: function ( relationships, deformerNodes ) {\n\n\t\t\tvar rawMorphTargets = [];\n\n\t\t\tfor ( var i = 0; i < relationships.children.length; i ++ ) {\n\n\t\t\t\tvar child = relationships.children[ i ];\n\n\t\t\t\tvar morphTargetNode = deformerNodes[ child.ID ];\n\n\t\t\t\tvar rawMorphTarget = {\n\n\t\t\t\t\tname: morphTargetNode.attrName,\n\t\t\t\t\tinitialWeight: morphTargetNode.DeformPercent,\n\t\t\t\t\tid: morphTargetNode.id,\n\t\t\t\t\tfullWeights: morphTargetNode.FullWeights.a\n\n\t\t\t\t};\n\n\t\t\t\tif ( morphTargetNode.attrType !== 'BlendShapeChannel' ) return;\n\n\t\t\t\trawMorphTarget.geoID = connections.get( parseInt( child.ID ) ).children.filter( function ( child ) {\n\n\t\t\t\t\treturn child.relationship === undefined;\n\n\t\t\t\t} )[ 0 ].ID;\n\n\t\t\t\trawMorphTargets.push( rawMorphTarget );\n\n\t\t\t}\n\n\t\t\treturn rawMorphTargets;\n\n\t\t},\n\n\t\t// create the main Group() to be returned by the loader\n\t\tparseScene: function ( deformers, geometryMap, materialMap ) {\n\n\t\t\tsceneGraph = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\n\t\t\tvar modelMap = this.parseModels( deformers.skeletons, geometryMap, materialMap );\n\n\t\t\tvar modelNodes = fbxTree.Objects.Model;\n\n\t\t\tvar scope = this;\n\t\t\tmodelMap.forEach( function ( model ) {\n\n\t\t\t\tvar modelNode = modelNodes[ model.ID ];\n\t\t\t\tscope.setLookAtProperties( model, modelNode );\n\n\t\t\t\tvar parentConnections = connections.get( model.ID ).parents;\n\n\t\t\t\tparentConnections.forEach( function ( connection ) {\n\n\t\t\t\t\tvar parent = modelMap.get( connection.ID );\n\t\t\t\t\tif ( parent !== undefined ) parent.add( model );\n\n\t\t\t\t} );\n\n\t\t\t\tif ( model.parent === null ) {\n\n\t\t\t\t\tsceneGraph.add( model );\n\n\t\t\t\t}\n\n\n\t\t\t} );\n\n\t\t\tthis.bindSkeleton( deformers.skeletons, geometryMap, modelMap );\n\n\t\t\tthis.createAmbientLight();\n\n\t\t\tthis.setupMorphMaterials();\n\n\t\t\tsceneGraph.traverse( function ( node ) {\n\n\t\t\t\tif ( node.userData.transformData ) {\n\n\t\t\t\t\tif ( node.parent ) {\n\n\t\t\t\t\t\tnode.userData.transformData.parentMatrix = node.parent.matrix;\n\t\t\t\t\t\tnode.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar transform = generateTransform( node.userData.transformData );\n\n\t\t\t\t\tnode.applyMatrix4( transform );\n\t\t\t\t\tnode.updateWorldMatrix();\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tvar animations = new AnimationParser().parse();\n\n\t\t\t// if all the models where already combined in a single group, just return that\n\t\t\tif ( sceneGraph.children.length === 1 && sceneGraph.children[ 0 ].isGroup ) {\n\n\t\t\t\tsceneGraph.children[ 0 ].animations = animations;\n\t\t\t\tsceneGraph = sceneGraph.children[ 0 ];\n\n\t\t\t}\n\n\t\t\tsceneGraph.animations = animations;\n\n\t\t},\n\n\t\t// parse nodes in FBXTree.Objects.Model\n\t\tparseModels: function ( skeletons, geometryMap, materialMap ) {\n\n\t\t\tvar modelMap = new Map();\n\t\t\tvar modelNodes = fbxTree.Objects.Model;\n\n\t\t\tfor ( var nodeID in modelNodes ) {\n\n\t\t\t\tvar id = parseInt( nodeID );\n\t\t\t\tvar node = modelNodes[ nodeID ];\n\t\t\t\tvar relationships = connections.get( id );\n\n\t\t\t\tvar model = this.buildSkeleton( relationships, skeletons, id, node.attrName );\n\n\t\t\t\tif ( ! model ) {\n\n\t\t\t\t\tswitch ( node.attrType ) {\n\n\t\t\t\t\t\tcase 'Camera':\n\t\t\t\t\t\t\tmodel = this.createCamera( relationships );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Light':\n\t\t\t\t\t\t\tmodel = this.createLight( relationships );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Mesh':\n\t\t\t\t\t\t\tmodel = this.createMesh( relationships, geometryMap, materialMap );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'NurbsCurve':\n\t\t\t\t\t\t\tmodel = this.createCurve( relationships, geometryMap );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'LimbNode':\n\t\t\t\t\t\tcase 'Root':\n\t\t\t\t\t\t\tmodel = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.N();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Null':\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tmodel = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmodel.name = node.attrName ? _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.r.sanitizeNodeName( node.attrName ) : '';\n\n\t\t\t\t\tmodel.ID = id;\n\n\t\t\t\t}\n\n\t\t\t\tthis.getTransformData( model, node );\n\t\t\t\tmodelMap.set( id, model );\n\n\t\t\t}\n\n\t\t\treturn modelMap;\n\n\t\t},\n\n\t\tbuildSkeleton: function ( relationships, skeletons, id, name ) {\n\n\t\t\tvar bone = null;\n\n\t\t\trelationships.parents.forEach( function ( parent ) {\n\n\t\t\t\tfor ( var ID in skeletons ) {\n\n\t\t\t\t\tvar skeleton = skeletons[ ID ];\n\n\t\t\t\t\tskeleton.rawBones.forEach( function ( rawBone, i ) {\n\n\t\t\t\t\t\tif ( rawBone.ID === parent.ID ) {\n\n\t\t\t\t\t\t\tvar subBone = bone;\n\t\t\t\t\t\t\tbone = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.N();\n\n\t\t\t\t\t\t\tbone.matrixWorld.copy( rawBone.transformLink );\n\n\t\t\t\t\t\t\t// set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id\n\n\t\t\t\t\t\t\tbone.name = name ? _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.r.sanitizeNodeName( name ) : '';\n\t\t\t\t\t\t\tbone.ID = id;\n\n\t\t\t\t\t\t\tskeleton.bones[ i ] = bone;\n\n\t\t\t\t\t\t\t// In cases where a bone is shared between multiple meshes\n\t\t\t\t\t\t\t// duplicate the bone here and and it as a child of the first bone\n\t\t\t\t\t\t\tif ( subBone !== null ) {\n\n\t\t\t\t\t\t\t\tbone.add( subBone );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn bone;\n\n\t\t},\n\n\t\t// create a PerspectiveCamera or OrthographicCamera\n\t\tcreateCamera: function ( relationships ) {\n\n\t\t\tvar model;\n\t\t\tvar cameraAttribute;\n\n\t\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\t\tvar attr = fbxTree.Objects.NodeAttribute[ child.ID ];\n\n\t\t\t\tif ( attr !== undefined ) {\n\n\t\t\t\t\tcameraAttribute = attr;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tif ( cameraAttribute === undefined ) {\n\n\t\t\t\tmodel = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.U();\n\n\t\t\t} else {\n\n\t\t\t\tvar type = 0;\n\t\t\t\tif ( cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1 ) {\n\n\t\t\t\t\ttype = 1;\n\n\t\t\t\t}\n\n\t\t\t\tvar nearClippingPlane = 1;\n\t\t\t\tif ( cameraAttribute.NearPlane !== undefined ) {\n\n\t\t\t\t\tnearClippingPlane = cameraAttribute.NearPlane.value / 1000;\n\n\t\t\t\t}\n\n\t\t\t\tvar farClippingPlane = 1000;\n\t\t\t\tif ( cameraAttribute.FarPlane !== undefined ) {\n\n\t\t\t\t\tfarClippingPlane = cameraAttribute.FarPlane.value / 1000;\n\n\t\t\t\t}\n\n\n\t\t\t\tvar width = window.innerWidth;\n\t\t\t\tvar height = window.innerHeight;\n\n\t\t\t\tif ( cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined ) {\n\n\t\t\t\t\twidth = cameraAttribute.AspectWidth.value;\n\t\t\t\t\theight = cameraAttribute.AspectHeight.value;\n\n\t\t\t\t}\n\n\t\t\t\tvar aspect = width / height;\n\n\t\t\t\tvar fov = 45;\n\t\t\t\tif ( cameraAttribute.FieldOfView !== undefined ) {\n\n\t\t\t\t\tfov = cameraAttribute.FieldOfView.value;\n\n\t\t\t\t}\n\n\t\t\t\tvar focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 0: // Perspective\n\t\t\t\t\t\tmodel = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.A( fov, aspect, nearClippingPlane, farClippingPlane );\n\t\t\t\t\t\tif ( focalLength !== null ) model.setFocalLength( focalLength );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 1: // Orthographic\n\t\t\t\t\t\tmodel = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.O( - width / 2, width / 2, height / 2, - height / 2, nearClippingPlane, farClippingPlane );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Unknown camera type ' + type + '.' );\n\t\t\t\t\t\tmodel = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.U();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn model;\n\n\t\t},\n\n\t\t// Create a DirectionalLight, PointLight or SpotLight\n\t\tcreateLight: function ( relationships ) {\n\n\t\t\tvar model;\n\t\t\tvar lightAttribute;\n\n\t\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\t\tvar attr = fbxTree.Objects.NodeAttribute[ child.ID ];\n\n\t\t\t\tif ( attr !== undefined ) {\n\n\t\t\t\t\tlightAttribute = attr;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tif ( lightAttribute === undefined ) {\n\n\t\t\t\tmodel = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.U();\n\n\t\t\t} else {\n\n\t\t\t\tvar type;\n\n\t\t\t\t// LightType can be undefined for Point lights\n\t\t\t\tif ( lightAttribute.LightType === undefined ) {\n\n\t\t\t\t\ttype = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttype = lightAttribute.LightType.value;\n\n\t\t\t\t}\n\n\t\t\t\tvar color = 0xffffff;\n\n\t\t\t\tif ( lightAttribute.Color !== undefined ) {\n\n\t\t\t\t\tcolor = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( lightAttribute.Color.value );\n\n\t\t\t\t}\n\n\t\t\t\tvar intensity = ( lightAttribute.Intensity === undefined ) ? 1 : lightAttribute.Intensity.value / 100;\n\n\t\t\t\t// light disabled\n\t\t\t\tif ( lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0 ) {\n\n\t\t\t\t\tintensity = 0;\n\n\t\t\t\t}\n\n\t\t\t\tvar distance = 0;\n\t\t\t\tif ( lightAttribute.FarAttenuationEnd !== undefined ) {\n\n\t\t\t\t\tif ( lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0 ) {\n\n\t\t\t\t\t\tdistance = 0;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdistance = lightAttribute.FarAttenuationEnd.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\n\t\t\t\tvar decay = 1;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 0: // Point\n\t\t\t\t\t\tmodel = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.Z( color, intensity, distance, decay );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 1: // Directional\n\t\t\t\t\t\tmodel = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__._( color, intensity );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 2: // Spot\n\t\t\t\t\t\tvar angle = Math.PI / 3;\n\n\t\t\t\t\t\tif ( lightAttribute.InnerAngle !== undefined ) {\n\n\t\t\t\t\t\t\tangle = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad( lightAttribute.InnerAngle.value );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar penumbra = 0;\n\t\t\t\t\t\tif ( lightAttribute.OuterAngle !== undefined ) {\n\n\t\t\t\t\t\t\t// TODO: this is not correct - FBX calculates outer and inner angle in degrees\n\t\t\t\t\t\t\t// with OuterAngle > InnerAngle && OuterAngle <= Math.PI\n\t\t\t\t\t\t\t// while three.js uses a penumbra between (0, 1) to attenuate the inner angle\n\t\t\t\t\t\t\tpenumbra = _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad( lightAttribute.OuterAngle.value );\n\t\t\t\t\t\t\tpenumbra = Math.max( penumbra, 1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmodel = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.Y( color, intensity, distance, angle, penumbra, decay );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a PointLight.' );\n\t\t\t\t\t\tmodel = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.Z( color, intensity );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1 ) {\n\n\t\t\t\t\tmodel.castShadow = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn model;\n\n\t\t},\n\n\t\tcreateMesh: function ( relationships, geometryMap, materialMap ) {\n\n\t\t\tvar model;\n\t\t\tvar geometry = null;\n\t\t\tvar material = null;\n\t\t\tvar materials = [];\n\n\t\t\t// get geometry and materials(s) from connections\n\t\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\t\tif ( geometryMap.has( child.ID ) ) {\n\n\t\t\t\t\tgeometry = geometryMap.get( child.ID );\n\n\t\t\t\t}\n\n\t\t\t\tif ( materialMap.has( child.ID ) ) {\n\n\t\t\t\t\tmaterials.push( materialMap.get( child.ID ) );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tif ( materials.length > 1 ) {\n\n\t\t\t\tmaterial = materials;\n\n\t\t\t} else if ( materials.length > 0 ) {\n\n\t\t\t\tmaterial = materials[ 0 ];\n\n\t\t\t} else {\n\n\t\t\t\tmaterial = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.al( { color: 0xcccccc } );\n\t\t\t\tmaterials.push( material );\n\n\t\t\t}\n\n\t\t\tif ( 'color' in geometry.attributes ) {\n\n\t\t\t\tmaterials.forEach( function ( material ) {\n\n\t\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( geometry.FBX_Deformer ) {\n\n\t\t\t\tmaterials.forEach( function ( material ) {\n\n\t\t\t\t\tmaterial.skinning = true;\n\n\t\t\t\t} );\n\n\t\t\t\tmodel = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.t( geometry, material );\n\t\t\t\tmodel.normalizeSkinWeights();\n\n\t\t\t} else {\n\n\t\t\t\tmodel = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.v( geometry, material );\n\n\t\t\t}\n\n\t\t\treturn model;\n\n\t\t},\n\n\t\tcreateCurve: function ( relationships, geometryMap ) {\n\n\t\t\tvar geometry = relationships.children.reduce( function ( geo, child ) {\n\n\t\t\t\tif ( geometryMap.has( child.ID ) ) geo = geometryMap.get( child.ID );\n\n\t\t\t\treturn geo;\n\n\t\t\t}, null );\n\n\t\t\t// FBX does not list materials for Nurbs lines, so we'll just put our own in here.\n\t\t\tvar material = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.q( { color: 0x3300ff, linewidth: 1 } );\n\t\t\treturn new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.x( geometry, material );\n\n\t\t},\n\n\t\t// parse the model node for transform data\n\t\tgetTransformData: function ( model, modelNode ) {\n\n\t\t\tvar transformData = {};\n\n\t\t\tif ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value );\n\n\t\t\tif ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value );\n\t\t\telse transformData.eulerOrder = 'ZYX';\n\n\t\t\tif ( 'Lcl_Translation' in modelNode ) transformData.translation = modelNode.Lcl_Translation.value;\n\n\t\t\tif ( 'PreRotation' in modelNode ) transformData.preRotation = modelNode.PreRotation.value;\n\t\t\tif ( 'Lcl_Rotation' in modelNode ) transformData.rotation = modelNode.Lcl_Rotation.value;\n\t\t\tif ( 'PostRotation' in modelNode ) transformData.postRotation = modelNode.PostRotation.value;\n\n\t\t\tif ( 'Lcl_Scaling' in modelNode ) transformData.scale = modelNode.Lcl_Scaling.value;\n\n\t\t\tif ( 'ScalingOffset' in modelNode ) transformData.scalingOffset = modelNode.ScalingOffset.value;\n\t\t\tif ( 'ScalingPivot' in modelNode ) transformData.scalingPivot = modelNode.ScalingPivot.value;\n\n\t\t\tif ( 'RotationOffset' in modelNode ) transformData.rotationOffset = modelNode.RotationOffset.value;\n\t\t\tif ( 'RotationPivot' in modelNode ) transformData.rotationPivot = modelNode.RotationPivot.value;\n\n\t\t\tmodel.userData.transformData = transformData;\n\n\t\t},\n\n\t\tsetLookAtProperties: function ( model, modelNode ) {\n\n\t\t\tif ( 'LookAtProperty' in modelNode ) {\n\n\t\t\t\tvar children = connections.get( model.ID ).children;\n\n\t\t\t\tchildren.forEach( function ( child ) {\n\n\t\t\t\t\tif ( child.relationship === 'LookAtProperty' ) {\n\n\t\t\t\t\t\tvar lookAtTarget = fbxTree.Objects.Model[ child.ID ];\n\n\t\t\t\t\t\tif ( 'Lcl_Translation' in lookAtTarget ) {\n\n\t\t\t\t\t\t\tvar pos = lookAtTarget.Lcl_Translation.value;\n\n\t\t\t\t\t\t\t// DirectionalLight, SpotLight\n\t\t\t\t\t\t\tif ( model.target !== undefined ) {\n\n\t\t\t\t\t\t\t\tmodel.target.position.fromArray( pos );\n\t\t\t\t\t\t\t\tsceneGraph.add( model.target );\n\n\t\t\t\t\t\t\t} else { // Cameras and other Object3Ds\n\n\t\t\t\t\t\t\t\tmodel.lookAt( new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V().fromArray( pos ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t},\n\n\t\tbindSkeleton: function ( skeletons, geometryMap, modelMap ) {\n\n\t\t\tvar bindMatrices = this.parsePoseNodes();\n\n\t\t\tfor ( var ID in skeletons ) {\n\n\t\t\t\tvar skeleton = skeletons[ ID ];\n\n\t\t\t\tvar parents = connections.get( parseInt( skeleton.ID ) ).parents;\n\n\t\t\t\tparents.forEach( function ( parent ) {\n\n\t\t\t\t\tif ( geometryMap.has( parent.ID ) ) {\n\n\t\t\t\t\t\tvar geoID = parent.ID;\n\t\t\t\t\t\tvar geoRelationships = connections.get( geoID );\n\n\t\t\t\t\t\tgeoRelationships.parents.forEach( function ( geoConnParent ) {\n\n\t\t\t\t\t\t\tif ( modelMap.has( geoConnParent.ID ) ) {\n\n\t\t\t\t\t\t\t\tvar model = modelMap.get( geoConnParent.ID );\n\n\t\t\t\t\t\t\t\tmodel.bind( new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.X( skeleton.bones ), bindMatrices[ geoConnParent.ID ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t},\n\n\t\tparsePoseNodes: function () {\n\n\t\t\tvar bindMatrices = {};\n\n\t\t\tif ( 'Pose' in fbxTree.Objects ) {\n\n\t\t\t\tvar BindPoseNode = fbxTree.Objects.Pose;\n\n\t\t\t\tfor ( var nodeID in BindPoseNode ) {\n\n\t\t\t\t\tif ( BindPoseNode[ nodeID ].attrType === 'BindPose' ) {\n\n\t\t\t\t\t\tvar poseNodes = BindPoseNode[ nodeID ].PoseNode;\n\n\t\t\t\t\t\tif ( Array.isArray( poseNodes ) ) {\n\n\t\t\t\t\t\t\tposeNodes.forEach( function ( poseNode ) {\n\n\t\t\t\t\t\t\t\tbindMatrices[ poseNode.Node ] = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W().fromArray( poseNode.Matrix.a );\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tbindMatrices[ poseNodes.Node ] = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W().fromArray( poseNodes.Matrix.a );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bindMatrices;\n\n\t\t},\n\n\t\t// Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\n\t\tcreateAmbientLight: function () {\n\n\t\t\tif ( 'GlobalSettings' in fbxTree && 'AmbientColor' in fbxTree.GlobalSettings ) {\n\n\t\t\t\tvar ambientColor = fbxTree.GlobalSettings.AmbientColor.value;\n\t\t\t\tvar r = ambientColor[ 0 ];\n\t\t\t\tvar g = ambientColor[ 1 ];\n\t\t\t\tvar b = ambientColor[ 2 ];\n\n\t\t\t\tif ( r !== 0 || g !== 0 || b !== 0 ) {\n\n\t\t\t\t\tvar color = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.C( r, g, b );\n\t\t\t\t\tsceneGraph.add( new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.am( color, 1 ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tsetupMorphMaterials: function () {\n\n\t\t\tvar scope = this;\n\t\t\tsceneGraph.traverse( function ( child ) {\n\n\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\tif ( child.geometry.morphAttributes.position && child.geometry.morphAttributes.position.length ) {\n\n\t\t\t\t\t\tif ( Array.isArray( child.material ) ) {\n\n\t\t\t\t\t\t\tchild.material.forEach( function ( material, i ) {\n\n\t\t\t\t\t\t\t\tscope.setupMorphMaterial( child, material, i );\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tscope.setupMorphMaterial( child, child.material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t},\n\n\t\tsetupMorphMaterial: function ( child, material, index ) {\n\n\t\t\tvar uuid = child.uuid;\n\t\t\tvar matUuid = material.uuid;\n\n\t\t\t// if a geometry has morph targets, it cannot share the material with other geometries\n\t\t\tvar sharedMat = false;\n\n\t\t\tsceneGraph.traverse( function ( node ) {\n\n\t\t\t\tif ( node.isMesh ) {\n\n\t\t\t\t\tif ( Array.isArray( node.material ) ) {\n\n\t\t\t\t\t\tnode.material.forEach( function ( mat ) {\n\n\t\t\t\t\t\t\tif ( mat.uuid === matUuid && node.uuid !== uuid ) sharedMat = true;\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else if ( node.material.uuid === matUuid && node.uuid !== uuid ) sharedMat = true;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tif ( sharedMat === true ) {\n\n\t\t\t\tvar clonedMat = material.clone();\n\t\t\t\tclonedMat.morphTargets = true;\n\n\t\t\t\tif ( index === undefined ) child.material = clonedMat;\n\t\t\t\telse child.material[ index ] = clonedMat;\n\n\t\t\t} else material.morphTargets = true;\n\n\t\t}\n\n\t};\n\n\t// parse Geometry data from FBXTree and return map of BufferGeometries\n\tfunction GeometryParser() {}\n\n\tGeometryParser.prototype = {\n\n\t\tconstructor: GeometryParser,\n\n\t\t// Parse nodes in FBXTree.Objects.Geometry\n\t\tparse: function ( deformers ) {\n\n\t\t\tvar geometryMap = new Map();\n\n\t\t\tif ( 'Geometry' in fbxTree.Objects ) {\n\n\t\t\t\tvar geoNodes = fbxTree.Objects.Geometry;\n\n\t\t\t\tfor ( var nodeID in geoNodes ) {\n\n\t\t\t\t\tvar relationships = connections.get( parseInt( nodeID ) );\n\t\t\t\t\tvar geo = this.parseGeometry( relationships, geoNodes[ nodeID ], deformers );\n\n\t\t\t\t\tgeometryMap.set( parseInt( nodeID ), geo );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn geometryMap;\n\n\t\t},\n\n\t\t// Parse single node in FBXTree.Objects.Geometry\n\t\tparseGeometry: function ( relationships, geoNode, deformers ) {\n\n\t\t\tswitch ( geoNode.attrType ) {\n\n\t\t\t\tcase 'Mesh':\n\t\t\t\t\treturn this.parseMeshGeometry( relationships, geoNode, deformers );\n\n\t\t\t\tcase 'NurbsCurve':\n\t\t\t\t\treturn this.parseNurbsGeometry( geoNode );\n\n\t\t\t}\n\n\t\t},\n\n\n\t\t// Parse single node mesh geometry in FBXTree.Objects.Geometry\n\t\tparseMeshGeometry: function ( relationships, geoNode, deformers ) {\n\n\t\t\tvar skeletons = deformers.skeletons;\n\t\t\tvar morphTargets = [];\n\n\t\t\tvar modelNodes = relationships.parents.map( function ( parent ) {\n\n\t\t\t\treturn fbxTree.Objects.Model[ parent.ID ];\n\n\t\t\t} );\n\n\t\t\t// don't create geometry if it is not associated with any models\n\t\t\tif ( modelNodes.length === 0 ) return;\n\n\t\t\tvar skeleton = relationships.children.reduce( function ( skeleton, child ) {\n\n\t\t\t\tif ( skeletons[ child.ID ] !== undefined ) skeleton = skeletons[ child.ID ];\n\n\t\t\t\treturn skeleton;\n\n\t\t\t}, null );\n\n\t\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\t\tif ( deformers.morphTargets[ child.ID ] !== undefined ) {\n\n\t\t\t\t\tmorphTargets.push( deformers.morphTargets[ child.ID ] );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\t// Assume one model and get the preRotation from that\n\t\t\t// if there is more than one model associated with the geometry this may cause problems\n\t\t\tvar modelNode = modelNodes[ 0 ];\n\n\t\t\tvar transformData = {};\n\n\t\t\tif ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value );\n\t\t\tif ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value );\n\n\t\t\tif ( 'GeometricTranslation' in modelNode ) transformData.translation = modelNode.GeometricTranslation.value;\n\t\t\tif ( 'GeometricRotation' in modelNode ) transformData.rotation = modelNode.GeometricRotation.value;\n\t\t\tif ( 'GeometricScaling' in modelNode ) transformData.scale = modelNode.GeometricScaling.value;\n\n\t\t\tvar transform = generateTransform( transformData );\n\n\t\t\treturn this.genGeometry( geoNode, skeleton, morphTargets, transform );\n\n\t\t},\n\n\t\t// Generate a BufferGeometry from a node in FBXTree.Objects.Geometry\n\t\tgenGeometry: function ( geoNode, skeleton, morphTargets, preTransform ) {\n\n\t\t\tvar geo = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\t\t\tif ( geoNode.attrName ) geo.name = geoNode.attrName;\n\n\t\t\tvar geoInfo = this.parseGeoNode( geoNode, skeleton );\n\t\t\tvar buffers = this.genBuffers( geoInfo );\n\n\t\t\tvar positionAttribute = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( buffers.vertex, 3 );\n\n\t\t\tpositionAttribute.applyMatrix4( preTransform );\n\n\t\t\tgeo.setAttribute( 'position', positionAttribute );\n\n\t\t\tif ( buffers.colors.length > 0 ) {\n\n\t\t\t\tgeo.setAttribute( 'color', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( buffers.colors, 3 ) );\n\n\t\t\t}\n\n\t\t\tif ( skeleton ) {\n\n\t\t\t\tgeo.setAttribute( 'skinIndex', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.az( buffers.weightsIndices, 4 ) );\n\n\t\t\t\tgeo.setAttribute( 'skinWeight', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( buffers.vertexWeights, 4 ) );\n\n\t\t\t\t// used later to bind the skeleton to the model\n\t\t\t\tgeo.FBX_Deformer = skeleton;\n\n\t\t\t}\n\n\t\t\tif ( buffers.normal.length > 0 ) {\n\n\t\t\t\tvar normalMatrix = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aA().getNormalMatrix( preTransform );\n\n\t\t\t\tvar normalAttribute = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( buffers.normal, 3 );\n\t\t\t\tnormalAttribute.applyNormalMatrix( normalMatrix );\n\n\t\t\t\tgeo.setAttribute( 'normal', normalAttribute );\n\n\t\t\t}\n\n\t\t\tbuffers.uvs.forEach( function ( uvBuffer, i ) {\n\n\t\t\t\t// subsequent uv buffers are called 'uv1', 'uv2', ...\n\t\t\t\tvar name = 'uv' + ( i + 1 ).toString();\n\n\t\t\t\t// the first uv buffer is just called 'uv'\n\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\tname = 'uv';\n\n\t\t\t\t}\n\n\t\t\t\tgeo.setAttribute( name, new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( buffers.uvs[ i ], 2 ) );\n\n\t\t\t} );\n\n\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t\t// Convert the material indices of each vertex into rendering groups on the geometry.\n\t\t\t\tvar prevMaterialIndex = buffers.materialIndex[ 0 ];\n\t\t\t\tvar startIndex = 0;\n\n\t\t\t\tbuffers.materialIndex.forEach( function ( currentIndex, i ) {\n\n\t\t\t\t\tif ( currentIndex !== prevMaterialIndex ) {\n\n\t\t\t\t\t\tgeo.addGroup( startIndex, i - startIndex, prevMaterialIndex );\n\n\t\t\t\t\t\tprevMaterialIndex = currentIndex;\n\t\t\t\t\t\tstartIndex = i;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\t// the loop above doesn't add the last group, do that here.\n\t\t\t\tif ( geo.groups.length > 0 ) {\n\n\t\t\t\t\tvar lastGroup = geo.groups[ geo.groups.length - 1 ];\n\t\t\t\t\tvar lastIndex = lastGroup.start + lastGroup.count;\n\n\t\t\t\t\tif ( lastIndex !== buffers.materialIndex.length ) {\n\n\t\t\t\t\t\tgeo.addGroup( lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// case where there are multiple materials but the whole geometry is only\n\t\t\t\t// using one of them\n\t\t\t\tif ( geo.groups.length === 0 ) {\n\n\t\t\t\t\tgeo.addGroup( 0, buffers.materialIndex.length, buffers.materialIndex[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.addMorphTargets( geo, geoNode, morphTargets, preTransform );\n\n\t\t\treturn geo;\n\n\t\t},\n\n\t\tparseGeoNode: function ( geoNode, skeleton ) {\n\n\t\t\tvar geoInfo = {};\n\n\t\t\tgeoInfo.vertexPositions = ( geoNode.Vertices !== undefined ) ? geoNode.Vertices.a : [];\n\t\t\tgeoInfo.vertexIndices = ( geoNode.PolygonVertexIndex !== undefined ) ? geoNode.PolygonVertexIndex.a : [];\n\n\t\t\tif ( geoNode.LayerElementColor ) {\n\n\t\t\t\tgeoInfo.color = this.parseVertexColors( geoNode.LayerElementColor[ 0 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoNode.LayerElementMaterial ) {\n\n\t\t\t\tgeoInfo.material = this.parseMaterialIndices( geoNode.LayerElementMaterial[ 0 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoNode.LayerElementNormal ) {\n\n\t\t\t\tgeoInfo.normal = this.parseNormals( geoNode.LayerElementNormal[ 0 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoNode.LayerElementUV ) {\n\n\t\t\t\tgeoInfo.uv = [];\n\n\t\t\t\tvar i = 0;\n\t\t\t\twhile ( geoNode.LayerElementUV[ i ] ) {\n\n\t\t\t\t\tif ( geoNode.LayerElementUV[ i ].UV ) {\n\n\t\t\t\t\t\tgeoInfo.uv.push( this.parseUVs( geoNode.LayerElementUV[ i ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ti ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeoInfo.weightTable = {};\n\n\t\t\tif ( skeleton !== null ) {\n\n\t\t\t\tgeoInfo.skeleton = skeleton;\n\n\t\t\t\tskeleton.rawBones.forEach( function ( rawBone, i ) {\n\n\t\t\t\t\t// loop over the bone's vertex indices and weights\n\t\t\t\t\trawBone.indices.forEach( function ( index, j ) {\n\n\t\t\t\t\t\tif ( geoInfo.weightTable[ index ] === undefined ) geoInfo.weightTable[ index ] = [];\n\n\t\t\t\t\t\tgeoInfo.weightTable[ index ].push( {\n\n\t\t\t\t\t\t\tid: i,\n\t\t\t\t\t\t\tweight: rawBone.weights[ j ],\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn geoInfo;\n\n\t\t},\n\n\t\tgenBuffers: function ( geoInfo ) {\n\n\t\t\tvar buffers = {\n\t\t\t\tvertex: [],\n\t\t\t\tnormal: [],\n\t\t\t\tcolors: [],\n\t\t\t\tuvs: [],\n\t\t\t\tmaterialIndex: [],\n\t\t\t\tvertexWeights: [],\n\t\t\t\tweightsIndices: [],\n\t\t\t};\n\n\t\t\tvar polygonIndex = 0;\n\t\t\tvar faceLength = 0;\n\t\t\tvar displayedWeightsWarning = false;\n\n\t\t\t// these will hold data for a single face\n\t\t\tvar facePositionIndexes = [];\n\t\t\tvar faceNormals = [];\n\t\t\tvar faceColors = [];\n\t\t\tvar faceUVs = [];\n\t\t\tvar faceWeights = [];\n\t\t\tvar faceWeightIndices = [];\n\n\t\t\tvar scope = this;\n\t\t\tgeoInfo.vertexIndices.forEach( function ( vertexIndex, polygonVertexIndex ) {\n\n\t\t\t\tvar endOfFace = false;\n\n\t\t\t\t// Face index and vertex index arrays are combined in a single array\n\t\t\t\t// A cube with quad faces looks like this:\n\t\t\t\t// PolygonVertexIndex: *24 {\n\t\t\t\t//  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\n\t\t\t\t//  }\n\t\t\t\t// Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\n\t\t\t\t// to find index of last vertex bit shift the index: ^ - 1\n\t\t\t\tif ( vertexIndex < 0 ) {\n\n\t\t\t\t\tvertexIndex = vertexIndex ^ - 1; // equivalent to ( x * -1 ) - 1\n\t\t\t\t\tendOfFace = true;\n\n\t\t\t\t}\n\n\t\t\t\tvar weightIndices = [];\n\t\t\t\tvar weights = [];\n\n\t\t\t\tfacePositionIndexes.push( vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2 );\n\n\t\t\t\tif ( geoInfo.color ) {\n\n\t\t\t\t\tvar data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color );\n\n\t\t\t\t\tfaceColors.push( data[ 0 ], data[ 1 ], data[ 2 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoInfo.skeleton ) {\n\n\t\t\t\t\tif ( geoInfo.weightTable[ vertexIndex ] !== undefined ) {\n\n\t\t\t\t\t\tgeoInfo.weightTable[ vertexIndex ].forEach( function ( wt ) {\n\n\t\t\t\t\t\t\tweights.push( wt.weight );\n\t\t\t\t\t\t\tweightIndices.push( wt.id );\n\n\t\t\t\t\t\t} );\n\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( weights.length > 4 ) {\n\n\t\t\t\t\t\tif ( ! displayedWeightsWarning ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.' );\n\t\t\t\t\t\t\tdisplayedWeightsWarning = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar wIndex = [ 0, 0, 0, 0 ];\n\t\t\t\t\t\tvar Weight = [ 0, 0, 0, 0 ];\n\n\t\t\t\t\t\tweights.forEach( function ( weight, weightIndex ) {\n\n\t\t\t\t\t\t\tvar currentWeight = weight;\n\t\t\t\t\t\t\tvar currentIndex = weightIndices[ weightIndex ];\n\n\t\t\t\t\t\t\tWeight.forEach( function ( comparedWeight, comparedWeightIndex, comparedWeightArray ) {\n\n\t\t\t\t\t\t\t\tif ( currentWeight > comparedWeight ) {\n\n\t\t\t\t\t\t\t\t\tcomparedWeightArray[ comparedWeightIndex ] = currentWeight;\n\t\t\t\t\t\t\t\t\tcurrentWeight = comparedWeight;\n\n\t\t\t\t\t\t\t\t\tvar tmp = wIndex[ comparedWeightIndex ];\n\t\t\t\t\t\t\t\t\twIndex[ comparedWeightIndex ] = currentIndex;\n\t\t\t\t\t\t\t\t\tcurrentIndex = tmp;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tweightIndices = wIndex;\n\t\t\t\t\t\tweights = Weight;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// if the weight array is shorter than 4 pad with 0s\n\t\t\t\t\twhile ( weights.length < 4 ) {\n\n\t\t\t\t\t\tweights.push( 0 );\n\t\t\t\t\t\tweightIndices.push( 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0; i < 4; ++ i ) {\n\n\t\t\t\t\t\tfaceWeights.push( weights[ i ] );\n\t\t\t\t\t\tfaceWeightIndices.push( weightIndices[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoInfo.normal ) {\n\n\t\t\t\t\tvar data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal );\n\n\t\t\t\t\tfaceNormals.push( data[ 0 ], data[ 1 ], data[ 2 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t\t\tvar materialIndex = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material )[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoInfo.uv ) {\n\n\t\t\t\t\tgeoInfo.uv.forEach( function ( uv, i ) {\n\n\t\t\t\t\t\tvar data = getData( polygonVertexIndex, polygonIndex, vertexIndex, uv );\n\n\t\t\t\t\t\tif ( faceUVs[ i ] === undefined ) {\n\n\t\t\t\t\t\t\tfaceUVs[ i ] = [];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfaceUVs[ i ].push( data[ 0 ] );\n\t\t\t\t\t\tfaceUVs[ i ].push( data[ 1 ] );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tfaceLength ++;\n\n\t\t\t\tif ( endOfFace ) {\n\n\t\t\t\t\tscope.genFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength );\n\n\t\t\t\t\tpolygonIndex ++;\n\t\t\t\t\tfaceLength = 0;\n\n\t\t\t\t\t// reset arrays for the next face\n\t\t\t\t\tfacePositionIndexes = [];\n\t\t\t\t\tfaceNormals = [];\n\t\t\t\t\tfaceColors = [];\n\t\t\t\t\tfaceUVs = [];\n\t\t\t\t\tfaceWeights = [];\n\t\t\t\t\tfaceWeightIndices = [];\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn buffers;\n\n\t\t},\n\n\t\t// Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\n\t\tgenFace: function ( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength ) {\n\n\t\t\tfor ( var i = 2; i < faceLength; i ++ ) {\n\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 0 ] ] );\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 1 ] ] );\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 2 ] ] );\n\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 ] ] );\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 1 ] ] );\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 2 ] ] );\n\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 ] ] );\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 1 ] ] );\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 2 ] ] );\n\n\t\t\t\tif ( geoInfo.skeleton ) {\n\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 0 ] );\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 1 ] );\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 2 ] );\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 3 ] );\n\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 ] );\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 1 ] );\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 2 ] );\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 3 ] );\n\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 ] );\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 1 ] );\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 2 ] );\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 3 ] );\n\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 0 ] );\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 1 ] );\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 2 ] );\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 3 ] );\n\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 ] );\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 1 ] );\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 2 ] );\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 3 ] );\n\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 ] );\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 1 ] );\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 2 ] );\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 3 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoInfo.color ) {\n\n\t\t\t\t\tbuffers.colors.push( faceColors[ 0 ] );\n\t\t\t\t\tbuffers.colors.push( faceColors[ 1 ] );\n\t\t\t\t\tbuffers.colors.push( faceColors[ 2 ] );\n\n\t\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 ] );\n\t\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 + 1 ] );\n\t\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 + 2 ] );\n\n\t\t\t\t\tbuffers.colors.push( faceColors[ i * 3 ] );\n\t\t\t\t\tbuffers.colors.push( faceColors[ i * 3 + 1 ] );\n\t\t\t\t\tbuffers.colors.push( faceColors[ i * 3 + 2 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\t\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\t\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoInfo.normal ) {\n\n\t\t\t\t\tbuffers.normal.push( faceNormals[ 0 ] );\n\t\t\t\t\tbuffers.normal.push( faceNormals[ 1 ] );\n\t\t\t\t\tbuffers.normal.push( faceNormals[ 2 ] );\n\n\t\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 ] );\n\t\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 1 ] );\n\t\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 2 ] );\n\n\t\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 ] );\n\t\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 + 1 ] );\n\t\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 + 2 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoInfo.uv ) {\n\n\t\t\t\t\tgeoInfo.uv.forEach( function ( uv, j ) {\n\n\t\t\t\t\t\tif ( buffers.uvs[ j ] === undefined ) buffers.uvs[ j ] = [];\n\n\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ 0 ] );\n\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ 1 ] );\n\n\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 ] );\n\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 + 1 ] );\n\n\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i * 2 ] );\n\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i * 2 + 1 ] );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\taddMorphTargets: function ( parentGeo, parentGeoNode, morphTargets, preTransform ) {\n\n\t\t\tif ( morphTargets.length === 0 ) return;\n\n\t\t\tparentGeo.morphTargetsRelative = true;\n\n\t\t\tparentGeo.morphAttributes.position = [];\n\t\t\t// parentGeo.morphAttributes.normal = []; // not implemented\n\n\t\t\tvar scope = this;\n\t\t\tmorphTargets.forEach( function ( morphTarget ) {\n\n\t\t\t\tmorphTarget.rawTargets.forEach( function ( rawTarget ) {\n\n\t\t\t\t\tvar morphGeoNode = fbxTree.Objects.Geometry[ rawTarget.geoID ];\n\n\t\t\t\t\tif ( morphGeoNode !== undefined ) {\n\n\t\t\t\t\t\tscope.genMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t},\n\n\t\t// a morph geometry node is similar to a standard  node, and the node is also contained\n\t\t// in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\n\t\t// and a special attribute Index defining which vertices of the original geometry are affected\n\t\t// Normal and position attributes only have data for the vertices that are affected by the morph\n\t\tgenMorphGeometry: function ( parentGeo, parentGeoNode, morphGeoNode, preTransform, name ) {\n\n\t\t\tvar vertexIndices = ( parentGeoNode.PolygonVertexIndex !== undefined ) ? parentGeoNode.PolygonVertexIndex.a : [];\n\n\t\t\tvar morphPositionsSparse = ( morphGeoNode.Vertices !== undefined ) ? morphGeoNode.Vertices.a : [];\n\t\t\tvar indices = ( morphGeoNode.Indexes !== undefined ) ? morphGeoNode.Indexes.a : [];\n\n\t\t\tvar length = parentGeo.attributes.position.count * 3;\n\t\t\tvar morphPositions = new Float32Array( length );\n\n\t\t\tfor ( var i = 0; i < indices.length; i ++ ) {\n\n\t\t\t\tvar morphIndex = indices[ i ] * 3;\n\n\t\t\t\tmorphPositions[ morphIndex ] = morphPositionsSparse[ i * 3 ];\n\t\t\t\tmorphPositions[ morphIndex + 1 ] = morphPositionsSparse[ i * 3 + 1 ];\n\t\t\t\tmorphPositions[ morphIndex + 2 ] = morphPositionsSparse[ i * 3 + 2 ];\n\n\t\t\t}\n\n\t\t\t// TODO: add morph normal support\n\t\t\tvar morphGeoInfo = {\n\t\t\t\tvertexIndices: vertexIndices,\n\t\t\t\tvertexPositions: morphPositions,\n\n\t\t\t};\n\n\t\t\tvar morphBuffers = this.genBuffers( morphGeoInfo );\n\n\t\t\tvar positionAttribute = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( morphBuffers.vertex, 3 );\n\t\t\tpositionAttribute.name = name || morphGeoNode.attrName;\n\n\t\t\tpositionAttribute.applyMatrix4( preTransform );\n\n\t\t\tparentGeo.morphAttributes.position.push( positionAttribute );\n\n\t\t},\n\n\t\t// Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\n\t\tparseNormals: function ( NormalNode ) {\n\n\t\t\tvar mappingType = NormalNode.MappingInformationType;\n\t\t\tvar referenceType = NormalNode.ReferenceInformationType;\n\t\t\tvar buffer = NormalNode.Normals.a;\n\t\t\tvar indexBuffer = [];\n\t\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\t\tif ( 'NormalIndex' in NormalNode ) {\n\n\t\t\t\t\tindexBuffer = NormalNode.NormalIndex.a;\n\n\t\t\t\t} else if ( 'NormalsIndex' in NormalNode ) {\n\n\t\t\t\t\tindexBuffer = NormalNode.NormalsIndex.a;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdataSize: 3,\n\t\t\t\tbuffer: buffer,\n\t\t\t\tindices: indexBuffer,\n\t\t\t\tmappingType: mappingType,\n\t\t\t\treferenceType: referenceType\n\t\t\t};\n\n\t\t},\n\n\t\t// Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\n\t\tparseUVs: function ( UVNode ) {\n\n\t\t\tvar mappingType = UVNode.MappingInformationType;\n\t\t\tvar referenceType = UVNode.ReferenceInformationType;\n\t\t\tvar buffer = UVNode.UV.a;\n\t\t\tvar indexBuffer = [];\n\t\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\t\tindexBuffer = UVNode.UVIndex.a;\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdataSize: 2,\n\t\t\t\tbuffer: buffer,\n\t\t\t\tindices: indexBuffer,\n\t\t\t\tmappingType: mappingType,\n\t\t\t\treferenceType: referenceType\n\t\t\t};\n\n\t\t},\n\n\t\t// Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\n\t\tparseVertexColors: function ( ColorNode ) {\n\n\t\t\tvar mappingType = ColorNode.MappingInformationType;\n\t\t\tvar referenceType = ColorNode.ReferenceInformationType;\n\t\t\tvar buffer = ColorNode.Colors.a;\n\t\t\tvar indexBuffer = [];\n\t\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\t\tindexBuffer = ColorNode.ColorIndex.a;\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdataSize: 4,\n\t\t\t\tbuffer: buffer,\n\t\t\t\tindices: indexBuffer,\n\t\t\t\tmappingType: mappingType,\n\t\t\t\treferenceType: referenceType\n\t\t\t};\n\n\t\t},\n\n\t\t// Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\n\t\tparseMaterialIndices: function ( MaterialNode ) {\n\n\t\t\tvar mappingType = MaterialNode.MappingInformationType;\n\t\t\tvar referenceType = MaterialNode.ReferenceInformationType;\n\n\t\t\tif ( mappingType === 'NoMappingInformation' ) {\n\n\t\t\t\treturn {\n\t\t\t\t\tdataSize: 1,\n\t\t\t\t\tbuffer: [ 0 ],\n\t\t\t\t\tindices: [ 0 ],\n\t\t\t\t\tmappingType: 'AllSame',\n\t\t\t\t\treferenceType: referenceType\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar materialIndexBuffer = MaterialNode.Materials.a;\n\n\t\t\t// Since materials are stored as indices, there's a bit of a mismatch between FBX and what\n\t\t\t// we expect.So we create an intermediate buffer that points to the index in the buffer,\n\t\t\t// for conforming with the other functions we've written for other data.\n\t\t\tvar materialIndices = [];\n\n\t\t\tfor ( var i = 0; i < materialIndexBuffer.length; ++ i ) {\n\n\t\t\t\tmaterialIndices.push( i );\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdataSize: 1,\n\t\t\t\tbuffer: materialIndexBuffer,\n\t\t\t\tindices: materialIndices,\n\t\t\t\tmappingType: mappingType,\n\t\t\t\treferenceType: referenceType\n\t\t\t};\n\n\t\t},\n\n\t\t// Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\n\t\tparseNurbsGeometry: function ( geoNode ) {\n\n\t\t\tif ( NURBSCurve === undefined ) {\n\n\t\t\t\tconsole.error( 'THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.' );\n\t\t\t\treturn new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\t\t}\n\n\t\t\tvar order = parseInt( geoNode.Order );\n\n\t\t\tif ( isNaN( order ) ) {\n\n\t\t\t\tconsole.error( 'THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id );\n\t\t\t\treturn new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\t\t}\n\n\t\t\tvar degree = order - 1;\n\n\t\t\tvar knots = geoNode.KnotVector.a;\n\t\t\tvar controlPoints = [];\n\t\t\tvar pointsValues = geoNode.Points.a;\n\n\t\t\tfor ( var i = 0, l = pointsValues.length; i < l; i += 4 ) {\n\n\t\t\t\tcontrolPoints.push( new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aw().fromArray( pointsValues, i ) );\n\n\t\t\t}\n\n\t\t\tvar startKnot, endKnot;\n\n\t\t\tif ( geoNode.Form === 'Closed' ) {\n\n\t\t\t\tcontrolPoints.push( controlPoints[ 0 ] );\n\n\t\t\t} else if ( geoNode.Form === 'Periodic' ) {\n\n\t\t\t\tstartKnot = degree;\n\t\t\t\tendKnot = knots.length - 1 - startKnot;\n\n\t\t\t\tfor ( var i = 0; i < degree; ++ i ) {\n\n\t\t\t\t\tcontrolPoints.push( controlPoints[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar curve = new NURBSCurve( degree, knots, controlPoints, startKnot, endKnot );\n\t\t\tvar vertices = curve.getPoints( controlPoints.length * 7 );\n\n\t\t\tvar positions = new Float32Array( vertices.length * 3 );\n\n\t\t\tvertices.forEach( function ( vertex, i ) {\n\n\t\t\t\tvertex.toArray( positions, i * 3 );\n\n\t\t\t} );\n\n\t\t\tvar geometry = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\t\t\tgeometry.setAttribute( 'position', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.c( positions, 3 ) );\n\n\t\t\treturn geometry;\n\n\t\t},\n\n\t};\n\n\t// parse animation data from FBXTree\n\tfunction AnimationParser() {}\n\n\tAnimationParser.prototype = {\n\n\t\tconstructor: AnimationParser,\n\n\t\t// take raw animation clips and turn them into three.js animation clips\n\t\tparse: function () {\n\n\t\t\tvar animationClips = [];\n\n\t\t\tvar rawClips = this.parseClips();\n\n\t\t\tif ( rawClips !== undefined ) {\n\n\t\t\t\tfor ( var key in rawClips ) {\n\n\t\t\t\t\tvar rawClip = rawClips[ key ];\n\n\t\t\t\t\tvar clip = this.addClip( rawClip );\n\n\t\t\t\t\tanimationClips.push( clip );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn animationClips;\n\n\t\t},\n\n\t\tparseClips: function () {\n\n\t\t\t// since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\n\t\t\t// if this is undefined we can safely assume there are no animations\n\t\t\tif ( fbxTree.Objects.AnimationCurve === undefined ) return undefined;\n\n\t\t\tvar curveNodesMap = this.parseAnimationCurveNodes();\n\n\t\t\tthis.parseAnimationCurves( curveNodesMap );\n\n\t\t\tvar layersMap = this.parseAnimationLayers( curveNodesMap );\n\t\t\tvar rawClips = this.parseAnimStacks( layersMap );\n\n\t\t\treturn rawClips;\n\n\t\t},\n\n\t\t// parse nodes in FBXTree.Objects.AnimationCurveNode\n\t\t// each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\n\t\t// and is referenced by an AnimationLayer\n\t\tparseAnimationCurveNodes: function () {\n\n\t\t\tvar rawCurveNodes = fbxTree.Objects.AnimationCurveNode;\n\n\t\t\tvar curveNodesMap = new Map();\n\n\t\t\tfor ( var nodeID in rawCurveNodes ) {\n\n\t\t\t\tvar rawCurveNode = rawCurveNodes[ nodeID ];\n\n\t\t\t\tif ( rawCurveNode.attrName.match( /S|R|T|DeformPercent/ ) !== null ) {\n\n\t\t\t\t\tvar curveNode = {\n\n\t\t\t\t\t\tid: rawCurveNode.id,\n\t\t\t\t\t\tattr: rawCurveNode.attrName,\n\t\t\t\t\t\tcurves: {},\n\n\t\t\t\t\t};\n\n\t\t\t\t\tcurveNodesMap.set( curveNode.id, curveNode );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn curveNodesMap;\n\n\t\t},\n\n\t\t// parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\n\t\t// previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\n\t\t// axis ( e.g. times and values of x rotation)\n\t\tparseAnimationCurves: function ( curveNodesMap ) {\n\n\t\t\tvar rawCurves = fbxTree.Objects.AnimationCurve;\n\n\t\t\t// TODO: Many values are identical up to roundoff error, but won't be optimised\n\t\t\t// e.g. position times: [0, 0.4, 0. 8]\n\t\t\t// position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]\n\t\t\t// clearly, this should be optimised to\n\t\t\t// times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]\n\t\t\t// this shows up in nearly every FBX file, and generally time array is length > 100\n\n\t\t\tfor ( var nodeID in rawCurves ) {\n\n\t\t\t\tvar animationCurve = {\n\n\t\t\t\t\tid: rawCurves[ nodeID ].id,\n\t\t\t\t\ttimes: rawCurves[ nodeID ].KeyTime.a.map( convertFBXTimeToSeconds ),\n\t\t\t\t\tvalues: rawCurves[ nodeID ].KeyValueFloat.a,\n\n\t\t\t\t};\n\n\t\t\t\tvar relationships = connections.get( animationCurve.id );\n\n\t\t\t\tif ( relationships !== undefined ) {\n\n\t\t\t\t\tvar animationCurveID = relationships.parents[ 0 ].ID;\n\t\t\t\t\tvar animationCurveRelationship = relationships.parents[ 0 ].relationship;\n\n\t\t\t\t\tif ( animationCurveRelationship.match( /X/ ) ) {\n\n\t\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'x' ] = animationCurve;\n\n\t\t\t\t\t} else if ( animationCurveRelationship.match( /Y/ ) ) {\n\n\t\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'y' ] = animationCurve;\n\n\t\t\t\t\t} else if ( animationCurveRelationship.match( /Z/ ) ) {\n\n\t\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'z' ] = animationCurve;\n\n\t\t\t\t\t} else if ( animationCurveRelationship.match( /d|DeformPercent/ ) && curveNodesMap.has( animationCurveID ) ) {\n\n\t\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'morph' ] = animationCurve;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t// parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\n\t\t// to various AnimationCurveNodes and is referenced by an AnimationStack node\n\t\t// note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\n\t\tparseAnimationLayers: function ( curveNodesMap ) {\n\n\t\t\tvar rawLayers = fbxTree.Objects.AnimationLayer;\n\n\t\t\tvar layersMap = new Map();\n\n\t\t\tfor ( var nodeID in rawLayers ) {\n\n\t\t\t\tvar layerCurveNodes = [];\n\n\t\t\t\tvar connection = connections.get( parseInt( nodeID ) );\n\n\t\t\t\tif ( connection !== undefined ) {\n\n\t\t\t\t\t// all the animationCurveNodes used in the layer\n\t\t\t\t\tvar children = connection.children;\n\n\t\t\t\t\tchildren.forEach( function ( child, i ) {\n\n\t\t\t\t\t\tif ( curveNodesMap.has( child.ID ) ) {\n\n\t\t\t\t\t\t\tvar curveNode = curveNodesMap.get( child.ID );\n\n\t\t\t\t\t\t\t// check that the curves are defined for at least one axis, otherwise ignore the curveNode\n\t\t\t\t\t\t\tif ( curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined ) {\n\n\t\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] === undefined ) {\n\n\t\t\t\t\t\t\t\t\tvar modelID = connections.get( child.ID ).parents.filter( function ( parent ) {\n\n\t\t\t\t\t\t\t\t\t\treturn parent.relationship !== undefined;\n\n\t\t\t\t\t\t\t\t\t} )[ 0 ].ID;\n\n\t\t\t\t\t\t\t\t\tif ( modelID !== undefined ) {\n\n\t\t\t\t\t\t\t\t\t\tvar rawModel = fbxTree.Objects.Model[ modelID.toString() ];\n\n\t\t\t\t\t\t\t\t\t\tif ( rawModel === undefined ) {\n\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Encountered a unused curve.', child );\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tvar node = {\n\n\t\t\t\t\t\t\t\t\t\t\tmodelName: rawModel.attrName ? _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.r.sanitizeNodeName( rawModel.attrName ) : '',\n\t\t\t\t\t\t\t\t\t\t\tID: rawModel.id,\n\t\t\t\t\t\t\t\t\t\t\tinitialPosition: [ 0, 0, 0 ],\n\t\t\t\t\t\t\t\t\t\t\tinitialRotation: [ 0, 0, 0 ],\n\t\t\t\t\t\t\t\t\t\t\tinitialScale: [ 1, 1, 1 ],\n\n\t\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t\tsceneGraph.traverse( function ( child ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( child.ID === rawModel.id ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tnode.transform = child.matrix;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif ( child.userData.transformData ) node.eulerOrder = child.userData.transformData.eulerOrder;\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t\t\t\tif ( ! node.transform ) node.transform = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\n\t\t\t\t\t\t\t\t\t\t// if the animated model is pre rotated, we'll have to apply the pre rotations to every\n\t\t\t\t\t\t\t\t\t\t// animation value as well\n\t\t\t\t\t\t\t\t\t\tif ( 'PreRotation' in rawModel ) node.preRotation = rawModel.PreRotation.value;\n\t\t\t\t\t\t\t\t\t\tif ( 'PostRotation' in rawModel ) node.postRotation = rawModel.PostRotation.value;\n\n\t\t\t\t\t\t\t\t\t\tlayerCurveNodes[ i ] = node;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] ) layerCurveNodes[ i ][ curveNode.attr ] = curveNode;\n\n\t\t\t\t\t\t\t} else if ( curveNode.curves.morph !== undefined ) {\n\n\t\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] === undefined ) {\n\n\t\t\t\t\t\t\t\t\tvar deformerID = connections.get( child.ID ).parents.filter( function ( parent ) {\n\n\t\t\t\t\t\t\t\t\t\treturn parent.relationship !== undefined;\n\n\t\t\t\t\t\t\t\t\t} )[ 0 ].ID;\n\n\t\t\t\t\t\t\t\t\tvar morpherID = connections.get( deformerID ).parents[ 0 ].ID;\n\t\t\t\t\t\t\t\t\tvar geoID = connections.get( morpherID ).parents[ 0 ].ID;\n\n\t\t\t\t\t\t\t\t\t// assuming geometry is not used in more than one model\n\t\t\t\t\t\t\t\t\tvar modelID = connections.get( geoID ).parents[ 0 ].ID;\n\n\t\t\t\t\t\t\t\t\tvar rawModel = fbxTree.Objects.Model[ modelID ];\n\n\t\t\t\t\t\t\t\t\tvar node = {\n\n\t\t\t\t\t\t\t\t\t\tmodelName: rawModel.attrName ? _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.r.sanitizeNodeName( rawModel.attrName ) : '',\n\t\t\t\t\t\t\t\t\t\tmorphName: fbxTree.Objects.Deformer[ deformerID ].attrName,\n\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\tlayerCurveNodes[ i ] = node;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tlayerCurveNodes[ i ][ curveNode.attr ] = curveNode;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tlayersMap.set( parseInt( nodeID ), layerCurveNodes );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn layersMap;\n\n\t\t},\n\n\t\t// parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\n\t\t// hierarchy. Each Stack node will be used to create a AnimationClip\n\t\tparseAnimStacks: function ( layersMap ) {\n\n\t\t\tvar rawStacks = fbxTree.Objects.AnimationStack;\n\n\t\t\t// connect the stacks (clips) up to the layers\n\t\t\tvar rawClips = {};\n\n\t\t\tfor ( var nodeID in rawStacks ) {\n\n\t\t\t\tvar children = connections.get( parseInt( nodeID ) ).children;\n\n\t\t\t\tif ( children.length > 1 ) {\n\n\t\t\t\t\t// it seems like stacks will always be associated with a single layer. But just in case there are files\n\t\t\t\t\t// where there are multiple layers per stack, we'll display a warning\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.' );\n\n\t\t\t\t}\n\n\t\t\t\tvar layer = layersMap.get( children[ 0 ].ID );\n\n\t\t\t\trawClips[ nodeID ] = {\n\n\t\t\t\t\tname: rawStacks[ nodeID ].attrName,\n\t\t\t\t\tlayer: layer,\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\treturn rawClips;\n\n\t\t},\n\n\t\taddClip: function ( rawClip ) {\n\n\t\t\tvar tracks = [];\n\n\t\t\tvar scope = this;\n\t\t\trawClip.layer.forEach( function ( rawTracks ) {\n\n\t\t\t\ttracks = tracks.concat( scope.generateTracks( rawTracks ) );\n\n\t\t\t} );\n\n\t\t\treturn new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.K( rawClip.name, - 1, tracks );\n\n\t\t},\n\n\t\tgenerateTracks: function ( rawTracks ) {\n\n\t\t\tvar tracks = [];\n\n\t\t\tvar initialPosition = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\tvar initialRotation = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.Q();\n\t\t\tvar initialScale = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t\t\tif ( rawTracks.transform ) rawTracks.transform.decompose( initialPosition, initialRotation, initialScale );\n\n\t\t\tinitialPosition = initialPosition.toArray();\n\t\t\tinitialRotation = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aj().setFromQuaternion( initialRotation, rawTracks.eulerOrder ).toArray();\n\t\t\tinitialScale = initialScale.toArray();\n\n\t\t\tif ( rawTracks.T !== undefined && Object.keys( rawTracks.T.curves ).length > 0 ) {\n\n\t\t\t\tvar positionTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.T.curves, initialPosition, 'position' );\n\t\t\t\tif ( positionTrack !== undefined ) tracks.push( positionTrack );\n\n\t\t\t}\n\n\t\t\tif ( rawTracks.R !== undefined && Object.keys( rawTracks.R.curves ).length > 0 ) {\n\n\t\t\t\tvar rotationTrack = this.generateRotationTrack( rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder );\n\t\t\t\tif ( rotationTrack !== undefined ) tracks.push( rotationTrack );\n\n\t\t\t}\n\n\t\t\tif ( rawTracks.S !== undefined && Object.keys( rawTracks.S.curves ).length > 0 ) {\n\n\t\t\t\tvar scaleTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale' );\n\t\t\t\tif ( scaleTrack !== undefined ) tracks.push( scaleTrack );\n\n\t\t\t}\n\n\t\t\tif ( rawTracks.DeformPercent !== undefined ) {\n\n\t\t\t\tvar morphTrack = this.generateMorphTrack( rawTracks );\n\t\t\t\tif ( morphTrack !== undefined ) tracks.push( morphTrack );\n\n\t\t\t}\n\n\t\t\treturn tracks;\n\n\t\t},\n\n\t\tgenerateVectorTrack: function ( modelName, curves, initialValue, type ) {\n\n\t\t\tvar times = this.getTimesForAllAxes( curves );\n\t\t\tvar values = this.getKeyframeTrackValues( times, curves, initialValue );\n\n\t\t\treturn new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.ac( modelName + '.' + type, times, values );\n\n\t\t},\n\n\t\tgenerateRotationTrack: function ( modelName, curves, initialValue, preRotation, postRotation, eulerOrder ) {\n\n\t\t\tif ( curves.x !== undefined ) {\n\n\t\t\t\tthis.interpolateRotations( curves.x );\n\t\t\t\tcurves.x.values = curves.x.values.map( _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad );\n\n\t\t\t}\n\n\t\t\tif ( curves.y !== undefined ) {\n\n\t\t\t\tthis.interpolateRotations( curves.y );\n\t\t\t\tcurves.y.values = curves.y.values.map( _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad );\n\n\t\t\t}\n\n\t\t\tif ( curves.z !== undefined ) {\n\n\t\t\t\tthis.interpolateRotations( curves.z );\n\t\t\t\tcurves.z.values = curves.z.values.map( _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad );\n\n\t\t\t}\n\n\t\t\tvar times = this.getTimesForAllAxes( curves );\n\t\t\tvar values = this.getKeyframeTrackValues( times, curves, initialValue );\n\n\t\t\tif ( preRotation !== undefined ) {\n\n\t\t\t\tpreRotation = preRotation.map( _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad );\n\t\t\t\tpreRotation.push( eulerOrder );\n\n\t\t\t\tpreRotation = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aj().fromArray( preRotation );\n\t\t\t\tpreRotation = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.Q().setFromEuler( preRotation );\n\n\t\t\t}\n\n\t\t\tif ( postRotation !== undefined ) {\n\n\t\t\t\tpostRotation = postRotation.map( _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad );\n\t\t\t\tpostRotation.push( eulerOrder );\n\n\t\t\t\tpostRotation = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aj().fromArray( postRotation );\n\t\t\t\tpostRotation = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.Q().setFromEuler( postRotation ).invert();\n\n\t\t\t}\n\n\t\t\tvar quaternion = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.Q();\n\t\t\tvar euler = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aj();\n\n\t\t\tvar quaternionValues = [];\n\n\t\t\tfor ( var i = 0; i < values.length; i += 3 ) {\n\n\t\t\t\teuler.set( values[ i ], values[ i + 1 ], values[ i + 2 ], eulerOrder );\n\n\t\t\t\tquaternion.setFromEuler( euler );\n\n\t\t\t\tif ( preRotation !== undefined ) quaternion.premultiply( preRotation );\n\t\t\t\tif ( postRotation !== undefined ) quaternion.multiply( postRotation );\n\n\t\t\t\tquaternion.toArray( quaternionValues, ( i / 3 ) * 4 );\n\n\t\t\t}\n\n\t\t\treturn new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.ad( modelName + '.quaternion', times, quaternionValues );\n\n\t\t},\n\n\t\tgenerateMorphTrack: function ( rawTracks ) {\n\n\t\t\tvar curves = rawTracks.DeformPercent.curves.morph;\n\t\t\tvar values = curves.values.map( function ( val ) {\n\n\t\t\t\treturn val / 100;\n\n\t\t\t} );\n\n\t\t\tvar morphNum = sceneGraph.getObjectByName( rawTracks.modelName ).morphTargetDictionary[ rawTracks.morphName ];\n\n\t\t\treturn new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.ae( rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']', curves.times, values );\n\n\t\t},\n\n\t\t// For all animated objects, times are defined separately for each axis\n\t\t// Here we'll combine the times into one sorted array without duplicates\n\t\tgetTimesForAllAxes: function ( curves ) {\n\n\t\t\tvar times = [];\n\n\t\t\t// first join together the times for each axis, if defined\n\t\t\tif ( curves.x !== undefined ) times = times.concat( curves.x.times );\n\t\t\tif ( curves.y !== undefined ) times = times.concat( curves.y.times );\n\t\t\tif ( curves.z !== undefined ) times = times.concat( curves.z.times );\n\n\t\t\t// then sort them\n\t\t\ttimes = times.sort( function ( a, b ) {\n\n\t\t\t\treturn a - b;\n\n\t\t\t} );\n\n\t\t\t// and remove duplicates\n\t\t\tif ( times.length > 1 ) {\n\n\t\t\t\tvar targetIndex = 1;\n\t\t\t\tvar lastValue = times[ 0 ];\n\t\t\t\tfor ( var i = 1; i < times.length; i ++ ) {\n\n\t\t\t\t\tvar currentValue = times[ i ];\n\t\t\t\t\tif ( currentValue !== lastValue ) {\n\n\t\t\t\t\t\ttimes[ targetIndex ] = currentValue;\n\t\t\t\t\t\tlastValue = currentValue;\n\t\t\t\t\t\ttargetIndex ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\ttimes = times.slice( 0, targetIndex );\n\n\t\t\t}\n\n\t\t\treturn times;\n\n\t\t},\n\n\t\tgetKeyframeTrackValues: function ( times, curves, initialValue ) {\n\n\t\t\tvar prevValue = initialValue;\n\n\t\t\tvar values = [];\n\n\t\t\tvar xIndex = - 1;\n\t\t\tvar yIndex = - 1;\n\t\t\tvar zIndex = - 1;\n\n\t\t\ttimes.forEach( function ( time ) {\n\n\t\t\t\tif ( curves.x ) xIndex = curves.x.times.indexOf( time );\n\t\t\t\tif ( curves.y ) yIndex = curves.y.times.indexOf( time );\n\t\t\t\tif ( curves.z ) zIndex = curves.z.times.indexOf( time );\n\n\t\t\t\t// if there is an x value defined for this frame, use that\n\t\t\t\tif ( xIndex !== - 1 ) {\n\n\t\t\t\t\tvar xValue = curves.x.values[ xIndex ];\n\t\t\t\t\tvalues.push( xValue );\n\t\t\t\t\tprevValue[ 0 ] = xValue;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// otherwise use the x value from the previous frame\n\t\t\t\t\tvalues.push( prevValue[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( yIndex !== - 1 ) {\n\n\t\t\t\t\tvar yValue = curves.y.values[ yIndex ];\n\t\t\t\t\tvalues.push( yValue );\n\t\t\t\t\tprevValue[ 1 ] = yValue;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvalues.push( prevValue[ 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( zIndex !== - 1 ) {\n\n\t\t\t\t\tvar zValue = curves.z.values[ zIndex ];\n\t\t\t\t\tvalues.push( zValue );\n\t\t\t\t\tprevValue[ 2 ] = zValue;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvalues.push( prevValue[ 2 ] );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn values;\n\n\t\t},\n\n\t\t// Rotations are defined as Euler angles which can have values  of any size\n\t\t// These will be converted to quaternions which don't support values greater than\n\t\t// PI, so we'll interpolate large rotations\n\t\tinterpolateRotations: function ( curve ) {\n\n\t\t\tfor ( var i = 1; i < curve.values.length; i ++ ) {\n\n\t\t\t\tvar initialValue = curve.values[ i - 1 ];\n\t\t\t\tvar valuesSpan = curve.values[ i ] - initialValue;\n\n\t\t\t\tvar absoluteSpan = Math.abs( valuesSpan );\n\n\t\t\t\tif ( absoluteSpan >= 180 ) {\n\n\t\t\t\t\tvar numSubIntervals = absoluteSpan / 180;\n\n\t\t\t\t\tvar step = valuesSpan / numSubIntervals;\n\t\t\t\t\tvar nextValue = initialValue + step;\n\n\t\t\t\t\tvar initialTime = curve.times[ i - 1 ];\n\t\t\t\t\tvar timeSpan = curve.times[ i ] - initialTime;\n\t\t\t\t\tvar interval = timeSpan / numSubIntervals;\n\t\t\t\t\tvar nextTime = initialTime + interval;\n\n\t\t\t\t\tvar interpolatedTimes = [];\n\t\t\t\t\tvar interpolatedValues = [];\n\n\t\t\t\t\twhile ( nextTime < curve.times[ i ] ) {\n\n\t\t\t\t\t\tinterpolatedTimes.push( nextTime );\n\t\t\t\t\t\tnextTime += interval;\n\n\t\t\t\t\t\tinterpolatedValues.push( nextValue );\n\t\t\t\t\t\tnextValue += step;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcurve.times = inject( curve.times, i, interpolatedTimes );\n\t\t\t\t\tcurve.values = inject( curve.values, i, interpolatedValues );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t};\n\n\t// parse an FBX file in ASCII format\n\tfunction TextParser() {}\n\n\tTextParser.prototype = {\n\n\t\tconstructor: TextParser,\n\n\t\tgetPrevNode: function () {\n\n\t\t\treturn this.nodeStack[ this.currentIndent - 2 ];\n\n\t\t},\n\n\t\tgetCurrentNode: function () {\n\n\t\t\treturn this.nodeStack[ this.currentIndent - 1 ];\n\n\t\t},\n\n\t\tgetCurrentProp: function () {\n\n\t\t\treturn this.currentProp;\n\n\t\t},\n\n\t\tpushStack: function ( node ) {\n\n\t\t\tthis.nodeStack.push( node );\n\t\t\tthis.currentIndent += 1;\n\n\t\t},\n\n\t\tpopStack: function () {\n\n\t\t\tthis.nodeStack.pop();\n\t\t\tthis.currentIndent -= 1;\n\n\t\t},\n\n\t\tsetCurrentProp: function ( val, name ) {\n\n\t\t\tthis.currentProp = val;\n\t\t\tthis.currentPropName = name;\n\n\t\t},\n\n\t\tparse: function ( text ) {\n\n\t\t\tthis.currentIndent = 0;\n\n\t\t\tthis.allNodes = new FBXTree();\n\t\t\tthis.nodeStack = [];\n\t\t\tthis.currentProp = [];\n\t\t\tthis.currentPropName = '';\n\n\t\t\tvar scope = this;\n\n\t\t\tvar split = text.split( /[\\r\\n]+/ );\n\n\t\t\tsplit.forEach( function ( line, i ) {\n\n\t\t\t\tvar matchComment = line.match( /^[\\s\\t]*;/ );\n\t\t\t\tvar matchEmpty = line.match( /^[\\s\\t]*$/ );\n\n\t\t\t\tif ( matchComment || matchEmpty ) return;\n\n\t\t\t\tvar matchBeginning = line.match( '^\\\\t{' + scope.currentIndent + '}(\\\\w+):(.*){', '' );\n\t\t\t\tvar matchProperty = line.match( '^\\\\t{' + ( scope.currentIndent ) + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)' );\n\t\t\t\tvar matchEnd = line.match( '^\\\\t{' + ( scope.currentIndent - 1 ) + '}}' );\n\n\t\t\t\tif ( matchBeginning ) {\n\n\t\t\t\t\tscope.parseNodeBegin( line, matchBeginning );\n\n\t\t\t\t} else if ( matchProperty ) {\n\n\t\t\t\t\tscope.parseNodeProperty( line, matchProperty, split[ ++ i ] );\n\n\t\t\t\t} else if ( matchEnd ) {\n\n\t\t\t\t\tscope.popStack();\n\n\t\t\t\t} else if ( line.match( /^[^\\s\\t}]/ ) ) {\n\n\t\t\t\t\t// large arrays are split over multiple lines terminated with a ',' character\n\t\t\t\t\t// if this is encountered the line needs to be joined to the previous line\n\t\t\t\t\tscope.parseNodePropertyContinued( line );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn this.allNodes;\n\n\t\t},\n\n\t\tparseNodeBegin: function ( line, property ) {\n\n\t\t\tvar nodeName = property[ 1 ].trim().replace( /^\"/, '' ).replace( /\"$/, '' );\n\n\t\t\tvar nodeAttrs = property[ 2 ].split( ',' ).map( function ( attr ) {\n\n\t\t\t\treturn attr.trim().replace( /^\"/, '' ).replace( /\"$/, '' );\n\n\t\t\t} );\n\n\t\t\tvar node = { name: nodeName };\n\t\t\tvar attrs = this.parseNodeAttr( nodeAttrs );\n\n\t\t\tvar currentNode = this.getCurrentNode();\n\n\t\t\t// a top node\n\t\t\tif ( this.currentIndent === 0 ) {\n\n\t\t\t\tthis.allNodes.add( nodeName, node );\n\n\t\t\t} else { // a subnode\n\n\t\t\t\t// if the subnode already exists, append it\n\t\t\t\tif ( nodeName in currentNode ) {\n\n\t\t\t\t\t// special case Pose needs PoseNodes as an array\n\t\t\t\t\tif ( nodeName === 'PoseNode' ) {\n\n\t\t\t\t\t\tcurrentNode.PoseNode.push( node );\n\n\t\t\t\t\t} else if ( currentNode[ nodeName ].id !== undefined ) {\n\n\t\t\t\t\t\tcurrentNode[ nodeName ] = {};\n\t\t\t\t\t\tcurrentNode[ nodeName ][ currentNode[ nodeName ].id ] = currentNode[ nodeName ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attrs.id !== '' ) currentNode[ nodeName ][ attrs.id ] = node;\n\n\t\t\t\t} else if ( typeof attrs.id === 'number' ) {\n\n\t\t\t\t\tcurrentNode[ nodeName ] = {};\n\t\t\t\t\tcurrentNode[ nodeName ][ attrs.id ] = node;\n\n\t\t\t\t} else if ( nodeName !== 'Properties70' ) {\n\n\t\t\t\t\tif ( nodeName === 'PoseNode' )\tcurrentNode[ nodeName ] = [ node ];\n\t\t\t\t\telse currentNode[ nodeName ] = node;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( typeof attrs.id === 'number' ) node.id = attrs.id;\n\t\t\tif ( attrs.name !== '' ) node.attrName = attrs.name;\n\t\t\tif ( attrs.type !== '' ) node.attrType = attrs.type;\n\n\t\t\tthis.pushStack( node );\n\n\t\t},\n\n\t\tparseNodeAttr: function ( attrs ) {\n\n\t\t\tvar id = attrs[ 0 ];\n\n\t\t\tif ( attrs[ 0 ] !== '' ) {\n\n\t\t\t\tid = parseInt( attrs[ 0 ] );\n\n\t\t\t\tif ( isNaN( id ) ) {\n\n\t\t\t\t\tid = attrs[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar name = '', type = '';\n\n\t\t\tif ( attrs.length > 1 ) {\n\n\t\t\t\tname = attrs[ 1 ].replace( /^(\\w+)::/, '' );\n\t\t\t\ttype = attrs[ 2 ];\n\n\t\t\t}\n\n\t\t\treturn { id: id, name: name, type: type };\n\n\t\t},\n\n\t\tparseNodeProperty: function ( line, property, contentLine ) {\n\n\t\t\tvar propName = property[ 1 ].replace( /^\"/, '' ).replace( /\"$/, '' ).trim();\n\t\t\tvar propValue = property[ 2 ].replace( /^\"/, '' ).replace( /\"$/, '' ).trim();\n\n\t\t\t// for special case: base64 image data follows \"Content: ,\" line\n\t\t\t//\tContent: ,\n\t\t\t//\t \"/9j/4RDaRXhpZgAATU0A...\"\n\t\t\tif ( propName === 'Content' && propValue === ',' ) {\n\n\t\t\t\tpropValue = contentLine.replace( /\"/g, '' ).replace( /,$/, '' ).trim();\n\n\t\t\t}\n\n\t\t\tvar currentNode = this.getCurrentNode();\n\t\t\tvar parentName = currentNode.name;\n\n\t\t\tif ( parentName === 'Properties70' ) {\n\n\t\t\t\tthis.parseNodeSpecialProperty( line, propName, propValue );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// Connections\n\t\t\tif ( propName === 'C' ) {\n\n\t\t\t\tvar connProps = propValue.split( ',' ).slice( 1 );\n\t\t\t\tvar from = parseInt( connProps[ 0 ] );\n\t\t\t\tvar to = parseInt( connProps[ 1 ] );\n\n\t\t\t\tvar rest = propValue.split( ',' ).slice( 3 );\n\n\t\t\t\trest = rest.map( function ( elem ) {\n\n\t\t\t\t\treturn elem.trim().replace( /^\"/, '' );\n\n\t\t\t\t} );\n\n\t\t\t\tpropName = 'connections';\n\t\t\t\tpropValue = [ from, to ];\n\t\t\t\tappend( propValue, rest );\n\n\t\t\t\tif ( currentNode[ propName ] === undefined ) {\n\n\t\t\t\t\tcurrentNode[ propName ] = [];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Node\n\t\t\tif ( propName === 'Node' ) currentNode.id = propValue;\n\n\t\t\t// connections\n\t\t\tif ( propName in currentNode && Array.isArray( currentNode[ propName ] ) ) {\n\n\t\t\t\tcurrentNode[ propName ].push( propValue );\n\n\t\t\t} else {\n\n\t\t\t\tif ( propName !== 'a' ) currentNode[ propName ] = propValue;\n\t\t\t\telse currentNode.a = propValue;\n\n\t\t\t}\n\n\t\t\tthis.setCurrentProp( currentNode, propName );\n\n\t\t\t// convert string to array, unless it ends in ',' in which case more will be added to it\n\t\t\tif ( propName === 'a' && propValue.slice( - 1 ) !== ',' ) {\n\n\t\t\t\tcurrentNode.a = parseNumberArray( propValue );\n\n\t\t\t}\n\n\t\t},\n\n\t\tparseNodePropertyContinued: function ( line ) {\n\n\t\t\tvar currentNode = this.getCurrentNode();\n\n\t\t\tcurrentNode.a += line;\n\n\t\t\t// if the line doesn't end in ',' we have reached the end of the property value\n\t\t\t// so convert the string to an array\n\t\t\tif ( line.slice( - 1 ) !== ',' ) {\n\n\t\t\t\tcurrentNode.a = parseNumberArray( currentNode.a );\n\n\t\t\t}\n\n\t\t},\n\n\t\t// parse \"Property70\"\n\t\tparseNodeSpecialProperty: function ( line, propName, propValue ) {\n\n\t\t\t// split this\n\t\t\t// P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\n\t\t\t// into array like below\n\t\t\t// [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\n\t\t\tvar props = propValue.split( '\",' ).map( function ( prop ) {\n\n\t\t\t\treturn prop.trim().replace( /^\\\"/, '' ).replace( /\\s/, '_' );\n\n\t\t\t} );\n\n\t\t\tvar innerPropName = props[ 0 ];\n\t\t\tvar innerPropType1 = props[ 1 ];\n\t\t\tvar innerPropType2 = props[ 2 ];\n\t\t\tvar innerPropFlag = props[ 3 ];\n\t\t\tvar innerPropValue = props[ 4 ];\n\n\t\t\t// cast values where needed, otherwise leave as strings\n\t\t\tswitch ( innerPropType1 ) {\n\n\t\t\t\tcase 'int':\n\t\t\t\tcase 'enum':\n\t\t\t\tcase 'bool':\n\t\t\t\tcase 'ULongLong':\n\t\t\t\tcase 'double':\n\t\t\t\tcase 'Number':\n\t\t\t\tcase 'FieldOfView':\n\t\t\t\t\tinnerPropValue = parseFloat( innerPropValue );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Color':\n\t\t\t\tcase 'ColorRGB':\n\t\t\t\tcase 'Vector3D':\n\t\t\t\tcase 'Lcl_Translation':\n\t\t\t\tcase 'Lcl_Rotation':\n\t\t\t\tcase 'Lcl_Scaling':\n\t\t\t\t\tinnerPropValue = parseNumberArray( innerPropValue );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// CAUTION: these props must append to parent's parent\n\t\t\tthis.getPrevNode()[ innerPropName ] = {\n\n\t\t\t\t'type': innerPropType1,\n\t\t\t\t'type2': innerPropType2,\n\t\t\t\t'flag': innerPropFlag,\n\t\t\t\t'value': innerPropValue\n\n\t\t\t};\n\n\t\t\tthis.setCurrentProp( this.getPrevNode(), innerPropName );\n\n\t\t},\n\n\t};\n\n\t// Parse an FBX file in Binary format\n\tfunction BinaryParser() {}\n\n\tBinaryParser.prototype = {\n\n\t\tconstructor: BinaryParser,\n\n\t\tparse: function ( buffer ) {\n\n\t\t\tvar reader = new BinaryReader( buffer );\n\t\t\treader.skip( 23 ); // skip magic 23 bytes\n\n\t\t\tvar version = reader.getUint32();\n\n\t\t\tif ( version < 6400 ) {\n\n\t\t\t\tthrow new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + version );\n\n\t\t\t}\n\n\t\t\tvar allNodes = new FBXTree();\n\n\t\t\twhile ( ! this.endOfContent( reader ) ) {\n\n\t\t\t\tvar node = this.parseNode( reader, version );\n\t\t\t\tif ( node !== null ) allNodes.add( node.name, node );\n\n\t\t\t}\n\n\t\t\treturn allNodes;\n\n\t\t},\n\n\t\t// Check if reader has reached the end of content.\n\t\tendOfContent: function ( reader ) {\n\n\t\t\t// footer size: 160bytes + 16-byte alignment padding\n\t\t\t// - 16bytes: magic\n\t\t\t// - padding til 16-byte alignment (at least 1byte?)\n\t\t\t//\t(seems like some exporters embed fixed 15 or 16bytes?)\n\t\t\t// - 4bytes: magic\n\t\t\t// - 4bytes: version\n\t\t\t// - 120bytes: zero\n\t\t\t// - 16bytes: magic\n\t\t\tif ( reader.size() % 16 === 0 ) {\n\n\t\t\t\treturn ( ( reader.getOffset() + 160 + 16 ) & ~ 0xf ) >= reader.size();\n\n\t\t\t} else {\n\n\t\t\t\treturn reader.getOffset() + 160 + 16 >= reader.size();\n\n\t\t\t}\n\n\t\t},\n\n\t\t// recursively parse nodes until the end of the file is reached\n\t\tparseNode: function ( reader, version ) {\n\n\t\t\tvar node = {};\n\n\t\t\t// The first three data sizes depends on version.\n\t\t\tvar endOffset = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\n\t\t\tvar numProperties = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\n\n\t\t\t( version >= 7500 ) ? reader.getUint64() : reader.getUint32(); // the returned propertyListLen is not used\n\n\t\t\tvar nameLen = reader.getUint8();\n\t\t\tvar name = reader.getString( nameLen );\n\n\t\t\t// Regards this node as NULL-record if endOffset is zero\n\t\t\tif ( endOffset === 0 ) return null;\n\n\t\t\tvar propertyList = [];\n\n\t\t\tfor ( var i = 0; i < numProperties; i ++ ) {\n\n\t\t\t\tpropertyList.push( this.parseProperty( reader ) );\n\n\t\t\t}\n\n\t\t\t// Regards the first three elements in propertyList as id, attrName, and attrType\n\t\t\tvar id = propertyList.length > 0 ? propertyList[ 0 ] : '';\n\t\t\tvar attrName = propertyList.length > 1 ? propertyList[ 1 ] : '';\n\t\t\tvar attrType = propertyList.length > 2 ? propertyList[ 2 ] : '';\n\n\t\t\t// check if this node represents just a single property\n\t\t\t// like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\n\t\t\tnode.singleProperty = ( numProperties === 1 && reader.getOffset() === endOffset ) ? true : false;\n\n\t\t\twhile ( endOffset > reader.getOffset() ) {\n\n\t\t\t\tvar subNode = this.parseNode( reader, version );\n\n\t\t\t\tif ( subNode !== null ) this.parseSubNode( name, node, subNode );\n\n\t\t\t}\n\n\t\t\tnode.propertyList = propertyList; // raw property list used by parent\n\n\t\t\tif ( typeof id === 'number' ) node.id = id;\n\t\t\tif ( attrName !== '' ) node.attrName = attrName;\n\t\t\tif ( attrType !== '' ) node.attrType = attrType;\n\t\t\tif ( name !== '' ) node.name = name;\n\n\t\t\treturn node;\n\n\t\t},\n\n\t\tparseSubNode: function ( name, node, subNode ) {\n\n\t\t\t// special case: child node is single property\n\t\t\tif ( subNode.singleProperty === true ) {\n\n\t\t\t\tvar value = subNode.propertyList[ 0 ];\n\n\t\t\t\tif ( Array.isArray( value ) ) {\n\n\t\t\t\t\tnode[ subNode.name ] = subNode;\n\n\t\t\t\t\tsubNode.a = value;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnode[ subNode.name ] = value;\n\n\t\t\t\t}\n\n\t\t\t} else if ( name === 'Connections' && subNode.name === 'C' ) {\n\n\t\t\t\tvar array = [];\n\n\t\t\t\tsubNode.propertyList.forEach( function ( property, i ) {\n\n\t\t\t\t\t// first Connection is FBX type (OO, OP, etc.). We'll discard these\n\t\t\t\t\tif ( i !== 0 ) array.push( property );\n\n\t\t\t\t} );\n\n\t\t\t\tif ( node.connections === undefined ) {\n\n\t\t\t\t\tnode.connections = [];\n\n\t\t\t\t}\n\n\t\t\t\tnode.connections.push( array );\n\n\t\t\t} else if ( subNode.name === 'Properties70' ) {\n\n\t\t\t\tvar keys = Object.keys( subNode );\n\n\t\t\t\tkeys.forEach( function ( key ) {\n\n\t\t\t\t\tnode[ key ] = subNode[ key ];\n\n\t\t\t\t} );\n\n\t\t\t} else if ( name === 'Properties70' && subNode.name === 'P' ) {\n\n\t\t\t\tvar innerPropName = subNode.propertyList[ 0 ];\n\t\t\t\tvar innerPropType1 = subNode.propertyList[ 1 ];\n\t\t\t\tvar innerPropType2 = subNode.propertyList[ 2 ];\n\t\t\t\tvar innerPropFlag = subNode.propertyList[ 3 ];\n\t\t\t\tvar innerPropValue;\n\n\t\t\t\tif ( innerPropName.indexOf( 'Lcl ' ) === 0 ) innerPropName = innerPropName.replace( 'Lcl ', 'Lcl_' );\n\t\t\t\tif ( innerPropType1.indexOf( 'Lcl ' ) === 0 ) innerPropType1 = innerPropType1.replace( 'Lcl ', 'Lcl_' );\n\n\t\t\t\tif ( innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf( 'Lcl_' ) === 0 ) {\n\n\t\t\t\t\tinnerPropValue = [\n\t\t\t\t\t\tsubNode.propertyList[ 4 ],\n\t\t\t\t\t\tsubNode.propertyList[ 5 ],\n\t\t\t\t\t\tsubNode.propertyList[ 6 ]\n\t\t\t\t\t];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tinnerPropValue = subNode.propertyList[ 4 ];\n\n\t\t\t\t}\n\n\t\t\t\t// this will be copied to parent, see above\n\t\t\t\tnode[ innerPropName ] = {\n\n\t\t\t\t\t'type': innerPropType1,\n\t\t\t\t\t'type2': innerPropType2,\n\t\t\t\t\t'flag': innerPropFlag,\n\t\t\t\t\t'value': innerPropValue\n\n\t\t\t\t};\n\n\t\t\t} else if ( node[ subNode.name ] === undefined ) {\n\n\t\t\t\tif ( typeof subNode.id === 'number' ) {\n\n\t\t\t\t\tnode[ subNode.name ] = {};\n\t\t\t\t\tnode[ subNode.name ][ subNode.id ] = subNode;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnode[ subNode.name ] = subNode;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( subNode.name === 'PoseNode' ) {\n\n\t\t\t\t\tif ( ! Array.isArray( node[ subNode.name ] ) ) {\n\n\t\t\t\t\t\tnode[ subNode.name ] = [ node[ subNode.name ] ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnode[ subNode.name ].push( subNode );\n\n\t\t\t\t} else if ( node[ subNode.name ][ subNode.id ] === undefined ) {\n\n\t\t\t\t\tnode[ subNode.name ][ subNode.id ] = subNode;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tparseProperty: function ( reader ) {\n\n\t\t\tvar type = reader.getString( 1 );\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'C':\n\t\t\t\t\treturn reader.getBoolean();\n\n\t\t\t\tcase 'D':\n\t\t\t\t\treturn reader.getFloat64();\n\n\t\t\t\tcase 'F':\n\t\t\t\t\treturn reader.getFloat32();\n\n\t\t\t\tcase 'I':\n\t\t\t\t\treturn reader.getInt32();\n\n\t\t\t\tcase 'L':\n\t\t\t\t\treturn reader.getInt64();\n\n\t\t\t\tcase 'R':\n\t\t\t\t\tvar length = reader.getUint32();\n\t\t\t\t\treturn reader.getArrayBuffer( length );\n\n\t\t\t\tcase 'S':\n\t\t\t\t\tvar length = reader.getUint32();\n\t\t\t\t\treturn reader.getString( length );\n\n\t\t\t\tcase 'Y':\n\t\t\t\t\treturn reader.getInt16();\n\n\t\t\t\tcase 'b':\n\t\t\t\tcase 'c':\n\t\t\t\tcase 'd':\n\t\t\t\tcase 'f':\n\t\t\t\tcase 'i':\n\t\t\t\tcase 'l':\n\n\t\t\t\t\tvar arrayLength = reader.getUint32();\n\t\t\t\t\tvar encoding = reader.getUint32(); // 0: non-compressed, 1: compressed\n\t\t\t\t\tvar compressedLength = reader.getUint32();\n\n\t\t\t\t\tif ( encoding === 0 ) {\n\n\t\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\t\treturn reader.getBooleanArray( arrayLength );\n\n\t\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\t\treturn reader.getFloat64Array( arrayLength );\n\n\t\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\t\treturn reader.getFloat32Array( arrayLength );\n\n\t\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\t\treturn reader.getInt32Array( arrayLength );\n\n\t\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\t\treturn reader.getInt64Array( arrayLength );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( typeof fflate === 'undefined' ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.FBXLoader: External library fflate.min.js required.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar data = Jr( new Uint8Array( reader.getArrayBuffer( compressedLength ) ) ); // eslint-disable-line no-undef\n\t\t\t\t\tvar reader2 = new BinaryReader( data.buffer );\n\n\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\treturn reader2.getBooleanArray( arrayLength );\n\n\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\treturn reader2.getFloat64Array( arrayLength );\n\n\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\treturn reader2.getFloat32Array( arrayLength );\n\n\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\treturn reader2.getInt32Array( arrayLength );\n\n\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\treturn reader2.getInt64Array( arrayLength );\n\n\t\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'THREE.FBXLoader: Unknown property type ' + type );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction BinaryReader( buffer, littleEndian ) {\n\n\t\tthis.dv = new DataView( buffer );\n\t\tthis.offset = 0;\n\t\tthis.littleEndian = ( littleEndian !== undefined ) ? littleEndian : true;\n\n\t}\n\n\tBinaryReader.prototype = {\n\n\t\tconstructor: BinaryReader,\n\n\t\tgetOffset: function () {\n\n\t\t\treturn this.offset;\n\n\t\t},\n\n\t\tsize: function () {\n\n\t\t\treturn this.dv.buffer.byteLength;\n\n\t\t},\n\n\t\tskip: function ( length ) {\n\n\t\t\tthis.offset += length;\n\n\t\t},\n\n\t\t// seems like true/false representation depends on exporter.\n\t\t// true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n\t\t// then sees LSB.\n\t\tgetBoolean: function () {\n\n\t\t\treturn ( this.getUint8() & 1 ) === 1;\n\n\t\t},\n\n\t\tgetBooleanArray: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getBoolean() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\tgetUint8: function () {\n\n\t\t\tvar value = this.dv.getUint8( this.offset );\n\t\t\tthis.offset += 1;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetInt16: function () {\n\n\t\t\tvar value = this.dv.getInt16( this.offset, this.littleEndian );\n\t\t\tthis.offset += 2;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetInt32: function () {\n\n\t\t\tvar value = this.dv.getInt32( this.offset, this.littleEndian );\n\t\t\tthis.offset += 4;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetInt32Array: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getInt32() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\tgetUint32: function () {\n\n\t\t\tvar value = this.dv.getUint32( this.offset, this.littleEndian );\n\t\t\tthis.offset += 4;\n\t\t\treturn value;\n\n\t\t},\n\n\t\t// JavaScript doesn't support 64-bit integer so calculate this here\n\t\t// 1 << 32 will return 1 so using multiply operation instead here.\n\t\t// There's a possibility that this method returns wrong value if the value\n\t\t// is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n\t\t// TODO: safely handle 64-bit integer\n\t\tgetInt64: function () {\n\n\t\t\tvar low, high;\n\n\t\t\tif ( this.littleEndian ) {\n\n\t\t\t\tlow = this.getUint32();\n\t\t\t\thigh = this.getUint32();\n\n\t\t\t} else {\n\n\t\t\t\thigh = this.getUint32();\n\t\t\t\tlow = this.getUint32();\n\n\t\t\t}\n\n\t\t\t// calculate negative value\n\t\t\tif ( high & 0x80000000 ) {\n\n\t\t\t\thigh = ~ high & 0xFFFFFFFF;\n\t\t\t\tlow = ~ low & 0xFFFFFFFF;\n\n\t\t\t\tif ( low === 0xFFFFFFFF ) high = ( high + 1 ) & 0xFFFFFFFF;\n\n\t\t\t\tlow = ( low + 1 ) & 0xFFFFFFFF;\n\n\t\t\t\treturn - ( high * 0x100000000 + low );\n\n\t\t\t}\n\n\t\t\treturn high * 0x100000000 + low;\n\n\t\t},\n\n\t\tgetInt64Array: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getInt64() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\t// Note: see getInt64() comment\n\t\tgetUint64: function () {\n\n\t\t\tvar low, high;\n\n\t\t\tif ( this.littleEndian ) {\n\n\t\t\t\tlow = this.getUint32();\n\t\t\t\thigh = this.getUint32();\n\n\t\t\t} else {\n\n\t\t\t\thigh = this.getUint32();\n\t\t\t\tlow = this.getUint32();\n\n\t\t\t}\n\n\t\t\treturn high * 0x100000000 + low;\n\n\t\t},\n\n\t\tgetFloat32: function () {\n\n\t\t\tvar value = this.dv.getFloat32( this.offset, this.littleEndian );\n\t\t\tthis.offset += 4;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetFloat32Array: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getFloat32() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\tgetFloat64: function () {\n\n\t\t\tvar value = this.dv.getFloat64( this.offset, this.littleEndian );\n\t\t\tthis.offset += 8;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetFloat64Array: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getFloat64() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\tgetArrayBuffer: function ( size ) {\n\n\t\t\tvar value = this.dv.buffer.slice( this.offset, this.offset + size );\n\t\t\tthis.offset += size;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetString: function ( size ) {\n\n\t\t\t// note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta[ i ] = this.getUint8();\n\n\t\t\t}\n\n\t\t\tvar nullByte = a.indexOf( 0 );\n\t\t\tif ( nullByte >= 0 ) a = a.slice( 0, nullByte );\n\n\t\t\treturn _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.f.decodeText( new Uint8Array( a ) );\n\n\t\t}\n\n\t};\n\n\t// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\n\t// and BinaryParser( FBX Binary format)\n\tfunction FBXTree() {}\n\n\tFBXTree.prototype = {\n\n\t\tconstructor: FBXTree,\n\n\t\tadd: function ( key, val ) {\n\n\t\t\tthis[ key ] = val;\n\n\t\t},\n\n\t};\n\n\t// ************** UTILITY FUNCTIONS **************\n\n\tfunction isFbxFormatBinary( buffer ) {\n\n\t\tvar CORRECT = 'Kaydara FBX Binary  \\0';\n\n\t\treturn buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString( buffer, 0, CORRECT.length );\n\n\t}\n\n\tfunction isFbxFormatASCII( text ) {\n\n\t\tvar CORRECT = [ 'K', 'a', 'y', 'd', 'a', 'r', 'a', '\\\\', 'F', 'B', 'X', '\\\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\\\', '\\\\' ];\n\n\t\tvar cursor = 0;\n\n\t\tfunction read( offset ) {\n\n\t\t\tvar result = text[ offset - 1 ];\n\t\t\ttext = text.slice( cursor + offset );\n\t\t\tcursor ++;\n\t\t\treturn result;\n\n\t\t}\n\n\t\tfor ( var i = 0; i < CORRECT.length; ++ i ) {\n\n\t\t\tvar num = read( 1 );\n\t\t\tif ( num === CORRECT[ i ] ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfunction getFbxVersion( text ) {\n\n\t\tvar versionRegExp = /FBXVersion: (\\d+)/;\n\t\tvar match = text.match( versionRegExp );\n\n\t\tif ( match ) {\n\n\t\t\tvar version = parseInt( match[ 1 ] );\n\t\t\treturn version;\n\n\t\t}\n\n\t\tthrow new Error( 'THREE.FBXLoader: Cannot find the version number for the file given.' );\n\n\t}\n\n\t// Converts FBX ticks into real time seconds.\n\tfunction convertFBXTimeToSeconds( time ) {\n\n\t\treturn time / 46186158000;\n\n\t}\n\n\tvar dataArray = [];\n\n\t// extracts the data from the correct position in the FBX array based on indexing type\n\tfunction getData( polygonVertexIndex, polygonIndex, vertexIndex, infoObject ) {\n\n\t\tvar index;\n\n\t\tswitch ( infoObject.mappingType ) {\n\n\t\t\tcase 'ByPolygonVertex' :\n\t\t\t\tindex = polygonVertexIndex;\n\t\t\t\tbreak;\n\t\t\tcase 'ByPolygon' :\n\t\t\t\tindex = polygonIndex;\n\t\t\t\tbreak;\n\t\t\tcase 'ByVertice' :\n\t\t\t\tindex = vertexIndex;\n\t\t\t\tbreak;\n\t\t\tcase 'AllSame' :\n\t\t\t\tindex = infoObject.indices[ 0 ];\n\t\t\t\tbreak;\n\t\t\tdefault :\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType );\n\n\t\t}\n\n\t\tif ( infoObject.referenceType === 'IndexToDirect' ) index = infoObject.indices[ index ];\n\n\t\tvar from = index * infoObject.dataSize;\n\t\tvar to = from + infoObject.dataSize;\n\n\t\treturn slice( dataArray, infoObject.buffer, from, to );\n\n\t}\n\n\tvar tempEuler = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aj();\n\tvar tempVec = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t// generate transformation from FBX transform data\n\t// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm\n\t// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e\n\tfunction generateTransform( transformData ) {\n\n\t\tvar lTranslationM = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lPreRotationM = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lRotationM = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lPostRotationM = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\n\t\tvar lScalingM = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lScalingPivotM = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lScalingOffsetM = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lRotationOffsetM = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lRotationPivotM = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\n\t\tvar lParentGX = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lParentLX = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lGlobalT = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\n\t\tvar inheritType = ( transformData.inheritType ) ? transformData.inheritType : 0;\n\n\t\tif ( transformData.translation ) lTranslationM.setPosition( tempVec.fromArray( transformData.translation ) );\n\n\t\tif ( transformData.preRotation ) {\n\n\t\t\tvar array = transformData.preRotation.map( _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad );\n\t\t\tarray.push( transformData.eulerOrder );\n\t\t\tlPreRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );\n\n\t\t}\n\n\t\tif ( transformData.rotation ) {\n\n\t\t\tvar array = transformData.rotation.map( _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad );\n\t\t\tarray.push( transformData.eulerOrder );\n\t\t\tlRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );\n\n\t\t}\n\n\t\tif ( transformData.postRotation ) {\n\n\t\t\tvar array = transformData.postRotation.map( _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad );\n\t\t\tarray.push( transformData.eulerOrder );\n\t\t\tlPostRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );\n\t\t\tlPostRotationM.invert();\n\n\t\t}\n\n\t\tif ( transformData.scale ) lScalingM.scale( tempVec.fromArray( transformData.scale ) );\n\n\t\t// Pivots and offsets\n\t\tif ( transformData.scalingOffset ) lScalingOffsetM.setPosition( tempVec.fromArray( transformData.scalingOffset ) );\n\t\tif ( transformData.scalingPivot ) lScalingPivotM.setPosition( tempVec.fromArray( transformData.scalingPivot ) );\n\t\tif ( transformData.rotationOffset ) lRotationOffsetM.setPosition( tempVec.fromArray( transformData.rotationOffset ) );\n\t\tif ( transformData.rotationPivot ) lRotationPivotM.setPosition( tempVec.fromArray( transformData.rotationPivot ) );\n\n\t\t// parent transform\n\t\tif ( transformData.parentMatrixWorld ) {\n\n\t\t\tlParentLX.copy( transformData.parentMatrix );\n\t\t\tlParentGX.copy( transformData.parentMatrixWorld );\n\n\t\t}\n\n\t\tvar lLRM = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W().copy( lPreRotationM ).multiply( lRotationM ).multiply( lPostRotationM );\n\t\t// Global Rotation\n\t\tvar lParentGRM = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tlParentGRM.extractRotation( lParentGX );\n\n\t\t// Global Shear*Scaling\n\t\tvar lParentTM = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tlParentTM.copyPosition( lParentGX );\n\n\t\tvar lParentGSM = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lParentGRSM = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W().copy( lParentTM ).invert().multiply( lParentGX );\n\t\tlParentGSM.copy( lParentGRM ).invert().multiply( lParentGRSM );\n\t\tvar lLSM = lScalingM;\n\n\t\tvar lGlobalRS = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\n\t\tif ( inheritType === 0 ) {\n\n\t\t\tlGlobalRS.copy( lParentGRM ).multiply( lLRM ).multiply( lParentGSM ).multiply( lLSM );\n\n\t\t} else if ( inheritType === 1 ) {\n\n\t\t\tlGlobalRS.copy( lParentGRM ).multiply( lParentGSM ).multiply( lLRM ).multiply( lLSM );\n\n\t\t} else {\n\n\t\t\tvar lParentLSM = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W().scale( new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V().setFromMatrixScale( lParentLX ) );\n\t\t\tvar lParentLSM_inv = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W().copy( lParentLSM ).invert();\n\t\t\tvar lParentGSM_noLocal = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W().copy( lParentGSM ).multiply( lParentLSM_inv );\n\n\t\t\tlGlobalRS.copy( lParentGRM ).multiply( lLRM ).multiply( lParentGSM_noLocal ).multiply( lLSM );\n\n\t\t}\n\n\t\tvar lRotationPivotM_inv = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tlRotationPivotM_inv.copy( lRotationPivotM ).invert();\n\t\tvar lScalingPivotM_inv = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tlScalingPivotM_inv.copy( lScalingPivotM ).invert();\n\t\t// Calculate the local transform matrix\n\t\tvar lTransform = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tlTransform.copy( lTranslationM ).multiply( lRotationOffsetM ).multiply( lRotationPivotM ).multiply( lPreRotationM ).multiply( lRotationM ).multiply( lPostRotationM ).multiply( lRotationPivotM_inv ).multiply( lScalingOffsetM ).multiply( lScalingPivotM ).multiply( lScalingM ).multiply( lScalingPivotM_inv );\n\n\t\tvar lLocalTWithAllPivotAndOffsetInfo = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W().copyPosition( lTransform );\n\n\t\tvar lGlobalTranslation = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W().copy( lParentGX ).multiply( lLocalTWithAllPivotAndOffsetInfo );\n\t\tlGlobalT.copyPosition( lGlobalTranslation );\n\n\t\tlTransform = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.W().copy( lGlobalT ).multiply( lGlobalRS );\n\n\t\t// from global to local\n\t\tlTransform.premultiply( lParentGX.invert() );\n\n\t\treturn lTransform;\n\n\t}\n\n\t// Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order\n\t// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\n\tfunction getEulerOrder( order ) {\n\n\t\torder = order || 0;\n\n\t\tvar enums = [\n\t\t\t'ZYX', // -> XYZ extrinsic\n\t\t\t'YZX', // -> XZY extrinsic\n\t\t\t'XZY', // -> YZX extrinsic\n\t\t\t'ZXY', // -> YXZ extrinsic\n\t\t\t'YXZ', // -> ZXY extrinsic\n\t\t\t'XYZ', // -> ZYX extrinsic\n\t\t\t//'SphericXYZ', // not possible to support\n\t\t];\n\n\t\tif ( order === 6 ) {\n\n\t\t\tconsole.warn( 'THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.' );\n\t\t\treturn enums[ 0 ];\n\n\t\t}\n\n\t\treturn enums[ order ];\n\n\t}\n\n\t// Parses comma separated list of numbers and returns them an array.\n\t// Used internally by the TextParser\n\tfunction parseNumberArray( value ) {\n\n\t\tvar array = value.split( ',' ).map( function ( val ) {\n\n\t\t\treturn parseFloat( val );\n\n\t\t} );\n\n\t\treturn array;\n\n\t}\n\n\tfunction convertArrayBufferToString( buffer, from, to ) {\n\n\t\tif ( from === undefined ) from = 0;\n\t\tif ( to === undefined ) to = buffer.byteLength;\n\n\t\treturn _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.f.decodeText( new Uint8Array( buffer, from, to ) );\n\n\t}\n\n\tfunction append( a, b ) {\n\n\t\tfor ( var i = 0, j = a.length, l = b.length; i < l; i ++, j ++ ) {\n\n\t\t\ta[ j ] = b[ i ];\n\n\t\t}\n\n\t}\n\n\tfunction slice( a, b, from, to ) {\n\n\t\tfor ( var i = from, j = 0; i < to; i ++, j ++ ) {\n\n\t\t\ta[ j ] = b[ i ];\n\n\t\t}\n\n\t\treturn a;\n\n\t}\n\n\t// inject array a2 into array a1 at index\n\tfunction inject( a1, index, a2 ) {\n\n\t\treturn a1.slice( 0, index ).concat( a2 ).concat( a1.slice( index ) );\n\n\t}\n\n\treturn FBXLoader;\n\n} )();\n\nvar SVGLoader = function ( manager ) {\n\n\t_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n\t// Default dots per inch\n\tthis.defaultDPI = 90;\n\n\t// Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n\tthis.defaultUnit = 'px';\n\n};\n\nSVGLoader.prototype = Object.assign( Object.create( _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\tconstructor: SVGLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.F( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( text ) {\n\n\t\tvar scope = this;\n\n\t\tfunction parseNode( node, style ) {\n\n\t\t\tif ( node.nodeType !== 1 ) return;\n\n\t\t\tvar transform = getNodeTransform( node );\n\n\t\t\tvar traverseChildNodes = true;\n\n\t\t\tvar path = null;\n\n\t\t\tswitch ( node.nodeName ) {\n\n\t\t\t\tcase 'svg':\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'style':\n\t\t\t\t\tparseCSSStylesheet( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'g':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'path':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tif ( node.hasAttribute( 'd' ) ) path = parsePathNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rect':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseRectNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polygon':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolygonNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polyline':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolylineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'circle':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseCircleNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ellipse':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseEllipseNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'line':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseLineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'defs':\n\t\t\t\t\ttraverseChildNodes = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'use':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tvar usedNodeId = node.href.baseVal.substring( 1 );\n\t\t\t\t\tvar usedNode = node.viewportElement.getElementById( usedNodeId );\n\t\t\t\t\tif ( usedNode ) {\n\n\t\t\t\t\t\tparseNode( usedNode, style );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'SVGLoader: \\'use node\\' references non-existent node id: ' + usedNodeId );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t\t// console.log( node );\n\n\t\t\t}\n\n\t\t\tif ( path ) {\n\n\t\t\t\tif ( style.fill !== undefined && style.fill !== 'none' ) {\n\n\t\t\t\t\tpath.color.setStyle( style.fill );\n\n\t\t\t\t}\n\n\t\t\t\ttransformPath( path, currentTransform );\n\n\t\t\t\tpaths.push( path );\n\n\t\t\t\tpath.userData = { node: node, style: style };\n\n\t\t\t}\n\n\t\t\tif ( traverseChildNodes ) {\n\n\t\t\t\tvar nodes = node.childNodes;\n\n\t\t\t\tfor ( var i = 0; i < nodes.length; i ++ ) {\n\n\t\t\t\t\tparseNode( nodes[ i ], style );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( transform ) {\n\n\t\t\t\ttransformStack.pop();\n\n\t\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\t\tcurrentTransform.copy( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parsePathNode( node ) {\n\n\t\t\tvar path = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aB();\n\n\t\t\tvar point = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\t\t\tvar control = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\n\t\t\tvar firstPoint = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\t\t\tvar isFirstPoint = true;\n\t\t\tvar doSetFirstPoint = false;\n\n\t\t\tvar d = node.getAttribute( 'd' );\n\n\t\t\t// console.log( d );\n\n\t\t\tvar commands = d.match( /[a-df-z][^a-df-z]*/ig );\n\n\t\t\tfor ( var i = 0, l = commands.length; i < l; i ++ ) {\n\n\t\t\t\tvar command = commands[ i ];\n\n\t\t\t\tvar type = command.charAt( 0 );\n\t\t\t\tvar data = command.substr( 1 ).trim();\n\n\t\t\t\tif ( isFirstPoint === true ) {\n\n\t\t\t\t\tdoSetFirstPoint = true;\n\t\t\t\t\tisFirstPoint = false;\n\n\t\t\t\t}\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'H':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'V':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'C':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 4 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tvar rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tvar ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'A':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t// skip command if start point == end point\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == point.x && numbers[ j + 6 ] == point.y ) continue;\n\n\t\t\t\t\t\t\tvar start = point.clone();\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'h':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 4 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'q':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tvar rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tvar ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = point.y + numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t// skip command if no displacement\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == 0 && numbers[ j + 6 ] == 0 ) continue;\n\n\t\t\t\t\t\t\tvar start = point.clone();\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Z':\n\t\t\t\t\tcase 'z':\n\t\t\t\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\t\t\t\tif ( path.currentPath.curves.length > 0 ) {\n\n\t\t\t\t\t\t\t// Reset point to beginning of Path\n\t\t\t\t\t\t\tpoint.copy( firstPoint );\n\t\t\t\t\t\t\tpath.currentPath.currentPoint.copy( point );\n\t\t\t\t\t\t\tisFirstPoint = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( command );\n\n\t\t\t\t}\n\n\t\t\t\t// console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n\t\t\t\tdoSetFirstPoint = false;\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCSSStylesheet( node ) {\n\n\t\t\tif ( ! node.sheet || ! node.sheet.cssRules || ! node.sheet.cssRules.length ) return;\n\n\t\t\tfor ( var i = 0; i < node.sheet.cssRules.length; i ++ ) {\n\n\t\t\t\tvar stylesheet = node.sheet.cssRules[ i ];\n\n\t\t\t\tif ( stylesheet.type !== 1 ) continue;\n\n\t\t\t\tvar selectorList = stylesheet.selectorText\n\t\t\t\t\t.split( /,/gm )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( var j = 0; j < selectorList.length; j ++ ) {\n\n\t\t\t\t\tstylesheets[ selectorList[ j ] ] = Object.assign(\n\t\t\t\t\t\tstylesheets[ selectorList[ j ] ] || {},\n\t\t\t\t\t\tstylesheet.style\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n\t\t * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n\t\t * From\n\t\t * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n\t\t * To\n\t\t * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n\t\t */\n\n\t\tfunction parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {\n\n\t\t\tif ( rx == 0 || ry == 0 ) {\n\n\t\t\t\t// draw a line if either of the radii == 0\n\t\t\t\tpath.lineTo( end.x, end.y );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tx_axis_rotation = x_axis_rotation * Math.PI / 180;\n\n\t\t\t// Ensure radii are positive\n\t\t\trx = Math.abs( rx );\n\t\t\try = Math.abs( ry );\n\n\t\t\t// Compute (x1', y1')\n\t\t\tvar dx2 = ( start.x - end.x ) / 2.0;\n\t\t\tvar dy2 = ( start.y - end.y ) / 2.0;\n\t\t\tvar x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;\n\t\t\tvar y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;\n\n\t\t\t// Compute (cx', cy')\n\t\t\tvar rxs = rx * rx;\n\t\t\tvar rys = ry * ry;\n\t\t\tvar x1ps = x1p * x1p;\n\t\t\tvar y1ps = y1p * y1p;\n\n\t\t\t// Ensure radii are large enough\n\t\t\tvar cr = x1ps / rxs + y1ps / rys;\n\n\t\t\tif ( cr > 1 ) {\n\n\t\t\t\t// scale up rx,ry equally so cr == 1\n\t\t\t\tvar s = Math.sqrt( cr );\n\t\t\t\trx = s * rx;\n\t\t\t\try = s * ry;\n\t\t\t\trxs = rx * rx;\n\t\t\t\trys = ry * ry;\n\n\t\t\t}\n\n\t\t\tvar dq = ( rxs * y1ps + rys * x1ps );\n\t\t\tvar pq = ( rxs * rys - dq ) / dq;\n\t\t\tvar q = Math.sqrt( Math.max( 0, pq ) );\n\t\t\tif ( large_arc_flag === sweep_flag ) q = - q;\n\t\t\tvar cxp = q * rx * y1p / ry;\n\t\t\tvar cyp = - q * ry * x1p / rx;\n\n\t\t\t// Step 3: Compute (cx, cy) from (cx', cy')\n\t\t\tvar cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;\n\t\t\tvar cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;\n\n\t\t\t// Step 4: Compute 1 and \n\t\t\tvar theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );\n\t\t\tvar delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );\n\n\t\t\tpath.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );\n\n\t\t}\n\n\t\tfunction svgAngle( ux, uy, vx, vy ) {\n\n\t\t\tvar dot = ux * vx + uy * vy;\n\t\t\tvar len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );\n\t\t\tvar ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear\n\t\t\tif ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;\n\t\t\treturn ang;\n\n\t\t}\n\n\t\t/*\n\t\t* According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n\t\t* rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n\t\t*/\n\t\tfunction parseRectNode( node ) {\n\n\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 );\n\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 );\n\t\t\tvar rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );\n\t\t\tvar ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );\n\t\t\tvar w = parseFloatWithUnits( node.getAttribute( 'width' ) );\n\t\t\tvar h = parseFloatWithUnits( node.getAttribute( 'height' ) );\n\n\t\t\tvar path = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aB();\n\t\t\tpath.moveTo( x + 2 * rx, y );\n\t\t\tpath.lineTo( x + w - 2 * rx, y );\n\t\t\tif ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y, x + w, y, x + w, y + 2 * ry );\n\t\t\tpath.lineTo( x + w, y + h - 2 * ry );\n\t\t\tif ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h );\n\t\t\tpath.lineTo( x + 2 * rx, y + h );\n\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo( x, y + h, x, y + h, x, y + h - 2 * ry );\n\n\t\t\t}\n\n\t\t\tpath.lineTo( x, y + 2 * ry );\n\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo( x, y, x, y, x + 2 * rx, y );\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolygonNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tvar x = parseFloatWithUnits( a );\n\t\t\t\tvar y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tvar path = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aB();\n\n\t\t\tvar index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolylineNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tvar x = parseFloatWithUnits( a );\n\t\t\t\tvar y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tvar path = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aB();\n\n\t\t\tvar index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCircleNode( node ) {\n\n\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'cx' ) );\n\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'cy' ) );\n\t\t\tvar r = parseFloatWithUnits( node.getAttribute( 'r' ) );\n\n\t\t\tvar subpath = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aC();\n\t\t\tsubpath.absarc( x, y, r, 0, Math.PI * 2 );\n\n\t\t\tvar path = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aB();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseEllipseNode( node ) {\n\n\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'cx' ) );\n\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'cy' ) );\n\t\t\tvar rx = parseFloatWithUnits( node.getAttribute( 'rx' ) );\n\t\t\tvar ry = parseFloatWithUnits( node.getAttribute( 'ry' ) );\n\n\t\t\tvar subpath = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aC();\n\t\t\tsubpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );\n\n\t\t\tvar path = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aB();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseLineNode( node ) {\n\n\t\t\tvar x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) );\n\t\t\tvar y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) );\n\t\t\tvar x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) );\n\t\t\tvar y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) );\n\n\t\t\tvar path = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aB();\n\t\t\tpath.moveTo( x1, y1 );\n\t\t\tpath.lineTo( x2, y2 );\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction parseStyle( node, style ) {\n\n\t\t\tstyle = Object.assign( {}, style ); // clone style\n\n\t\t\tvar stylesheetStyles = {};\n\n\t\t\tif ( node.hasAttribute( 'class' ) ) {\n\n\t\t\t\tvar classSelectors = node.getAttribute( 'class' )\n\t\t\t\t\t.split( /\\s/ )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( var i = 0; i < classSelectors.length; i ++ ) {\n\n\t\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '.' + classSelectors[ i ] ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( node.hasAttribute( 'id' ) ) {\n\n\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '#' + node.getAttribute( 'id' ) ] );\n\n\t\t\t}\n\n\t\t\tfunction addStyle( svgName, jsName, adjustFunction ) {\n\n\t\t\t\tif ( adjustFunction === undefined ) adjustFunction = function copy( v ) {\n\n\t\t\t\t\tif ( v.startsWith( 'url' ) ) console.warn( 'SVGLoader: url access in attributes is not implemented.' );\n\n\t\t\t\t\treturn v;\n\n\t\t\t\t};\n\n\t\t\t\tif ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) );\n\t\t\t\tif ( stylesheetStyles[ svgName ] ) style[ jsName ] = adjustFunction( stylesheetStyles[ svgName ] );\n\t\t\t\tif ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] );\n\n\t\t\t}\n\n\t\t\tfunction clamp( v ) {\n\n\t\t\t\treturn Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) );\n\n\t\t\t}\n\n\t\t\tfunction positive( v ) {\n\n\t\t\t\treturn Math.max( 0, parseFloatWithUnits( v ) );\n\n\t\t\t}\n\n\t\t\taddStyle( 'fill', 'fill' );\n\t\t\taddStyle( 'fill-opacity', 'fillOpacity', clamp );\n\t\t\taddStyle( 'opacity', 'opacity', clamp );\n\t\t\taddStyle( 'stroke', 'stroke' );\n\t\t\taddStyle( 'stroke-opacity', 'strokeOpacity', clamp );\n\t\t\taddStyle( 'stroke-width', 'strokeWidth', positive );\n\t\t\taddStyle( 'stroke-linejoin', 'strokeLineJoin' );\n\t\t\taddStyle( 'stroke-linecap', 'strokeLineCap' );\n\t\t\taddStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive );\n\t\t\taddStyle( 'visibility', 'visibility' );\n\n\t\t\treturn style;\n\n\t\t}\n\n\t\t// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\t\tfunction getReflection( a, b ) {\n\n\t\t\treturn a - ( b - a );\n\n\t\t}\n\n\t\t// from https://github.com/ppvg/svg-numbers (MIT License)\n\n\t\tfunction parseFloats( input ) {\n\n\t\t\tif ( typeof input !== 'string' ) {\n\n\t\t\t\tthrow new TypeError( 'Invalid input: ' + typeof input );\n\n\t\t\t}\n\n\t\t\t// Character groups\n\t\t\tvar RE = {\n\t\t\t\tSEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n\t\t\t\tWHITESPACE: /[ \\t\\r\\n]/,\n\t\t\t\tDIGIT: /[\\d]/,\n\t\t\t\tSIGN: /[-+]/,\n\t\t\t\tPOINT: /\\./,\n\t\t\t\tCOMMA: /,/,\n\t\t\t\tEXP: /e/i\n\t\t\t};\n\n\t\t\t// States\n\t\t\tvar SEP = 0;\n\t\t\tvar INT = 1;\n\t\t\tvar FLOAT = 2;\n\t\t\tvar EXP = 3;\n\n\t\t\tvar state = SEP;\n\t\t\tvar seenComma = true;\n\t\t\tvar result = [], number = '', exponent = '';\n\n\t\t\tfunction throwSyntaxError( current, i, partial ) {\n\n\t\t\t\tvar error = new SyntaxError( 'Unexpected character \"' + current + '\" at index ' + i + '.' );\n\t\t\t\terror.partial = partial;\n\t\t\t\tthrow error;\n\n\t\t\t}\n\n\t\t\tfunction newNumber() {\n\n\t\t\t\tif ( number !== '' ) {\n\n\t\t\t\t\tif ( exponent === '' ) result.push( Number( number ) );\n\t\t\t\t\telse result.push( Number( number ) * Math.pow( 10, Number( exponent ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tnumber = '';\n\t\t\t\texponent = '';\n\n\t\t\t}\n\n\t\t\tvar current, i = 0, length = input.length;\n\t\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\t\tcurrent = input[ i ];\n\n\t\t\t\t// parse until next number\n\t\t\t\tif ( state === SEP ) {\n\n\t\t\t\t\t// eat whitespace\n\t\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// start new number\n\t\t\t\t\tif ( RE.DIGIT.test( current ) || RE.SIGN.test( current ) ) {\n\n\t\t\t\t\t\tstate = INT;\n\t\t\t\t\t\tnumber = current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\t\tnumber = current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double commas (e.g. \"1, , 2\")\n\t\t\t\t\tif ( RE.COMMA.test( current ) ) {\n\n\t\t\t\t\t\tif ( seenComma ) {\n\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tseenComma = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse integer part\n\t\t\t\tif ( state === INT ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\n\n\t\t\t\t\t\tstate = EXP;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n\t\t\t\t\tif ( RE.SIGN.test( current )\n\t\t\t\t\t\t\t&& number.length === 1\n\t\t\t\t\t\t\t&& RE.SIGN.test( number[ 0 ] ) ) {\n\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse decimal part\n\t\t\t\tif ( state === FLOAT ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\n\n\t\t\t\t\t\tstate = EXP;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double decimal points (e.g. \"1..2\")\n\t\t\t\t\tif ( RE.POINT.test( current ) && number[ number.length - 1 ] === '.' ) {\n\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse exponent part\n\t\t\t\tif ( state == EXP ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\texponent += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.SIGN.test( current ) ) {\n\n\t\t\t\t\t\tif ( exponent === '' ) {\n\n\t\t\t\t\t\t\texponent += current;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( exponent.length === 1 && RE.SIGN.test( exponent ) ) {\n\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\t// end of number\n\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = SEP;\n\t\t\t\t\tseenComma = false;\n\n\t\t\t\t} else if ( RE.COMMA.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = SEP;\n\t\t\t\t\tseenComma = true;\n\n\t\t\t\t} else if ( RE.SIGN.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = INT;\n\t\t\t\t\tnumber = current;\n\n\t\t\t\t} else if ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\tnumber = current;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add the last number found (if any)\n\t\t\tnewNumber();\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\t// Units\n\n\t\tvar units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ];\n\n\t\t// Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n\t\tvar unitConversion = {\n\n\t\t\t'mm': {\n\t\t\t\t'mm': 1,\n\t\t\t\t'cm': 0.1,\n\t\t\t\t'in': 1 / 25.4,\n\t\t\t\t'pt': 72 / 25.4,\n\t\t\t\t'pc': 6 / 25.4,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'cm': {\n\t\t\t\t'mm': 10,\n\t\t\t\t'cm': 1,\n\t\t\t\t'in': 1 / 2.54,\n\t\t\t\t'pt': 72 / 2.54,\n\t\t\t\t'pc': 6 / 2.54,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'in': {\n\t\t\t\t'mm': 25.4,\n\t\t\t\t'cm': 2.54,\n\t\t\t\t'in': 1,\n\t\t\t\t'pt': 72,\n\t\t\t\t'pc': 6,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'pt': {\n\t\t\t\t'mm': 25.4 / 72,\n\t\t\t\t'cm': 2.54 / 72,\n\t\t\t\t'in': 1 / 72,\n\t\t\t\t'pt': 1,\n\t\t\t\t'pc': 6 / 72,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'pc': {\n\t\t\t\t'mm': 25.4 / 6,\n\t\t\t\t'cm': 2.54 / 6,\n\t\t\t\t'in': 1 / 6,\n\t\t\t\t'pt': 72 / 6,\n\t\t\t\t'pc': 1,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'px': {\n\t\t\t\t'px': 1\n\t\t\t}\n\n\t\t};\n\n\t\tfunction parseFloatWithUnits( string ) {\n\n\t\t\tvar theUnit = 'px';\n\n\t\t\tif ( typeof string === 'string' || string instanceof String ) {\n\n\t\t\t\tfor ( var i = 0, n = units.length; i < n; i ++ ) {\n\n\t\t\t\t\tvar u = units[ i ];\n\n\t\t\t\t\tif ( string.endsWith( u ) ) {\n\n\t\t\t\t\t\ttheUnit = u;\n\t\t\t\t\t\tstring = string.substring( 0, string.length - u.length );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar scale = undefined;\n\n\t\t\tif ( theUnit === 'px' && scope.defaultUnit !== 'px' ) {\n\n\t\t\t\t// Conversion scale from  pixels to inches, then to default units\n\n\t\t\t\tscale = unitConversion[ 'in' ][ scope.defaultUnit ] / scope.defaultDPI;\n\n\t\t\t} else {\n\n\t\t\t\tscale = unitConversion[ theUnit ][ scope.defaultUnit ];\n\n\t\t\t\tif ( scale < 0 ) {\n\n\t\t\t\t\t// Conversion scale to pixels\n\n\t\t\t\t\tscale = unitConversion[ theUnit ][ 'in' ] * scope.defaultDPI;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn scale * parseFloat( string );\n\n\t\t}\n\n\t\t// Transforms\n\n\t\tfunction getNodeTransform( node ) {\n\n\t\t\tif ( ! ( node.hasAttribute( 'transform' ) || ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) ) ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar transform = parseNodeTransform( node );\n\n\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\ttransform.premultiply( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t}\n\n\t\t\tcurrentTransform.copy( transform );\n\t\t\ttransformStack.push( transform );\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction parseNodeTransform( node ) {\n\n\t\t\tvar transform = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aA();\n\t\t\tvar currentTransform = tempTransform0;\n\n\t\t\tif ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) {\n\n\t\t\t\tvar tx = parseFloatWithUnits( node.getAttribute( 'x' ) );\n\t\t\t\tvar ty = parseFloatWithUnits( node.getAttribute( 'y' ) );\n\n\t\t\t\ttransform.translate( tx, ty );\n\n\t\t\t}\n\n\t\t\tif ( node.hasAttribute( 'transform' ) ) {\n\n\t\t\t\tvar transformsTexts = node.getAttribute( 'transform' ).split( ')' );\n\n\t\t\t\tfor ( var tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) {\n\n\t\t\t\t\tvar transformText = transformsTexts[ tIndex ].trim();\n\n\t\t\t\t\tif ( transformText === '' ) continue;\n\n\t\t\t\t\tvar openParPos = transformText.indexOf( '(' );\n\t\t\t\t\tvar closeParPos = transformText.length;\n\n\t\t\t\t\tif ( openParPos > 0 && openParPos < closeParPos ) {\n\n\t\t\t\t\t\tvar transformType = transformText.substr( 0, openParPos );\n\n\t\t\t\t\t\tvar array = parseFloats( transformText.substr( openParPos + 1, closeParPos - openParPos - 1 ) );\n\n\t\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t\t\tswitch ( transformType ) {\n\n\t\t\t\t\t\t\tcase 'translate':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tvar tx = array[ 0 ];\n\t\t\t\t\t\t\t\t\tvar ty = tx;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tty = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.translate( tx, ty );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'rotate':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tvar angle = 0;\n\t\t\t\t\t\t\t\t\tvar cx = 0;\n\t\t\t\t\t\t\t\t\tvar cy = 0;\n\n\t\t\t\t\t\t\t\t\t// Angle\n\t\t\t\t\t\t\t\t\tangle = - array[ 0 ] * Math.PI / 180;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 3 ) {\n\n\t\t\t\t\t\t\t\t\t\t// Center x, y\n\t\t\t\t\t\t\t\t\t\tcx = array[ 1 ];\n\t\t\t\t\t\t\t\t\t\tcy = array[ 2 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Rotate around center (cx, cy)\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( - cx, - cy );\n\t\t\t\t\t\t\t\t\ttempTransform2.identity().rotate( angle );\n\t\t\t\t\t\t\t\t\ttempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( cx, cy );\n\t\t\t\t\t\t\t\t\tcurrentTransform.multiplyMatrices( tempTransform1, tempTransform3 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'scale':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tvar scaleX = array[ 0 ];\n\t\t\t\t\t\t\t\t\tvar scaleY = scaleX;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tscaleY = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.scale( scaleX, scaleY );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'skewX':\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,\n\t\t\t\t\t\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'skewY':\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t\t\t\t\t\tMath.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'matrix':\n\n\t\t\t\t\t\t\t\tif ( array.length === 6 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\tarray[ 0 ], array[ 2 ], array[ 4 ],\n\t\t\t\t\t\t\t\t\t\tarray[ 1 ], array[ 3 ], array[ 5 ],\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttransform.premultiply( currentTransform );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction transformPath( path, m ) {\n\n\t\t\tfunction transfVec2( v2 ) {\n\n\t\t\t\ttempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );\n\n\t\t\t\tv2.set( tempV3.x, tempV3.y );\n\n\t\t\t}\n\n\t\t\tvar isRotated = isTransformRotated( m );\n\n\t\t\tvar subPaths = path.subPaths;\n\n\t\t\tfor ( var i = 0, n = subPaths.length; i < n; i ++ ) {\n\n\t\t\t\tvar subPath = subPaths[ i ];\n\t\t\t\tvar curves = subPath.curves;\n\n\t\t\t\tfor ( var j = 0; j < curves.length; j ++ ) {\n\n\t\t\t\t\tvar curve = curves[ j ];\n\n\t\t\t\t\tif ( curve.isLineCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isCubicBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\t\t\t\t\t\ttransfVec2( curve.v3 );\n\n\t\t\t\t\t} else if ( curve.isQuadraticBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isEllipseCurve ) {\n\n\t\t\t\t\t\tif ( isRotated ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttempV2.set( curve.aX, curve.aY );\n\t\t\t\t\t\ttransfVec2( tempV2 );\n\t\t\t\t\t\tcurve.aX = tempV2.x;\n\t\t\t\t\t\tcurve.aY = tempV2.y;\n\n\t\t\t\t\t\tcurve.xRadius *= getTransformScaleX( m );\n\t\t\t\t\t\tcurve.yRadius *= getTransformScaleY( m );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction isTransformRotated( m ) {\n\n\t\t\treturn m.elements[ 1 ] !== 0 || m.elements[ 3 ] !== 0;\n\n\t\t}\n\n\t\tfunction getTransformScaleX( m ) {\n\n\t\t\tvar te = m.elements;\n\t\t\treturn Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] );\n\n\t\t}\n\n\t\tfunction getTransformScaleY( m ) {\n\n\t\t\tvar te = m.elements;\n\t\t\treturn Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] );\n\n\t\t}\n\n\t\t//\n\n\t\tvar paths = [];\n\t\tvar stylesheets = {};\n\n\t\tvar transformStack = [];\n\n\t\tvar tempTransform0 = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aA();\n\t\tvar tempTransform1 = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aA();\n\t\tvar tempTransform2 = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aA();\n\t\tvar tempTransform3 = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aA();\n\t\tvar tempV2 = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\t\tvar tempV3 = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t\tvar currentTransform = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aA();\n\n\t\tvar xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml\n\n\t\tparseNode( xml.documentElement, {\n\t\t\tfill: '#000',\n\t\t\tfillOpacity: 1,\n\t\t\tstrokeOpacity: 1,\n\t\t\tstrokeWidth: 1,\n\t\t\tstrokeLineJoin: 'miter',\n\t\t\tstrokeLineCap: 'butt',\n\t\t\tstrokeMiterLimit: 4\n\t\t} );\n\n\t\tvar data = { paths: paths, xml: xml.documentElement };\n\n\t\t// console.log( paths );\n\t\treturn data;\n\n\t}\n\n} );\n\nSVGLoader.getStrokeStyle = function ( width, color, lineJoin, lineCap, miterLimit ) {\n\n\t// Param width: Stroke width\n\t// Param color: As returned by THREE.Color.getStyle()\n\t// Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n\t// Param lineCap: One of \"round\", \"square\" or \"butt\"\n\t// Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n\t// Returns style object\n\n\twidth = width !== undefined ? width : 1;\n\tcolor = color !== undefined ? color : '#000';\n\tlineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n\tlineCap = lineCap !== undefined ? lineCap : 'butt';\n\tmiterLimit = miterLimit !== undefined ? miterLimit : 4;\n\n\treturn {\n\t\tstrokeColor: color,\n\t\tstrokeWidth: width,\n\t\tstrokeLineJoin: lineJoin,\n\t\tstrokeLineCap: lineCap,\n\t\tstrokeMiterLimit: miterLimit\n\t};\n\n};\n\nSVGLoader.pointsToStroke = function ( points, style, arcDivisions, minDistance ) {\n\n\t// Generates a stroke with some witdh around the given path.\n\t// The path can be open or closed (last point equals to first point)\n\t// Param points: Array of Vector2D (the path). Minimum 2 points.\n\t// Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n\t// Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n\t// Param minDistance: Points closer to this distance will be merged. (Optional)\n\t// Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\tif ( SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) {\n\n\t\treturn null;\n\n\t}\n\n\tvar geometry = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\tgeometry.setAttribute( 'position', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( vertices, 3 ) );\n\tgeometry.setAttribute( 'normal', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( normals, 3 ) );\n\tgeometry.setAttribute( 'uv', new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.d( uvs, 2 ) );\n\n\treturn geometry;\n\n};\n\nSVGLoader.pointsToStrokeWithBuffers = function () {\n\n\tvar tempV2_1 = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar tempV2_2 = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar tempV2_3 = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar tempV2_4 = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar tempV2_5 = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar tempV2_6 = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar tempV2_7 = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar lastPointL = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar lastPointR = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar point0L = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar point0R = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar currentPointL = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar currentPointR = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar nextPointL = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar nextPointR = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar innerPoint = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar outerPoint = new _index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\n\treturn function ( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) {\n\n\t\t// This function can be called to update existing arrays or buffers.\n\t\t// Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n\t\t// Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n\t\t// Returns number of written vertices / normals / uvs pairs\n\t\t// if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n\t\t// 'normals' and 'uvs' buffers are optional\n\n\t\tarcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n\t\tminDistance = minDistance !== undefined ? minDistance : 0.001;\n\t\tvertexOffset = vertexOffset !== undefined ? vertexOffset : 0;\n\n\t\t// First ensure there are no duplicated points\n\t\tpoints = removeDuplicatedPoints( points );\n\n\t\tvar numPoints = points.length;\n\n\t\tif ( numPoints < 2 ) return 0;\n\n\t\tvar isClosed = points[ 0 ].equals( points[ numPoints - 1 ] );\n\n\t\tvar currentPoint;\n\t\tvar previousPoint = points[ 0 ];\n\t\tvar nextPoint;\n\n\t\tvar strokeWidth2 = style.strokeWidth / 2;\n\n\t\tvar deltaU = 1 / ( numPoints - 1 );\n\t\tvar u0 = 0;\n\n\t\tvar innerSideModified;\n\t\tvar joinIsOnLeftSide;\n\t\tvar isMiter;\n\t\tvar initialJoinIsOnLeftSide = false;\n\n\t\tvar numVertices = 0;\n\t\tvar currentCoordinate = vertexOffset * 3;\n\t\tvar currentCoordinateUV = vertexOffset * 2;\n\n\t\t// Get initial left and right stroke points\n\t\tgetNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 );\n\t\tlastPointL.copy( points[ 0 ] ).sub( tempV2_1 );\n\t\tlastPointR.copy( points[ 0 ] ).add( tempV2_1 );\n\t\tpoint0L.copy( lastPointL );\n\t\tpoint0R.copy( lastPointR );\n\n\t\tfor ( var iPoint = 1; iPoint < numPoints; iPoint ++ ) {\n\n\t\t\tcurrentPoint = points[ iPoint ];\n\n\t\t\t// Get next point\n\t\t\tif ( iPoint === numPoints - 1 ) {\n\n\t\t\t\tif ( isClosed ) {\n\n\t\t\t\t\t// Skip duplicated initial point\n\t\t\t\t\tnextPoint = points[ 1 ];\n\n\t\t\t\t} else nextPoint = undefined;\n\n\t\t\t} else {\n\n\t\t\t\tnextPoint = points[ iPoint + 1 ];\n\n\t\t\t}\n\n\t\t\t// Normal of previous segment in tempV2_1\n\t\t\tvar normal1 = tempV2_1;\n\t\t\tgetNormal( previousPoint, currentPoint, normal1 );\n\n\t\t\ttempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 );\n\t\t\tcurrentPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\tcurrentPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\tvar u1 = u0 + deltaU;\n\n\t\t\tinnerSideModified = false;\n\n\t\t\tif ( nextPoint !== undefined ) {\n\n\t\t\t\t// Normal of next segment in tempV2_2\n\t\t\t\tgetNormal( currentPoint, nextPoint, tempV2_2 );\n\n\t\t\t\ttempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 );\n\t\t\t\tnextPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\t\tnextPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\t\tjoinIsOnLeftSide = true;\n\t\t\t\ttempV2_3.subVectors( nextPoint, previousPoint );\n\t\t\t\tif ( normal1.dot( tempV2_3 ) < 0 ) {\n\n\t\t\t\t\tjoinIsOnLeftSide = false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n\n\t\t\t\ttempV2_3.subVectors( nextPoint, currentPoint );\n\t\t\t\ttempV2_3.normalize();\n\t\t\t\tvar dot = Math.abs( normal1.dot( tempV2_3 ) );\n\n\t\t\t\t// If path is straight, don't create join\n\t\t\t\tif ( dot !== 0 ) {\n\n\t\t\t\t\t// Compute inner and outer segment intersections\n\t\t\t\t\tvar miterSide = strokeWidth2 / dot;\n\t\t\t\t\ttempV2_3.multiplyScalar( - miterSide );\n\t\t\t\t\ttempV2_4.subVectors( currentPoint, previousPoint );\n\t\t\t\t\ttempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 );\n\t\t\t\t\tinnerPoint.copy( tempV2_5 ).negate();\n\t\t\t\t\tvar miterLength2 = tempV2_5.length();\n\t\t\t\t\tvar segmentLengthPrev = tempV2_4.length();\n\t\t\t\t\ttempV2_4.divideScalar( segmentLengthPrev );\n\t\t\t\t\ttempV2_6.subVectors( nextPoint, currentPoint );\n\t\t\t\t\tvar segmentLengthNext = tempV2_6.length();\n\t\t\t\t\ttempV2_6.divideScalar( segmentLengthNext );\n\t\t\t\t\t// Check that previous and next segments doesn't overlap with the innerPoint of intersection\n\t\t\t\t\tif ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) {\n\n\t\t\t\t\t\tinnerSideModified = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\touterPoint.copy( tempV2_5 ).add( currentPoint );\n\t\t\t\t\tinnerPoint.add( currentPoint );\n\n\t\t\t\t\tisMiter = false;\n\n\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\tnextPointR.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointR.copy( innerPoint );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tnextPointL.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointL.copy( innerPoint );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// The segment triangles are generated here if there was overlapping\n\n\t\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( style.strokeLineJoin ) {\n\n\t\t\t\t\t\tcase 'bevel':\n\n\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'round':\n\n\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t// Join triangles\n\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'miter':\n\t\t\t\t\t\tcase 'miter-clip':\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tvar miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2;\n\n\t\t\t\t\t\t\tif ( miterFraction < 1 ) {\n\n\t\t\t\t\t\t\t\t// The join miter length exceeds the miter limit\n\n\t\t\t\t\t\t\t\tif ( style.strokeLineJoin !== 'miter-clip' ) {\n\n\t\t\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t\t\t// Miter-clip join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Miter join segment triangles\n\n\t\t\t\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\t\t\t\t// Optimized segment + join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\tnextPointL.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tnextPointR.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Add extra miter join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tisMiter = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// The segment triangles are generated here when two consecutive points are collinear\n\n\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// The segment triangles are generated here if it is the ending segment\n\n\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t}\n\n\t\t\tif ( ! isClosed && iPoint === numPoints - 1 ) {\n\n\t\t\t\t// Start line endcap\n\t\t\t\taddCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 );\n\n\t\t\t}\n\n\t\t\t// Increment loop variables\n\n\t\t\tu0 = u1;\n\n\t\t\tpreviousPoint = currentPoint;\n\n\t\t\tlastPointL.copy( nextPointL );\n\t\t\tlastPointR.copy( nextPointR );\n\n\t\t}\n\n\t\tif ( ! isClosed ) {\n\n\t\t\t// Ending line endcap\n\t\t\taddCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 );\n\n\t\t} else if ( innerSideModified && vertices ) {\n\n\t\t\t// Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n\t\t\tvar lastOuter = outerPoint;\n\t\t\tvar lastInner = innerPoint;\n\n\t\t\tif ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) {\n\n\t\t\t\tlastOuter = innerPoint;\n\t\t\t\tlastInner = outerPoint;\n\n\t\t\t}\n\n\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\tif ( isMiter || initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 0 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 1 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( isMiter || ! initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 1 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn numVertices;\n\n\t\t// -- End of algorithm\n\n\t\t// -- Functions\n\n\t\tfunction getNormal( p1, p2, result ) {\n\n\t\t\tresult.subVectors( p2, p1 );\n\t\t\treturn result.set( - result.y, result.x ).normalize();\n\n\t\t}\n\n\t\tfunction addVertex( position, u, v ) {\n\n\t\t\tif ( vertices ) {\n\n\t\t\t\tvertices[ currentCoordinate ] = position.x;\n\t\t\t\tvertices[ currentCoordinate + 1 ] = position.y;\n\t\t\t\tvertices[ currentCoordinate + 2 ] = 0;\n\n\t\t\t\tif ( normals ) {\n\n\t\t\t\t\tnormals[ currentCoordinate ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 1 ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 2 ] = 1;\n\n\t\t\t\t}\n\n\t\t\t\tcurrentCoordinate += 3;\n\n\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\tuvs[ currentCoordinateUV ] = u;\n\t\t\t\t\tuvs[ currentCoordinateUV + 1 ] = v;\n\n\t\t\t\t\tcurrentCoordinateUV += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnumVertices += 3;\n\n\t\t}\n\n\t\tfunction makeCircularSector( center, p1, p2, u, v ) {\n\n\t\t\t// param p1, p2: Points in the circle arc.\n\t\t\t// p1 and p2 are in clockwise direction.\n\n\t\t\ttempV2_1.copy( p1 ).sub( center ).normalize();\n\t\t\ttempV2_2.copy( p2 ).sub( center ).normalize();\n\n\t\t\tvar angle = Math.PI;\n\t\t\tvar dot = tempV2_1.dot( tempV2_2 );\n\t\t\tif ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) );\n\n\t\t\tangle /= arcDivisions;\n\n\t\t\ttempV2_3.copy( p1 );\n\n\t\t\tfor ( var i = 0, il = arcDivisions - 1; i < il; i ++ ) {\n\n\t\t\t\ttempV2_4.copy( tempV2_3 ).rotateAround( center, angle );\n\n\t\t\t\taddVertex( tempV2_3, u, v );\n\t\t\t\taddVertex( tempV2_4, u, v );\n\t\t\t\taddVertex( center, u, 0.5 );\n\n\t\t\t\ttempV2_3.copy( tempV2_4 );\n\n\t\t\t}\n\n\t\t\taddVertex( tempV2_4, u, v );\n\t\t\taddVertex( p2, u, v );\n\t\t\taddVertex( center, u, 0.5 );\n\n\t\t}\n\n\t\tfunction makeSegmentTriangles() {\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( currentPointL, u1, 1 );\n\t\t\taddVertex( currentPointR, u1, 0 );\n\n\t\t}\n\n\t\tfunction makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t// Optimized segment + bevel triangles\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Bevel join triangle. The segment triangles are done in the main loop\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( nextPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointR, u0, 1 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( nextPointR, u0, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) {\n\n\t\t\t// param center: End point of the path\n\t\t\t// param p1, p2: Left and right cap points\n\n\t\t\tswitch ( style.strokeLineCap ) {\n\n\t\t\t\tcase 'round':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\tmakeCircularSector( center, p2, p1, u, 0.5 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmakeCircularSector( center, p1, p2, u, 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'square':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p1, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 3 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p2, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\tvar vl = vertices.length;\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction removeDuplicatedPoints( points ) {\n\n\t\t\t// Creates a new array if necessary with duplicated points removed.\n\t\t\t// This does not remove duplicated initial and ending points of a closed path.\n\n\t\t\tvar dupPoints = false;\n\t\t\tfor ( var i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) {\n\n\t\t\t\t\tdupPoints = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! dupPoints ) return points;\n\n\t\t\tvar newPoints = [];\n\t\t\tnewPoints.push( points[ 0 ] );\n\n\t\t\tfor ( var i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) {\n\n\t\t\t\t\tnewPoints.push( points[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnewPoints.push( points[ points.length - 1 ] );\n\n\t\t\treturn newPoints;\n\n\t\t}\n\n\t};\n\n}();\n\n_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.U.DefaultUp.set(0, 0, 1);\nvar defaultColor = 'hotpink';\nvar traverseChildren = function (child, opacity, shadow) {\n    if (child.isMesh) {\n        if (shadow) {\n            child.castShadow = true;\n            child.receiveShadow = true;\n        }\n        if (opacity !== 1.0) {\n            if (child.material.isMaterial) {\n                child.material.transparent = true;\n                child.material.opacity = opacity;\n            }\n            else if (Array.isArray(child.material)) {\n                child.material.forEach(function (mat) {\n                    mat.transparent = true;\n                    mat.opacity = opacity;\n                });\n            }\n        }\n    }\n    else if (child.type === 'PointLight') {\n        child.visible = false;\n    }\n    else if (child.isObject3D || child.isGroup) {\n        child.children.forEach(function (child2) {\n            traverseChildren(child2, opacity, shadow);\n        });\n    }\n};\nvar STLAsset = function (props) {\n    var model = (0,_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aD)(STLLoader, props.url);\n    var scene = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () { return model.clone(); }, [model]);\n    // console.log('Loading: ')\n    // console.log(props)\n    // useEffect(() => {\n    //     // scene.children.forEach((child) => {\n    //     //     traverseChildren(child, props.opacity, true)\n    //     // })\n    //     scene.name = 'loaded'\n    // })\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", { position: [props.t[0], props.t[1], props.t[2]], quaternion: [props.q[0], props.q[1], props.q[2], props.q[3]], scale: [props.scale[0], props.scale[1], props.scale[2]], castShadow: true, receiveShadow: true, name: 'loaded' },\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", { object: scene, attach: \"geometry\" }),\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"meshStandardMaterial\", { color: props.color ? props.color : defaultColor, transparent: props.opacity !== 1.0 ? true : false, opacity: props.opacity ? props.opacity : 1.0 })));\n};\nvar GLTFAsset = function (props) {\n    var model = (0,_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aD)(GLTFLoader, props.url);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        model.scene.children.forEach(function (child) {\n            traverseChildren(child, props.opacity, true);\n        });\n    });\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", { position: [props.t[0], props.t[1], props.t[2]], quaternion: [props.q[0], props.q[1], props.q[2], props.q[3]], scale: [props.scale[0], props.scale[1], props.scale[2]], castShadow: true, receiveShadow: true },\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", { object: model.scene, opacity: props.opacity, castShadow: true, receiveShadow: true })));\n};\nvar ColladaAsset = function (props) {\n    var model = (0,_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aD)(ColladaLoader, props.url);\n    var scene = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () { return model.scene.clone(); }, [model.scene]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        scene.children.forEach(function (child) {\n            traverseChildren(child, props.opacity, true);\n        });\n        scene.name = 'loaded';\n        // if (props.q) {\n        //     model.scene.quaternion.set(\n        //         props.q[0],\n        //         props.q[1],\n        //         props.q[2],\n        //         props.q[3]\n        //     )\n        // }\n    });\n    // return (\n    //     <group\n    //         position={props.t}\n    //         castShadow={true}\n    //         receiveShadow={true}\n    //         scale={props.scale}\n    //         quaternion={props.q}\n    //     >\n    //         <primitive object={model.scene} />\n    //     </group>\n    // )\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", { object: scene, position: props.t, scale: props.scale, quaternion: props.q }));\n};\nvar OBJAsset = function (props) {\n    var mtlurl = props.url.slice(0, props.url.length - 3) + 'mtl';\n    var materials = (0,_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aD)(MTLLoader, mtlurl);\n    var model = (0,_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aD)(OBJLoader, props.url, function (loader) {\n        materials.preload();\n        // loader.setMaterials(materials)\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        model.children.forEach(function (child) {\n            traverseChildren(child, props.opacity, true);\n        });\n    });\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", { position: [props.t[0], props.t[1], props.t[2]], quaternion: [props.q[0], props.q[1], props.q[2], props.q[3]], scale: [props.scale[0], props.scale[1], props.scale[2]], castShadow: true, receiveShadow: true },\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", { object: model })));\n};\nvar VRMLAsset = function (props) {\n    var model = (0,_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aD)(VRMLLoader, props.url);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        model.children.forEach(function (child) {\n            traverseChildren(child, props.opacity, true);\n        });\n    });\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", { position: [props.t[0], props.t[1], props.t[2]], quaternion: [props.q[0], props.q[1], props.q[2], props.q[3]], scale: [props.scale[0], props.scale[1], props.scale[2]], castShadow: true, receiveShadow: true },\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", { object: model })));\n};\nvar PCDAsset = function (props) {\n    var model = (0,_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aD)(PCDLoader, props.url);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        // model.material.color = props.color\n        //     ? new THREE.Color(props.color)\n        //     : new THREE.Color(defaultColor)\n        // model.material.transparent = props.opacity !== 1.0 ? true : false\n        // model.material.opacity = props.opacity ? props.opacity : 1.0\n    });\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", { position: [props.t[0], props.t[1], props.t[2]], quaternion: [props.q[0], props.q[1], props.q[2], props.q[3]], scale: [props.scale[0], props.scale[1], props.scale[2]], castShadow: true, receiveShadow: true },\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", { object: model })));\n};\nvar PLYAsset = function (props) {\n    var model = (0,_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aD)(PLYLoader, props.url);\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", { position: [props.t[0], props.t[1], props.t[2]], quaternion: [props.q[0], props.q[1], props.q[2], props.q[3]], scale: [props.scale[0], props.scale[1], props.scale[2]], castShadow: true, receiveShadow: true },\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", { object: model, attach: \"geometry\" }),\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"meshStandardMaterial\", { color: props.color ? props.color : defaultColor, transparent: props.opacity !== 1.0 ? true : false, opacity: props.opacity ? props.opacity : 1.0 })));\n};\nvar FBXAsset = function (props) {\n    var model = (0,_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aD)(FBXLoader, props.url);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        model.children.forEach(function (child) {\n            traverseChildren(child, props.opacity, true);\n        });\n    });\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", { position: [props.t[0], props.t[1], props.t[2]], quaternion: [props.q[0], props.q[1], props.q[2], props.q[3]], scale: [props.scale[0], props.scale[1], props.scale[2]], castShadow: true, receiveShadow: true },\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", { object: model })));\n};\nvar SVGShape = function (_a) {\n    var shape = _a.shape, color = _a.color, index = _a.index, opacity = _a.opacity;\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", null,\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"meshLambertMaterial\", { attach: \"material\", color: color, polygonOffset: true, polygonOffsetFactor: index * -0.1, transparent: opacity !== 1.0 ? true : false, opacity: opacity ? opacity : 1.0 }),\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"shapeBufferGeometry\", { attach: \"geometry\", args: [shape] })));\n};\nvar SVGAsset = react__WEBPACK_IMPORTED_MODULE_1__.memo(function (props) {\n    var paths = (0,_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aD)(SVGLoader, props.url).paths;\n    var shapes = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () {\n        return paths.flatMap(function (path, index) {\n            return path\n                .toShapes(true)\n                .map(function (shape) { return ({ index: index, shape: shape, color: path.color }); });\n        });\n    }, [paths]);\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", { children: shapes.map(function (newProps, key) { return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(SVGShape, (0,_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ key: key, opacity: props.opacity }, newProps))); }), scale: [\n            -0.01 * props.scale[0],\n            0.01 * props.scale[1],\n            0.01 * props.scale[2],\n        ], position: [props.t[0], props.t[1], props.t[2]], quaternion: [props.q[0], props.q[1], props.q[2], props.q[3]] }));\n});\nvar Loader = function (props) {\n    var ext = props.filename.split('.').pop().toLowerCase();\n    var url = props.filename;\n    url = \"retrieve/\" + url;\n    switch (ext) {\n        case 'stl':\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(STLAsset, (0,_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n        case 'gltf':\n        case 'glb':\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(GLTFAsset, (0,_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n        case 'dae':\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(ColladaAsset, (0,_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n        case 'obj':\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(OBJAsset, (0,_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n        case 'wrl':\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(VRMLAsset, (0,_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n        case 'pcd':\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(PCDAsset, (0,_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n        case 'ply':\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(PLYAsset, (0,_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n        case 'fbx':\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(FBXAsset, (0,_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n        case 'svg':\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(SVGAsset, (0,_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n        default:\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(ColladaAsset, (0,_index_13441088_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Loader);\n//# sourceMappingURL=Loader-1cb5ada7.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3JlYWN0LXN3aWZ0L2Rpc3QvTG9hZGVyLTFjYjVhZGE3LmpzP2QwMmMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUF3ekQ7QUFDN3ZEO0FBQ3hDOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyw4Q0FBOEM7QUFDNUYsS0FBSyxPQUFPO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsQ0FBQyxzREFBYTs7QUFFZDs7QUFFQSxvREFBb0QsMkRBQWtCOztBQUV0RTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsaURBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUgsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEscUJBQXFCLFNBQVM7O0FBRTlCOztBQUVBOztBQUVBOztBQUVBLGtEQUFrRDs7QUFFbEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLFFBQVE7O0FBRTlDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7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QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUosR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVUsNERBQXNCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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OztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLGFBQWE7O0FBRWxDLHNCQUFzQixhQUFhOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLGFBQWE7O0FBRWxDLHNCQUFzQixhQUFhOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNB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QTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7O0FBRUEsaURBQWlELFFBQVE7O0FBRXpEOztBQUVBOztBQUVBOztBQUVBLGNBQWMsaURBQWE7O0FBRTNCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhDQUE4QyxPQUFPOztBQUVyRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxPQUFPOztBQUVyRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsa0NBQWtDLE9BQU87O0FBRXpDLGlDQUFpQztBQUNqQzs7QUFFQSxnQkFBZ0IsZ0JBQWdCOztBQUVoQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLHVDQUF1Qzs7QUFFbEU7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQixnQkFBZ0I7O0FBRWhDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJCQUEyQixpREFBTzs7QUFFbEMsSUFBSTs7QUFFSiwyQkFBMkIsaURBQU87O0FBRWxDOztBQUVBOztBQUVBLDZDQUE2QyxPQUFPOztBQUVwRDtBQUNBLDBCQUEwQixpREFBTzs7QUFFakMsd0JBQXdCLHVDQUF1Qzs7QUFFL0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhDQUE4QyxPQUFPOztBQUVyRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsOENBQThDLE9BQU87O0FBRXJEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsOENBQThDLE9BQU87O0FBRXJEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhDQUE4QyxPQUFPOztBQUVyRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhDQUE4QyxPQUFPOztBQUVyRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhDQUE4QyxPQUFPOztB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGdEQUFnRCxTQUFTOztBQUV6RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7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LHNDQUFzQyxPQUFPOztBQUU3QztBQUNBOztBQUVBLDRCQUE0QixpREFBUTs7QUFFcEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLE9BQU87O0FBRTlDOztBQUVBOztBQUVBOztBQUVBLCtDQUErQyxRQUFROztBQUV2RDs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUJBQXFCLGlEQUFLOztBQUUxQjs7QUFFQTs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsaURBQU87QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLGlEQUFLOztBQUV6QjtBQUNBOztBQUVBOztBQUVBLHVDQUF1QyxPQUFPOztBQUU5QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQkFBMkIsa0RBQWM7QUFDekMsMkJBQTJCLGlEQUFpQixHQUFHLG1CQUFtQixrREFBUSx1Q0FBdUM7O0FBRWpIOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQSxtQkFBbUIsaURBQUk7QUFDdkI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsK0JBQStCLGtEQUFjO0FBQzdDLCtCQUErQixpREFBaUIsR0FBRyxtQkFBbUIsa0RBQVEsMkRBQTJEOztBQUV6STs7QUFFQSx1QkFBdUIsaURBQUk7QUFDM0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLGlEQUFpQixHQUFHLGtCQUFrQjtBQUM3RDs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsK0JBQStCOztBQUUvQiwrQkFBK0IsaURBQWMsR0FBRyxrQkFBa0I7O0FBRWxFOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLGlEQUFNOztBQUV6QixNQUFNLDhCQUE4Qjs7QUFFcEMsNkJBQTZCLGlEQUFpQixHQUFHLGtCQUFrQjs7QUFFbkU7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsaURBQVk7O0FBRS9CLE1BQU0sT0FBTzs7QUFFYjs7QUFFQTs7QUFFQSw2Q0FBNkMsa0RBQVMsR0FBRyxpREFBVTs7QUFFbkU7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLGlEQUFJOztBQUV2Qjs7QUFFQSxLQUFLOztBQUVMLGtCQUFrQixpREFBUTs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLGtEQUFpQjtBQUN4Qzs7QUFFQTs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUEsdUJBQXVCLGlEQUFpQixHQUFHLGtCQUFrQjs7QUFFN0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDLDZCQUE2QjtBQUM3Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QyxpREFBSztBQUM1Qzs7QUFFQTtBQUNBLHdDQUF3QyxpREFBSztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsaURBQUs7QUFDN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0IsaURBQWM7QUFDOUIsZ0JBQWdCLGlEQUFjOztBQUU5Qjs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0I7O0FBRXBCLHVEQUF1RCxRQUFROztBQUUvRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxxQkFBcUIsa0RBQVcsK0NBQStDLGtEQUFVLEdBQUcsaURBQVM7QUFDckcsb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0EsaURBQWlELGtEQUFtQjtBQUNwRTs7QUFFQTtBQUNBLGlEQUFpRCxrREFBbUI7QUFDcEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0IsaURBQWM7QUFDOUIsZ0JBQWdCLGlEQUFjOztBQUU5Qjs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlELGtEQUFtQjtBQUNwRTs7QUFFQTtBQUNBLGlEQUFpRCxrREFBbUI7QUFDcEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUIsaURBQU87QUFDeEIsbUJBQW1CLGlEQUFPO0FBQzFCLGdCQUFnQixpREFBTztBQUN2QixzQkFBc0IsaURBQU87QUFDN0I7O0FBRUE7O0FBRUEsdUNBQXVDLE9BQU87O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1QyxPQUFPOztBQUU5QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUNBQXVDLE9BQU87O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZ0JBQWdCLGlEQUFjLEdBQUc7O0FBRWpDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQSwyRUFBMkUsaURBQXNCOztBQUVqRzs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQSw0RUFBNEUsaURBQXNCOztBQUVsRzs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQSxNQUFNOztBQUVOOztBQUVBLHVFQUF1RSxpREFBc0I7O0FBRTdGOztBQUVBOztBQUVBLHVCQUF1QixpREFBYztBQUNyQywyRUFBMkUsaURBQXNCOztBQUVqRztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUNBQXVDLE9BQU87O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBEQUEwRDs7QUFFMUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsOERBQThEO0FBQzlELDJHQUEyRzs7QUFFM0csT0FBTzs7QUFFUDs7QUFFQSxzRUFBc0UsaURBQXNCOztBQUU1Rjs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBLGdFQUFnRTtBQUNoRSxnRkFBZ0Y7QUFDaEYsOEZBQThGOzs7QUFHOUYsT0FBTzs7QUFFUDs7QUFFQSxvRUFBb0U7QUFDcEUsOEZBQThGOztBQUU5Rjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1QkFBdUIsaURBQWM7O0FBRXJDLDBFQUEwRSxpREFBc0I7QUFDaEc7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVCQUF1QixpREFBYzs7QUFFckMsMkNBQTJDLGlEQUFzQjtBQUNqRSxxREFBcUQsaURBQXNCOztBQUUzRTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsaURBQU87O0FBRTFCOztBQUVBLHVDQUF1QyxPQUFPOztBQUU5QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLGtEQUFXOztBQUVsQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLGtEQUFZOztBQUVuQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVCQUF1QixrREFBZ0I7O0FBRXZDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1QyxPQUFPOztBQUU5QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx1QkFBdUIsa0RBQWM7O0FBRXJDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsUUFBUTs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxrREFBTzs7QUFFckIsa0JBQWtCLFFBQVE7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjs7QUFFQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsUUFBUTs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0IsUUFBUTs7QUFFMUI7O0FBRUE7O0FBRUEsa0JBQWtCLFFBQVE7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsUUFBUTs7QUFFM0I7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLFFBQVE7O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7O0FBRTlCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7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LEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtGQUFrRjtBQUNsRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLG1CQUFtQixVQUFVOztBQUU3Qjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLG1CQUFtQixVQUFVOztBQUU3Qjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxtQkFBbUIsVUFBVTs7QUFFN0I7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsbUJBQW1CLFVBQVU7O0FBRTdCOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsbUJBQW1CLFVBQVU7O0FBRTdCOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsd0RBQXdEO0FBQ3hEOztBQUVBLG1CQUFtQixVQUFVOztBQUU3Qjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLFVBQVUsNERBQXNCOztBQUVoQzs7QUFFQTs7QUFFQTtB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QUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsZ0NBQWdDOztBQUVuRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IseUJBQXlCOztBQUU3QztBQUNBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixrREFBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixrREFBUzs7QUFFM0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixrREFBUzs7QUFFM0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixrREFBSTtBQUN6Qjs7QUFFQSxrQkFBa0Isa0RBQVM7QUFDM0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGtEQUFJO0FBQ3pCOztBQUVBLGtCQUFrQixrREFBUztBQUMzQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isa0RBQVM7QUFDM0I7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDRCQUE0QixVQUFVOztBQUV0Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsMkJBQTJCOztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGVBQWUsWUFBWTs7QUFFM0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLGtEQUFPO0FBQzlCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0RBQWtELGFBQWE7O0FBRS9EOztBQUVB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixvQkFBb0I7O0FBRTNDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTs7QUFFVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBLFVBQVU7O0FBRVY7O0FBRUE7OztBQUdBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMENBQTBDLFFBQVE7O0FBRWxEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsT0FBTzs7QUFFakQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDBDQUEwQyxPQUFPOztBQUVqRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVELCtEQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFTO0FBQ3pCLGdCQUFnQiw4Q0FBTyxjQUFjLHNCQUFzQixFQUFFO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxRQUFRO0FBQ1IsWUFBWSxnREFBNEIsVUFBVSwrTkFBK047QUFDalIsUUFBUSxnREFBNEIsZUFBZSxvQ0FBb0M7QUFDdkYsUUFBUSxnREFBNEIsMEJBQTBCLG1KQUFtSjtBQUNqTjtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFTO0FBQ3pCLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCxZQUFZLGdEQUE0QixVQUFVLCtNQUErTTtBQUNqUSxRQUFRLGdEQUE0QixlQUFlLHFGQUFxRjtBQUN4STtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFTO0FBQ3pCLGdCQUFnQiw4Q0FBTyxjQUFjLDRCQUE0QixFQUFFO0FBQ25FLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQiw4QkFBOEI7QUFDOUIsc0JBQXNCO0FBQ3RCLDJCQUEyQjtBQUMzQjtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0E7QUFDQSxZQUFZLGdEQUE0QixlQUFlLDRFQUE0RTtBQUNuSTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQVM7QUFDN0IsZ0JBQWdCLHNEQUFTO0FBQ3pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMLFlBQVksZ0RBQTRCLFVBQVUsK01BQStNO0FBQ2pRLFFBQVEsZ0RBQTRCLGVBQWUsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQVM7QUFDekIsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMLFlBQVksZ0RBQTRCLFVBQVUsK01BQStNO0FBQ2pRLFFBQVEsZ0RBQTRCLGVBQWUsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQVM7QUFDekIsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxnREFBNEIsVUFBVSwrTUFBK007QUFDalEsUUFBUSxnREFBNEIsZUFBZSxnQkFBZ0I7QUFDbkU7QUFDQTtBQUNBLGdCQUFnQixzREFBUztBQUN6QixZQUFZLGdEQUE0QixVQUFVLCtNQUErTTtBQUNqUSxRQUFRLGdEQUE0QixlQUFlLG9DQUFvQztBQUN2RixRQUFRLGdEQUE0QiwwQkFBMEIsbUpBQW1KO0FBQ2pOO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQVM7QUFDekIsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMLFlBQVksZ0RBQTRCLFVBQVUsK01BQStNO0FBQ2pRLFFBQVEsZ0RBQTRCLGVBQWUsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0RBQTRCO0FBQ3hDLFFBQVEsZ0RBQTRCLHlCQUF5QiwwS0FBMEs7QUFDdk8sUUFBUSxnREFBNEIseUJBQXlCLG9DQUFvQztBQUNqRztBQUNBLGVBQWUsdUNBQW1CO0FBQ2xDLGdCQUFnQixzREFBUztBQUN6QixpQkFBaUIsOENBQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFVBQVUsZ0RBQWdELEVBQUUsRUFBRTtBQUNyRyxTQUFTO0FBQ1QsS0FBSztBQUNMLFlBQVksZ0RBQTRCLFdBQVcsZ0RBQWdELFNBQVMsZ0RBQTRCLFdBQVcsc0RBQVEsRUFBRSxtQ0FBbUMsY0FBYyxFQUFFO0FBQ2hOO0FBQ0E7QUFDQTtBQUNBLHlIQUF5SDtBQUN6SCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdEQUE0QixXQUFXLHNEQUFRLEVBQUUsV0FBVztBQUMvRTtBQUNBO0FBQ0EsbUJBQW1CLGdEQUE0QixZQUFZLHNEQUFRLEVBQUUsV0FBVztBQUNoRjtBQUNBLG1CQUFtQixnREFBNEIsZUFBZSxzREFBUSxFQUFFLFdBQVc7QUFDbkY7QUFDQSxtQkFBbUIsZ0RBQTRCLFdBQVcsc0RBQVEsRUFBRSxXQUFXO0FBQy9FO0FBQ0EsbUJBQW1CLGdEQUE0QixZQUFZLHNEQUFRLEVBQUUsV0FBVztBQUNoRjtBQUNBLG1CQUFtQixnREFBNEIsV0FBVyxzREFBUSxFQUFFLFdBQVc7QUFDL0U7QUFDQSxtQkFBbUIsZ0RBQTRCLFdBQVcsc0RBQVEsRUFBRSxXQUFXO0FBQy9FO0FBQ0EsbUJBQW1CLGdEQUE0QixXQUFXLHNEQUFRLEVBQUUsV0FBVztBQUMvRTtBQUNBLG1CQUFtQixnREFBNEIsV0FBVyxzREFBUSxFQUFFLFdBQVc7QUFDL0U7QUFDQSxtQkFBbUIsZ0RBQTRCLGVBQWUsc0RBQVEsRUFBRSxXQUFXO0FBQ25GO0FBQ0E7O0FBRUEsK0RBQWUsTUFBTSxFQUFDO0FBQ3RCIiwiZmlsZSI6Ii4uLy4uL3JlYWN0LXN3aWZ0L2Rpc3QvTG9hZGVyLTFjYjVhZGE3LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTCBhcyBMb2FkZXIkMSwgRiBhcyBGaWxlTG9hZGVyLCBCIGFzIEJ1ZmZlckdlb21ldHJ5LCBjIGFzIEJ1ZmZlckF0dHJpYnV0ZSwgViBhcyBWZWN0b3IzLCBkIGFzIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUsIGYgYXMgTG9hZGVyVXRpbHMsIGcgYXMgTWVzaEJhc2ljTWF0ZXJpYWwsIEMgYXMgQ29sb3IsIGggYXMgTWVzaFN0YW5kYXJkTWF0ZXJpYWwsIGkgYXMgVGFuZ2VudFNwYWNlTm9ybWFsTWFwLCBJIGFzIEltYWdlQml0bWFwTG9hZGVyLCBqIGFzIFRleHR1cmVMb2FkZXIsIGsgYXMgSW50ZXJsZWF2ZWRCdWZmZXIsIGwgYXMgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUsIFIgYXMgUkdCRm9ybWF0LCBtIGFzIExpbmVhckZpbHRlciwgbiBhcyBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIsIG8gYXMgUmVwZWF0V3JhcHBpbmcsIFAgYXMgUG9pbnRzTWF0ZXJpYWwsIHAgYXMgTWF0ZXJpYWwsIHEgYXMgTGluZUJhc2ljTWF0ZXJpYWwsIEQgYXMgRG91YmxlU2lkZSwgYSBhcyBWZWN0b3IyLCBzIGFzIHNSR0JFbmNvZGluZywgciBhcyBQcm9wZXJ0eUJpbmRpbmcsIHQgYXMgU2tpbm5lZE1lc2gsIHYgYXMgTWVzaCwgdyBhcyBMaW5lU2VnbWVudHMsIHggYXMgTGluZSwgeSBhcyBMaW5lTG9vcCwgeiBhcyBQb2ludHMsIEcgYXMgR3JvdXAsIEEgYXMgUGVyc3BlY3RpdmVDYW1lcmEsIEggYXMgTWF0aFV0aWxzLCBPIGFzIE9ydGhvZ3JhcGhpY0NhbWVyYSwgSiBhcyBJbnRlcnBvbGF0ZUxpbmVhciwgSyBhcyBBbmltYXRpb25DbGlwLCBOIGFzIEJvbmUsIFUgYXMgT2JqZWN0M0QsIFcgYXMgTWF0cml4NCwgWCBhcyBTa2VsZXRvbiwgWSBhcyBTcG90TGlnaHQsIFogYXMgUG9pbnRMaWdodCwgXyBhcyBEaXJlY3Rpb25hbExpZ2h0LCAkIGFzIE1lc2hQaHlzaWNhbE1hdGVyaWFsLCBhMCBhcyBJbnRlcnBvbGFudCwgYTEgYXMgTmVhcmVzdEZpbHRlciwgYTIgYXMgTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIsIGEzIGFzIExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIsIGE0IGFzIE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIsIGE1IGFzIENsYW1wVG9FZGdlV3JhcHBpbmcsIGE2IGFzIE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcsIGE3IGFzIEludGVycG9sYXRlRGlzY3JldGUsIGE4IGFzIEZyb250U2lkZSwgYTkgYXMgQ2FudmFzVGV4dHVyZSwgYWEgYXMgVHJpYW5nbGVGYW5EcmF3TW9kZSwgYWIgYXMgVHJpYW5nbGVTdHJpcERyYXdNb2RlLCBhYyBhcyBWZWN0b3JLZXlmcmFtZVRyYWNrLCBhZCBhcyBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaywgYWUgYXMgTnVtYmVyS2V5ZnJhbWVUcmFjaywgYWYgYXMgQm94MywgYWcgYXMgU3BoZXJlLCBhaCBhcyBUZXh0dXJlLCBRIGFzIFF1YXRlcm5pb24sIGFpIGFzIFNjZW5lLCBhaiBhcyBFdWxlciwgYWsgYXMgTWVzaExhbWJlcnRNYXRlcmlhbCwgYWwgYXMgTWVzaFBob25nTWF0ZXJpYWwsIGFtIGFzIEFtYmllbnRMaWdodCwgYW4gYXMgRGVmYXVsdExvYWRpbmdNYW5hZ2VyLCBhbyBhcyBTcGhlcmVHZW9tZXRyeSwgYXAgYXMgQmFja1NpZGUsIGFxIGFzIERhdGFUZXh0dXJlLCBhciBhcyBSR0JBRm9ybWF0LCBhcyBhcyBCb3hHZW9tZXRyeSwgYXQgYXMgQ29uZUdlb21ldHJ5LCBhdSBhcyBDeWxpbmRlckdlb21ldHJ5LCBhdiBhcyBTaGFwZVV0aWxzLCBhdyBhcyBWZWN0b3I0LCBheCBhcyBDdXJ2ZSwgYXkgYXMgRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcsIGF6IGFzIFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSwgYUEgYXMgTWF0cml4MywgYUIgYXMgU2hhcGVQYXRoLCBhQyBhcyBQYXRoLCBhRCBhcyB1c2VMb2FkZXIsIGFFIGFzIF9fYXNzaWduIH0gZnJvbSAnLi9pbmRleC0xMzQ0MTA4OC5qcyc7XG5pbXBvcnQgUmVhY3RfX2RlZmF1bHQsIHsgdXNlTWVtbywgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0ICdyZWFjdC1kb20nO1xuXG4vKipcbiAqIERlc2NyaXB0aW9uOiBBIFRIUkVFIGxvYWRlciBmb3IgU1RMIEFTQ0lJIGZpbGVzLCBhcyBjcmVhdGVkIGJ5IFNvbGlkd29ya3MgYW5kIG90aGVyIENBRCBwcm9ncmFtcy5cbiAqXG4gKiBTdXBwb3J0cyBib3RoIGJpbmFyeSBhbmQgQVNDSUkgZW5jb2RlZCBmaWxlcywgd2l0aCBhdXRvbWF0aWMgZGV0ZWN0aW9uIG9mIHR5cGUuXG4gKlxuICogVGhlIGxvYWRlciByZXR1cm5zIGEgbm9uLWluZGV4ZWQgYnVmZmVyIGdlb21ldHJ5LlxuICpcbiAqIExpbWl0YXRpb25zOlxuICogIEJpbmFyeSBkZWNvZGluZyBzdXBwb3J0cyBcIk1hZ2ljc1wiIGNvbG9yIGZvcm1hdCAoaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TVExfKGZpbGVfZm9ybWF0KSNDb2xvcl9pbl9iaW5hcnlfU1RMKS5cbiAqICBUaGVyZSBpcyBwZXJoYXBzIHNvbWUgcXVlc3Rpb24gYXMgdG8gaG93IHZhbGlkIGl0IGlzIHRvIGFsd2F5cyBhc3N1bWUgbGl0dGxlLWVuZGlhbi1uZXNzLlxuICogIEFTQ0lJIGRlY29kaW5nIGFzc3VtZXMgZmlsZSBpcyBVVEYtOC5cbiAqXG4gKiBVc2FnZTpcbiAqICB2YXIgbG9hZGVyID0gbmV3IFNUTExvYWRlcigpO1xuICogIGxvYWRlci5sb2FkKCAnLi9tb2RlbHMvc3RsL3Nsb3R0ZWRfZGlzay5zdGwnLCBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuICogICAgc2NlbmUuYWRkKCBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnkgKSApO1xuICogIH0pO1xuICpcbiAqIEZvciBiaW5hcnkgU1RMcyBnZW9tZXRyeSBtaWdodCBjb250YWluIGNvbG9ycyBmb3IgdmVydGljZXMuIFRvIHVzZSBpdDpcbiAqICAvLyB1c2UgdGhlIHNhbWUgY29kZSB0byBsb2FkIFNUTCBhcyBhYm92ZVxuICogIGlmIChnZW9tZXRyeS5oYXNDb2xvcnMpIHtcbiAqICAgIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKHsgb3BhY2l0eTogZ2VvbWV0cnkuYWxwaGEsIHZlcnRleENvbG9yczogdHJ1ZSB9KTtcbiAqICB9IGVsc2UgeyAuLi4uIH1cbiAqICB2YXIgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcbiAqXG4gKiBGb3IgQVNDSUkgU1RMcyBjb250YWluaW5nIG11bHRpcGxlIHNvbGlkcywgZWFjaCBzb2xpZCBpcyBhc3NpZ25lZCB0byBhIGRpZmZlcmVudCBncm91cC5cbiAqIEdyb3VwcyBjYW4gYmUgdXNlZCB0byBhc3NpZ24gYSBkaWZmZXJlbnQgY29sb3IgYnkgZGVmaW5pbmcgYW4gYXJyYXkgb2YgbWF0ZXJpYWxzIHdpdGggdGhlIHNhbWUgbGVuZ3RoIG9mXG4gKiBnZW9tZXRyeS5ncm91cHMgYW5kIHBhc3NpbmcgaXQgdG8gdGhlIE1lc2ggY29uc3RydWN0b3I6XG4gKlxuICogdmFyIG1lc2ggPSBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG4gKlxuICogRm9yIGV4YW1wbGU6XG4gKlxuICogIHZhciBtYXRlcmlhbHMgPSBbXTtcbiAqICB2YXIgbkdlb21ldHJ5R3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzLmxlbmd0aDtcbiAqXG4gKiAgdmFyIGNvbG9yTWFwID0gLi4uOyAvLyBTb21lIGxvZ2ljIHRvIGluZGV4IGNvbG9ycy5cbiAqXG4gKiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuR2VvbWV0cnlHcm91cHM7IGkrKykge1xuICpcbiAqXHRcdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCh7XG4gKlx0XHRcdGNvbG9yOiBjb2xvck1hcFtpXSxcbiAqXHRcdFx0d2lyZWZyYW1lOiBmYWxzZVxuICpcdFx0fSk7XG4gKlxuICogIH1cbiAqXG4gKiAgbWF0ZXJpYWxzLnB1c2gobWF0ZXJpYWwpO1xuICogIHZhciBtZXNoID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFscyk7XG4gKi9cblxuXG52YXIgU1RMTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xuXG5cdExvYWRlciQxLmNhbGwoIHRoaXMsIG1hbmFnZXIgKTtcblxufTtcblxuU1RMTG9hZGVyLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExvYWRlciQxLnByb3RvdHlwZSApLCB7XG5cblx0Y29uc3RydWN0b3I6IFNUTExvYWRlcixcblxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHZhciBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xuXHRcdGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggdGhpcy5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcblxuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcblxuXHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRvbkxvYWQoIHNjb3BlLnBhcnNlKCB0ZXh0ICkgKTtcblxuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICkge1xuXG5cdFx0XHRcdFx0b25FcnJvciggZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdH0sXG5cblx0cGFyc2U6IGZ1bmN0aW9uICggZGF0YSApIHtcblxuXHRcdGZ1bmN0aW9uIGlzQmluYXJ5KCBkYXRhICkge1xuXG5cdFx0XHR2YXIgZXhwZWN0LCBmYWNlX3NpemUsIG5fZmFjZXMsIHJlYWRlcjtcblx0XHRcdHJlYWRlciA9IG5ldyBEYXRhVmlldyggZGF0YSApO1xuXHRcdFx0ZmFjZV9zaXplID0gKCAzMiAvIDggKiAzICkgKyAoICggMzIgLyA4ICogMyApICogMyApICsgKCAxNiAvIDggKTtcblx0XHRcdG5fZmFjZXMgPSByZWFkZXIuZ2V0VWludDMyKCA4MCwgdHJ1ZSApO1xuXHRcdFx0ZXhwZWN0ID0gODAgKyAoIDMyIC8gOCApICsgKCBuX2ZhY2VzICogZmFjZV9zaXplICk7XG5cblx0XHRcdGlmICggZXhwZWN0ID09PSByZWFkZXIuYnl0ZUxlbmd0aCApIHtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBbiBBU0NJSSBTVEwgZGF0YSBtdXN0IGJlZ2luIHdpdGggJ3NvbGlkICcgYXMgdGhlIGZpcnN0IHNpeCBieXRlcy5cblx0XHRcdC8vIEhvd2V2ZXIsIEFTQ0lJIFNUTHMgbGFja2luZyB0aGUgU1BBQ0UgYWZ0ZXIgdGhlICdkJyBhcmUga25vd24gdG8gYmVcblx0XHRcdC8vIHBsZW50aWZ1bC4gIFNvLCBjaGVjayB0aGUgZmlyc3QgNSBieXRlcyBmb3IgJ3NvbGlkJy5cblxuXHRcdFx0Ly8gU2V2ZXJhbCBlbmNvZGluZ3MsIHN1Y2ggYXMgVVRGLTgsIHByZWNlZGUgdGhlIHRleHQgd2l0aCB1cCB0byA1IGJ5dGVzOlxuXHRcdFx0Ly8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnl0ZV9vcmRlcl9tYXJrI0J5dGVfb3JkZXJfbWFya3NfYnlfZW5jb2Rpbmdcblx0XHRcdC8vIFNlYXJjaCBmb3IgXCJzb2xpZFwiIHRvIHN0YXJ0IGFueXdoZXJlIGFmdGVyIHRob3NlIHByZWZpeGVzLlxuXG5cdFx0XHQvLyBVUy1BU0NJSSBvcmRpbmFsIHZhbHVlcyBmb3IgJ3MnLCAnbycsICdsJywgJ2knLCAnZCdcblxuXHRcdFx0dmFyIHNvbGlkID0gWyAxMTUsIDExMSwgMTA4LCAxMDUsIDEwMCBdO1xuXG5cdFx0XHRmb3IgKCB2YXIgb2ZmID0gMDsgb2ZmIDwgNTsgb2ZmICsrICkge1xuXG5cdFx0XHRcdC8vIElmIFwic29saWRcIiB0ZXh0IGlzIG1hdGNoZWQgdG8gdGhlIGN1cnJlbnQgb2Zmc2V0LCBkZWNsYXJlIGl0IHRvIGJlIGFuIEFTQ0lJIFNUTC5cblxuXHRcdFx0XHRpZiAoIG1hdGNoRGF0YVZpZXdBdCggc29saWQsIHJlYWRlciwgb2ZmICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ291bGRuJ3QgZmluZCBcInNvbGlkXCIgdGV4dCBhdCB0aGUgYmVnaW5uaW5nOyBpdCBpcyBiaW5hcnkgU1RMLlxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG1hdGNoRGF0YVZpZXdBdCggcXVlcnksIHJlYWRlciwgb2Zmc2V0ICkge1xuXG5cdFx0XHQvLyBDaGVjayBpZiBlYWNoIGJ5dGUgaW4gcXVlcnkgbWF0Y2hlcyB0aGUgY29ycmVzcG9uZGluZyBieXRlIGZyb20gdGhlIGN1cnJlbnQgb2Zmc2V0XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBxdWVyeS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIHF1ZXJ5WyBpIF0gIT09IHJlYWRlci5nZXRVaW50OCggb2Zmc2V0ICsgaSwgZmFsc2UgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlQmluYXJ5KCBkYXRhICkge1xuXG5cdFx0XHR2YXIgcmVhZGVyID0gbmV3IERhdGFWaWV3KCBkYXRhICk7XG5cdFx0XHR2YXIgZmFjZXMgPSByZWFkZXIuZ2V0VWludDMyKCA4MCwgdHJ1ZSApO1xuXG5cdFx0XHR2YXIgciwgZywgYiwgaGFzQ29sb3JzID0gZmFsc2UsIGNvbG9ycztcblx0XHRcdHZhciBkZWZhdWx0UiwgZGVmYXVsdEcsIGRlZmF1bHRCLCBhbHBoYTtcblxuXHRcdFx0Ly8gcHJvY2VzcyBTVEwgaGVhZGVyXG5cdFx0XHQvLyBjaGVjayBmb3IgZGVmYXVsdCBjb2xvciBpbiBoZWFkZXIgKFwiQ09MT1I9cmdiYVwiIHNlcXVlbmNlKS5cblxuXHRcdFx0Zm9yICggdmFyIGluZGV4ID0gMDsgaW5kZXggPCA4MCAtIDEwOyBpbmRleCArKyApIHtcblxuXHRcdFx0XHRpZiAoICggcmVhZGVyLmdldFVpbnQzMiggaW5kZXgsIGZhbHNlICkgPT0gMHg0MzRGNEM0RiAvKkNPTE8qLyApICYmXG5cdFx0XHRcdFx0KCByZWFkZXIuZ2V0VWludDgoIGluZGV4ICsgNCApID09IDB4NTIgLyonUicqLyApICYmXG5cdFx0XHRcdFx0KCByZWFkZXIuZ2V0VWludDgoIGluZGV4ICsgNSApID09IDB4M0QgLyonPScqLyApICkge1xuXG5cdFx0XHRcdFx0aGFzQ29sb3JzID0gdHJ1ZTtcblx0XHRcdFx0XHRjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KCBmYWNlcyAqIDMgKiAzICk7XG5cblx0XHRcdFx0XHRkZWZhdWx0UiA9IHJlYWRlci5nZXRVaW50OCggaW5kZXggKyA2ICkgLyAyNTU7XG5cdFx0XHRcdFx0ZGVmYXVsdEcgPSByZWFkZXIuZ2V0VWludDgoIGluZGV4ICsgNyApIC8gMjU1O1xuXHRcdFx0XHRcdGRlZmF1bHRCID0gcmVhZGVyLmdldFVpbnQ4KCBpbmRleCArIDggKSAvIDI1NTtcblx0XHRcdFx0XHRhbHBoYSA9IHJlYWRlci5nZXRVaW50OCggaW5kZXggKyA5ICkgLyAyNTU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBkYXRhT2Zmc2V0ID0gODQ7XG5cdFx0XHR2YXIgZmFjZUxlbmd0aCA9IDEyICogNCArIDI7XG5cblx0XHRcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXG5cdFx0XHR2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBmYWNlcyAqIDMgKiAzICk7XG5cdFx0XHR2YXIgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoIGZhY2VzICogMyAqIDMgKTtcblxuXHRcdFx0Zm9yICggdmFyIGZhY2UgPSAwOyBmYWNlIDwgZmFjZXM7IGZhY2UgKysgKSB7XG5cblx0XHRcdFx0dmFyIHN0YXJ0ID0gZGF0YU9mZnNldCArIGZhY2UgKiBmYWNlTGVuZ3RoO1xuXHRcdFx0XHR2YXIgbm9ybWFsWCA9IHJlYWRlci5nZXRGbG9hdDMyKCBzdGFydCwgdHJ1ZSApO1xuXHRcdFx0XHR2YXIgbm9ybWFsWSA9IHJlYWRlci5nZXRGbG9hdDMyKCBzdGFydCArIDQsIHRydWUgKTtcblx0XHRcdFx0dmFyIG5vcm1hbFogPSByZWFkZXIuZ2V0RmxvYXQzMiggc3RhcnQgKyA4LCB0cnVlICk7XG5cblx0XHRcdFx0aWYgKCBoYXNDb2xvcnMgKSB7XG5cblx0XHRcdFx0XHR2YXIgcGFja2VkQ29sb3IgPSByZWFkZXIuZ2V0VWludDE2KCBzdGFydCArIDQ4LCB0cnVlICk7XG5cblx0XHRcdFx0XHRpZiAoICggcGFja2VkQ29sb3IgJiAweDgwMDAgKSA9PT0gMCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gZmFjZXQgaGFzIGl0cyBvd24gdW5pcXVlIGNvbG9yXG5cblx0XHRcdFx0XHRcdHIgPSAoIHBhY2tlZENvbG9yICYgMHgxRiApIC8gMzE7XG5cdFx0XHRcdFx0XHRnID0gKCAoIHBhY2tlZENvbG9yID4+IDUgKSAmIDB4MUYgKSAvIDMxO1xuXHRcdFx0XHRcdFx0YiA9ICggKCBwYWNrZWRDb2xvciA+PiAxMCApICYgMHgxRiApIC8gMzE7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRyID0gZGVmYXVsdFI7XG5cdFx0XHRcdFx0XHRnID0gZGVmYXVsdEc7XG5cdFx0XHRcdFx0XHRiID0gZGVmYXVsdEI7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMTsgaSA8PSAzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIHZlcnRleHN0YXJ0ID0gc3RhcnQgKyBpICogMTI7XG5cdFx0XHRcdFx0dmFyIGNvbXBvbmVudElkeCA9ICggZmFjZSAqIDMgKiAzICkgKyAoICggaSAtIDEgKSAqIDMgKTtcblxuXHRcdFx0XHRcdHZlcnRpY2VzWyBjb21wb25lbnRJZHggXSA9IHJlYWRlci5nZXRGbG9hdDMyKCB2ZXJ0ZXhzdGFydCwgdHJ1ZSApO1xuXHRcdFx0XHRcdHZlcnRpY2VzWyBjb21wb25lbnRJZHggKyAxIF0gPSByZWFkZXIuZ2V0RmxvYXQzMiggdmVydGV4c3RhcnQgKyA0LCB0cnVlICk7XG5cdFx0XHRcdFx0dmVydGljZXNbIGNvbXBvbmVudElkeCArIDIgXSA9IHJlYWRlci5nZXRGbG9hdDMyKCB2ZXJ0ZXhzdGFydCArIDgsIHRydWUgKTtcblxuXHRcdFx0XHRcdG5vcm1hbHNbIGNvbXBvbmVudElkeCBdID0gbm9ybWFsWDtcblx0XHRcdFx0XHRub3JtYWxzWyBjb21wb25lbnRJZHggKyAxIF0gPSBub3JtYWxZO1xuXHRcdFx0XHRcdG5vcm1hbHNbIGNvbXBvbmVudElkeCArIDIgXSA9IG5vcm1hbFo7XG5cblx0XHRcdFx0XHRpZiAoIGhhc0NvbG9ycyApIHtcblxuXHRcdFx0XHRcdFx0Y29sb3JzWyBjb21wb25lbnRJZHggXSA9IHI7XG5cdFx0XHRcdFx0XHRjb2xvcnNbIGNvbXBvbmVudElkeCArIDEgXSA9IGc7XG5cdFx0XHRcdFx0XHRjb2xvcnNbIGNvbXBvbmVudElkeCArIDIgXSA9IGI7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cblx0XHRcdGlmICggaGFzQ29sb3JzICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcblx0XHRcdFx0Z2VvbWV0cnkuaGFzQ29sb3JzID0gdHJ1ZTtcblx0XHRcdFx0Z2VvbWV0cnkuYWxwaGEgPSBhbHBoYTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUFTQ0lJKCBkYXRhICkge1xuXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRcdHZhciBwYXR0ZXJuU29saWQgPSAvc29saWQoW1xcc1xcU10qPyllbmRzb2xpZC9nO1xuXHRcdFx0dmFyIHBhdHRlcm5GYWNlID0gL2ZhY2V0KFtcXHNcXFNdKj8pZW5kZmFjZXQvZztcblx0XHRcdHZhciBmYWNlQ291bnRlciA9IDA7XG5cblx0XHRcdHZhciBwYXR0ZXJuRmxvYXQgPSAvW1xcc10rKFsrLV0/KD86XFxkKikoPzpcXC5cXGQqKT8oPzpbZUVdWystXT9cXGQrKT8pLy5zb3VyY2U7XG5cdFx0XHR2YXIgcGF0dGVyblZlcnRleCA9IG5ldyBSZWdFeHAoICd2ZXJ0ZXgnICsgcGF0dGVybkZsb2F0ICsgcGF0dGVybkZsb2F0ICsgcGF0dGVybkZsb2F0LCAnZycgKTtcblx0XHRcdHZhciBwYXR0ZXJuTm9ybWFsID0gbmV3IFJlZ0V4cCggJ25vcm1hbCcgKyBwYXR0ZXJuRmxvYXQgKyBwYXR0ZXJuRmxvYXQgKyBwYXR0ZXJuRmxvYXQsICdnJyApO1xuXG5cdFx0XHR2YXIgdmVydGljZXMgPSBbXTtcblx0XHRcdHZhciBub3JtYWxzID0gW107XG5cblx0XHRcdHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHR2YXIgZ3JvdXBDb3VudCA9IDA7XG5cdFx0XHR2YXIgc3RhcnRWZXJ0ZXggPSAwO1xuXHRcdFx0dmFyIGVuZFZlcnRleCA9IDA7XG5cblx0XHRcdHdoaWxlICggKCByZXN1bHQgPSBwYXR0ZXJuU29saWQuZXhlYyggZGF0YSApICkgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0c3RhcnRWZXJ0ZXggPSBlbmRWZXJ0ZXg7XG5cblx0XHRcdFx0dmFyIHNvbGlkID0gcmVzdWx0WyAwIF07XG5cblx0XHRcdFx0d2hpbGUgKCAoIHJlc3VsdCA9IHBhdHRlcm5GYWNlLmV4ZWMoIHNvbGlkICkgKSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdHZhciB2ZXJ0ZXhDb3VudFBlckZhY2UgPSAwO1xuXHRcdFx0XHRcdHZhciBub3JtYWxDb3VudFBlckZhY2UgPSAwO1xuXG5cdFx0XHRcdFx0dmFyIHRleHQgPSByZXN1bHRbIDAgXTtcblxuXHRcdFx0XHRcdHdoaWxlICggKCByZXN1bHQgPSBwYXR0ZXJuTm9ybWFsLmV4ZWMoIHRleHQgKSApICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRub3JtYWwueCA9IHBhcnNlRmxvYXQoIHJlc3VsdFsgMSBdICk7XG5cdFx0XHRcdFx0XHRub3JtYWwueSA9IHBhcnNlRmxvYXQoIHJlc3VsdFsgMiBdICk7XG5cdFx0XHRcdFx0XHRub3JtYWwueiA9IHBhcnNlRmxvYXQoIHJlc3VsdFsgMyBdICk7XG5cdFx0XHRcdFx0XHRub3JtYWxDb3VudFBlckZhY2UgKys7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR3aGlsZSAoICggcmVzdWx0ID0gcGF0dGVyblZlcnRleC5leGVjKCB0ZXh0ICkgKSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0dmVydGljZXMucHVzaCggcGFyc2VGbG9hdCggcmVzdWx0WyAxIF0gKSwgcGFyc2VGbG9hdCggcmVzdWx0WyAyIF0gKSwgcGFyc2VGbG9hdCggcmVzdWx0WyAzIF0gKSApO1xuXHRcdFx0XHRcdFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XG5cdFx0XHRcdFx0XHR2ZXJ0ZXhDb3VudFBlckZhY2UgKys7XG5cdFx0XHRcdFx0XHRlbmRWZXJ0ZXggKys7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBldmVyeSBmYWNlIGhhdmUgdG8gb3duIE9ORSB2YWxpZCBub3JtYWxcblxuXHRcdFx0XHRcdGlmICggbm9ybWFsQ291bnRQZXJGYWNlICE9PSAxICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuU1RMTG9hZGVyOiBTb21ldGhpbmcgaXNuXFwndCByaWdodCB3aXRoIHRoZSBub3JtYWwgb2YgZmFjZSBudW1iZXIgJyArIGZhY2VDb3VudGVyICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBlYWNoIGZhY2UgaGF2ZSB0byBvd24gVEhSRUUgdmFsaWQgdmVydGljZXNcblxuXHRcdFx0XHRcdGlmICggdmVydGV4Q291bnRQZXJGYWNlICE9PSAzICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuU1RMTG9hZGVyOiBTb21ldGhpbmcgaXNuXFwndCByaWdodCB3aXRoIHRoZSB2ZXJ0aWNlcyBvZiBmYWNlIG51bWJlciAnICsgZmFjZUNvdW50ZXIgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZhY2VDb3VudGVyICsrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgc3RhcnQgPSBzdGFydFZlcnRleDtcblx0XHRcdFx0dmFyIGNvdW50ID0gZW5kVmVydGV4IC0gc3RhcnRWZXJ0ZXg7XG5cblx0XHRcdFx0Z2VvbWV0cnkuYWRkR3JvdXAoIHN0YXJ0LCBjb3VudCwgZ3JvdXBDb3VudCApO1xuXHRcdFx0XHRncm91cENvdW50ICsrO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblxuXHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZW5zdXJlU3RyaW5nKCBidWZmZXIgKSB7XG5cblx0XHRcdGlmICggdHlwZW9mIGJ1ZmZlciAhPT0gJ3N0cmluZycgKSB7XG5cblx0XHRcdFx0cmV0dXJuIExvYWRlclV0aWxzLmRlY29kZVRleHQoIG5ldyBVaW50OEFycmF5KCBidWZmZXIgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBidWZmZXI7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBlbnN1cmVCaW5hcnkoIGJ1ZmZlciApIHtcblxuXHRcdFx0aWYgKCB0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJyApIHtcblxuXHRcdFx0XHR2YXIgYXJyYXlfYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoIGJ1ZmZlci5sZW5ndGggKTtcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGFycmF5X2J1ZmZlclsgaSBdID0gYnVmZmVyLmNoYXJDb2RlQXQoIGkgKSAmIDB4ZmY7IC8vIGltcGxpY2l0bHkgYXNzdW1lcyBsaXR0bGUtZW5kaWFuXG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBhcnJheV9idWZmZXIuYnVmZmVyIHx8IGFycmF5X2J1ZmZlcjtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gYnVmZmVyO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBzdGFydFxuXG5cdFx0dmFyIGJpbkRhdGEgPSBlbnN1cmVCaW5hcnkoIGRhdGEgKTtcblxuXHRcdHJldHVybiBpc0JpbmFyeSggYmluRGF0YSApID8gcGFyc2VCaW5hcnkoIGJpbkRhdGEgKSA6IHBhcnNlQVNDSUkoIGVuc3VyZVN0cmluZyggZGF0YSApICk7XG5cblx0fVxuXG59ICk7XG5cbnZhciBHTFRGTG9hZGVyID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0ZnVuY3Rpb24gR0xURkxvYWRlciggbWFuYWdlciApIHtcblxuXHRcdExvYWRlciQxLmNhbGwoIHRoaXMsIG1hbmFnZXIgKTtcblxuXHRcdHRoaXMuZHJhY29Mb2FkZXIgPSBudWxsO1xuXHRcdHRoaXMua3R4MkxvYWRlciA9IG51bGw7XG5cdFx0dGhpcy5tZXNob3B0RGVjb2RlciA9IG51bGw7XG5cblx0XHR0aGlzLnBsdWdpbkNhbGxiYWNrcyA9IFtdO1xuXG5cdFx0dGhpcy5yZWdpc3RlciggZnVuY3Rpb24gKCBwYXJzZXIgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgR0xURk1hdGVyaWFsc0NsZWFyY29hdEV4dGVuc2lvbiggcGFyc2VyICk7XG5cblx0XHR9ICk7XG5cblx0XHR0aGlzLnJlZ2lzdGVyKCBmdW5jdGlvbiAoIHBhcnNlciApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBHTFRGVGV4dHVyZUJhc2lzVUV4dGVuc2lvbiggcGFyc2VyICk7XG5cblx0XHR9ICk7XG5cblx0XHR0aGlzLnJlZ2lzdGVyKCBmdW5jdGlvbiAoIHBhcnNlciApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBHTFRGVGV4dHVyZVdlYlBFeHRlbnNpb24oIHBhcnNlciApO1xuXG5cdFx0fSApO1xuXG5cdFx0dGhpcy5yZWdpc3RlciggZnVuY3Rpb24gKCBwYXJzZXIgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgR0xURk1hdGVyaWFsc1RyYW5zbWlzc2lvbkV4dGVuc2lvbiggcGFyc2VyICk7XG5cblx0XHR9ICk7XG5cblx0XHR0aGlzLnJlZ2lzdGVyKCBmdW5jdGlvbiAoIHBhcnNlciApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBHTFRGTGlnaHRzRXh0ZW5zaW9uKCBwYXJzZXIgKTtcblxuXHRcdH0gKTtcblxuXHRcdHRoaXMucmVnaXN0ZXIoIGZ1bmN0aW9uICggcGFyc2VyICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IEdMVEZNZXNob3B0Q29tcHJlc3Npb24oIHBhcnNlciApO1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHRHTFRGTG9hZGVyLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExvYWRlciQxLnByb3RvdHlwZSApLCB7XG5cblx0XHRjb25zdHJ1Y3RvcjogR0xURkxvYWRlcixcblxuXHRcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHRcdHZhciByZXNvdXJjZVBhdGg7XG5cblx0XHRcdGlmICggdGhpcy5yZXNvdXJjZVBhdGggIT09ICcnICkge1xuXG5cdFx0XHRcdHJlc291cmNlUGF0aCA9IHRoaXMucmVzb3VyY2VQYXRoO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLnBhdGggIT09ICcnICkge1xuXG5cdFx0XHRcdHJlc291cmNlUGF0aCA9IHRoaXMucGF0aDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXNvdXJjZVBhdGggPSBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSggdXJsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGVsbHMgdGhlIExvYWRpbmdNYW5hZ2VyIHRvIHRyYWNrIGFuIGV4dHJhIGl0ZW0sIHdoaWNoIHJlc29sdmVzIGFmdGVyXG5cdFx0XHQvLyB0aGUgbW9kZWwgaXMgZnVsbHkgbG9hZGVkLiBUaGlzIG1lYW5zIHRoZSBjb3VudCBvZiBpdGVtcyBsb2FkZWQgd2lsbFxuXHRcdFx0Ly8gYmUgaW5jb3JyZWN0LCBidXQgZW5zdXJlcyBtYW5hZ2VyLm9uTG9hZCgpIGRvZXMgbm90IGZpcmUgZWFybHkuXG5cdFx0XHR0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuXHRcdFx0dmFyIF9vbkVycm9yID0gZnVuY3Rpb24gKCBlICkge1xuXG5cdFx0XHRcdGlmICggb25FcnJvciApIHtcblxuXHRcdFx0XHRcdG9uRXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHRcdH07XG5cblx0XHRcdHZhciBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cblx0XHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcblx0XHRcdGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcblx0XHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCB0aGlzLnJlcXVlc3RIZWFkZXIgKTtcblx0XHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHRoaXMud2l0aENyZWRlbnRpYWxzICk7XG5cblx0XHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggZGF0YSApIHtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0c2NvcGUucGFyc2UoIGRhdGEsIHJlc291cmNlUGF0aCwgZnVuY3Rpb24gKCBnbHRmICkge1xuXG5cdFx0XHRcdFx0XHRvbkxvYWQoIGdsdGYgKTtcblxuXHRcdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuXHRcdFx0XHRcdH0sIF9vbkVycm9yICk7XG5cblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHRfb25FcnJvciggZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSwgb25Qcm9ncmVzcywgX29uRXJyb3IgKTtcblxuXHRcdH0sXG5cblx0XHRzZXREUkFDT0xvYWRlcjogZnVuY3Rpb24gKCBkcmFjb0xvYWRlciApIHtcblxuXHRcdFx0dGhpcy5kcmFjb0xvYWRlciA9IGRyYWNvTG9hZGVyO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0RERTTG9hZGVyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvcihcblxuXHRcdFx0XHQnVEhSRUUuR0xURkxvYWRlcjogXCJNU0ZUX3RleHR1cmVfZGRzXCIgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gUGxlYXNlIHVwZGF0ZSB0byBcIktIUl90ZXh0dXJlX2Jhc2lzdVwiLidcblxuXHRcdFx0KTtcblxuXHRcdH0sXG5cblx0XHRzZXRLVFgyTG9hZGVyOiBmdW5jdGlvbiAoIGt0eDJMb2FkZXIgKSB7XG5cblx0XHRcdHRoaXMua3R4MkxvYWRlciA9IGt0eDJMb2FkZXI7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRNZXNob3B0RGVjb2RlcjogZnVuY3Rpb24gKCBtZXNob3B0RGVjb2RlciApIHtcblxuXHRcdFx0dGhpcy5tZXNob3B0RGVjb2RlciA9IG1lc2hvcHREZWNvZGVyO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0cmVnaXN0ZXI6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cblx0XHRcdGlmICggdGhpcy5wbHVnaW5DYWxsYmFja3MuaW5kZXhPZiggY2FsbGJhY2sgKSA9PT0gLSAxICkge1xuXG5cdFx0XHRcdHRoaXMucGx1Z2luQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0dW5yZWdpc3RlcjogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdFx0aWYgKCB0aGlzLnBsdWdpbkNhbGxiYWNrcy5pbmRleE9mKCBjYWxsYmFjayApICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0dGhpcy5wbHVnaW5DYWxsYmFja3Muc3BsaWNlKCB0aGlzLnBsdWdpbkNhbGxiYWNrcy5pbmRleE9mKCBjYWxsYmFjayApLCAxICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0cGFyc2U6IGZ1bmN0aW9uICggZGF0YSwgcGF0aCwgb25Mb2FkLCBvbkVycm9yICkge1xuXG5cdFx0XHR2YXIgY29udGVudDtcblx0XHRcdHZhciBleHRlbnNpb25zID0ge307XG5cdFx0XHR2YXIgcGx1Z2lucyA9IHt9O1xuXG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyApIHtcblxuXHRcdFx0XHRjb250ZW50ID0gZGF0YTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR2YXIgbWFnaWMgPSBMb2FkZXJVdGlscy5kZWNvZGVUZXh0KCBuZXcgVWludDhBcnJheSggZGF0YSwgMCwgNCApICk7XG5cblx0XHRcdFx0aWYgKCBtYWdpYyA9PT0gQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTUFHSUMgKSB7XG5cblx0XHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0XHRleHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9CSU5BUllfR0xURiBdID0gbmV3IEdMVEZCaW5hcnlFeHRlbnNpb24oIGRhdGEgKTtcblxuXHRcdFx0XHRcdH0gY2F0Y2ggKCBlcnJvciApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZXJyb3IgKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnRlbnQgPSBleHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9CSU5BUllfR0xURiBdLmNvbnRlbnQ7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnRlbnQgPSBMb2FkZXJVdGlscy5kZWNvZGVUZXh0KCBuZXcgVWludDhBcnJheSggZGF0YSApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBqc29uID0gSlNPTi5wYXJzZSggY29udGVudCApO1xuXG5cdFx0XHRpZiAoIGpzb24uYXNzZXQgPT09IHVuZGVmaW5lZCB8fCBqc29uLmFzc2V0LnZlcnNpb25bIDAgXSA8IDIgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgYXNzZXQuIGdsVEYgdmVyc2lvbnMgPj0yLjAgYXJlIHN1cHBvcnRlZC4nICkgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBwYXJzZXIgPSBuZXcgR0xURlBhcnNlcigganNvbiwge1xuXG5cdFx0XHRcdHBhdGg6IHBhdGggfHwgdGhpcy5yZXNvdXJjZVBhdGggfHwgJycsXG5cdFx0XHRcdGNyb3NzT3JpZ2luOiB0aGlzLmNyb3NzT3JpZ2luLFxuXHRcdFx0XHRyZXF1ZXN0SGVhZGVyOiB0aGlzLnJlcXVlc3RIZWFkZXIsXG5cdFx0XHRcdG1hbmFnZXI6IHRoaXMubWFuYWdlcixcblx0XHRcdFx0a3R4MkxvYWRlcjogdGhpcy5rdHgyTG9hZGVyLFxuXHRcdFx0XHRtZXNob3B0RGVjb2RlcjogdGhpcy5tZXNob3B0RGVjb2RlclxuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHBhcnNlci5maWxlTG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHRoaXMucmVxdWVzdEhlYWRlciApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnBsdWdpbkNhbGxiYWNrcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIHBsdWdpbiA9IHRoaXMucGx1Z2luQ2FsbGJhY2tzWyBpIF0oIHBhcnNlciApO1xuXHRcdFx0XHRwbHVnaW5zWyBwbHVnaW4ubmFtZSBdID0gcGx1Z2luO1xuXG5cdFx0XHRcdC8vIFdvcmthcm91bmQgdG8gYXZvaWQgZGV0ZXJtaW5pbmcgYXMgdW5rbm93biBleHRlbnNpb25cblx0XHRcdFx0Ly8gaW4gYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKCkuXG5cdFx0XHRcdC8vIFJlbW92ZSB0aGlzIHdvcmthcm91bmQgaWYgd2UgbW92ZSBhbGwgdGhlIGV4aXN0aW5nXG5cdFx0XHRcdC8vIGV4dGVuc2lvbiBoYW5kbGVycyB0byBwbHVnaW4gc3lzdGVtXG5cdFx0XHRcdGV4dGVuc2lvbnNbIHBsdWdpbi5uYW1lIF0gPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICgganNvbi5leHRlbnNpb25zVXNlZCApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBqc29uLmV4dGVuc2lvbnNVc2VkLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdFx0XHRcdHZhciBleHRlbnNpb25OYW1lID0ganNvbi5leHRlbnNpb25zVXNlZFsgaSBdO1xuXHRcdFx0XHRcdHZhciBleHRlbnNpb25zUmVxdWlyZWQgPSBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZCB8fCBbXTtcblxuXHRcdFx0XHRcdHN3aXRjaCAoIGV4dGVuc2lvbk5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1VOTElUOlxuXHRcdFx0XHRcdFx0XHRleHRlbnNpb25zWyBleHRlbnNpb25OYW1lIF0gPSBuZXcgR0xURk1hdGVyaWFsc1VubGl0RXh0ZW5zaW9uKCk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19QQlJfU1BFQ1VMQVJfR0xPU1NJTkVTUzpcblx0XHRcdFx0XHRcdFx0ZXh0ZW5zaW9uc1sgZXh0ZW5zaW9uTmFtZSBdID0gbmV3IEdMVEZNYXRlcmlhbHNQYnJTcGVjdWxhckdsb3NzaW5lc3NFeHRlbnNpb24oKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTjpcblx0XHRcdFx0XHRcdFx0ZXh0ZW5zaW9uc1sgZXh0ZW5zaW9uTmFtZSBdID0gbmV3IEdMVEZEcmFjb01lc2hDb21wcmVzc2lvbkV4dGVuc2lvbigganNvbiwgdGhpcy5kcmFjb0xvYWRlciApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSBFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STTpcblx0XHRcdFx0XHRcdFx0ZXh0ZW5zaW9uc1sgZXh0ZW5zaW9uTmFtZSBdID0gbmV3IEdMVEZUZXh0dXJlVHJhbnNmb3JtRXh0ZW5zaW9uKCk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIEVYVEVOU0lPTlMuS0hSX01FU0hfUVVBTlRJWkFUSU9OOlxuXHRcdFx0XHRcdFx0XHRleHRlbnNpb25zWyBleHRlbnNpb25OYW1lIF0gPSBuZXcgR0xURk1lc2hRdWFudGl6YXRpb25FeHRlbnNpb24oKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBleHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZiggZXh0ZW5zaW9uTmFtZSApID49IDAgJiYgcGx1Z2luc1sgZXh0ZW5zaW9uTmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HTFRGTG9hZGVyOiBVbmtub3duIGV4dGVuc2lvbiBcIicgKyBleHRlbnNpb25OYW1lICsgJ1wiLicgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHBhcnNlci5zZXRFeHRlbnNpb25zKCBleHRlbnNpb25zICk7XG5cdFx0XHRwYXJzZXIuc2V0UGx1Z2lucyggcGx1Z2lucyApO1xuXHRcdFx0cGFyc2VyLnBhcnNlKCBvbkxvYWQsIG9uRXJyb3IgKTtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0LyogR0xURlJFR0lTVFJZICovXG5cblx0ZnVuY3Rpb24gR0xURlJlZ2lzdHJ5KCkge1xuXG5cdFx0dmFyIG9iamVjdHMgPSB7fTtcblxuXHRcdHJldHVyblx0e1xuXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgga2V5ICkge1xuXG5cdFx0XHRcdHJldHVybiBvYmplY3RzWyBrZXkgXTtcblxuXHRcdFx0fSxcblxuXHRcdFx0YWRkOiBmdW5jdGlvbiAoIGtleSwgb2JqZWN0ICkge1xuXG5cdFx0XHRcdG9iamVjdHNbIGtleSBdID0gb2JqZWN0O1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uICgga2V5ICkge1xuXG5cdFx0XHRcdGRlbGV0ZSBvYmplY3RzWyBrZXkgXTtcblxuXHRcdFx0fSxcblxuXHRcdFx0cmVtb3ZlQWxsOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0b2JqZWN0cyA9IHt9O1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdH1cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKiBFWFRFTlNJT05TICoqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdHZhciBFWFRFTlNJT05TID0ge1xuXHRcdEtIUl9CSU5BUllfR0xURjogJ0tIUl9iaW5hcnlfZ2xURicsXG5cdFx0S0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT046ICdLSFJfZHJhY29fbWVzaF9jb21wcmVzc2lvbicsXG5cdFx0S0hSX0xJR0hUU19QVU5DVFVBTDogJ0tIUl9saWdodHNfcHVuY3R1YWwnLFxuXHRcdEtIUl9NQVRFUklBTFNfQ0xFQVJDT0FUOiAnS0hSX21hdGVyaWFsc19jbGVhcmNvYXQnLFxuXHRcdEtIUl9NQVRFUklBTFNfUEJSX1NQRUNVTEFSX0dMT1NTSU5FU1M6ICdLSFJfbWF0ZXJpYWxzX3BiclNwZWN1bGFyR2xvc3NpbmVzcycsXG5cdFx0S0hSX01BVEVSSUFMU19UUkFOU01JU1NJT046ICdLSFJfbWF0ZXJpYWxzX3RyYW5zbWlzc2lvbicsXG5cdFx0S0hSX01BVEVSSUFMU19VTkxJVDogJ0tIUl9tYXRlcmlhbHNfdW5saXQnLFxuXHRcdEtIUl9URVhUVVJFX0JBU0lTVTogJ0tIUl90ZXh0dXJlX2Jhc2lzdScsXG5cdFx0S0hSX1RFWFRVUkVfVFJBTlNGT1JNOiAnS0hSX3RleHR1cmVfdHJhbnNmb3JtJyxcblx0XHRLSFJfTUVTSF9RVUFOVElaQVRJT046ICdLSFJfbWVzaF9xdWFudGl6YXRpb24nLFxuXHRcdEVYVF9URVhUVVJFX1dFQlA6ICdFWFRfdGV4dHVyZV93ZWJwJyxcblx0XHRFWFRfTUVTSE9QVF9DT01QUkVTU0lPTjogJ0VYVF9tZXNob3B0X2NvbXByZXNzaW9uJ1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQdW5jdHVhbCBMaWdodHMgRXh0ZW5zaW9uXG5cdCAqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl9saWdodHNfcHVuY3R1YWxcblx0ICovXG5cdGZ1bmN0aW9uIEdMVEZMaWdodHNFeHRlbnNpb24oIHBhcnNlciApIHtcblxuXHRcdHRoaXMucGFyc2VyID0gcGFyc2VyO1xuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX0xJR0hUU19QVU5DVFVBTDtcblxuXHRcdC8vIE9iamVjdDNEIGluc3RhbmNlIGNhY2hlc1xuXHRcdHRoaXMuY2FjaGUgPSB7IHJlZnM6IHt9LCB1c2VzOiB7fSB9O1xuXG5cdH1cblxuXHRHTFRGTGlnaHRzRXh0ZW5zaW9uLnByb3RvdHlwZS5fbWFya0RlZnMgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG5cdFx0dmFyIG5vZGVEZWZzID0gdGhpcy5wYXJzZXIuanNvbi5ub2RlcyB8fCBbXTtcblxuXHRcdGZvciAoIHZhciBub2RlSW5kZXggPSAwLCBub2RlTGVuZ3RoID0gbm9kZURlZnMubGVuZ3RoOyBub2RlSW5kZXggPCBub2RlTGVuZ3RoOyBub2RlSW5kZXggKysgKSB7XG5cblx0XHRcdHZhciBub2RlRGVmID0gbm9kZURlZnNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRpZiAoIG5vZGVEZWYuZXh0ZW5zaW9uc1xuXHRcdFx0XHQmJiBub2RlRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdXG5cdFx0XHRcdCYmIG5vZGVEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0ubGlnaHQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRwYXJzZXIuX2FkZE5vZGVSZWYoIHRoaXMuY2FjaGUsIG5vZGVEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0ubGlnaHQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0R0xURkxpZ2h0c0V4dGVuc2lvbi5wcm90b3R5cGUuX2xvYWRMaWdodCA9IGZ1bmN0aW9uICggbGlnaHRJbmRleCApIHtcblxuXHRcdHZhciBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcblx0XHR2YXIgY2FjaGVLZXkgPSAnbGlnaHQ6JyArIGxpZ2h0SW5kZXg7XG5cdFx0dmFyIGRlcGVuZGVuY3kgPSBwYXJzZXIuY2FjaGUuZ2V0KCBjYWNoZUtleSApO1xuXG5cdFx0aWYgKCBkZXBlbmRlbmN5ICkgcmV0dXJuIGRlcGVuZGVuY3k7XG5cblx0XHR2YXIganNvbiA9IHBhcnNlci5qc29uO1xuXHRcdHZhciBleHRlbnNpb25zID0gKCBqc29uLmV4dGVuc2lvbnMgJiYganNvbi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXSApIHx8IHt9O1xuXHRcdHZhciBsaWdodERlZnMgPSBleHRlbnNpb25zLmxpZ2h0cyB8fCBbXTtcblx0XHR2YXIgbGlnaHREZWYgPSBsaWdodERlZnNbIGxpZ2h0SW5kZXggXTtcblx0XHR2YXIgbGlnaHROb2RlO1xuXG5cdFx0dmFyIGNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApO1xuXG5cdFx0aWYgKCBsaWdodERlZi5jb2xvciAhPT0gdW5kZWZpbmVkICkgY29sb3IuZnJvbUFycmF5KCBsaWdodERlZi5jb2xvciApO1xuXG5cdFx0dmFyIHJhbmdlID0gbGlnaHREZWYucmFuZ2UgIT09IHVuZGVmaW5lZCA/IGxpZ2h0RGVmLnJhbmdlIDogMDtcblxuXHRcdHN3aXRjaCAoIGxpZ2h0RGVmLnR5cGUgKSB7XG5cblx0XHRcdGNhc2UgJ2RpcmVjdGlvbmFsJzpcblx0XHRcdFx0bGlnaHROb2RlID0gbmV3IERpcmVjdGlvbmFsTGlnaHQoIGNvbG9yICk7XG5cdFx0XHRcdGxpZ2h0Tm9kZS50YXJnZXQucG9zaXRpb24uc2V0KCAwLCAwLCAtIDEgKTtcblx0XHRcdFx0bGlnaHROb2RlLmFkZCggbGlnaHROb2RlLnRhcmdldCApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAncG9pbnQnOlxuXHRcdFx0XHRsaWdodE5vZGUgPSBuZXcgUG9pbnRMaWdodCggY29sb3IgKTtcblx0XHRcdFx0bGlnaHROb2RlLmRpc3RhbmNlID0gcmFuZ2U7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdzcG90Jzpcblx0XHRcdFx0bGlnaHROb2RlID0gbmV3IFNwb3RMaWdodCggY29sb3IgKTtcblx0XHRcdFx0bGlnaHROb2RlLmRpc3RhbmNlID0gcmFuZ2U7XG5cdFx0XHRcdC8vIEhhbmRsZSBzcG90bGlnaHQgcHJvcGVydGllcy5cblx0XHRcdFx0bGlnaHREZWYuc3BvdCA9IGxpZ2h0RGVmLnNwb3QgfHwge307XG5cdFx0XHRcdGxpZ2h0RGVmLnNwb3QuaW5uZXJDb25lQW5nbGUgPSBsaWdodERlZi5zcG90LmlubmVyQ29uZUFuZ2xlICE9PSB1bmRlZmluZWQgPyBsaWdodERlZi5zcG90LmlubmVyQ29uZUFuZ2xlIDogMDtcblx0XHRcdFx0bGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZSA9IGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGUgIT09IHVuZGVmaW5lZCA/IGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGUgOiBNYXRoLlBJIC8gNC4wO1xuXHRcdFx0XHRsaWdodE5vZGUuYW5nbGUgPSBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlO1xuXHRcdFx0XHRsaWdodE5vZGUucGVudW1icmEgPSAxLjAgLSBsaWdodERlZi5zcG90LmlubmVyQ29uZUFuZ2xlIC8gbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZTtcblx0XHRcdFx0bGlnaHROb2RlLnRhcmdldC5wb3NpdGlvbi5zZXQoIDAsIDAsIC0gMSApO1xuXHRcdFx0XHRsaWdodE5vZGUuYWRkKCBsaWdodE5vZGUudGFyZ2V0ICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBVbmV4cGVjdGVkIGxpZ2h0IHR5cGU6ICcgKyBsaWdodERlZi50eXBlICk7XG5cblx0XHR9XG5cblx0XHQvLyBTb21lIGxpZ2h0cyAoZS5nLiBzcG90KSBkZWZhdWx0IHRvIGEgcG9zaXRpb24gb3RoZXIgdGhhbiB0aGUgb3JpZ2luLiBSZXNldCB0aGUgcG9zaXRpb25cblx0XHQvLyBoZXJlLCBiZWNhdXNlIG5vZGUtbGV2ZWwgcGFyc2luZyB3aWxsIG9ubHkgb3ZlcnJpZGUgcG9zaXRpb24gaWYgZXhwbGljaXRseSBzcGVjaWZpZWQuXG5cdFx0bGlnaHROb2RlLnBvc2l0aW9uLnNldCggMCwgMCwgMCApO1xuXG5cdFx0bGlnaHROb2RlLmRlY2F5ID0gMjtcblxuXHRcdGlmICggbGlnaHREZWYuaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBsaWdodE5vZGUuaW50ZW5zaXR5ID0gbGlnaHREZWYuaW50ZW5zaXR5O1xuXG5cdFx0bGlnaHROb2RlLm5hbWUgPSBwYXJzZXIuY3JlYXRlVW5pcXVlTmFtZSggbGlnaHREZWYubmFtZSB8fCAoICdsaWdodF8nICsgbGlnaHRJbmRleCApICk7XG5cblx0XHRkZXBlbmRlbmN5ID0gUHJvbWlzZS5yZXNvbHZlKCBsaWdodE5vZGUgKTtcblxuXHRcdHBhcnNlci5jYWNoZS5hZGQoIGNhY2hlS2V5LCBkZXBlbmRlbmN5ICk7XG5cblx0XHRyZXR1cm4gZGVwZW5kZW5jeTtcblxuXHR9O1xuXG5cdEdMVEZMaWdodHNFeHRlbnNpb24ucHJvdG90eXBlLmNyZWF0ZU5vZGVBdHRhY2htZW50ID0gZnVuY3Rpb24gKCBub2RlSW5kZXggKSB7XG5cblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdHZhciBqc29uID0gcGFyc2VyLmpzb247XG5cdFx0dmFyIG5vZGVEZWYgPSBqc29uLm5vZGVzWyBub2RlSW5kZXggXTtcblx0XHR2YXIgbGlnaHREZWYgPSAoIG5vZGVEZWYuZXh0ZW5zaW9ucyAmJiBub2RlRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkgfHwge307XG5cdFx0dmFyIGxpZ2h0SW5kZXggPSBsaWdodERlZi5saWdodDtcblxuXHRcdGlmICggbGlnaHRJbmRleCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIG51bGw7XG5cblx0XHRyZXR1cm4gdGhpcy5fbG9hZExpZ2h0KCBsaWdodEluZGV4ICkudGhlbiggZnVuY3Rpb24gKCBsaWdodCApIHtcblxuXHRcdFx0cmV0dXJuIHBhcnNlci5fZ2V0Tm9kZVJlZiggc2VsZi5jYWNoZSwgbGlnaHRJbmRleCwgbGlnaHQgKTtcblxuXHRcdH0gKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBVbmxpdCBNYXRlcmlhbHMgRXh0ZW5zaW9uXG5cdCAqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl9tYXRlcmlhbHNfdW5saXRcblx0ICovXG5cdGZ1bmN0aW9uIEdMVEZNYXRlcmlhbHNVbmxpdEV4dGVuc2lvbigpIHtcblxuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19VTkxJVDtcblxuXHR9XG5cblx0R0xURk1hdGVyaWFsc1VubGl0RXh0ZW5zaW9uLnByb3RvdHlwZS5nZXRNYXRlcmlhbFR5cGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gTWVzaEJhc2ljTWF0ZXJpYWw7XG5cblx0fTtcblxuXHRHTFRGTWF0ZXJpYWxzVW5saXRFeHRlbnNpb24ucHJvdG90eXBlLmV4dGVuZFBhcmFtcyA9IGZ1bmN0aW9uICggbWF0ZXJpYWxQYXJhbXMsIG1hdGVyaWFsRGVmLCBwYXJzZXIgKSB7XG5cblx0XHR2YXIgcGVuZGluZyA9IFtdO1xuXG5cdFx0bWF0ZXJpYWxQYXJhbXMuY29sb3IgPSBuZXcgQ29sb3IoIDEuMCwgMS4wLCAxLjAgKTtcblx0XHRtYXRlcmlhbFBhcmFtcy5vcGFjaXR5ID0gMS4wO1xuXG5cdFx0dmFyIG1ldGFsbGljUm91Z2huZXNzID0gbWF0ZXJpYWxEZWYucGJyTWV0YWxsaWNSb3VnaG5lc3M7XG5cblx0XHRpZiAoIG1ldGFsbGljUm91Z2huZXNzICkge1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvciApICkge1xuXG5cdFx0XHRcdHZhciBhcnJheSA9IG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvcjtcblxuXHRcdFx0XHRtYXRlcmlhbFBhcmFtcy5jb2xvci5mcm9tQXJyYXkoIGFycmF5ICk7XG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSBhcnJheVsgMyBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAnbWFwJywgbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZSApICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIENsZWFyY29hdCBNYXRlcmlhbHMgRXh0ZW5zaW9uXG5cdCAqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl9tYXRlcmlhbHNfY2xlYXJjb2F0XG5cdCAqL1xuXHRmdW5jdGlvbiBHTFRGTWF0ZXJpYWxzQ2xlYXJjb2F0RXh0ZW5zaW9uKCBwYXJzZXIgKSB7XG5cblx0XHR0aGlzLnBhcnNlciA9IHBhcnNlcjtcblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfQ0xFQVJDT0FUO1xuXG5cdH1cblxuXHRHTFRGTWF0ZXJpYWxzQ2xlYXJjb2F0RXh0ZW5zaW9uLnByb3RvdHlwZS5nZXRNYXRlcmlhbFR5cGUgPSBmdW5jdGlvbiAoIG1hdGVyaWFsSW5kZXggKSB7XG5cblx0XHR2YXIgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG5cdFx0dmFyIG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHRpZiAoICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkgcmV0dXJuIG51bGw7XG5cblx0XHRyZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG5cblx0fTtcblxuXHRHTFRGTWF0ZXJpYWxzQ2xlYXJjb2F0RXh0ZW5zaW9uLnByb3RvdHlwZS5leHRlbmRNYXRlcmlhbFBhcmFtcyA9IGZ1bmN0aW9uICggbWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMgKSB7XG5cblx0XHR2YXIgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG5cdFx0dmFyIG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHRpZiAoICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkge1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cblx0XHR9XG5cblx0XHR2YXIgcGVuZGluZyA9IFtdO1xuXG5cdFx0dmFyIGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdO1xuXG5cdFx0aWYgKCBleHRlbnNpb24uY2xlYXJjb2F0RmFjdG9yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zLmNsZWFyY29hdCA9IGV4dGVuc2lvbi5jbGVhcmNvYXRGYWN0b3I7XG5cblx0XHR9XG5cblx0XHRpZiAoIGV4dGVuc2lvbi5jbGVhcmNvYXRUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAnY2xlYXJjb2F0TWFwJywgZXh0ZW5zaW9uLmNsZWFyY29hdFRleHR1cmUgKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBleHRlbnNpb24uY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zLmNsZWFyY29hdFJvdWdobmVzcyA9IGV4dGVuc2lvbi5jbGVhcmNvYXRSb3VnaG5lc3NGYWN0b3I7XG5cblx0XHR9XG5cblx0XHRpZiAoIGV4dGVuc2lvbi5jbGVhcmNvYXRSb3VnaG5lc3NUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAnY2xlYXJjb2F0Um91Z2huZXNzTWFwJywgZXh0ZW5zaW9uLmNsZWFyY29hdFJvdWdobmVzc1RleHR1cmUgKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBleHRlbnNpb24uY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ2NsZWFyY29hdE5vcm1hbE1hcCcsIGV4dGVuc2lvbi5jbGVhcmNvYXROb3JtYWxUZXh0dXJlICkgKTtcblxuXHRcdFx0aWYgKCBleHRlbnNpb24uY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZS5zY2FsZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZhciBzY2FsZSA9IGV4dGVuc2lvbi5jbGVhcmNvYXROb3JtYWxUZXh0dXJlLnNjYWxlO1xuXG5cdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzExNDM4I2lzc3VlY29tbWVudC01MDcwMDM5OTVcblx0XHRcdFx0bWF0ZXJpYWxQYXJhbXMuY2xlYXJjb2F0Tm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMiggc2NhbGUsIC0gc2NhbGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nICk7XG5cblx0fTtcblxuXHQvKipcblx0ICogVHJhbnNtaXNzaW9uIE1hdGVyaWFscyBFeHRlbnNpb25cblx0ICpcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX21hdGVyaWFsc190cmFuc21pc3Npb25cblx0ICogRHJhZnQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9wdWxsLzE2OThcblx0ICovXG5cdGZ1bmN0aW9uIEdMVEZNYXRlcmlhbHNUcmFuc21pc3Npb25FeHRlbnNpb24oIHBhcnNlciApIHtcblxuXHRcdHRoaXMucGFyc2VyID0gcGFyc2VyO1xuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19UUkFOU01JU1NJT047XG5cblx0fVxuXG5cdEdMVEZNYXRlcmlhbHNUcmFuc21pc3Npb25FeHRlbnNpb24ucHJvdG90eXBlLmdldE1hdGVyaWFsVHlwZSA9IGZ1bmN0aW9uICggbWF0ZXJpYWxJbmRleCApIHtcblxuXHRcdHZhciBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcblx0XHR2YXIgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbIG1hdGVyaWFsSW5kZXggXTtcblxuXHRcdGlmICggISBtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0gKSByZXR1cm4gbnVsbDtcblxuXHRcdHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcblxuXHR9O1xuXG5cdEdMVEZNYXRlcmlhbHNUcmFuc21pc3Npb25FeHRlbnNpb24ucHJvdG90eXBlLmV4dGVuZE1hdGVyaWFsUGFyYW1zID0gZnVuY3Rpb24gKCBtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcyApIHtcblxuXHRcdHZhciBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcblx0XHR2YXIgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbIG1hdGVyaWFsSW5kZXggXTtcblxuXHRcdGlmICggISBtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0gKSB7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblxuXHRcdH1cblxuXHRcdHZhciBwZW5kaW5nID0gW107XG5cblx0XHR2YXIgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF07XG5cblx0XHRpZiAoIGV4dGVuc2lvbi50cmFuc21pc3Npb25GYWN0b3IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0bWF0ZXJpYWxQYXJhbXMudHJhbnNtaXNzaW9uID0gZXh0ZW5zaW9uLnRyYW5zbWlzc2lvbkZhY3RvcjtcblxuXHRcdH1cblxuXHRcdGlmICggZXh0ZW5zaW9uLnRyYW5zbWlzc2lvblRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICd0cmFuc21pc3Npb25NYXAnLCBleHRlbnNpb24udHJhbnNtaXNzaW9uVGV4dHVyZSApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmcgKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBCYXNpc1UgVGV4dHVyZSBFeHRlbnNpb25cblx0ICpcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX3RleHR1cmVfYmFzaXN1XG5cdCAqL1xuXHRmdW5jdGlvbiBHTFRGVGV4dHVyZUJhc2lzVUV4dGVuc2lvbiggcGFyc2VyICkge1xuXG5cdFx0dGhpcy5wYXJzZXIgPSBwYXJzZXI7XG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9CQVNJU1U7XG5cblx0fVxuXG5cdEdMVEZUZXh0dXJlQmFzaXNVRXh0ZW5zaW9uLnByb3RvdHlwZS5sb2FkVGV4dHVyZSA9IGZ1bmN0aW9uICggdGV4dHVyZUluZGV4ICkge1xuXG5cdFx0dmFyIHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdHZhciBqc29uID0gcGFyc2VyLmpzb247XG5cblx0XHR2YXIgdGV4dHVyZURlZiA9IGpzb24udGV4dHVyZXNbIHRleHR1cmVJbmRleCBdO1xuXG5cdFx0aWYgKCAhIHRleHR1cmVEZWYuZXh0ZW5zaW9ucyB8fCAhIHRleHR1cmVEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0gKSB7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGV4dGVuc2lvbiA9IHRleHR1cmVEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF07XG5cdFx0dmFyIHNvdXJjZSA9IGpzb24uaW1hZ2VzWyBleHRlbnNpb24uc291cmNlIF07XG5cdFx0dmFyIGxvYWRlciA9IHBhcnNlci5vcHRpb25zLmt0eDJMb2FkZXI7XG5cblx0XHRpZiAoICEgbG9hZGVyICkge1xuXG5cdFx0XHRpZiAoIGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkICYmIGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkLmluZGV4T2YoIHRoaXMubmFtZSApID49IDAgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogc2V0S1RYMkxvYWRlciBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgbG9hZGluZyBLVFgyIHRleHR1cmVzJyApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEFzc3VtZXMgdGhhdCB0aGUgZXh0ZW5zaW9uIGlzIG9wdGlvbmFsIGFuZCB0aGF0IGEgZmFsbGJhY2sgdGV4dHVyZSBpcyBwcmVzZW50XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcGFyc2VyLmxvYWRUZXh0dXJlSW1hZ2UoIHRleHR1cmVJbmRleCwgc291cmNlLCBsb2FkZXIgKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBXZWJQIFRleHR1cmUgRXh0ZW5zaW9uXG5cdCAqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9WZW5kb3IvRVhUX3RleHR1cmVfd2VicFxuXHQgKi9cblx0ZnVuY3Rpb24gR0xURlRleHR1cmVXZWJQRXh0ZW5zaW9uKCBwYXJzZXIgKSB7XG5cblx0XHR0aGlzLnBhcnNlciA9IHBhcnNlcjtcblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLkVYVF9URVhUVVJFX1dFQlA7XG5cdFx0dGhpcy5pc1N1cHBvcnRlZCA9IG51bGw7XG5cblx0fVxuXG5cdEdMVEZUZXh0dXJlV2ViUEV4dGVuc2lvbi5wcm90b3R5cGUubG9hZFRleHR1cmUgPSBmdW5jdGlvbiAoIHRleHR1cmVJbmRleCApIHtcblxuXHRcdHZhciBuYW1lID0gdGhpcy5uYW1lO1xuXHRcdHZhciBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcblx0XHR2YXIganNvbiA9IHBhcnNlci5qc29uO1xuXG5cdFx0dmFyIHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzWyB0ZXh0dXJlSW5kZXggXTtcblxuXHRcdGlmICggISB0ZXh0dXJlRGVmLmV4dGVuc2lvbnMgfHwgISB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbIG5hbWUgXSApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHR2YXIgZXh0ZW5zaW9uID0gdGV4dHVyZURlZi5leHRlbnNpb25zWyBuYW1lIF07XG5cdFx0dmFyIHNvdXJjZSA9IGpzb24uaW1hZ2VzWyBleHRlbnNpb24uc291cmNlIF07XG5cblx0XHR2YXIgbG9hZGVyID0gcGFyc2VyLnRleHR1cmVMb2FkZXI7XG5cdFx0aWYgKCBzb3VyY2UudXJpICkge1xuXG5cdFx0XHR2YXIgaGFuZGxlciA9IHBhcnNlci5vcHRpb25zLm1hbmFnZXIuZ2V0SGFuZGxlciggc291cmNlLnVyaSApO1xuXHRcdFx0aWYgKCBoYW5kbGVyICE9PSBudWxsICkgbG9hZGVyID0gaGFuZGxlcjtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmRldGVjdFN1cHBvcnQoKS50aGVuKCBmdW5jdGlvbiAoIGlzU3VwcG9ydGVkICkge1xuXG5cdFx0XHRpZiAoIGlzU3VwcG9ydGVkICkgcmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZUltYWdlKCB0ZXh0dXJlSW5kZXgsIHNvdXJjZSwgbG9hZGVyICk7XG5cblx0XHRcdGlmICgganNvbi5leHRlbnNpb25zUmVxdWlyZWQgJiYganNvbi5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZiggbmFtZSApID49IDAgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogV2ViUCByZXF1aXJlZCBieSBhc3NldCBidXQgdW5zdXBwb3J0ZWQuJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIEZhbGwgYmFjayB0byBQTkcgb3IgSlBFRy5cblx0XHRcdHJldHVybiBwYXJzZXIubG9hZFRleHR1cmUoIHRleHR1cmVJbmRleCApO1xuXG5cdFx0fSApO1xuXG5cdH07XG5cblx0R0xURlRleHR1cmVXZWJQRXh0ZW5zaW9uLnByb3RvdHlwZS5kZXRlY3RTdXBwb3J0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0aWYgKCAhIHRoaXMuaXNTdXBwb3J0ZWQgKSB7XG5cblx0XHRcdHRoaXMuaXNTdXBwb3J0ZWQgPSBuZXcgUHJvbWlzZSggZnVuY3Rpb24gKCByZXNvbHZlICkge1xuXG5cdFx0XHRcdHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuXG5cdFx0XHRcdC8vIExvc3N5IHRlc3QgaW1hZ2UuIFN1cHBvcnQgZm9yIGxvc3N5IGltYWdlcyBkb2Vzbid0IGd1YXJhbnRlZSBzdXBwb3J0IGZvciBhbGxcblx0XHRcdFx0Ly8gV2ViUCBpbWFnZXMsIHVuZm9ydHVuYXRlbHkuXG5cdFx0XHRcdGltYWdlLnNyYyA9ICdkYXRhOmltYWdlL3dlYnA7YmFzZTY0LFVrbEdSaUlBQUFCWFJVSlFWbEE0SUJZQUFBQXdBUUNkQVNvQkFBRUFEc0QrSmFRQUEzQUFBQUFBJztcblxuXHRcdFx0XHRpbWFnZS5vbmxvYWQgPSBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0cmVzb2x2ZSggaW1hZ2UuaGVpZ2h0ID09PSAxICk7XG5cblx0XHRcdFx0fTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuaXNTdXBwb3J0ZWQ7XG5cblx0fTtcblxuXHQvKipcblx0KiBtZXNob3B0IEJ1ZmZlclZpZXcgQ29tcHJlc3Npb24gRXh0ZW5zaW9uXG5cdCpcblx0KiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvVmVuZG9yL0VYVF9tZXNob3B0X2NvbXByZXNzaW9uXG5cdCovXG5cdGZ1bmN0aW9uIEdMVEZNZXNob3B0Q29tcHJlc3Npb24oIHBhcnNlciApIHtcblxuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuRVhUX01FU0hPUFRfQ09NUFJFU1NJT047XG5cdFx0dGhpcy5wYXJzZXIgPSBwYXJzZXI7XG5cblx0fVxuXG5cdEdMVEZNZXNob3B0Q29tcHJlc3Npb24ucHJvdG90eXBlLmxvYWRCdWZmZXJWaWV3ID0gZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdHZhciBqc29uID0gdGhpcy5wYXJzZXIuanNvbjtcblx0XHR2YXIgYnVmZmVyVmlldyA9IGpzb24uYnVmZmVyVmlld3NbIGluZGV4IF07XG5cblx0XHRpZiAoIGJ1ZmZlclZpZXcuZXh0ZW5zaW9ucyAmJiBidWZmZXJWaWV3LmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkge1xuXG5cdFx0XHR2YXIgZXh0ZW5zaW9uRGVmID0gYnVmZmVyVmlldy5leHRlbnNpb25zWyB0aGlzLm5hbWUgXTtcblxuXHRcdFx0dmFyIGJ1ZmZlciA9IHRoaXMucGFyc2VyLmdldERlcGVuZGVuY3koICdidWZmZXInLCBleHRlbnNpb25EZWYuYnVmZmVyICk7XG5cdFx0XHR2YXIgZGVjb2RlciA9IHRoaXMucGFyc2VyLm9wdGlvbnMubWVzaG9wdERlY29kZXI7XG5cblx0XHRcdGlmICggISBkZWNvZGVyIHx8ICEgZGVjb2Rlci5zdXBwb3J0ZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZCAmJiBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKCB0aGlzLm5hbWUgKSA+PSAwICkge1xuXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogc2V0TWVzaG9wdERlY29kZXIgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGxvYWRpbmcgY29tcHJlc3NlZCBmaWxlcycgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gQXNzdW1lcyB0aGF0IHRoZSBleHRlbnNpb24gaXMgb3B0aW9uYWwgYW5kIHRoYXQgZmFsbGJhY2sgYnVmZmVyIGRhdGEgaXMgcHJlc2VudFxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIFsgYnVmZmVyLCBkZWNvZGVyLnJlYWR5IF0gKS50aGVuKCBmdW5jdGlvbiAoIHJlcyApIHtcblxuXHRcdFx0XHR2YXIgYnl0ZU9mZnNldCA9IGV4dGVuc2lvbkRlZi5ieXRlT2Zmc2V0IHx8IDA7XG5cdFx0XHRcdHZhciBieXRlTGVuZ3RoID0gZXh0ZW5zaW9uRGVmLmJ5dGVMZW5ndGggfHwgMDtcblxuXHRcdFx0XHR2YXIgY291bnQgPSBleHRlbnNpb25EZWYuY291bnQ7XG5cdFx0XHRcdHZhciBzdHJpZGUgPSBleHRlbnNpb25EZWYuYnl0ZVN0cmlkZTtcblxuXHRcdFx0XHR2YXIgcmVzdWx0ID0gbmV3IEFycmF5QnVmZmVyKCBjb3VudCAqIHN0cmlkZSApO1xuXHRcdFx0XHR2YXIgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkoIHJlc1sgMCBdLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoICk7XG5cblx0XHRcdFx0ZGVjb2Rlci5kZWNvZGVHbHRmQnVmZmVyKCBuZXcgVWludDhBcnJheSggcmVzdWx0ICksIGNvdW50LCBzdHJpZGUsIHNvdXJjZSwgZXh0ZW5zaW9uRGVmLm1vZGUsIGV4dGVuc2lvbkRlZi5maWx0ZXIgKTtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuXHRcdFx0fSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvKiBCSU5BUlkgRVhURU5TSU9OICovXG5cdHZhciBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9NQUdJQyA9ICdnbFRGJztcblx0dmFyIEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCA9IDEyO1xuXHR2YXIgQklOQVJZX0VYVEVOU0lPTl9DSFVOS19UWVBFUyA9IHsgSlNPTjogMHg0RTRGNTM0QSwgQklOOiAweDAwNEU0OTQyIH07XG5cblx0ZnVuY3Rpb24gR0xURkJpbmFyeUV4dGVuc2lvbiggZGF0YSApIHtcblxuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX0JJTkFSWV9HTFRGO1xuXHRcdHRoaXMuY29udGVudCA9IG51bGw7XG5cdFx0dGhpcy5ib2R5ID0gbnVsbDtcblxuXHRcdHZhciBoZWFkZXJWaWV3ID0gbmV3IERhdGFWaWV3KCBkYXRhLCAwLCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEggKTtcblxuXHRcdHRoaXMuaGVhZGVyID0ge1xuXHRcdFx0bWFnaWM6IExvYWRlclV0aWxzLmRlY29kZVRleHQoIG5ldyBVaW50OEFycmF5KCBkYXRhLnNsaWNlKCAwLCA0ICkgKSApLFxuXHRcdFx0dmVyc2lvbjogaGVhZGVyVmlldy5nZXRVaW50MzIoIDQsIHRydWUgKSxcblx0XHRcdGxlbmd0aDogaGVhZGVyVmlldy5nZXRVaW50MzIoIDgsIHRydWUgKVxuXHRcdH07XG5cblx0XHRpZiAoIHRoaXMuaGVhZGVyLm1hZ2ljICE9PSBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9NQUdJQyApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgZ2xURi1CaW5hcnkgaGVhZGVyLicgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuaGVhZGVyLnZlcnNpb24gPCAyLjAgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IExlZ2FjeSBiaW5hcnkgZmlsZSBkZXRlY3RlZC4nICk7XG5cblx0XHR9XG5cblx0XHR2YXIgY2h1bmtDb250ZW50c0xlbmd0aCA9IHRoaXMuaGVhZGVyLmxlbmd0aCAtIEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSDtcblx0XHR2YXIgY2h1bmtWaWV3ID0gbmV3IERhdGFWaWV3KCBkYXRhLCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEggKTtcblx0XHR2YXIgY2h1bmtJbmRleCA9IDA7XG5cblx0XHR3aGlsZSAoIGNodW5rSW5kZXggPCBjaHVua0NvbnRlbnRzTGVuZ3RoICkge1xuXG5cdFx0XHR2YXIgY2h1bmtMZW5ndGggPSBjaHVua1ZpZXcuZ2V0VWludDMyKCBjaHVua0luZGV4LCB0cnVlICk7XG5cdFx0XHRjaHVua0luZGV4ICs9IDQ7XG5cblx0XHRcdHZhciBjaHVua1R5cGUgPSBjaHVua1ZpZXcuZ2V0VWludDMyKCBjaHVua0luZGV4LCB0cnVlICk7XG5cdFx0XHRjaHVua0luZGV4ICs9IDQ7XG5cblx0XHRcdGlmICggY2h1bmtUeXBlID09PSBCSU5BUllfRVhURU5TSU9OX0NIVU5LX1RZUEVTLkpTT04gKSB7XG5cblx0XHRcdFx0dmFyIGNvbnRlbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KCBkYXRhLCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEggKyBjaHVua0luZGV4LCBjaHVua0xlbmd0aCApO1xuXHRcdFx0XHR0aGlzLmNvbnRlbnQgPSBMb2FkZXJVdGlscy5kZWNvZGVUZXh0KCBjb250ZW50QXJyYXkgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggY2h1bmtUeXBlID09PSBCSU5BUllfRVhURU5TSU9OX0NIVU5LX1RZUEVTLkJJTiApIHtcblxuXHRcdFx0XHR2YXIgYnl0ZU9mZnNldCA9IEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCArIGNodW5rSW5kZXg7XG5cdFx0XHRcdHRoaXMuYm9keSA9IGRhdGEuc2xpY2UoIGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBjaHVua0xlbmd0aCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIENsaWVudHMgbXVzdCBpZ25vcmUgY2h1bmtzIHdpdGggdW5rbm93biB0eXBlcy5cblxuXHRcdFx0Y2h1bmtJbmRleCArPSBjaHVua0xlbmd0aDtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5jb250ZW50ID09PSBudWxsICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBKU09OIGNvbnRlbnQgbm90IGZvdW5kLicgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIERSQUNPIE1lc2ggQ29tcHJlc3Npb24gRXh0ZW5zaW9uXG5cdCAqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl9kcmFjb19tZXNoX2NvbXByZXNzaW9uXG5cdCAqL1xuXHRmdW5jdGlvbiBHTFRGRHJhY29NZXNoQ29tcHJlc3Npb25FeHRlbnNpb24oIGpzb24sIGRyYWNvTG9hZGVyICkge1xuXG5cdFx0aWYgKCAhIGRyYWNvTG9hZGVyICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBObyBEUkFDT0xvYWRlciBpbnN0YW5jZSBwcm92aWRlZC4nICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OO1xuXHRcdHRoaXMuanNvbiA9IGpzb247XG5cdFx0dGhpcy5kcmFjb0xvYWRlciA9IGRyYWNvTG9hZGVyO1xuXHRcdHRoaXMuZHJhY29Mb2FkZXIucHJlbG9hZCgpO1xuXG5cdH1cblxuXHRHTFRGRHJhY29NZXNoQ29tcHJlc3Npb25FeHRlbnNpb24ucHJvdG90eXBlLmRlY29kZVByaW1pdGl2ZSA9IGZ1bmN0aW9uICggcHJpbWl0aXZlLCBwYXJzZXIgKSB7XG5cblx0XHR2YXIganNvbiA9IHRoaXMuanNvbjtcblx0XHR2YXIgZHJhY29Mb2FkZXIgPSB0aGlzLmRyYWNvTG9hZGVyO1xuXHRcdHZhciBidWZmZXJWaWV3SW5kZXggPSBwcmltaXRpdmUuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0uYnVmZmVyVmlldztcblx0XHR2YXIgZ2x0ZkF0dHJpYnV0ZU1hcCA9IHByaW1pdGl2ZS5leHRlbnNpb25zWyB0aGlzLm5hbWUgXS5hdHRyaWJ1dGVzO1xuXHRcdHZhciB0aHJlZUF0dHJpYnV0ZU1hcCA9IHt9O1xuXHRcdHZhciBhdHRyaWJ1dGVOb3JtYWxpemVkTWFwID0ge307XG5cdFx0dmFyIGF0dHJpYnV0ZVR5cGVNYXAgPSB7fTtcblxuXHRcdGZvciAoIHZhciBhdHRyaWJ1dGVOYW1lIGluIGdsdGZBdHRyaWJ1dGVNYXAgKSB7XG5cblx0XHRcdHZhciB0aHJlZUF0dHJpYnV0ZU5hbWUgPSBBVFRSSUJVVEVTWyBhdHRyaWJ1dGVOYW1lIF0gfHwgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHR0aHJlZUF0dHJpYnV0ZU1hcFsgdGhyZWVBdHRyaWJ1dGVOYW1lIF0gPSBnbHRmQXR0cmlidXRlTWFwWyBhdHRyaWJ1dGVOYW1lIF07XG5cblx0XHR9XG5cblx0XHRmb3IgKCBhdHRyaWJ1dGVOYW1lIGluIHByaW1pdGl2ZS5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHR2YXIgdGhyZWVBdHRyaWJ1dGVOYW1lID0gQVRUUklCVVRFU1sgYXR0cmlidXRlTmFtZSBdIHx8IGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBnbHRmQXR0cmlidXRlTWFwWyBhdHRyaWJ1dGVOYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR2YXIgYWNjZXNzb3JEZWYgPSBqc29uLmFjY2Vzc29yc1sgcHJpbWl0aXZlLmF0dHJpYnV0ZXNbIGF0dHJpYnV0ZU5hbWUgXSBdO1xuXHRcdFx0XHR2YXIgY29tcG9uZW50VHlwZSA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1sgYWNjZXNzb3JEZWYuY29tcG9uZW50VHlwZSBdO1xuXG5cdFx0XHRcdGF0dHJpYnV0ZVR5cGVNYXBbIHRocmVlQXR0cmlidXRlTmFtZSBdID0gY29tcG9uZW50VHlwZTtcblx0XHRcdFx0YXR0cmlidXRlTm9ybWFsaXplZE1hcFsgdGhyZWVBdHRyaWJ1dGVOYW1lIF0gPSBhY2Nlc3NvckRlZi5ub3JtYWxpemVkID09PSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3koICdidWZmZXJWaWV3JywgYnVmZmVyVmlld0luZGV4ICkudGhlbiggZnVuY3Rpb24gKCBidWZmZXJWaWV3ICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoIGZ1bmN0aW9uICggcmVzb2x2ZSApIHtcblxuXHRcdFx0XHRkcmFjb0xvYWRlci5kZWNvZGVEcmFjb0ZpbGUoIGJ1ZmZlclZpZXcsIGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgYXR0cmlidXRlTmFtZSBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgYXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlc1sgYXR0cmlidXRlTmFtZSBdO1xuXHRcdFx0XHRcdFx0dmFyIG5vcm1hbGl6ZWQgPSBhdHRyaWJ1dGVOb3JtYWxpemVkTWFwWyBhdHRyaWJ1dGVOYW1lIF07XG5cblx0XHRcdFx0XHRcdGlmICggbm9ybWFsaXplZCAhPT0gdW5kZWZpbmVkICkgYXR0cmlidXRlLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVzb2x2ZSggZ2VvbWV0cnkgKTtcblxuXHRcdFx0XHR9LCB0aHJlZUF0dHJpYnV0ZU1hcCwgYXR0cmlidXRlVHlwZU1hcCApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHR9ICk7XG5cblx0fTtcblxuXHQvKipcblx0ICogVGV4dHVyZSBUcmFuc2Zvcm0gRXh0ZW5zaW9uXG5cdCAqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl90ZXh0dXJlX3RyYW5zZm9ybVxuXHQgKi9cblx0ZnVuY3Rpb24gR0xURlRleHR1cmVUcmFuc2Zvcm1FeHRlbnNpb24oKSB7XG5cblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STTtcblxuXHR9XG5cblx0R0xURlRleHR1cmVUcmFuc2Zvcm1FeHRlbnNpb24ucHJvdG90eXBlLmV4dGVuZFRleHR1cmUgPSBmdW5jdGlvbiAoIHRleHR1cmUsIHRyYW5zZm9ybSApIHtcblxuXHRcdHRleHR1cmUgPSB0ZXh0dXJlLmNsb25lKCk7XG5cblx0XHRpZiAoIHRyYW5zZm9ybS5vZmZzZXQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGV4dHVyZS5vZmZzZXQuZnJvbUFycmF5KCB0cmFuc2Zvcm0ub2Zmc2V0ICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRyYW5zZm9ybS5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0ZXh0dXJlLnJvdGF0aW9uID0gdHJhbnNmb3JtLnJvdGF0aW9uO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0cmFuc2Zvcm0uc2NhbGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGV4dHVyZS5yZXBlYXQuZnJvbUFycmF5KCB0cmFuc2Zvcm0uc2NhbGUgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdHJhbnNmb3JtLnRleENvb3JkICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdMVEZMb2FkZXI6IEN1c3RvbSBVViBzZXRzIGluIFwiJyArIHRoaXMubmFtZSArICdcIiBleHRlbnNpb24gbm90IHlldCBzdXBwb3J0ZWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTcGVjdWxhci1HbG9zc2luZXNzIEV4dGVuc2lvblxuXHQgKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfbWF0ZXJpYWxzX3BiclNwZWN1bGFyR2xvc3NpbmVzc1xuXHQgKi9cblxuXHQvKipcblx0ICogQSBzdWIgY2xhc3Mgb2YgU3RhbmRhcmRNYXRlcmlhbCB3aXRoIHNvbWUgb2YgdGhlIGZ1bmN0aW9uYWxpdHlcblx0ICogY2hhbmdlZCB2aWEgdGhlIGBvbkJlZm9yZUNvbXBpbGVgIGNhbGxiYWNrXG5cdCAqIEBwYWlsaGVhZFxuXHQgKi9cblxuXHRmdW5jdGlvbiBHTFRGTWVzaFN0YW5kYXJkU0dNYXRlcmlhbCggcGFyYW1zICkge1xuXG5cdFx0TWVzaFN0YW5kYXJkTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy5pc0dMVEZTcGVjdWxhckdsb3NzaW5lc3NNYXRlcmlhbCA9IHRydWU7XG5cblx0XHQvL3ZhcmlvdXMgY2h1bmtzIHRoYXQgbmVlZCByZXBsYWNpbmdcblx0XHR2YXIgc3BlY3VsYXJNYXBQYXJzRnJhZ21lbnRDaHVuayA9IFtcblx0XHRcdCcjaWZkZWYgVVNFX1NQRUNVTEFSTUFQJyxcblx0XHRcdCdcdHVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyTWFwOycsXG5cdFx0XHQnI2VuZGlmJ1xuXHRcdF0uam9pbiggJ1xcbicgKTtcblxuXHRcdHZhciBnbG9zc2luZXNzTWFwUGFyc0ZyYWdtZW50Q2h1bmsgPSBbXG5cdFx0XHQnI2lmZGVmIFVTRV9HTE9TU0lORVNTTUFQJyxcblx0XHRcdCdcdHVuaWZvcm0gc2FtcGxlcjJEIGdsb3NzaW5lc3NNYXA7Jyxcblx0XHRcdCcjZW5kaWYnXG5cdFx0XS5qb2luKCAnXFxuJyApO1xuXG5cdFx0dmFyIHNwZWN1bGFyTWFwRnJhZ21lbnRDaHVuayA9IFtcblx0XHRcdCd2ZWMzIHNwZWN1bGFyRmFjdG9yID0gc3BlY3VsYXI7Jyxcblx0XHRcdCcjaWZkZWYgVVNFX1NQRUNVTEFSTUFQJyxcblx0XHRcdCdcdHZlYzQgdGV4ZWxTcGVjdWxhciA9IHRleHR1cmUyRCggc3BlY3VsYXJNYXAsIHZVdiApOycsXG5cdFx0XHQnXHR0ZXhlbFNwZWN1bGFyID0gc1JHQlRvTGluZWFyKCB0ZXhlbFNwZWN1bGFyICk7Jyxcblx0XHRcdCdcdC8vIHJlYWRzIGNoYW5uZWwgUkdCLCBjb21wYXRpYmxlIHdpdGggYSBnbFRGIFNwZWN1bGFyLUdsb3NzaW5lc3MgKFJHQkEpIHRleHR1cmUnLFxuXHRcdFx0J1x0c3BlY3VsYXJGYWN0b3IgKj0gdGV4ZWxTcGVjdWxhci5yZ2I7Jyxcblx0XHRcdCcjZW5kaWYnXG5cdFx0XS5qb2luKCAnXFxuJyApO1xuXG5cdFx0dmFyIGdsb3NzaW5lc3NNYXBGcmFnbWVudENodW5rID0gW1xuXHRcdFx0J2Zsb2F0IGdsb3NzaW5lc3NGYWN0b3IgPSBnbG9zc2luZXNzOycsXG5cdFx0XHQnI2lmZGVmIFVTRV9HTE9TU0lORVNTTUFQJyxcblx0XHRcdCdcdHZlYzQgdGV4ZWxHbG9zc2luZXNzID0gdGV4dHVyZTJEKCBnbG9zc2luZXNzTWFwLCB2VXYgKTsnLFxuXHRcdFx0J1x0Ly8gcmVhZHMgY2hhbm5lbCBBLCBjb21wYXRpYmxlIHdpdGggYSBnbFRGIFNwZWN1bGFyLUdsb3NzaW5lc3MgKFJHQkEpIHRleHR1cmUnLFxuXHRcdFx0J1x0Z2xvc3NpbmVzc0ZhY3RvciAqPSB0ZXhlbEdsb3NzaW5lc3MuYTsnLFxuXHRcdFx0JyNlbmRpZidcblx0XHRdLmpvaW4oICdcXG4nICk7XG5cblx0XHR2YXIgbGlnaHRQaHlzaWNhbEZyYWdtZW50Q2h1bmsgPSBbXG5cdFx0XHQnUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbDsnLFxuXHRcdFx0J21hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2IgKiAoIDEuIC0gbWF4KCBzcGVjdWxhckZhY3Rvci5yLCBtYXgoIHNwZWN1bGFyRmFjdG9yLmcsIHNwZWN1bGFyRmFjdG9yLmIgKSApICk7Jyxcblx0XHRcdCd2ZWMzIGR4eSA9IG1heCggYWJzKCBkRmR4KCBnZW9tZXRyeU5vcm1hbCApICksIGFicyggZEZkeSggZ2VvbWV0cnlOb3JtYWwgKSApICk7Jyxcblx0XHRcdCdmbG9hdCBnZW9tZXRyeVJvdWdobmVzcyA9IG1heCggbWF4KCBkeHkueCwgZHh5LnkgKSwgZHh5LnogKTsnLFxuXHRcdFx0J21hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzID0gbWF4KCAxLjAgLSBnbG9zc2luZXNzRmFjdG9yLCAwLjA1MjUgKTsgLy8gMC4wNTI1IGNvcnJlc3BvbmRzIHRvIHRoZSBiYXNlIG1pcCBvZiBhIDI1NiBjdWJlbWFwLicsXG5cdFx0XHQnbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MgKz0gZ2VvbWV0cnlSb3VnaG5lc3M7Jyxcblx0XHRcdCdtYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcyA9IG1pbiggbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MsIDEuMCApOycsXG5cdFx0XHQnbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IHNwZWN1bGFyRmFjdG9yOycsXG5cdFx0XS5qb2luKCAnXFxuJyApO1xuXG5cdFx0dmFyIHVuaWZvcm1zID0ge1xuXHRcdFx0c3BlY3VsYXI6IHsgdmFsdWU6IG5ldyBDb2xvcigpLnNldEhleCggMHhmZmZmZmYgKSB9LFxuXHRcdFx0Z2xvc3NpbmVzczogeyB2YWx1ZTogMSB9LFxuXHRcdFx0c3BlY3VsYXJNYXA6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRcdGdsb3NzaW5lc3NNYXA6IHsgdmFsdWU6IG51bGwgfVxuXHRcdH07XG5cblx0XHR0aGlzLl9leHRyYVVuaWZvcm1zID0gdW5pZm9ybXM7XG5cblx0XHR0aGlzLm9uQmVmb3JlQ29tcGlsZSA9IGZ1bmN0aW9uICggc2hhZGVyICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgdW5pZm9ybU5hbWUgaW4gdW5pZm9ybXMgKSB7XG5cblx0XHRcdFx0c2hhZGVyLnVuaWZvcm1zWyB1bmlmb3JtTmFtZSBdID0gdW5pZm9ybXNbIHVuaWZvcm1OYW1lIF07XG5cblx0XHRcdH1cblxuXHRcdFx0c2hhZGVyLmZyYWdtZW50U2hhZGVyID0gc2hhZGVyLmZyYWdtZW50U2hhZGVyXG5cdFx0XHRcdC5yZXBsYWNlKCAndW5pZm9ybSBmbG9hdCByb3VnaG5lc3M7JywgJ3VuaWZvcm0gdmVjMyBzcGVjdWxhcjsnIClcblx0XHRcdFx0LnJlcGxhY2UoICd1bmlmb3JtIGZsb2F0IG1ldGFsbmVzczsnLCAndW5pZm9ybSBmbG9hdCBnbG9zc2luZXNzOycgKVxuXHRcdFx0XHQucmVwbGFjZSggJyNpbmNsdWRlIDxyb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudD4nLCBzcGVjdWxhck1hcFBhcnNGcmFnbWVudENodW5rIClcblx0XHRcdFx0LnJlcGxhY2UoICcjaW5jbHVkZSA8bWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQ+JywgZ2xvc3NpbmVzc01hcFBhcnNGcmFnbWVudENodW5rIClcblx0XHRcdFx0LnJlcGxhY2UoICcjaW5jbHVkZSA8cm91Z2huZXNzbWFwX2ZyYWdtZW50PicsIHNwZWN1bGFyTWFwRnJhZ21lbnRDaHVuayApXG5cdFx0XHRcdC5yZXBsYWNlKCAnI2luY2x1ZGUgPG1ldGFsbmVzc21hcF9mcmFnbWVudD4nLCBnbG9zc2luZXNzTWFwRnJhZ21lbnRDaHVuayApXG5cdFx0XHRcdC5yZXBsYWNlKCAnI2luY2x1ZGUgPGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudD4nLCBsaWdodFBoeXNpY2FsRnJhZ21lbnRDaHVuayApO1xuXG5cdFx0fTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLCB7XG5cblx0XHRcdHNwZWN1bGFyOiB7XG5cdFx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIHVuaWZvcm1zLnNwZWN1bGFyLnZhbHVlO1xuXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNldDogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0XHRcdFx0dW5pZm9ybXMuc3BlY3VsYXIudmFsdWUgPSB2O1xuXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdHNwZWN1bGFyTWFwOiB7XG5cdFx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIHVuaWZvcm1zLnNwZWN1bGFyTWFwLnZhbHVlO1xuXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNldDogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0XHRcdFx0dW5pZm9ybXMuc3BlY3VsYXJNYXAudmFsdWUgPSB2O1xuXG5cdFx0XHRcdFx0aWYgKCB2ICkge1xuXG5cdFx0XHRcdFx0XHR0aGlzLmRlZmluZXMuVVNFX1NQRUNVTEFSTUFQID0gJyc7IC8vIFVTRV9VViBpcyBzZXQgYnkgdGhlIHJlbmRlcmVyIGZvciBzcGVjdWxhciBtYXBzXG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRkZWxldGUgdGhpcy5kZWZpbmVzLlVTRV9TUEVDVUxBUk1BUDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRnbG9zc2luZXNzOiB7XG5cdFx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIHVuaWZvcm1zLmdsb3NzaW5lc3MudmFsdWU7XG5cblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdFx0XHR1bmlmb3Jtcy5nbG9zc2luZXNzLnZhbHVlID0gdjtcblxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRnbG9zc2luZXNzTWFwOiB7XG5cdFx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIHVuaWZvcm1zLmdsb3NzaW5lc3NNYXAudmFsdWU7XG5cblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdFx0XHR1bmlmb3Jtcy5nbG9zc2luZXNzTWFwLnZhbHVlID0gdjtcblxuXHRcdFx0XHRcdGlmICggdiApIHtcblxuXHRcdFx0XHRcdFx0dGhpcy5kZWZpbmVzLlVTRV9HTE9TU0lORVNTTUFQID0gJyc7XG5cdFx0XHRcdFx0XHR0aGlzLmRlZmluZXMuVVNFX1VWID0gJyc7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRkZWxldGUgdGhpcy5kZWZpbmVzLlVTRV9HTE9TU0lORVNTTUFQO1xuXHRcdFx0XHRcdFx0ZGVsZXRlIHRoaXMuZGVmaW5lcy5VU0VfVVY7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSApO1xuXG5cdFx0ZGVsZXRlIHRoaXMubWV0YWxuZXNzO1xuXHRcdGRlbGV0ZSB0aGlzLnJvdWdobmVzcztcblx0XHRkZWxldGUgdGhpcy5tZXRhbG5lc3NNYXA7XG5cdFx0ZGVsZXRlIHRoaXMucm91Z2huZXNzTWFwO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtcyApO1xuXG5cdH1cblxuXHRHTFRGTWVzaFN0YW5kYXJkU0dNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUgKTtcblx0R0xURk1lc2hTdGFuZGFyZFNHTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR0xURk1lc2hTdGFuZGFyZFNHTWF0ZXJpYWw7XG5cblx0R0xURk1lc2hTdGFuZGFyZFNHTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdE1lc2hTdGFuZGFyZE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXHRcdHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XG5cdFx0dGhpcy5zcGVjdWxhci5jb3B5KCBzb3VyY2Uuc3BlY3VsYXIgKTtcblx0XHR0aGlzLmdsb3NzaW5lc3NNYXAgPSBzb3VyY2UuZ2xvc3NpbmVzc01hcDtcblx0XHR0aGlzLmdsb3NzaW5lc3MgPSBzb3VyY2UuZ2xvc3NpbmVzcztcblx0XHRkZWxldGUgdGhpcy5tZXRhbG5lc3M7XG5cdFx0ZGVsZXRlIHRoaXMucm91Z2huZXNzO1xuXHRcdGRlbGV0ZSB0aGlzLm1ldGFsbmVzc01hcDtcblx0XHRkZWxldGUgdGhpcy5yb3VnaG5lc3NNYXA7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBHTFRGTWF0ZXJpYWxzUGJyU3BlY3VsYXJHbG9zc2luZXNzRXh0ZW5zaW9uKCkge1xuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0bmFtZTogRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1BCUl9TUEVDVUxBUl9HTE9TU0lORVNTLFxuXG5cdFx0XHRzcGVjdWxhckdsb3NzaW5lc3NQYXJhbXM6IFtcblx0XHRcdFx0J2NvbG9yJyxcblx0XHRcdFx0J21hcCcsXG5cdFx0XHRcdCdsaWdodE1hcCcsXG5cdFx0XHRcdCdsaWdodE1hcEludGVuc2l0eScsXG5cdFx0XHRcdCdhb01hcCcsXG5cdFx0XHRcdCdhb01hcEludGVuc2l0eScsXG5cdFx0XHRcdCdlbWlzc2l2ZScsXG5cdFx0XHRcdCdlbWlzc2l2ZUludGVuc2l0eScsXG5cdFx0XHRcdCdlbWlzc2l2ZU1hcCcsXG5cdFx0XHRcdCdidW1wTWFwJyxcblx0XHRcdFx0J2J1bXBTY2FsZScsXG5cdFx0XHRcdCdub3JtYWxNYXAnLFxuXHRcdFx0XHQnbm9ybWFsTWFwVHlwZScsXG5cdFx0XHRcdCdkaXNwbGFjZW1lbnRNYXAnLFxuXHRcdFx0XHQnZGlzcGxhY2VtZW50U2NhbGUnLFxuXHRcdFx0XHQnZGlzcGxhY2VtZW50QmlhcycsXG5cdFx0XHRcdCdzcGVjdWxhck1hcCcsXG5cdFx0XHRcdCdzcGVjdWxhcicsXG5cdFx0XHRcdCdnbG9zc2luZXNzTWFwJyxcblx0XHRcdFx0J2dsb3NzaW5lc3MnLFxuXHRcdFx0XHQnYWxwaGFNYXAnLFxuXHRcdFx0XHQnZW52TWFwJyxcblx0XHRcdFx0J2Vudk1hcEludGVuc2l0eScsXG5cdFx0XHRcdCdyZWZyYWN0aW9uUmF0aW8nLFxuXHRcdFx0XSxcblxuXHRcdFx0Z2V0TWF0ZXJpYWxUeXBlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0cmV0dXJuIEdMVEZNZXNoU3RhbmRhcmRTR01hdGVyaWFsO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRleHRlbmRQYXJhbXM6IGZ1bmN0aW9uICggbWF0ZXJpYWxQYXJhbXMsIG1hdGVyaWFsRGVmLCBwYXJzZXIgKSB7XG5cblx0XHRcdFx0dmFyIHBiclNwZWN1bGFyR2xvc3NpbmVzcyA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdO1xuXG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLmNvbG9yID0gbmV3IENvbG9yKCAxLjAsIDEuMCwgMS4wICk7XG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSAxLjA7XG5cblx0XHRcdFx0dmFyIHBlbmRpbmcgPSBbXTtcblxuXHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHBiclNwZWN1bGFyR2xvc3NpbmVzcy5kaWZmdXNlRmFjdG9yICkgKSB7XG5cblx0XHRcdFx0XHR2YXIgYXJyYXkgPSBwYnJTcGVjdWxhckdsb3NzaW5lc3MuZGlmZnVzZUZhY3RvcjtcblxuXHRcdFx0XHRcdG1hdGVyaWFsUGFyYW1zLmNvbG9yLmZyb21BcnJheSggYXJyYXkgKTtcblx0XHRcdFx0XHRtYXRlcmlhbFBhcmFtcy5vcGFjaXR5ID0gYXJyYXlbIDMgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBwYnJTcGVjdWxhckdsb3NzaW5lc3MuZGlmZnVzZVRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAnbWFwJywgcGJyU3BlY3VsYXJHbG9zc2luZXNzLmRpZmZ1c2VUZXh0dXJlICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWF0ZXJpYWxQYXJhbXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoIDAuMCwgMC4wLCAwLjAgKTtcblx0XHRcdFx0bWF0ZXJpYWxQYXJhbXMuZ2xvc3NpbmVzcyA9IHBiclNwZWN1bGFyR2xvc3NpbmVzcy5nbG9zc2luZXNzRmFjdG9yICE9PSB1bmRlZmluZWQgPyBwYnJTcGVjdWxhckdsb3NzaW5lc3MuZ2xvc3NpbmVzc0ZhY3RvciA6IDEuMDtcblx0XHRcdFx0bWF0ZXJpYWxQYXJhbXMuc3BlY3VsYXIgPSBuZXcgQ29sb3IoIDEuMCwgMS4wLCAxLjAgKTtcblxuXHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHBiclNwZWN1bGFyR2xvc3NpbmVzcy5zcGVjdWxhckZhY3RvciApICkge1xuXG5cdFx0XHRcdFx0bWF0ZXJpYWxQYXJhbXMuc3BlY3VsYXIuZnJvbUFycmF5KCBwYnJTcGVjdWxhckdsb3NzaW5lc3Muc3BlY3VsYXJGYWN0b3IgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBwYnJTcGVjdWxhckdsb3NzaW5lc3Muc3BlY3VsYXJHbG9zc2luZXNzVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0dmFyIHNwZWNHbG9zc01hcERlZiA9IHBiclNwZWN1bGFyR2xvc3NpbmVzcy5zcGVjdWxhckdsb3NzaW5lc3NUZXh0dXJlO1xuXHRcdFx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAnZ2xvc3NpbmVzc01hcCcsIHNwZWNHbG9zc01hcERlZiApICk7XG5cdFx0XHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdzcGVjdWxhck1hcCcsIHNwZWNHbG9zc01hcERlZiApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRjcmVhdGVNYXRlcmlhbDogZnVuY3Rpb24gKCBtYXRlcmlhbFBhcmFtcyApIHtcblxuXHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgR0xURk1lc2hTdGFuZGFyZFNHTWF0ZXJpYWwoIG1hdGVyaWFsUGFyYW1zICk7XG5cdFx0XHRcdG1hdGVyaWFsLmZvZyA9IHRydWU7XG5cblx0XHRcdFx0bWF0ZXJpYWwuY29sb3IgPSBtYXRlcmlhbFBhcmFtcy5jb2xvcjtcblxuXHRcdFx0XHRtYXRlcmlhbC5tYXAgPSBtYXRlcmlhbFBhcmFtcy5tYXAgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBtYXRlcmlhbFBhcmFtcy5tYXA7XG5cblx0XHRcdFx0bWF0ZXJpYWwubGlnaHRNYXAgPSBudWxsO1xuXHRcdFx0XHRtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcblxuXHRcdFx0XHRtYXRlcmlhbC5hb01hcCA9IG1hdGVyaWFsUGFyYW1zLmFvTWFwID09PSB1bmRlZmluZWQgPyBudWxsIDogbWF0ZXJpYWxQYXJhbXMuYW9NYXA7XG5cdFx0XHRcdG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xuXG5cdFx0XHRcdG1hdGVyaWFsLmVtaXNzaXZlID0gbWF0ZXJpYWxQYXJhbXMuZW1pc3NpdmU7XG5cdFx0XHRcdG1hdGVyaWFsLmVtaXNzaXZlSW50ZW5zaXR5ID0gMS4wO1xuXHRcdFx0XHRtYXRlcmlhbC5lbWlzc2l2ZU1hcCA9IG1hdGVyaWFsUGFyYW1zLmVtaXNzaXZlTWFwID09PSB1bmRlZmluZWQgPyBudWxsIDogbWF0ZXJpYWxQYXJhbXMuZW1pc3NpdmVNYXA7XG5cblx0XHRcdFx0bWF0ZXJpYWwuYnVtcE1hcCA9IG1hdGVyaWFsUGFyYW1zLmJ1bXBNYXAgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBtYXRlcmlhbFBhcmFtcy5idW1wTWFwO1xuXHRcdFx0XHRtYXRlcmlhbC5idW1wU2NhbGUgPSAxO1xuXG5cdFx0XHRcdG1hdGVyaWFsLm5vcm1hbE1hcCA9IG1hdGVyaWFsUGFyYW1zLm5vcm1hbE1hcCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG1hdGVyaWFsUGFyYW1zLm5vcm1hbE1hcDtcblx0XHRcdFx0bWF0ZXJpYWwubm9ybWFsTWFwVHlwZSA9IFRhbmdlbnRTcGFjZU5vcm1hbE1hcDtcblxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsUGFyYW1zLm5vcm1hbFNjYWxlICkgbWF0ZXJpYWwubm9ybWFsU2NhbGUgPSBtYXRlcmlhbFBhcmFtcy5ub3JtYWxTY2FsZTtcblxuXHRcdFx0XHRtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xuXHRcdFx0XHRtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XG5cdFx0XHRcdG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXG5cdFx0XHRcdG1hdGVyaWFsLnNwZWN1bGFyTWFwID0gbWF0ZXJpYWxQYXJhbXMuc3BlY3VsYXJNYXAgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBtYXRlcmlhbFBhcmFtcy5zcGVjdWxhck1hcDtcblx0XHRcdFx0bWF0ZXJpYWwuc3BlY3VsYXIgPSBtYXRlcmlhbFBhcmFtcy5zcGVjdWxhcjtcblxuXHRcdFx0XHRtYXRlcmlhbC5nbG9zc2luZXNzTWFwID0gbWF0ZXJpYWxQYXJhbXMuZ2xvc3NpbmVzc01hcCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG1hdGVyaWFsUGFyYW1zLmdsb3NzaW5lc3NNYXA7XG5cdFx0XHRcdG1hdGVyaWFsLmdsb3NzaW5lc3MgPSBtYXRlcmlhbFBhcmFtcy5nbG9zc2luZXNzO1xuXG5cdFx0XHRcdG1hdGVyaWFsLmFscGhhTWFwID0gbnVsbDtcblxuXHRcdFx0XHRtYXRlcmlhbC5lbnZNYXAgPSBtYXRlcmlhbFBhcmFtcy5lbnZNYXAgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBtYXRlcmlhbFBhcmFtcy5lbnZNYXA7XG5cdFx0XHRcdG1hdGVyaWFsLmVudk1hcEludGVuc2l0eSA9IDEuMDtcblxuXHRcdFx0XHRtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xuXG5cdFx0XHRcdHJldHVybiBtYXRlcmlhbDtcblxuXHRcdFx0fSxcblxuXHRcdH07XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBNZXNoIFF1YW50aXphdGlvbiBFeHRlbnNpb25cblx0ICpcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX21lc2hfcXVhbnRpemF0aW9uXG5cdCAqL1xuXHRmdW5jdGlvbiBHTFRGTWVzaFF1YW50aXphdGlvbkV4dGVuc2lvbigpIHtcblxuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01FU0hfUVVBTlRJWkFUSU9OO1xuXG5cdH1cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKiBJTlRFUlBPTEFUSU9OICoqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdC8vIFNwbGluZSBJbnRlcnBvbGF0aW9uXG5cdC8vIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjYXBwZW5kaXgtYy1zcGxpbmUtaW50ZXJwb2xhdGlvblxuXHRmdW5jdGlvbiBHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudCggcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApIHtcblxuXHRcdEludGVycG9sYW50LmNhbGwoIHRoaXMsIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKTtcblxuXHR9XG5cblx0R0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW50ZXJwb2xhbnQucHJvdG90eXBlICk7XG5cdEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50O1xuXG5cdEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50LnByb3RvdHlwZS5jb3B5U2FtcGxlVmFsdWVfID0gZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdC8vIENvcGllcyBhIHNhbXBsZSB2YWx1ZSB0byB0aGUgcmVzdWx0IGJ1ZmZlci4gU2VlIGRlc2NyaXB0aW9uIG9mIGdsVEZcblx0XHQvLyBDVUJJQ1NQTElORSB2YWx1ZXMgbGF5b3V0IGluIGludGVycG9sYXRlXygpIGZ1bmN0aW9uIGJlbG93LlxuXG5cdFx0dmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLFxuXHRcdFx0dmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsXG5cdFx0XHR2YWx1ZVNpemUgPSB0aGlzLnZhbHVlU2l6ZSxcblx0XHRcdG9mZnNldCA9IGluZGV4ICogdmFsdWVTaXplICogMyArIHZhbHVlU2l6ZTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gdmFsdWVTaXplOyBpICsrICkge1xuXG5cdFx0XHRyZXN1bHRbIGkgXSA9IHZhbHVlc1sgb2Zmc2V0ICsgaSBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9O1xuXG5cdEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50LnByb3RvdHlwZS5iZWZvcmVTdGFydF8gPSBHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudC5wcm90b3R5cGUuY29weVNhbXBsZVZhbHVlXztcblxuXHRHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudC5wcm90b3R5cGUuYWZ0ZXJFbmRfID0gR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQucHJvdG90eXBlLmNvcHlTYW1wbGVWYWx1ZV87XG5cblx0R0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQucHJvdG90eXBlLmludGVycG9sYXRlXyA9IGZ1bmN0aW9uICggaTEsIHQwLCB0LCB0MSApIHtcblxuXHRcdHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcjtcblx0XHR2YXIgdmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXM7XG5cdFx0dmFyIHN0cmlkZSA9IHRoaXMudmFsdWVTaXplO1xuXG5cdFx0dmFyIHN0cmlkZTIgPSBzdHJpZGUgKiAyO1xuXHRcdHZhciBzdHJpZGUzID0gc3RyaWRlICogMztcblxuXHRcdHZhciB0ZCA9IHQxIC0gdDA7XG5cblx0XHR2YXIgcCA9ICggdCAtIHQwICkgLyB0ZDtcblx0XHR2YXIgcHAgPSBwICogcDtcblx0XHR2YXIgcHBwID0gcHAgKiBwO1xuXG5cdFx0dmFyIG9mZnNldDEgPSBpMSAqIHN0cmlkZTM7XG5cdFx0dmFyIG9mZnNldDAgPSBvZmZzZXQxIC0gc3RyaWRlMztcblxuXHRcdHZhciBzMiA9IC0gMiAqIHBwcCArIDMgKiBwcDtcblx0XHR2YXIgczMgPSBwcHAgLSBwcDtcblx0XHR2YXIgczAgPSAxIC0gczI7XG5cdFx0dmFyIHMxID0gczMgLSBwcCArIHA7XG5cblx0XHQvLyBMYXlvdXQgb2Yga2V5ZnJhbWUgb3V0cHV0IHZhbHVlcyBmb3IgQ1VCSUNTUExJTkUgYW5pbWF0aW9uczpcblx0XHQvLyAgIFsgaW5UYW5nZW50XzEsIHNwbGluZVZlcnRleF8xLCBvdXRUYW5nZW50XzEsIGluVGFuZ2VudF8yLCBzcGxpbmVWZXJ0ZXhfMiwgLi4uIF1cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IHN0cmlkZTsgaSArKyApIHtcblxuXHRcdFx0dmFyIHAwID0gdmFsdWVzWyBvZmZzZXQwICsgaSArIHN0cmlkZSBdOyAvLyBzcGxpbmVWZXJ0ZXhfa1xuXHRcdFx0dmFyIG0wID0gdmFsdWVzWyBvZmZzZXQwICsgaSArIHN0cmlkZTIgXSAqIHRkOyAvLyBvdXRUYW5nZW50X2sgKiAodF9rKzEgLSB0X2spXG5cdFx0XHR2YXIgcDEgPSB2YWx1ZXNbIG9mZnNldDEgKyBpICsgc3RyaWRlIF07IC8vIHNwbGluZVZlcnRleF9rKzFcblx0XHRcdHZhciBtMSA9IHZhbHVlc1sgb2Zmc2V0MSArIGkgXSAqIHRkOyAvLyBpblRhbmdlbnRfaysxICogKHRfaysxIC0gdF9rKVxuXG5cdFx0XHRyZXN1bHRbIGkgXSA9IHMwICogcDAgKyBzMSAqIG0wICsgczIgKiBwMSArIHMzICogbTE7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH07XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyoqKioqKioqKiogSU5URVJOQUxTICoqKioqKioqKioqKi9cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHQvKiBDT05TVEFOVFMgKi9cblxuXHR2YXIgV0VCR0xfQ09OU1RBTlRTID0ge1xuXHRcdEZMT0FUOiA1MTI2LFxuXHRcdC8vRkxPQVRfTUFUMjogMzU2NzQsXG5cdFx0RkxPQVRfTUFUMzogMzU2NzUsXG5cdFx0RkxPQVRfTUFUNDogMzU2NzYsXG5cdFx0RkxPQVRfVkVDMjogMzU2NjQsXG5cdFx0RkxPQVRfVkVDMzogMzU2NjUsXG5cdFx0RkxPQVRfVkVDNDogMzU2NjYsXG5cdFx0TElORUFSOiA5NzI5LFxuXHRcdFJFUEVBVDogMTA0OTcsXG5cdFx0U0FNUExFUl8yRDogMzU2NzgsXG5cdFx0UE9JTlRTOiAwLFxuXHRcdExJTkVTOiAxLFxuXHRcdExJTkVfTE9PUDogMixcblx0XHRMSU5FX1NUUklQOiAzLFxuXHRcdFRSSUFOR0xFUzogNCxcblx0XHRUUklBTkdMRV9TVFJJUDogNSxcblx0XHRUUklBTkdMRV9GQU46IDYsXG5cdFx0VU5TSUdORURfQllURTogNTEyMSxcblx0XHRVTlNJR05FRF9TSE9SVDogNTEyM1xuXHR9O1xuXG5cdHZhciBXRUJHTF9DT01QT05FTlRfVFlQRVMgPSB7XG5cdFx0NTEyMDogSW50OEFycmF5LFxuXHRcdDUxMjE6IFVpbnQ4QXJyYXksXG5cdFx0NTEyMjogSW50MTZBcnJheSxcblx0XHQ1MTIzOiBVaW50MTZBcnJheSxcblx0XHQ1MTI1OiBVaW50MzJBcnJheSxcblx0XHQ1MTI2OiBGbG9hdDMyQXJyYXlcblx0fTtcblxuXHR2YXIgV0VCR0xfRklMVEVSUyA9IHtcblx0XHQ5NzI4OiBOZWFyZXN0RmlsdGVyLFxuXHRcdDk3Mjk6IExpbmVhckZpbHRlcixcblx0XHQ5OTg0OiBOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlcixcblx0XHQ5OTg1OiBMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyLFxuXHRcdDk5ODY6IE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIsXG5cdFx0OTk4NzogTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyXG5cdH07XG5cblx0dmFyIFdFQkdMX1dSQVBQSU5HUyA9IHtcblx0XHQzMzA3MTogQ2xhbXBUb0VkZ2VXcmFwcGluZyxcblx0XHQzMzY0ODogTWlycm9yZWRSZXBlYXRXcmFwcGluZyxcblx0XHQxMDQ5NzogUmVwZWF0V3JhcHBpbmdcblx0fTtcblxuXHR2YXIgV0VCR0xfVFlQRV9TSVpFUyA9IHtcblx0XHQnU0NBTEFSJzogMSxcblx0XHQnVkVDMic6IDIsXG5cdFx0J1ZFQzMnOiAzLFxuXHRcdCdWRUM0JzogNCxcblx0XHQnTUFUMic6IDQsXG5cdFx0J01BVDMnOiA5LFxuXHRcdCdNQVQ0JzogMTZcblx0fTtcblxuXHR2YXIgQVRUUklCVVRFUyA9IHtcblx0XHRQT1NJVElPTjogJ3Bvc2l0aW9uJyxcblx0XHROT1JNQUw6ICdub3JtYWwnLFxuXHRcdFRBTkdFTlQ6ICd0YW5nZW50Jyxcblx0XHRURVhDT09SRF8wOiAndXYnLFxuXHRcdFRFWENPT1JEXzE6ICd1djInLFxuXHRcdENPTE9SXzA6ICdjb2xvcicsXG5cdFx0V0VJR0hUU18wOiAnc2tpbldlaWdodCcsXG5cdFx0Sk9JTlRTXzA6ICdza2luSW5kZXgnLFxuXHR9O1xuXG5cdHZhciBQQVRIX1BST1BFUlRJRVMgPSB7XG5cdFx0c2NhbGU6ICdzY2FsZScsXG5cdFx0dHJhbnNsYXRpb246ICdwb3NpdGlvbicsXG5cdFx0cm90YXRpb246ICdxdWF0ZXJuaW9uJyxcblx0XHR3ZWlnaHRzOiAnbW9ycGhUYXJnZXRJbmZsdWVuY2VzJ1xuXHR9O1xuXG5cdHZhciBJTlRFUlBPTEFUSU9OID0ge1xuXHRcdENVQklDU1BMSU5FOiB1bmRlZmluZWQsIC8vIFdlIHVzZSBhIGN1c3RvbSBpbnRlcnBvbGFudCAoR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhdGlvbikgZm9yIENVQklDU1BMSU5FIHRyYWNrcy4gRWFjaFxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtleWZyYW1lIHRyYWNrIHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhIGRlZmF1bHQgaW50ZXJwb2xhdGlvbiB0eXBlLCB0aGVuIG1vZGlmaWVkLlxuXHRcdExJTkVBUjogSW50ZXJwb2xhdGVMaW5lYXIsXG5cdFx0U1RFUDogSW50ZXJwb2xhdGVEaXNjcmV0ZVxuXHR9O1xuXG5cdHZhciBBTFBIQV9NT0RFUyA9IHtcblx0XHRPUEFRVUU6ICdPUEFRVUUnLFxuXHRcdE1BU0s6ICdNQVNLJyxcblx0XHRCTEVORDogJ0JMRU5EJ1xuXHR9O1xuXG5cdC8qIFVUSUxJVFkgRlVOQ1RJT05TICovXG5cblx0ZnVuY3Rpb24gcmVzb2x2ZVVSTCggdXJsLCBwYXRoICkge1xuXG5cdFx0Ly8gSW52YWxpZCBVUkxcblx0XHRpZiAoIHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnIHx8IHVybCA9PT0gJycgKSByZXR1cm4gJyc7XG5cblx0XHQvLyBIb3N0IFJlbGF0aXZlIFVSTFxuXHRcdGlmICggL15odHRwcz86XFwvXFwvL2kudGVzdCggcGF0aCApICYmIC9eXFwvLy50ZXN0KCB1cmwgKSApIHtcblxuXHRcdFx0cGF0aCA9IHBhdGgucmVwbGFjZSggLyheaHR0cHM/OlxcL1xcL1teXFwvXSspLiovaSwgJyQxJyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gQWJzb2x1dGUgVVJMIGh0dHA6Ly8saHR0cHM6Ly8sLy9cblx0XHRpZiAoIC9eKGh0dHBzPzopP1xcL1xcLy9pLnRlc3QoIHVybCApICkgcmV0dXJuIHVybDtcblxuXHRcdC8vIERhdGEgVVJJXG5cdFx0aWYgKCAvXmRhdGE6LiosLiokL2kudGVzdCggdXJsICkgKSByZXR1cm4gdXJsO1xuXG5cdFx0Ly8gQmxvYiBVUkxcblx0XHRpZiAoIC9eYmxvYjouKiQvaS50ZXN0KCB1cmwgKSApIHJldHVybiB1cmw7XG5cblx0XHQvLyBSZWxhdGl2ZSBVUkxcblx0XHRyZXR1cm4gcGF0aCArIHVybDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjZGVmYXVsdC1tYXRlcmlhbFxuXHQgKi9cblx0ZnVuY3Rpb24gY3JlYXRlRGVmYXVsdE1hdGVyaWFsKCBjYWNoZSApIHtcblxuXHRcdGlmICggY2FjaGVbICdEZWZhdWx0TWF0ZXJpYWwnIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y2FjaGVbICdEZWZhdWx0TWF0ZXJpYWwnIF0gPSBuZXcgTWVzaFN0YW5kYXJkTWF0ZXJpYWwoIHtcblx0XHRcdFx0Y29sb3I6IDB4RkZGRkZGLFxuXHRcdFx0XHRlbWlzc2l2ZTogMHgwMDAwMDAsXG5cdFx0XHRcdG1ldGFsbmVzczogMSxcblx0XHRcdFx0cm91Z2huZXNzOiAxLFxuXHRcdFx0XHR0cmFuc3BhcmVudDogZmFsc2UsXG5cdFx0XHRcdGRlcHRoVGVzdDogdHJ1ZSxcblx0XHRcdFx0c2lkZTogRnJvbnRTaWRlXG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gY2FjaGVbICdEZWZhdWx0TWF0ZXJpYWwnIF07XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YSgga25vd25FeHRlbnNpb25zLCBvYmplY3QsIG9iamVjdERlZiApIHtcblxuXHRcdC8vIEFkZCB1bmtub3duIGdsVEYgZXh0ZW5zaW9ucyB0byBhbiBvYmplY3QncyB1c2VyRGF0YS5cblxuXHRcdGZvciAoIHZhciBuYW1lIGluIG9iamVjdERlZi5leHRlbnNpb25zICkge1xuXG5cdFx0XHRpZiAoIGtub3duRXh0ZW5zaW9uc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0b2JqZWN0LnVzZXJEYXRhLmdsdGZFeHRlbnNpb25zID0gb2JqZWN0LnVzZXJEYXRhLmdsdGZFeHRlbnNpb25zIHx8IHt9O1xuXHRcdFx0XHRvYmplY3QudXNlckRhdGEuZ2x0ZkV4dGVuc2lvbnNbIG5hbWUgXSA9IG9iamVjdERlZi5leHRlbnNpb25zWyBuYW1lIF07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7T2JqZWN0M0R8TWF0ZXJpYWx8QnVmZmVyR2VvbWV0cnl9IG9iamVjdFxuXHQgKiBAcGFyYW0ge0dMVEYuZGVmaW5pdGlvbn0gZ2x0ZkRlZlxuXHQgKi9cblx0ZnVuY3Rpb24gYXNzaWduRXh0cmFzVG9Vc2VyRGF0YSggb2JqZWN0LCBnbHRmRGVmICkge1xuXG5cdFx0aWYgKCBnbHRmRGVmLmV4dHJhcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIHR5cGVvZiBnbHRmRGVmLmV4dHJhcyA9PT0gJ29iamVjdCcgKSB7XG5cblx0XHRcdFx0T2JqZWN0LmFzc2lnbiggb2JqZWN0LnVzZXJEYXRhLCBnbHRmRGVmLmV4dHJhcyApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdMVEZMb2FkZXI6IElnbm9yaW5nIHByaW1pdGl2ZSB0eXBlIC5leHRyYXMsICcgKyBnbHRmRGVmLmV4dHJhcyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI21vcnBoLXRhcmdldHNcblx0ICpcblx0ICogQHBhcmFtIHtCdWZmZXJHZW9tZXRyeX0gZ2VvbWV0cnlcblx0ICogQHBhcmFtIHtBcnJheTxHTFRGLlRhcmdldD59IHRhcmdldHNcblx0ICogQHBhcmFtIHtHTFRGUGFyc2VyfSBwYXJzZXJcblx0ICogQHJldHVybiB7UHJvbWlzZTxCdWZmZXJHZW9tZXRyeT59XG5cdCAqL1xuXHRmdW5jdGlvbiBhZGRNb3JwaFRhcmdldHMoIGdlb21ldHJ5LCB0YXJnZXRzLCBwYXJzZXIgKSB7XG5cblx0XHR2YXIgaGFzTW9ycGhQb3NpdGlvbiA9IGZhbHNlO1xuXHRcdHZhciBoYXNNb3JwaE5vcm1hbCA9IGZhbHNlO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZhciB0YXJnZXQgPSB0YXJnZXRzWyBpIF07XG5cblx0XHRcdGlmICggdGFyZ2V0LlBPU0lUSU9OICE9PSB1bmRlZmluZWQgKSBoYXNNb3JwaFBvc2l0aW9uID0gdHJ1ZTtcblx0XHRcdGlmICggdGFyZ2V0Lk5PUk1BTCAhPT0gdW5kZWZpbmVkICkgaGFzTW9ycGhOb3JtYWwgPSB0cnVlO1xuXG5cdFx0XHRpZiAoIGhhc01vcnBoUG9zaXRpb24gJiYgaGFzTW9ycGhOb3JtYWwgKSBicmVhaztcblxuXHRcdH1cblxuXHRcdGlmICggISBoYXNNb3JwaFBvc2l0aW9uICYmICEgaGFzTW9ycGhOb3JtYWwgKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCBnZW9tZXRyeSApO1xuXG5cdFx0dmFyIHBlbmRpbmdQb3NpdGlvbkFjY2Vzc29ycyA9IFtdO1xuXHRcdHZhciBwZW5kaW5nTm9ybWFsQWNjZXNzb3JzID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHRhcmdldCA9IHRhcmdldHNbIGkgXTtcblxuXHRcdFx0aWYgKCBoYXNNb3JwaFBvc2l0aW9uICkge1xuXG5cdFx0XHRcdHZhciBwZW5kaW5nQWNjZXNzb3IgPSB0YXJnZXQuUE9TSVRJT04gIT09IHVuZGVmaW5lZFxuXHRcdFx0XHRcdD8gcGFyc2VyLmdldERlcGVuZGVuY3koICdhY2Nlc3NvcicsIHRhcmdldC5QT1NJVElPTiApXG5cdFx0XHRcdFx0OiBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHRcdHBlbmRpbmdQb3NpdGlvbkFjY2Vzc29ycy5wdXNoKCBwZW5kaW5nQWNjZXNzb3IgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc01vcnBoTm9ybWFsICkge1xuXG5cdFx0XHRcdHZhciBwZW5kaW5nQWNjZXNzb3IgPSB0YXJnZXQuTk9STUFMICE9PSB1bmRlZmluZWRcblx0XHRcdFx0XHQ/IHBhcnNlci5nZXREZXBlbmRlbmN5KCAnYWNjZXNzb3InLCB0YXJnZXQuTk9STUFMIClcblx0XHRcdFx0XHQ6IGdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsO1xuXG5cdFx0XHRcdHBlbmRpbmdOb3JtYWxBY2Nlc3NvcnMucHVzaCggcGVuZGluZ0FjY2Vzc29yICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggW1xuXHRcdFx0UHJvbWlzZS5hbGwoIHBlbmRpbmdQb3NpdGlvbkFjY2Vzc29ycyApLFxuXHRcdFx0UHJvbWlzZS5hbGwoIHBlbmRpbmdOb3JtYWxBY2Nlc3NvcnMgKVxuXHRcdF0gKS50aGVuKCBmdW5jdGlvbiAoIGFjY2Vzc29ycyApIHtcblxuXHRcdFx0dmFyIG1vcnBoUG9zaXRpb25zID0gYWNjZXNzb3JzWyAwIF07XG5cdFx0XHR2YXIgbW9ycGhOb3JtYWxzID0gYWNjZXNzb3JzWyAxIF07XG5cblx0XHRcdGlmICggaGFzTW9ycGhQb3NpdGlvbiApIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiA9IG1vcnBoUG9zaXRpb25zO1xuXHRcdFx0aWYgKCBoYXNNb3JwaE5vcm1hbCApIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgPSBtb3JwaE5vcm1hbHM7XG5cdFx0XHRnZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHRydWU7XG5cblx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHRcdH0gKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7TWVzaH0gbWVzaFxuXHQgKiBAcGFyYW0ge0dMVEYuTWVzaH0gbWVzaERlZlxuXHQgKi9cblx0ZnVuY3Rpb24gdXBkYXRlTW9ycGhUYXJnZXRzKCBtZXNoLCBtZXNoRGVmICkge1xuXG5cdFx0bWVzaC51cGRhdGVNb3JwaFRhcmdldHMoKTtcblxuXHRcdGlmICggbWVzaERlZi53ZWlnaHRzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBtZXNoRGVmLndlaWdodHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0bWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXSA9IG1lc2hEZWYud2VpZ2h0c1sgaSBdO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyAuZXh0cmFzIGhhcyB1c2VyLWRlZmluZWQgZGF0YSwgc28gY2hlY2sgdGhhdCAuZXh0cmFzLnRhcmdldE5hbWVzIGlzIGFuIGFycmF5LlxuXHRcdGlmICggbWVzaERlZi5leHRyYXMgJiYgQXJyYXkuaXNBcnJheSggbWVzaERlZi5leHRyYXMudGFyZ2V0TmFtZXMgKSApIHtcblxuXHRcdFx0dmFyIHRhcmdldE5hbWVzID0gbWVzaERlZi5leHRyYXMudGFyZ2V0TmFtZXM7XG5cblx0XHRcdGlmICggbWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXMubGVuZ3RoID09PSB0YXJnZXROYW1lcy5sZW5ndGggKSB7XG5cblx0XHRcdFx0bWVzaC5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSB7fTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGFyZ2V0TmFtZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRtZXNoLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgdGFyZ2V0TmFtZXNbIGkgXSBdID0gaTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkxvYWRlcjogSW52YWxpZCBleHRyYXMudGFyZ2V0TmFtZXMgbGVuZ3RoLiBJZ25vcmluZyBuYW1lcy4nICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlS2V5KCBwcmltaXRpdmVEZWYgKSB7XG5cblx0XHR2YXIgZHJhY29FeHRlbnNpb24gPSBwcmltaXRpdmVEZWYuZXh0ZW5zaW9ucyAmJiBwcmltaXRpdmVEZWYuZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTiBdO1xuXHRcdHZhciBnZW9tZXRyeUtleTtcblxuXHRcdGlmICggZHJhY29FeHRlbnNpb24gKSB7XG5cblx0XHRcdGdlb21ldHJ5S2V5ID0gJ2RyYWNvOicgKyBkcmFjb0V4dGVuc2lvbi5idWZmZXJWaWV3XG5cdFx0XHRcdCsgJzonICsgZHJhY29FeHRlbnNpb24uaW5kaWNlc1xuXHRcdFx0XHQrICc6JyArIGNyZWF0ZUF0dHJpYnV0ZXNLZXkoIGRyYWNvRXh0ZW5zaW9uLmF0dHJpYnV0ZXMgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGdlb21ldHJ5S2V5ID0gcHJpbWl0aXZlRGVmLmluZGljZXMgKyAnOicgKyBjcmVhdGVBdHRyaWJ1dGVzS2V5KCBwcmltaXRpdmVEZWYuYXR0cmlidXRlcyApICsgJzonICsgcHJpbWl0aXZlRGVmLm1vZGU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZ2VvbWV0cnlLZXk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUF0dHJpYnV0ZXNLZXkoIGF0dHJpYnV0ZXMgKSB7XG5cblx0XHR2YXIgYXR0cmlidXRlc0tleSA9ICcnO1xuXG5cdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyggYXR0cmlidXRlcyApLnNvcnQoKTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBrZXlzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRhdHRyaWJ1dGVzS2V5ICs9IGtleXNbIGkgXSArICc6JyArIGF0dHJpYnV0ZXNbIGtleXNbIGkgXSBdICsgJzsnO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGF0dHJpYnV0ZXNLZXk7XG5cblx0fVxuXG5cdC8qIEdMVEYgUEFSU0VSICovXG5cblx0ZnVuY3Rpb24gR0xURlBhcnNlcigganNvbiwgb3B0aW9ucyApIHtcblxuXHRcdHRoaXMuanNvbiA9IGpzb24gfHwge307XG5cdFx0dGhpcy5leHRlbnNpb25zID0ge307XG5cdFx0dGhpcy5wbHVnaW5zID0ge307XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdC8vIGxvYWRlciBvYmplY3QgY2FjaGVcblx0XHR0aGlzLmNhY2hlID0gbmV3IEdMVEZSZWdpc3RyeSgpO1xuXG5cdFx0Ly8gYXNzb2NpYXRpb25zIGJldHdlZW4gVGhyZWUuanMgb2JqZWN0cyBhbmQgZ2xURiBlbGVtZW50c1xuXHRcdHRoaXMuYXNzb2NpYXRpb25zID0gbmV3IE1hcCgpO1xuXG5cdFx0Ly8gQnVmZmVyR2VvbWV0cnkgY2FjaGluZ1xuXHRcdHRoaXMucHJpbWl0aXZlQ2FjaGUgPSB7fTtcblxuXHRcdC8vIE9iamVjdDNEIGluc3RhbmNlIGNhY2hlc1xuXHRcdHRoaXMubWVzaENhY2hlID0geyByZWZzOiB7fSwgdXNlczoge30gfTtcblx0XHR0aGlzLmNhbWVyYUNhY2hlID0geyByZWZzOiB7fSwgdXNlczoge30gfTtcblx0XHR0aGlzLmxpZ2h0Q2FjaGUgPSB7IHJlZnM6IHt9LCB1c2VzOiB7fSB9O1xuXG5cdFx0Ly8gVHJhY2sgbm9kZSBuYW1lcywgdG8gZW5zdXJlIG5vIGR1cGxpY2F0ZXNcblx0XHR0aGlzLm5vZGVOYW1lc1VzZWQgPSB7fTtcblxuXHRcdC8vIFVzZSBhbiBJbWFnZUJpdG1hcExvYWRlciBpZiBpbWFnZUJpdG1hcHMgYXJlIHN1cHBvcnRlZC4gTW92ZXMgbXVjaCBvZiB0aGVcblx0XHQvLyBleHBlbnNpdmUgd29yayBvZiB1cGxvYWRpbmcgYSB0ZXh0dXJlIHRvIHRoZSBHUFUgb2ZmIHRoZSBtYWluIHRocmVhZC5cblx0XHRpZiAoIHR5cGVvZiBjcmVhdGVJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgL0ZpcmVmb3gvLnRlc3QoIG5hdmlnYXRvci51c2VyQWdlbnQgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdHRoaXMudGV4dHVyZUxvYWRlciA9IG5ldyBJbWFnZUJpdG1hcExvYWRlciggdGhpcy5vcHRpb25zLm1hbmFnZXIgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMudGV4dHVyZUxvYWRlciA9IG5ldyBUZXh0dXJlTG9hZGVyKCB0aGlzLm9wdGlvbnMubWFuYWdlciApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy50ZXh0dXJlTG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gKTtcblx0XHR0aGlzLnRleHR1cmVMb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggdGhpcy5vcHRpb25zLnJlcXVlc3RIZWFkZXIgKTtcblxuXHRcdHRoaXMuZmlsZUxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm9wdGlvbnMubWFuYWdlciApO1xuXHRcdHRoaXMuZmlsZUxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSAndXNlLWNyZWRlbnRpYWxzJyApIHtcblxuXHRcdFx0dGhpcy5maWxlTG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdHJ1ZSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5zZXRFeHRlbnNpb25zID0gZnVuY3Rpb24gKCBleHRlbnNpb25zICkge1xuXG5cdFx0dGhpcy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcblxuXHR9O1xuXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLnNldFBsdWdpbnMgPSBmdW5jdGlvbiAoIHBsdWdpbnMgKSB7XG5cblx0XHR0aGlzLnBsdWdpbnMgPSBwbHVnaW5zO1xuXG5cdH07XG5cblx0R0xURlBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIG9uTG9hZCwgb25FcnJvciApIHtcblxuXHRcdHZhciBwYXJzZXIgPSB0aGlzO1xuXHRcdHZhciBqc29uID0gdGhpcy5qc29uO1xuXHRcdHZhciBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuXG5cdFx0Ly8gQ2xlYXIgdGhlIGxvYWRlciBjYWNoZVxuXHRcdHRoaXMuY2FjaGUucmVtb3ZlQWxsKCk7XG5cblx0XHQvLyBNYXJrIHRoZSBzcGVjaWFsIG5vZGVzL21lc2hlcyBpbiBqc29uIGZvciBlZmZpY2llbnQgcGFyc2Vcblx0XHR0aGlzLl9pbnZva2VBbGwoIGZ1bmN0aW9uICggZXh0ICkge1xuXG5cdFx0XHRyZXR1cm4gZXh0Ll9tYXJrRGVmcyAmJiBleHQuX21hcmtEZWZzKCk7XG5cblx0XHR9ICk7XG5cblx0XHRQcm9taXNlLmFsbCggdGhpcy5faW52b2tlQWxsKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0cmV0dXJuIGV4dC5iZWZvcmVSb290ICYmIGV4dC5iZWZvcmVSb290KCk7XG5cblx0XHR9ICkgKS50aGVuKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLmFsbCggW1xuXG5cdFx0XHRcdHBhcnNlci5nZXREZXBlbmRlbmNpZXMoICdzY2VuZScgKSxcblx0XHRcdFx0cGFyc2VyLmdldERlcGVuZGVuY2llcyggJ2FuaW1hdGlvbicgKSxcblx0XHRcdFx0cGFyc2VyLmdldERlcGVuZGVuY2llcyggJ2NhbWVyYScgKSxcblxuXHRcdFx0XSApO1xuXG5cdFx0fSApLnRoZW4oIGZ1bmN0aW9uICggZGVwZW5kZW5jaWVzICkge1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0ge1xuXHRcdFx0XHRzY2VuZTogZGVwZW5kZW5jaWVzWyAwIF1bIGpzb24uc2NlbmUgfHwgMCBdLFxuXHRcdFx0XHRzY2VuZXM6IGRlcGVuZGVuY2llc1sgMCBdLFxuXHRcdFx0XHRhbmltYXRpb25zOiBkZXBlbmRlbmNpZXNbIDEgXSxcblx0XHRcdFx0Y2FtZXJhczogZGVwZW5kZW5jaWVzWyAyIF0sXG5cdFx0XHRcdGFzc2V0OiBqc29uLmFzc2V0LFxuXHRcdFx0XHRwYXJzZXI6IHBhcnNlcixcblx0XHRcdFx0dXNlckRhdGE6IHt9XG5cdFx0XHR9O1xuXG5cdFx0XHRhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoIGV4dGVuc2lvbnMsIHJlc3VsdCwganNvbiApO1xuXG5cdFx0XHRhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKCByZXN1bHQsIGpzb24gKTtcblxuXHRcdFx0UHJvbWlzZS5hbGwoIHBhcnNlci5faW52b2tlQWxsKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0XHRyZXR1cm4gZXh0LmFmdGVyUm9vdCAmJiBleHQuYWZ0ZXJSb290KCByZXN1bHQgKTtcblxuXHRcdFx0fSApICkudGhlbiggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdG9uTG9hZCggcmVzdWx0ICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH0gKS5jYXRjaCggb25FcnJvciApO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIE1hcmtzIHRoZSBzcGVjaWFsIG5vZGVzL21lc2hlcyBpbiBqc29uIGZvciBlZmZpY2llbnQgcGFyc2UuXG5cdCAqL1xuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5fbWFya0RlZnMgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbm9kZURlZnMgPSB0aGlzLmpzb24ubm9kZXMgfHwgW107XG5cdFx0dmFyIHNraW5EZWZzID0gdGhpcy5qc29uLnNraW5zIHx8IFtdO1xuXHRcdHZhciBtZXNoRGVmcyA9IHRoaXMuanNvbi5tZXNoZXMgfHwgW107XG5cblx0XHQvLyBOb3RoaW5nIGluIHRoZSBub2RlIGRlZmluaXRpb24gaW5kaWNhdGVzIHdoZXRoZXIgaXQgaXMgYSBCb25lIG9yIGFuXG5cdFx0Ly8gT2JqZWN0M0QuIFVzZSB0aGUgc2tpbnMnIGpvaW50IHJlZmVyZW5jZXMgdG8gbWFyayBib25lcy5cblx0XHRmb3IgKCB2YXIgc2tpbkluZGV4ID0gMCwgc2tpbkxlbmd0aCA9IHNraW5EZWZzLmxlbmd0aDsgc2tpbkluZGV4IDwgc2tpbkxlbmd0aDsgc2tpbkluZGV4ICsrICkge1xuXG5cdFx0XHR2YXIgam9pbnRzID0gc2tpbkRlZnNbIHNraW5JbmRleCBdLmpvaW50cztcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGpvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRub2RlRGVmc1sgam9pbnRzWyBpIF0gXS5pc0JvbmUgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBJdGVyYXRlIG92ZXIgYWxsIG5vZGVzLCBtYXJraW5nIHJlZmVyZW5jZXMgdG8gc2hhcmVkIHJlc291cmNlcyxcblx0XHQvLyBhcyB3ZWxsIGFzIHNrZWxldG9uIGpvaW50cy5cblx0XHRmb3IgKCB2YXIgbm9kZUluZGV4ID0gMCwgbm9kZUxlbmd0aCA9IG5vZGVEZWZzLmxlbmd0aDsgbm9kZUluZGV4IDwgbm9kZUxlbmd0aDsgbm9kZUluZGV4ICsrICkge1xuXG5cdFx0XHR2YXIgbm9kZURlZiA9IG5vZGVEZWZzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0aWYgKCBub2RlRGVmLm1lc2ggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0aGlzLl9hZGROb2RlUmVmKCB0aGlzLm1lc2hDYWNoZSwgbm9kZURlZi5tZXNoICk7XG5cblx0XHRcdFx0Ly8gTm90aGluZyBpbiB0aGUgbWVzaCBkZWZpbml0aW9uIGluZGljYXRlcyB3aGV0aGVyIGl0IGlzXG5cdFx0XHRcdC8vIGEgU2tpbm5lZE1lc2ggb3IgTWVzaC4gVXNlIHRoZSBub2RlJ3MgbWVzaCByZWZlcmVuY2Vcblx0XHRcdFx0Ly8gdG8gbWFyayBTa2lubmVkTWVzaCBpZiBub2RlIGhhcyBza2luLlxuXHRcdFx0XHRpZiAoIG5vZGVEZWYuc2tpbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0bWVzaERlZnNbIG5vZGVEZWYubWVzaCBdLmlzU2tpbm5lZE1lc2ggPSB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG5vZGVEZWYuY2FtZXJhICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGhpcy5fYWRkTm9kZVJlZiggdGhpcy5jYW1lcmFDYWNoZSwgbm9kZURlZi5jYW1lcmEgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0LyoqXG5cdCAqIENvdW50cyByZWZlcmVuY2VzIHRvIHNoYXJlZCBub2RlIC8gT2JqZWN0M0QgcmVzb3VyY2VzLiBUaGVzZSByZXNvdXJjZXNcblx0ICogY2FuIGJlIHJldXNlZCwgb3IgXCJpbnN0YW50aWF0ZWRcIiwgYXQgbXVsdGlwbGUgbm9kZXMgaW4gdGhlIHNjZW5lXG5cdCAqIGhpZXJhcmNoeS4gTWVzaCwgQ2FtZXJhLCBhbmQgTGlnaHQgaW5zdGFuY2VzIGFyZSBpbnN0YW50aWF0ZWQgYW5kIG11c3Rcblx0ICogYmUgbWFya2VkLiBOb24tc2NlbmVncmFwaCByZXNvdXJjZXMgKGxpa2UgTWF0ZXJpYWxzLCBHZW9tZXRyaWVzLCBhbmRcblx0ICogVGV4dHVyZXMpIGNhbiBiZSByZXVzZWQgZGlyZWN0bHkgYW5kIGFyZSBub3QgbWFya2VkIGhlcmUuXG5cdCAqXG5cdCAqIEV4YW1wbGU6IENlc2l1bU1pbGtUcnVjayBzYW1wbGUgbW9kZWwgcmV1c2VzIFwiV2hlZWxcIiBtZXNoZXMuXG5cdCAqL1xuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5fYWRkTm9kZVJlZiA9IGZ1bmN0aW9uICggY2FjaGUsIGluZGV4ICkge1xuXG5cdFx0aWYgKCBpbmRleCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0aWYgKCBjYWNoZS5yZWZzWyBpbmRleCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNhY2hlLnJlZnNbIGluZGV4IF0gPSBjYWNoZS51c2VzWyBpbmRleCBdID0gMDtcblxuXHRcdH1cblxuXHRcdGNhY2hlLnJlZnNbIGluZGV4IF0gKys7XG5cblx0fTtcblxuXHQvKiogUmV0dXJucyBhIHJlZmVyZW5jZSB0byBhIHNoYXJlZCByZXNvdXJjZSwgY2xvbmluZyBpdCBpZiBuZWNlc3NhcnkuICovXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLl9nZXROb2RlUmVmID0gZnVuY3Rpb24gKCBjYWNoZSwgaW5kZXgsIG9iamVjdCApIHtcblxuXHRcdGlmICggY2FjaGUucmVmc1sgaW5kZXggXSA8PSAxICkgcmV0dXJuIG9iamVjdDtcblxuXHRcdHZhciByZWYgPSBvYmplY3QuY2xvbmUoKTtcblxuXHRcdHJlZi5uYW1lICs9ICdfaW5zdGFuY2VfJyArICggY2FjaGUudXNlc1sgaW5kZXggXSArKyApO1xuXG5cdFx0cmV0dXJuIHJlZjtcblxuXHR9O1xuXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLl9pbnZva2VPbmUgPSBmdW5jdGlvbiAoIGZ1bmMgKSB7XG5cblx0XHR2YXIgZXh0ZW5zaW9ucyA9IE9iamVjdC52YWx1ZXMoIHRoaXMucGx1Z2lucyApO1xuXHRcdGV4dGVuc2lvbnMucHVzaCggdGhpcyApO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZXh0ZW5zaW9ucy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciByZXN1bHQgPSBmdW5jKCBleHRlbnNpb25zWyBpIF0gKTtcblxuXHRcdFx0aWYgKCByZXN1bHQgKSByZXR1cm4gcmVzdWx0O1xuXG5cdFx0fVxuXG5cdH07XG5cblx0R0xURlBhcnNlci5wcm90b3R5cGUuX2ludm9rZUFsbCA9IGZ1bmN0aW9uICggZnVuYyApIHtcblxuXHRcdHZhciBleHRlbnNpb25zID0gT2JqZWN0LnZhbHVlcyggdGhpcy5wbHVnaW5zICk7XG5cdFx0ZXh0ZW5zaW9ucy51bnNoaWZ0KCB0aGlzICk7XG5cblx0XHR2YXIgcGVuZGluZyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZXh0ZW5zaW9ucy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciByZXN1bHQgPSBmdW5jKCBleHRlbnNpb25zWyBpIF0gKTtcblxuXHRcdFx0aWYgKCByZXN1bHQgKSBwZW5kaW5nLnB1c2goIHJlc3VsdCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBlbmRpbmc7XG5cblx0fTtcblxuXHQvKipcblx0ICogUmVxdWVzdHMgdGhlIHNwZWNpZmllZCBkZXBlbmRlbmN5IGFzeW5jaHJvbm91c2x5LCB3aXRoIGNhY2hpbmcuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdDNEfE1hdGVyaWFsfFRIUkVFLlRleHR1cmV8QW5pbWF0aW9uQ2xpcHxBcnJheUJ1ZmZlcnxPYmplY3Q+fVxuXHQgKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUuZ2V0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uICggdHlwZSwgaW5kZXggKSB7XG5cblx0XHR2YXIgY2FjaGVLZXkgPSB0eXBlICsgJzonICsgaW5kZXg7XG5cdFx0dmFyIGRlcGVuZGVuY3kgPSB0aGlzLmNhY2hlLmdldCggY2FjaGVLZXkgKTtcblxuXHRcdGlmICggISBkZXBlbmRlbmN5ICkge1xuXG5cdFx0XHRzd2l0Y2ggKCB0eXBlICkge1xuXG5cdFx0XHRcdGNhc2UgJ3NjZW5lJzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5sb2FkU2NlbmUoIGluZGV4ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbm9kZSc6XG5cdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IHRoaXMubG9hZE5vZGUoIGluZGV4ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbWVzaCc6XG5cdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZSggZnVuY3Rpb24gKCBleHQgKSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiBleHQubG9hZE1lc2ggJiYgZXh0LmxvYWRNZXNoKCBpbmRleCApO1xuXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2FjY2Vzc29yJzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5sb2FkQWNjZXNzb3IoIGluZGV4ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnYnVmZmVyVmlldyc6XG5cdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZSggZnVuY3Rpb24gKCBleHQgKSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiBleHQubG9hZEJ1ZmZlclZpZXcgJiYgZXh0LmxvYWRCdWZmZXJWaWV3KCBpbmRleCApO1xuXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2J1ZmZlcic6XG5cdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IHRoaXMubG9hZEJ1ZmZlciggaW5kZXggKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdtYXRlcmlhbCc6XG5cdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZSggZnVuY3Rpb24gKCBleHQgKSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiBleHQubG9hZE1hdGVyaWFsICYmIGV4dC5sb2FkTWF0ZXJpYWwoIGluZGV4ICk7XG5cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAndGV4dHVyZSc6XG5cdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZSggZnVuY3Rpb24gKCBleHQgKSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiBleHQubG9hZFRleHR1cmUgJiYgZXh0LmxvYWRUZXh0dXJlKCBpbmRleCApO1xuXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3NraW4nOlxuXHRcdFx0XHRcdGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRTa2luKCBpbmRleCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2FuaW1hdGlvbic6XG5cdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IHRoaXMubG9hZEFuaW1hdGlvbiggaW5kZXggKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdjYW1lcmEnOlxuXHRcdFx0XHRcdGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRDYW1lcmEoIGluZGV4ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdVbmtub3duIHR5cGU6ICcgKyB0eXBlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5jYWNoZS5hZGQoIGNhY2hlS2V5LCBkZXBlbmRlbmN5ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGVwZW5kZW5jeTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXF1ZXN0cyBhbGwgZGVwZW5kZW5jaWVzIG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBhc3luY2hyb25vdXNseSwgd2l0aCBjYWNoaW5nLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PE9iamVjdD4+fVxuXHQgKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUuZ2V0RGVwZW5kZW5jaWVzID0gZnVuY3Rpb24gKCB0eXBlICkge1xuXG5cdFx0dmFyIGRlcGVuZGVuY2llcyA9IHRoaXMuY2FjaGUuZ2V0KCB0eXBlICk7XG5cblx0XHRpZiAoICEgZGVwZW5kZW5jaWVzICkge1xuXG5cdFx0XHR2YXIgcGFyc2VyID0gdGhpcztcblx0XHRcdHZhciBkZWZzID0gdGhpcy5qc29uWyB0eXBlICsgKCB0eXBlID09PSAnbWVzaCcgPyAnZXMnIDogJ3MnICkgXSB8fCBbXTtcblxuXHRcdFx0ZGVwZW5kZW5jaWVzID0gUHJvbWlzZS5hbGwoIGRlZnMubWFwKCBmdW5jdGlvbiAoIGRlZiwgaW5kZXggKSB7XG5cblx0XHRcdFx0cmV0dXJuIHBhcnNlci5nZXREZXBlbmRlbmN5KCB0eXBlLCBpbmRleCApO1xuXG5cdFx0XHR9ICkgKTtcblxuXHRcdFx0dGhpcy5jYWNoZS5hZGQoIHR5cGUsIGRlcGVuZGVuY2llcyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlcGVuZGVuY2llcztcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2J1ZmZlcnMtYW5kLWJ1ZmZlci12aWV3c1xuXHQgKiBAcGFyYW0ge251bWJlcn0gYnVmZmVySW5kZXhcblx0ICogQHJldHVybiB7UHJvbWlzZTxBcnJheUJ1ZmZlcj59XG5cdCAqL1xuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5sb2FkQnVmZmVyID0gZnVuY3Rpb24gKCBidWZmZXJJbmRleCApIHtcblxuXHRcdHZhciBidWZmZXJEZWYgPSB0aGlzLmpzb24uYnVmZmVyc1sgYnVmZmVySW5kZXggXTtcblx0XHR2YXIgbG9hZGVyID0gdGhpcy5maWxlTG9hZGVyO1xuXG5cdFx0aWYgKCBidWZmZXJEZWYudHlwZSAmJiBidWZmZXJEZWYudHlwZSAhPT0gJ2FycmF5YnVmZmVyJyApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogJyArIGJ1ZmZlckRlZi50eXBlICsgJyBidWZmZXIgdHlwZSBpcyBub3Qgc3VwcG9ydGVkLicgKTtcblxuXHRcdH1cblxuXHRcdC8vIElmIHByZXNlbnQsIEdMQiBjb250YWluZXIgaXMgcmVxdWlyZWQgdG8gYmUgdGhlIGZpcnN0IGJ1ZmZlci5cblx0XHRpZiAoIGJ1ZmZlckRlZi51cmkgPT09IHVuZGVmaW5lZCAmJiBidWZmZXJJbmRleCA9PT0gMCApIHtcblxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSggdGhpcy5leHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9CSU5BUllfR0xURiBdLmJvZHkgKTtcblxuXHRcdH1cblxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKCBmdW5jdGlvbiAoIHJlc29sdmUsIHJlamVjdCApIHtcblxuXHRcdFx0bG9hZGVyLmxvYWQoIHJlc29sdmVVUkwoIGJ1ZmZlckRlZi51cmksIG9wdGlvbnMucGF0aCApLCByZXNvbHZlLCB1bmRlZmluZWQsIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRyZWplY3QoIG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IEZhaWxlZCB0byBsb2FkIGJ1ZmZlciBcIicgKyBidWZmZXJEZWYudXJpICsgJ1wiLicgKSApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHR9ICk7XG5cblx0fTtcblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNidWZmZXJzLWFuZC1idWZmZXItdmlld3Ncblx0ICogQHBhcmFtIHtudW1iZXJ9IGJ1ZmZlclZpZXdJbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5QnVmZmVyPn1cblx0ICovXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLmxvYWRCdWZmZXJWaWV3ID0gZnVuY3Rpb24gKCBidWZmZXJWaWV3SW5kZXggKSB7XG5cblx0XHR2YXIgYnVmZmVyVmlld0RlZiA9IHRoaXMuanNvbi5idWZmZXJWaWV3c1sgYnVmZmVyVmlld0luZGV4IF07XG5cblx0XHRyZXR1cm4gdGhpcy5nZXREZXBlbmRlbmN5KCAnYnVmZmVyJywgYnVmZmVyVmlld0RlZi5idWZmZXIgKS50aGVuKCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcblxuXHRcdFx0dmFyIGJ5dGVMZW5ndGggPSBidWZmZXJWaWV3RGVmLmJ5dGVMZW5ndGggfHwgMDtcblx0XHRcdHZhciBieXRlT2Zmc2V0ID0gYnVmZmVyVmlld0RlZi5ieXRlT2Zmc2V0IHx8IDA7XG5cdFx0XHRyZXR1cm4gYnVmZmVyLnNsaWNlKCBieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCApO1xuXG5cdFx0fSApO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjYWNjZXNzb3JzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhY2Nlc3NvckluZGV4XG5cdCAqIEByZXR1cm4ge1Byb21pc2U8QnVmZmVyQXR0cmlidXRlfEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlPn1cblx0ICovXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLmxvYWRBY2Nlc3NvciA9IGZ1bmN0aW9uICggYWNjZXNzb3JJbmRleCApIHtcblxuXHRcdHZhciBwYXJzZXIgPSB0aGlzO1xuXHRcdHZhciBqc29uID0gdGhpcy5qc29uO1xuXG5cdFx0dmFyIGFjY2Vzc29yRGVmID0gdGhpcy5qc29uLmFjY2Vzc29yc1sgYWNjZXNzb3JJbmRleCBdO1xuXG5cdFx0aWYgKCBhY2Nlc3NvckRlZi5idWZmZXJWaWV3ID09PSB1bmRlZmluZWQgJiYgYWNjZXNzb3JEZWYuc3BhcnNlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIElnbm9yZSBlbXB0eSBhY2Nlc3NvcnMsIHdoaWNoIG1heSBiZSB1c2VkIHRvIGRlY2xhcmUgcnVudGltZVxuXHRcdFx0Ly8gaW5mb3JtYXRpb24gYWJvdXQgYXR0cmlidXRlcyBjb21pbmcgZnJvbSBhbm90aGVyIHNvdXJjZSAoZS5nLiBEcmFjb1xuXHRcdFx0Ly8gY29tcHJlc3Npb24gZXh0ZW5zaW9uKS5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoIG51bGwgKTtcblxuXHRcdH1cblxuXHRcdHZhciBwZW5kaW5nQnVmZmVyVmlld3MgPSBbXTtcblxuXHRcdGlmICggYWNjZXNzb3JEZWYuYnVmZmVyVmlldyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwZW5kaW5nQnVmZmVyVmlld3MucHVzaCggdGhpcy5nZXREZXBlbmRlbmN5KCAnYnVmZmVyVmlldycsIGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgKSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cGVuZGluZ0J1ZmZlclZpZXdzLnB1c2goIG51bGwgKTtcblxuXHRcdH1cblxuXHRcdGlmICggYWNjZXNzb3JEZWYuc3BhcnNlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKCB0aGlzLmdldERlcGVuZGVuY3koICdidWZmZXJWaWV3JywgYWNjZXNzb3JEZWYuc3BhcnNlLmluZGljZXMuYnVmZmVyVmlldyApICk7XG5cdFx0XHRwZW5kaW5nQnVmZmVyVmlld3MucHVzaCggdGhpcy5nZXREZXBlbmRlbmN5KCAnYnVmZmVyVmlldycsIGFjY2Vzc29yRGVmLnNwYXJzZS52YWx1ZXMuYnVmZmVyVmlldyApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmdCdWZmZXJWaWV3cyApLnRoZW4oIGZ1bmN0aW9uICggYnVmZmVyVmlld3MgKSB7XG5cblx0XHRcdHZhciBidWZmZXJWaWV3ID0gYnVmZmVyVmlld3NbIDAgXTtcblxuXHRcdFx0dmFyIGl0ZW1TaXplID0gV0VCR0xfVFlQRV9TSVpFU1sgYWNjZXNzb3JEZWYudHlwZSBdO1xuXHRcdFx0dmFyIFR5cGVkQXJyYXkgPSBXRUJHTF9DT01QT05FTlRfVFlQRVNbIGFjY2Vzc29yRGVmLmNvbXBvbmVudFR5cGUgXTtcblxuXHRcdFx0Ly8gRm9yIFZFQzM6IGl0ZW1TaXplIGlzIDMsIGVsZW1lbnRCeXRlcyBpcyA0LCBpdGVtQnl0ZXMgaXMgMTIuXG5cdFx0XHR2YXIgZWxlbWVudEJ5dGVzID0gVHlwZWRBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcblx0XHRcdHZhciBpdGVtQnl0ZXMgPSBlbGVtZW50Qnl0ZXMgKiBpdGVtU2l6ZTtcblx0XHRcdHZhciBieXRlT2Zmc2V0ID0gYWNjZXNzb3JEZWYuYnl0ZU9mZnNldCB8fCAwO1xuXHRcdFx0dmFyIGJ5dGVTdHJpZGUgPSBhY2Nlc3NvckRlZi5idWZmZXJWaWV3ICE9PSB1bmRlZmluZWQgPyBqc29uLmJ1ZmZlclZpZXdzWyBhY2Nlc3NvckRlZi5idWZmZXJWaWV3IF0uYnl0ZVN0cmlkZSA6IHVuZGVmaW5lZDtcblx0XHRcdHZhciBub3JtYWxpemVkID0gYWNjZXNzb3JEZWYubm9ybWFsaXplZCA9PT0gdHJ1ZTtcblx0XHRcdHZhciBhcnJheSwgYnVmZmVyQXR0cmlidXRlO1xuXG5cdFx0XHQvLyBUaGUgYnVmZmVyIGlzIG5vdCBpbnRlcmxlYXZlZCBpZiB0aGUgc3RyaWRlIGlzIHRoZSBpdGVtIHNpemUgaW4gYnl0ZXMuXG5cdFx0XHRpZiAoIGJ5dGVTdHJpZGUgJiYgYnl0ZVN0cmlkZSAhPT0gaXRlbUJ5dGVzICkge1xuXG5cdFx0XHRcdC8vIEVhY2ggXCJzbGljZVwiIG9mIHRoZSBidWZmZXIsIGFzIGRlZmluZWQgYnkgJ2NvdW50JyBlbGVtZW50cyBvZiAnYnl0ZVN0cmlkZScgYnl0ZXMsIGdldHMgaXRzIG93biBJbnRlcmxlYXZlZEJ1ZmZlclxuXHRcdFx0XHQvLyBUaGlzIG1ha2VzIHN1cmUgdGhhdCBJQkEuY291bnQgcmVmbGVjdHMgYWNjZXNzb3IuY291bnQgcHJvcGVybHlcblx0XHRcdFx0dmFyIGliU2xpY2UgPSBNYXRoLmZsb29yKCBieXRlT2Zmc2V0IC8gYnl0ZVN0cmlkZSApO1xuXHRcdFx0XHR2YXIgaWJDYWNoZUtleSA9ICdJbnRlcmxlYXZlZEJ1ZmZlcjonICsgYWNjZXNzb3JEZWYuYnVmZmVyVmlldyArICc6JyArIGFjY2Vzc29yRGVmLmNvbXBvbmVudFR5cGUgKyAnOicgKyBpYlNsaWNlICsgJzonICsgYWNjZXNzb3JEZWYuY291bnQ7XG5cdFx0XHRcdHZhciBpYiA9IHBhcnNlci5jYWNoZS5nZXQoIGliQ2FjaGVLZXkgKTtcblxuXHRcdFx0XHRpZiAoICEgaWIgKSB7XG5cblx0XHRcdFx0XHRhcnJheSA9IG5ldyBUeXBlZEFycmF5KCBidWZmZXJWaWV3LCBpYlNsaWNlICogYnl0ZVN0cmlkZSwgYWNjZXNzb3JEZWYuY291bnQgKiBieXRlU3RyaWRlIC8gZWxlbWVudEJ5dGVzICk7XG5cblx0XHRcdFx0XHQvLyBJbnRlZ2VyIHBhcmFtZXRlcnMgdG8gSUIvSUJBIGFyZSBpbiBhcnJheSBlbGVtZW50cywgbm90IGJ5dGVzLlxuXHRcdFx0XHRcdGliID0gbmV3IEludGVybGVhdmVkQnVmZmVyKCBhcnJheSwgYnl0ZVN0cmlkZSAvIGVsZW1lbnRCeXRlcyApO1xuXG5cdFx0XHRcdFx0cGFyc2VyLmNhY2hlLmFkZCggaWJDYWNoZUtleSwgaWIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnVmZmVyQXR0cmlidXRlID0gbmV3IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKCBpYiwgaXRlbVNpemUsICggYnl0ZU9mZnNldCAlIGJ5dGVTdHJpZGUgKSAvIGVsZW1lbnRCeXRlcywgbm9ybWFsaXplZCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggYnVmZmVyVmlldyA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoIGFjY2Vzc29yRGVmLmNvdW50ICogaXRlbVNpemUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0YXJyYXkgPSBuZXcgVHlwZWRBcnJheSggYnVmZmVyVmlldywgYnl0ZU9mZnNldCwgYWNjZXNzb3JEZWYuY291bnQgKiBpdGVtU2l6ZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRidWZmZXJBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI3NwYXJzZS1hY2Nlc3NvcnNcblx0XHRcdGlmICggYWNjZXNzb3JEZWYuc3BhcnNlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dmFyIGl0ZW1TaXplSW5kaWNlcyA9IFdFQkdMX1RZUEVfU0laRVMuU0NBTEFSO1xuXHRcdFx0XHR2YXIgVHlwZWRBcnJheUluZGljZXMgPSBXRUJHTF9DT01QT05FTlRfVFlQRVNbIGFjY2Vzc29yRGVmLnNwYXJzZS5pbmRpY2VzLmNvbXBvbmVudFR5cGUgXTtcblxuXHRcdFx0XHR2YXIgYnl0ZU9mZnNldEluZGljZXMgPSBhY2Nlc3NvckRlZi5zcGFyc2UuaW5kaWNlcy5ieXRlT2Zmc2V0IHx8IDA7XG5cdFx0XHRcdHZhciBieXRlT2Zmc2V0VmFsdWVzID0gYWNjZXNzb3JEZWYuc3BhcnNlLnZhbHVlcy5ieXRlT2Zmc2V0IHx8IDA7XG5cblx0XHRcdFx0dmFyIHNwYXJzZUluZGljZXMgPSBuZXcgVHlwZWRBcnJheUluZGljZXMoIGJ1ZmZlclZpZXdzWyAxIF0sIGJ5dGVPZmZzZXRJbmRpY2VzLCBhY2Nlc3NvckRlZi5zcGFyc2UuY291bnQgKiBpdGVtU2l6ZUluZGljZXMgKTtcblx0XHRcdFx0dmFyIHNwYXJzZVZhbHVlcyA9IG5ldyBUeXBlZEFycmF5KCBidWZmZXJWaWV3c1sgMiBdLCBieXRlT2Zmc2V0VmFsdWVzLCBhY2Nlc3NvckRlZi5zcGFyc2UuY291bnQgKiBpdGVtU2l6ZSApO1xuXG5cdFx0XHRcdGlmICggYnVmZmVyVmlldyAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdC8vIEF2b2lkIG1vZGlmeWluZyB0aGUgb3JpZ2luYWwgQXJyYXlCdWZmZXIsIGlmIHRoZSBidWZmZXJWaWV3IHdhc24ndCBpbml0aWFsaXplZCB3aXRoIHplcm9lcy5cblx0XHRcdFx0XHRidWZmZXJBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKCBidWZmZXJBdHRyaWJ1dGUuYXJyYXkuc2xpY2UoKSwgYnVmZmVyQXR0cmlidXRlLml0ZW1TaXplLCBidWZmZXJBdHRyaWJ1dGUubm9ybWFsaXplZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc3BhcnNlSW5kaWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBpbmRleCA9IHNwYXJzZUluZGljZXNbIGkgXTtcblxuXHRcdFx0XHRcdGJ1ZmZlckF0dHJpYnV0ZS5zZXRYKCBpbmRleCwgc3BhcnNlVmFsdWVzWyBpICogaXRlbVNpemUgXSApO1xuXHRcdFx0XHRcdGlmICggaXRlbVNpemUgPj0gMiApIGJ1ZmZlckF0dHJpYnV0ZS5zZXRZKCBpbmRleCwgc3BhcnNlVmFsdWVzWyBpICogaXRlbVNpemUgKyAxIF0gKTtcblx0XHRcdFx0XHRpZiAoIGl0ZW1TaXplID49IDMgKSBidWZmZXJBdHRyaWJ1dGUuc2V0WiggaW5kZXgsIHNwYXJzZVZhbHVlc1sgaSAqIGl0ZW1TaXplICsgMiBdICk7XG5cdFx0XHRcdFx0aWYgKCBpdGVtU2l6ZSA+PSA0ICkgYnVmZmVyQXR0cmlidXRlLnNldFcoIGluZGV4LCBzcGFyc2VWYWx1ZXNbIGkgKiBpdGVtU2l6ZSArIDMgXSApO1xuXHRcdFx0XHRcdGlmICggaXRlbVNpemUgPj0gNSApIHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIGl0ZW1TaXplIGluIHNwYXJzZSBCdWZmZXJBdHRyaWJ1dGUuJyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYnVmZmVyQXR0cmlidXRlO1xuXG5cdFx0fSApO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCN0ZXh0dXJlc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gdGV4dHVyZUluZGV4XG5cdCAqIEByZXR1cm4ge1Byb21pc2U8VEhSRUUuVGV4dHVyZT59XG5cdCAqL1xuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5sb2FkVGV4dHVyZSA9IGZ1bmN0aW9uICggdGV4dHVyZUluZGV4ICkge1xuXG5cdFx0dmFyIGpzb24gPSB0aGlzLmpzb247XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cdFx0dmFyIHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzWyB0ZXh0dXJlSW5kZXggXTtcblx0XHR2YXIgc291cmNlID0ganNvbi5pbWFnZXNbIHRleHR1cmVEZWYuc291cmNlIF07XG5cblx0XHR2YXIgbG9hZGVyID0gdGhpcy50ZXh0dXJlTG9hZGVyO1xuXG5cdFx0aWYgKCBzb3VyY2UudXJpICkge1xuXG5cdFx0XHR2YXIgaGFuZGxlciA9IG9wdGlvbnMubWFuYWdlci5nZXRIYW5kbGVyKCBzb3VyY2UudXJpICk7XG5cdFx0XHRpZiAoIGhhbmRsZXIgIT09IG51bGwgKSBsb2FkZXIgPSBoYW5kbGVyO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMubG9hZFRleHR1cmVJbWFnZSggdGV4dHVyZUluZGV4LCBzb3VyY2UsIGxvYWRlciApO1xuXG5cdH07XG5cblx0R0xURlBhcnNlci5wcm90b3R5cGUubG9hZFRleHR1cmVJbWFnZSA9IGZ1bmN0aW9uICggdGV4dHVyZUluZGV4LCBzb3VyY2UsIGxvYWRlciApIHtcblxuXHRcdHZhciBwYXJzZXIgPSB0aGlzO1xuXHRcdHZhciBqc29uID0gdGhpcy5qc29uO1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0dmFyIHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzWyB0ZXh0dXJlSW5kZXggXTtcblxuXHRcdHZhciBVUkwgPSBzZWxmLlVSTCB8fCBzZWxmLndlYmtpdFVSTDtcblxuXHRcdHZhciBzb3VyY2VVUkkgPSBzb3VyY2UudXJpO1xuXHRcdHZhciBpc09iamVjdFVSTCA9IGZhbHNlO1xuXHRcdHZhciBoYXNBbHBoYSA9IHRydWU7XG5cblx0XHRpZiAoIHNvdXJjZS5taW1lVHlwZSA9PT0gJ2ltYWdlL2pwZWcnICkgaGFzQWxwaGEgPSBmYWxzZTtcblxuXHRcdGlmICggc291cmNlLmJ1ZmZlclZpZXcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gTG9hZCBiaW5hcnkgaW1hZ2UgZGF0YSBmcm9tIGJ1ZmZlclZpZXcsIGlmIHByb3ZpZGVkLlxuXG5cdFx0XHRzb3VyY2VVUkkgPSBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ2J1ZmZlclZpZXcnLCBzb3VyY2UuYnVmZmVyVmlldyApLnRoZW4oIGZ1bmN0aW9uICggYnVmZmVyVmlldyApIHtcblxuXHRcdFx0XHRpZiAoIHNvdXJjZS5taW1lVHlwZSA9PT0gJ2ltYWdlL3BuZycgKSB7XG5cblx0XHRcdFx0XHQvLyBJbnNwZWN0IHRoZSBQTkcgJ0lIRFInIGNodW5rIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBpbWFnZSBjb3VsZCBoYXZlIGFuXG5cdFx0XHRcdFx0Ly8gYWxwaGEgY2hhbm5lbC4gVGhpcyBjaGVjayBpcyBjb25zZXJ2YXRpdmUg4oCUIHRoZSBpbWFnZSBjb3VsZCBoYXZlIGFuIGFscGhhXG5cdFx0XHRcdFx0Ly8gY2hhbm5lbCB3aXRoIGFsbCB2YWx1ZXMgPT0gMSwgYW5kIHRoZSBpbmRleGVkIHR5cGUgKGNvbG9yVHlwZSA9PSAzKSBvbmx5XG5cdFx0XHRcdFx0Ly8gc29tZXRpbWVzIGNvbnRhaW5zIGFscGhhLlxuXHRcdFx0XHRcdC8vXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUG9ydGFibGVfTmV0d29ya19HcmFwaGljcyNGaWxlX2hlYWRlclxuXHRcdFx0XHRcdHZhciBjb2xvclR5cGUgPSBuZXcgRGF0YVZpZXcoIGJ1ZmZlclZpZXcsIDI1LCAxICkuZ2V0VWludDgoIDAsIGZhbHNlICk7XG5cdFx0XHRcdFx0aGFzQWxwaGEgPSBjb2xvclR5cGUgPT09IDYgfHwgY29sb3JUeXBlID09PSA0IHx8IGNvbG9yVHlwZSA9PT0gMztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aXNPYmplY3RVUkwgPSB0cnVlO1xuXHRcdFx0XHR2YXIgYmxvYiA9IG5ldyBCbG9iKCBbIGJ1ZmZlclZpZXcgXSwgeyB0eXBlOiBzb3VyY2UubWltZVR5cGUgfSApO1xuXHRcdFx0XHRzb3VyY2VVUkkgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKCBibG9iICk7XG5cdFx0XHRcdHJldHVybiBzb3VyY2VVUkk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH0gZWxzZSBpZiAoIHNvdXJjZS51cmkgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogSW1hZ2UgJyArIHRleHR1cmVJbmRleCArICcgaXMgbWlzc2luZyBVUkkgYW5kIGJ1ZmZlclZpZXcnICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCBzb3VyY2VVUkkgKS50aGVuKCBmdW5jdGlvbiAoIHNvdXJjZVVSSSApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKCBmdW5jdGlvbiAoIHJlc29sdmUsIHJlamVjdCApIHtcblxuXHRcdFx0XHR2YXIgb25Mb2FkID0gcmVzb2x2ZTtcblxuXHRcdFx0XHRpZiAoIGxvYWRlci5pc0ltYWdlQml0bWFwTG9hZGVyID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0b25Mb2FkID0gZnVuY3Rpb24gKCBpbWFnZUJpdG1hcCApIHtcblxuXHRcdFx0XHRcdFx0cmVzb2x2ZSggbmV3IENhbnZhc1RleHR1cmUoIGltYWdlQml0bWFwICkgKTtcblxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxvYWRlci5sb2FkKCByZXNvbHZlVVJMKCBzb3VyY2VVUkksIG9wdGlvbnMucGF0aCApLCBvbkxvYWQsIHVuZGVmaW5lZCwgcmVqZWN0ICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH0gKS50aGVuKCBmdW5jdGlvbiAoIHRleHR1cmUgKSB7XG5cblx0XHRcdC8vIENsZWFuIHVwIHJlc291cmNlcyBhbmQgY29uZmlndXJlIFRleHR1cmUuXG5cblx0XHRcdGlmICggaXNPYmplY3RVUkwgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0VVJMLnJldm9rZU9iamVjdFVSTCggc291cmNlVVJJICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGV4dHVyZS5mbGlwWSA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoIHRleHR1cmVEZWYubmFtZSApIHRleHR1cmUubmFtZSA9IHRleHR1cmVEZWYubmFtZTtcblxuXHRcdFx0Ly8gV2hlbiB0aGVyZSBpcyBkZWZpbml0ZWx5IG5vIGFscGhhIGNoYW5uZWwgaW4gdGhlIHRleHR1cmUsIHNldCBSR0JGb3JtYXQgdG8gc2F2ZSBzcGFjZS5cblx0XHRcdGlmICggISBoYXNBbHBoYSApIHRleHR1cmUuZm9ybWF0ID0gUkdCRm9ybWF0O1xuXG5cdFx0XHR2YXIgc2FtcGxlcnMgPSBqc29uLnNhbXBsZXJzIHx8IHt9O1xuXHRcdFx0dmFyIHNhbXBsZXIgPSBzYW1wbGVyc1sgdGV4dHVyZURlZi5zYW1wbGVyIF0gfHwge307XG5cblx0XHRcdHRleHR1cmUubWFnRmlsdGVyID0gV0VCR0xfRklMVEVSU1sgc2FtcGxlci5tYWdGaWx0ZXIgXSB8fCBMaW5lYXJGaWx0ZXI7XG5cdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IFdFQkdMX0ZJTFRFUlNbIHNhbXBsZXIubWluRmlsdGVyIF0gfHwgTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyO1xuXHRcdFx0dGV4dHVyZS53cmFwUyA9IFdFQkdMX1dSQVBQSU5HU1sgc2FtcGxlci53cmFwUyBdIHx8IFJlcGVhdFdyYXBwaW5nO1xuXHRcdFx0dGV4dHVyZS53cmFwVCA9IFdFQkdMX1dSQVBQSU5HU1sgc2FtcGxlci53cmFwVCBdIHx8IFJlcGVhdFdyYXBwaW5nO1xuXG5cdFx0XHRwYXJzZXIuYXNzb2NpYXRpb25zLnNldCggdGV4dHVyZSwge1xuXHRcdFx0XHR0eXBlOiAndGV4dHVyZXMnLFxuXHRcdFx0XHRpbmRleDogdGV4dHVyZUluZGV4XG5cdFx0XHR9ICk7XG5cblx0XHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdFx0fSApO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIEFzeW5jaHJvbm91c2x5IGFzc2lnbnMgYSB0ZXh0dXJlIHRvIHRoZSBnaXZlbiBtYXRlcmlhbCBwYXJhbWV0ZXJzLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gbWF0ZXJpYWxQYXJhbXNcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1hcE5hbWVcblx0ICogQHBhcmFtIHtPYmplY3R9IG1hcERlZlxuXHQgKiBAcmV0dXJuIHtQcm9taXNlfVxuXHQgKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUuYXNzaWduVGV4dHVyZSA9IGZ1bmN0aW9uICggbWF0ZXJpYWxQYXJhbXMsIG1hcE5hbWUsIG1hcERlZiApIHtcblxuXHRcdHZhciBwYXJzZXIgPSB0aGlzO1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jeSggJ3RleHR1cmUnLCBtYXBEZWYuaW5kZXggKS50aGVuKCBmdW5jdGlvbiAoIHRleHR1cmUgKSB7XG5cblx0XHRcdC8vIE1hdGVyaWFscyBzYW1wbGUgYW9NYXAgZnJvbSBVViBzZXQgMSBhbmQgb3RoZXIgbWFwcyBmcm9tIFVWIHNldCAwIC0gdGhpcyBjYW4ndCBiZSBjb25maWd1cmVkXG5cdFx0XHQvLyBIb3dldmVyLCB3ZSB3aWxsIGNvcHkgVVYgc2V0IDAgdG8gVVYgc2V0IDEgb24gZGVtYW5kIGZvciBhb01hcFxuXHRcdFx0aWYgKCBtYXBEZWYudGV4Q29vcmQgIT09IHVuZGVmaW5lZCAmJiBtYXBEZWYudGV4Q29vcmQgIT0gMCAmJiAhICggbWFwTmFtZSA9PT0gJ2FvTWFwJyAmJiBtYXBEZWYudGV4Q29vcmQgPT0gMSApICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdMVEZMb2FkZXI6IEN1c3RvbSBVViBzZXQgJyArIG1hcERlZi50ZXhDb29yZCArICcgZm9yIHRleHR1cmUgJyArIG1hcE5hbWUgKyAnIG5vdCB5ZXQgc3VwcG9ydGVkLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHBhcnNlci5leHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STSBdICkge1xuXG5cdFx0XHRcdHZhciB0cmFuc2Zvcm0gPSBtYXBEZWYuZXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkID8gbWFwRGVmLmV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNIF0gOiB1bmRlZmluZWQ7XG5cblx0XHRcdFx0aWYgKCB0cmFuc2Zvcm0gKSB7XG5cblx0XHRcdFx0XHR2YXIgZ2x0ZlJlZmVyZW5jZSA9IHBhcnNlci5hc3NvY2lhdGlvbnMuZ2V0KCB0ZXh0dXJlICk7XG5cdFx0XHRcdFx0dGV4dHVyZSA9IHBhcnNlci5leHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STSBdLmV4dGVuZFRleHR1cmUoIHRleHR1cmUsIHRyYW5zZm9ybSApO1xuXHRcdFx0XHRcdHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KCB0ZXh0dXJlLCBnbHRmUmVmZXJlbmNlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zWyBtYXBOYW1lIF0gPSB0ZXh0dXJlO1xuXG5cdFx0fSApO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIEFzc2lnbnMgZmluYWwgbWF0ZXJpYWwgdG8gYSBNZXNoLCBMaW5lLCBvciBQb2ludHMgaW5zdGFuY2UuIFRoZSBpbnN0YW5jZVxuXHQgKiBhbHJlYWR5IGhhcyBhIG1hdGVyaWFsIChnZW5lcmF0ZWQgZnJvbSB0aGUgZ2xURiBtYXRlcmlhbCBvcHRpb25zIGFsb25lKVxuXHQgKiBidXQgcmV1c2Ugb2YgdGhlIHNhbWUgZ2xURiBtYXRlcmlhbCBtYXkgcmVxdWlyZSBtdWx0aXBsZSB0aHJlZWpzIG1hdGVyaWFsc1xuXHQgKiB0byBhY2NvbW1vZGF0ZSBkaWZmZXJlbnQgcHJpbWl0aXZlIHR5cGVzLCBkZWZpbmVzLCBldGMuIE5ldyBtYXRlcmlhbHMgd2lsbFxuXHQgKiBiZSBjcmVhdGVkIGlmIG5lY2Vzc2FyeSwgYW5kIHJldXNlZCBmcm9tIGEgY2FjaGUuXG5cdCAqIEBwYXJhbSAge09iamVjdDNEfSBtZXNoIE1lc2gsIExpbmUsIG9yIFBvaW50cyBpbnN0YW5jZS5cblx0ICovXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLmFzc2lnbkZpbmFsTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIG1lc2ggKSB7XG5cblx0XHR2YXIgZ2VvbWV0cnkgPSBtZXNoLmdlb21ldHJ5O1xuXHRcdHZhciBtYXRlcmlhbCA9IG1lc2gubWF0ZXJpYWw7XG5cblx0XHR2YXIgdXNlVmVydGV4VGFuZ2VudHMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnRhbmdlbnQgIT09IHVuZGVmaW5lZDtcblx0XHR2YXIgdXNlVmVydGV4Q29sb3JzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvciAhPT0gdW5kZWZpbmVkO1xuXHRcdHZhciB1c2VGbGF0U2hhZGluZyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsID09PSB1bmRlZmluZWQ7XG5cdFx0dmFyIHVzZVNraW5uaW5nID0gbWVzaC5pc1NraW5uZWRNZXNoID09PSB0cnVlO1xuXHRcdHZhciB1c2VNb3JwaFRhcmdldHMgPSBPYmplY3Qua2V5cyggZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzICkubGVuZ3RoID4gMDtcblx0XHR2YXIgdXNlTW9ycGhOb3JtYWxzID0gdXNlTW9ycGhUYXJnZXRzICYmIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgIT09IHVuZGVmaW5lZDtcblxuXHRcdGlmICggbWVzaC5pc1BvaW50cyApIHtcblxuXHRcdFx0dmFyIGNhY2hlS2V5ID0gJ1BvaW50c01hdGVyaWFsOicgKyBtYXRlcmlhbC51dWlkO1xuXG5cdFx0XHR2YXIgcG9pbnRzTWF0ZXJpYWwgPSB0aGlzLmNhY2hlLmdldCggY2FjaGVLZXkgKTtcblxuXHRcdFx0aWYgKCAhIHBvaW50c01hdGVyaWFsICkge1xuXG5cdFx0XHRcdHBvaW50c01hdGVyaWFsID0gbmV3IFBvaW50c01hdGVyaWFsKCk7XG5cdFx0XHRcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHBvaW50c01hdGVyaWFsLCBtYXRlcmlhbCApO1xuXHRcdFx0XHRwb2ludHNNYXRlcmlhbC5jb2xvci5jb3B5KCBtYXRlcmlhbC5jb2xvciApO1xuXHRcdFx0XHRwb2ludHNNYXRlcmlhbC5tYXAgPSBtYXRlcmlhbC5tYXA7XG5cdFx0XHRcdHBvaW50c01hdGVyaWFsLnNpemVBdHRlbnVhdGlvbiA9IGZhbHNlOyAvLyBnbFRGIHNwZWMgc2F5cyBwb2ludHMgc2hvdWxkIGJlIDFweFxuXG5cdFx0XHRcdHRoaXMuY2FjaGUuYWRkKCBjYWNoZUtleSwgcG9pbnRzTWF0ZXJpYWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRtYXRlcmlhbCA9IHBvaW50c01hdGVyaWFsO1xuXG5cdFx0fSBlbHNlIGlmICggbWVzaC5pc0xpbmUgKSB7XG5cblx0XHRcdHZhciBjYWNoZUtleSA9ICdMaW5lQmFzaWNNYXRlcmlhbDonICsgbWF0ZXJpYWwudXVpZDtcblxuXHRcdFx0dmFyIGxpbmVNYXRlcmlhbCA9IHRoaXMuY2FjaGUuZ2V0KCBjYWNoZUtleSApO1xuXG5cdFx0XHRpZiAoICEgbGluZU1hdGVyaWFsICkge1xuXG5cdFx0XHRcdGxpbmVNYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCgpO1xuXHRcdFx0XHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCBsaW5lTWF0ZXJpYWwsIG1hdGVyaWFsICk7XG5cdFx0XHRcdGxpbmVNYXRlcmlhbC5jb2xvci5jb3B5KCBtYXRlcmlhbC5jb2xvciApO1xuXG5cdFx0XHRcdHRoaXMuY2FjaGUuYWRkKCBjYWNoZUtleSwgbGluZU1hdGVyaWFsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bWF0ZXJpYWwgPSBsaW5lTWF0ZXJpYWw7XG5cblx0XHR9XG5cblx0XHQvLyBDbG9uZSB0aGUgbWF0ZXJpYWwgaWYgaXQgd2lsbCBiZSBtb2RpZmllZFxuXHRcdGlmICggdXNlVmVydGV4VGFuZ2VudHMgfHwgdXNlVmVydGV4Q29sb3JzIHx8IHVzZUZsYXRTaGFkaW5nIHx8IHVzZVNraW5uaW5nIHx8IHVzZU1vcnBoVGFyZ2V0cyApIHtcblxuXHRcdFx0dmFyIGNhY2hlS2V5ID0gJ0Nsb25lZE1hdGVyaWFsOicgKyBtYXRlcmlhbC51dWlkICsgJzonO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmlzR0xURlNwZWN1bGFyR2xvc3NpbmVzc01hdGVyaWFsICkgY2FjaGVLZXkgKz0gJ3NwZWN1bGFyLWdsb3NzaW5lc3M6Jztcblx0XHRcdGlmICggdXNlU2tpbm5pbmcgKSBjYWNoZUtleSArPSAnc2tpbm5pbmc6Jztcblx0XHRcdGlmICggdXNlVmVydGV4VGFuZ2VudHMgKSBjYWNoZUtleSArPSAndmVydGV4LXRhbmdlbnRzOic7XG5cdFx0XHRpZiAoIHVzZVZlcnRleENvbG9ycyApIGNhY2hlS2V5ICs9ICd2ZXJ0ZXgtY29sb3JzOic7XG5cdFx0XHRpZiAoIHVzZUZsYXRTaGFkaW5nICkgY2FjaGVLZXkgKz0gJ2ZsYXQtc2hhZGluZzonO1xuXHRcdFx0aWYgKCB1c2VNb3JwaFRhcmdldHMgKSBjYWNoZUtleSArPSAnbW9ycGgtdGFyZ2V0czonO1xuXHRcdFx0aWYgKCB1c2VNb3JwaE5vcm1hbHMgKSBjYWNoZUtleSArPSAnbW9ycGgtbm9ybWFsczonO1xuXG5cdFx0XHR2YXIgY2FjaGVkTWF0ZXJpYWwgPSB0aGlzLmNhY2hlLmdldCggY2FjaGVLZXkgKTtcblxuXHRcdFx0aWYgKCAhIGNhY2hlZE1hdGVyaWFsICkge1xuXG5cdFx0XHRcdGNhY2hlZE1hdGVyaWFsID0gbWF0ZXJpYWwuY2xvbmUoKTtcblxuXHRcdFx0XHRpZiAoIHVzZVNraW5uaW5nICkgY2FjaGVkTWF0ZXJpYWwuc2tpbm5pbmcgPSB0cnVlO1xuXHRcdFx0XHRpZiAoIHVzZVZlcnRleENvbG9ycyApIGNhY2hlZE1hdGVyaWFsLnZlcnRleENvbG9ycyA9IHRydWU7XG5cdFx0XHRcdGlmICggdXNlRmxhdFNoYWRpbmcgKSBjYWNoZWRNYXRlcmlhbC5mbGF0U2hhZGluZyA9IHRydWU7XG5cdFx0XHRcdGlmICggdXNlTW9ycGhUYXJnZXRzICkgY2FjaGVkTWF0ZXJpYWwubW9ycGhUYXJnZXRzID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCB1c2VNb3JwaE5vcm1hbHMgKSBjYWNoZWRNYXRlcmlhbC5tb3JwaE5vcm1hbHMgPSB0cnVlO1xuXG5cdFx0XHRcdGlmICggdXNlVmVydGV4VGFuZ2VudHMgKSB7XG5cblx0XHRcdFx0XHRjYWNoZWRNYXRlcmlhbC52ZXJ0ZXhUYW5nZW50cyA9IHRydWU7XG5cblx0XHRcdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8xMTQzOCNpc3N1ZWNvbW1lbnQtNTA3MDAzOTk1XG5cdFx0XHRcdFx0aWYgKCBjYWNoZWRNYXRlcmlhbC5ub3JtYWxTY2FsZSApIGNhY2hlZE1hdGVyaWFsLm5vcm1hbFNjYWxlLnkgKj0gLSAxO1xuXHRcdFx0XHRcdGlmICggY2FjaGVkTWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsU2NhbGUgKSBjYWNoZWRNYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxTY2FsZS55ICo9IC0gMTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5jYWNoZS5hZGQoIGNhY2hlS2V5LCBjYWNoZWRNYXRlcmlhbCApO1xuXG5cdFx0XHRcdHRoaXMuYXNzb2NpYXRpb25zLnNldCggY2FjaGVkTWF0ZXJpYWwsIHRoaXMuYXNzb2NpYXRpb25zLmdldCggbWF0ZXJpYWwgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdG1hdGVyaWFsID0gY2FjaGVkTWF0ZXJpYWw7XG5cblx0XHR9XG5cblx0XHQvLyB3b3JrYXJvdW5kcyBmb3IgbWVzaCBhbmQgZ2VvbWV0cnlcblxuXHRcdGlmICggbWF0ZXJpYWwuYW9NYXAgJiYgZ2VvbWV0cnkuYXR0cmlidXRlcy51djIgPT09IHVuZGVmaW5lZCAmJiBnZW9tZXRyeS5hdHRyaWJ1dGVzLnV2ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3V2MicsIGdlb21ldHJ5LmF0dHJpYnV0ZXMudXYgKTtcblxuXHRcdH1cblxuXHRcdG1lc2gubWF0ZXJpYWwgPSBtYXRlcmlhbDtcblxuXHR9O1xuXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLmdldE1hdGVyaWFsVHlwZSA9IGZ1bmN0aW9uICggLyogbWF0ZXJpYWxJbmRleCAqLyApIHtcblxuXHRcdHJldHVybiBNZXNoU3RhbmRhcmRNYXRlcmlhbDtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI21hdGVyaWFsc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF0ZXJpYWxJbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPE1hdGVyaWFsPn1cblx0ICovXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLmxvYWRNYXRlcmlhbCA9IGZ1bmN0aW9uICggbWF0ZXJpYWxJbmRleCApIHtcblxuXHRcdHZhciBwYXJzZXIgPSB0aGlzO1xuXHRcdHZhciBqc29uID0gdGhpcy5qc29uO1xuXHRcdHZhciBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuXHRcdHZhciBtYXRlcmlhbERlZiA9IGpzb24ubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHR2YXIgbWF0ZXJpYWxUeXBlO1xuXHRcdHZhciBtYXRlcmlhbFBhcmFtcyA9IHt9O1xuXHRcdHZhciBtYXRlcmlhbEV4dGVuc2lvbnMgPSBtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHBlbmRpbmcgPSBbXTtcblxuXHRcdGlmICggbWF0ZXJpYWxFeHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfUEJSX1NQRUNVTEFSX0dMT1NTSU5FU1MgXSApIHtcblxuXHRcdFx0dmFyIHNnRXh0ZW5zaW9uID0gZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1BCUl9TUEVDVUxBUl9HTE9TU0lORVNTIF07XG5cdFx0XHRtYXRlcmlhbFR5cGUgPSBzZ0V4dGVuc2lvbi5nZXRNYXRlcmlhbFR5cGUoKTtcblx0XHRcdHBlbmRpbmcucHVzaCggc2dFeHRlbnNpb24uZXh0ZW5kUGFyYW1zKCBtYXRlcmlhbFBhcmFtcywgbWF0ZXJpYWxEZWYsIHBhcnNlciApICk7XG5cblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbEV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19VTkxJVCBdICkge1xuXG5cdFx0XHR2YXIga211RXh0ZW5zaW9uID0gZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1VOTElUIF07XG5cdFx0XHRtYXRlcmlhbFR5cGUgPSBrbXVFeHRlbnNpb24uZ2V0TWF0ZXJpYWxUeXBlKCk7XG5cdFx0XHRwZW5kaW5nLnB1c2goIGttdUV4dGVuc2lvbi5leHRlbmRQYXJhbXMoIG1hdGVyaWFsUGFyYW1zLCBtYXRlcmlhbERlZiwgcGFyc2VyICkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFNwZWNpZmljYXRpb246XG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjbWV0YWxsaWMtcm91Z2huZXNzLW1hdGVyaWFsXG5cblx0XHRcdHZhciBtZXRhbGxpY1JvdWdobmVzcyA9IG1hdGVyaWFsRGVmLnBick1ldGFsbGljUm91Z2huZXNzIHx8IHt9O1xuXG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5jb2xvciA9IG5ldyBDb2xvciggMS4wLCAxLjAsIDEuMCApO1xuXHRcdFx0bWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IDEuMDtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3IgKSApIHtcblxuXHRcdFx0XHR2YXIgYXJyYXkgPSBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3I7XG5cblx0XHRcdFx0bWF0ZXJpYWxQYXJhbXMuY29sb3IuZnJvbUFycmF5KCBhcnJheSApO1xuXHRcdFx0XHRtYXRlcmlhbFBhcmFtcy5vcGFjaXR5ID0gYXJyYXlbIDMgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ21hcCcsIG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zLm1ldGFsbmVzcyA9IG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljRmFjdG9yICE9PSB1bmRlZmluZWQgPyBtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY0ZhY3RvciA6IDEuMDtcblx0XHRcdG1hdGVyaWFsUGFyYW1zLnJvdWdobmVzcyA9IG1ldGFsbGljUm91Z2huZXNzLnJvdWdobmVzc0ZhY3RvciAhPT0gdW5kZWZpbmVkID8gbWV0YWxsaWNSb3VnaG5lc3Mucm91Z2huZXNzRmFjdG9yIDogMS4wO1xuXG5cdFx0XHRpZiAoIG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAnbWV0YWxuZXNzTWFwJywgbWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlICkgKTtcblx0XHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdyb3VnaG5lc3NNYXAnLCBtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdG1hdGVyaWFsVHlwZSA9IHRoaXMuX2ludm9rZU9uZSggZnVuY3Rpb24gKCBleHQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGV4dC5nZXRNYXRlcmlhbFR5cGUgJiYgZXh0LmdldE1hdGVyaWFsVHlwZSggbWF0ZXJpYWxJbmRleCApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHBlbmRpbmcucHVzaCggUHJvbWlzZS5hbGwoIHRoaXMuX2ludm9rZUFsbCggZnVuY3Rpb24gKCBleHQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGV4dC5leHRlbmRNYXRlcmlhbFBhcmFtcyAmJiBleHQuZXh0ZW5kTWF0ZXJpYWxQYXJhbXMoIG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zICk7XG5cblx0XHRcdH0gKSApICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsRGVmLmRvdWJsZVNpZGVkID09PSB0cnVlICkge1xuXG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5zaWRlID0gRG91YmxlU2lkZTtcblxuXHRcdH1cblxuXHRcdHZhciBhbHBoYU1vZGUgPSBtYXRlcmlhbERlZi5hbHBoYU1vZGUgfHwgQUxQSEFfTU9ERVMuT1BBUVVFO1xuXG5cdFx0aWYgKCBhbHBoYU1vZGUgPT09IEFMUEhBX01PREVTLkJMRU5EICkge1xuXG5cdFx0XHRtYXRlcmlhbFBhcmFtcy50cmFuc3BhcmVudCA9IHRydWU7XG5cblx0XHRcdC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMTc3MDZcblx0XHRcdG1hdGVyaWFsUGFyYW1zLmRlcHRoV3JpdGUgPSBmYWxzZTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zLnRyYW5zcGFyZW50ID0gZmFsc2U7XG5cblx0XHRcdGlmICggYWxwaGFNb2RlID09PSBBTFBIQV9NT0RFUy5NQVNLICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLmFscGhhVGVzdCA9IG1hdGVyaWFsRGVmLmFscGhhQ3V0b2ZmICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbERlZi5hbHBoYUN1dG9mZiA6IDAuNTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbERlZi5ub3JtYWxUZXh0dXJlICE9PSB1bmRlZmluZWQgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCApIHtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdub3JtYWxNYXAnLCBtYXRlcmlhbERlZi5ub3JtYWxUZXh0dXJlICkgKTtcblxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMTE0MzgjaXNzdWVjb21tZW50LTUwNzAwMzk5NVxuXHRcdFx0bWF0ZXJpYWxQYXJhbXMubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMiggMSwgLSAxICk7XG5cblx0XHRcdGlmICggbWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZS5zY2FsZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLm5vcm1hbFNjYWxlLnNldCggbWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZS5zY2FsZSwgLSBtYXRlcmlhbERlZi5ub3JtYWxUZXh0dXJlLnNjYWxlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWxEZWYub2NjbHVzaW9uVGV4dHVyZSAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsVHlwZSAhPT0gTWVzaEJhc2ljTWF0ZXJpYWwgKSB7XG5cblx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAnYW9NYXAnLCBtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlICkgKTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlLnN0cmVuZ3RoICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bWF0ZXJpYWxQYXJhbXMuYW9NYXBJbnRlbnNpdHkgPSBtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlLnN0cmVuZ3RoO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsRGVmLmVtaXNzaXZlRmFjdG9yICE9PSB1bmRlZmluZWQgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCApIHtcblxuXHRcdFx0bWF0ZXJpYWxQYXJhbXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoKS5mcm9tQXJyYXkoIG1hdGVyaWFsRGVmLmVtaXNzaXZlRmFjdG9yICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsRGVmLmVtaXNzaXZlVGV4dHVyZSAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsVHlwZSAhPT0gTWVzaEJhc2ljTWF0ZXJpYWwgKSB7XG5cblx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAnZW1pc3NpdmVNYXAnLCBtYXRlcmlhbERlZi5lbWlzc2l2ZVRleHR1cmUgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nICkudGhlbiggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgbWF0ZXJpYWw7XG5cblx0XHRcdGlmICggbWF0ZXJpYWxUeXBlID09PSBHTFRGTWVzaFN0YW5kYXJkU0dNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRtYXRlcmlhbCA9IGV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19QQlJfU1BFQ1VMQVJfR0xPU1NJTkVTUyBdLmNyZWF0ZU1hdGVyaWFsKCBtYXRlcmlhbFBhcmFtcyApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG1hdGVyaWFsID0gbmV3IG1hdGVyaWFsVHlwZSggbWF0ZXJpYWxQYXJhbXMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsRGVmLm5hbWUgKSBtYXRlcmlhbC5uYW1lID0gbWF0ZXJpYWxEZWYubmFtZTtcblxuXHRcdFx0Ly8gYmFzZUNvbG9yVGV4dHVyZSwgZW1pc3NpdmVUZXh0dXJlLCBhbmQgc3BlY3VsYXJHbG9zc2luZXNzVGV4dHVyZSB1c2Ugc1JHQiBlbmNvZGluZy5cblx0XHRcdGlmICggbWF0ZXJpYWwubWFwICkgbWF0ZXJpYWwubWFwLmVuY29kaW5nID0gc1JHQkVuY29kaW5nO1xuXHRcdFx0aWYgKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCApIG1hdGVyaWFsLmVtaXNzaXZlTWFwLmVuY29kaW5nID0gc1JHQkVuY29kaW5nO1xuXG5cdFx0XHRhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKCBtYXRlcmlhbCwgbWF0ZXJpYWxEZWYgKTtcblxuXHRcdFx0cGFyc2VyLmFzc29jaWF0aW9ucy5zZXQoIG1hdGVyaWFsLCB7IHR5cGU6ICdtYXRlcmlhbHMnLCBpbmRleDogbWF0ZXJpYWxJbmRleCB9ICk7XG5cblx0XHRcdGlmICggbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyApIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YSggZXh0ZW5zaW9ucywgbWF0ZXJpYWwsIG1hdGVyaWFsRGVmICk7XG5cblx0XHRcdHJldHVybiBtYXRlcmlhbDtcblxuXHRcdH0gKTtcblxuXHR9O1xuXG5cdC8qKiBXaGVuIE9iamVjdDNEIGluc3RhbmNlcyBhcmUgdGFyZ2V0ZWQgYnkgYW5pbWF0aW9uLCB0aGV5IG5lZWQgdW5pcXVlIG5hbWVzLiAqL1xuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVVbmlxdWVOYW1lID0gZnVuY3Rpb24gKCBvcmlnaW5hbE5hbWUgKSB7XG5cblx0XHR2YXIgc2FuaXRpemVkTmFtZSA9IFByb3BlcnR5QmluZGluZy5zYW5pdGl6ZU5vZGVOYW1lKCBvcmlnaW5hbE5hbWUgfHwgJycgKTtcblxuXHRcdHZhciBuYW1lID0gc2FuaXRpemVkTmFtZTtcblxuXHRcdGZvciAoIHZhciBpID0gMTsgdGhpcy5ub2RlTmFtZXNVc2VkWyBuYW1lIF07ICsrIGkgKSB7XG5cblx0XHRcdG5hbWUgPSBzYW5pdGl6ZWROYW1lICsgJ18nICsgaTtcblxuXHRcdH1cblxuXHRcdHRoaXMubm9kZU5hbWVzVXNlZFsgbmFtZSBdID0gdHJ1ZTtcblxuXHRcdHJldHVybiBuYW1lO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7QnVmZmVyR2VvbWV0cnl9IGdlb21ldHJ5XG5cdCAqIEBwYXJhbSB7R0xURi5QcmltaXRpdmV9IHByaW1pdGl2ZURlZlxuXHQgKiBAcGFyYW0ge0dMVEZQYXJzZXJ9IHBhcnNlclxuXHQgKi9cblx0ZnVuY3Rpb24gY29tcHV0ZUJvdW5kcyggZ2VvbWV0cnksIHByaW1pdGl2ZURlZiwgcGFyc2VyICkge1xuXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBwcmltaXRpdmVEZWYuYXR0cmlidXRlcztcblxuXHRcdHZhciBib3ggPSBuZXcgQm94MygpO1xuXG5cdFx0aWYgKCBhdHRyaWJ1dGVzLlBPU0lUSU9OICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBhY2Nlc3NvciA9IHBhcnNlci5qc29uLmFjY2Vzc29yc1sgYXR0cmlidXRlcy5QT1NJVElPTiBdO1xuXG5cdFx0XHR2YXIgbWluID0gYWNjZXNzb3IubWluO1xuXHRcdFx0dmFyIG1heCA9IGFjY2Vzc29yLm1heDtcblxuXHRcdFx0Ly8gZ2xURiByZXF1aXJlcyAnbWluJyBhbmQgJ21heCcsIGJ1dCBWUk0gKHdoaWNoIGV4dGVuZHMgZ2xURikgY3VycmVudGx5IGlnbm9yZXMgdGhhdCByZXF1aXJlbWVudC5cblxuXHRcdFx0aWYgKCBtaW4gIT09IHVuZGVmaW5lZCAmJiBtYXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRib3guc2V0KFxuXHRcdFx0XHRcdG5ldyBWZWN0b3IzKCBtaW5bIDAgXSwgbWluWyAxIF0sIG1pblsgMiBdICksXG5cdFx0XHRcdFx0bmV3IFZlY3RvcjMoIG1heFsgMCBdLCBtYXhbIDEgXSwgbWF4WyAyIF0gKSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdMVEZMb2FkZXI6IE1pc3NpbmcgbWluL21heCBwcm9wZXJ0aWVzIGZvciBhY2Nlc3NvciBQT1NJVElPTi4nICk7XG5cblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHR2YXIgdGFyZ2V0cyA9IHByaW1pdGl2ZURlZi50YXJnZXRzO1xuXG5cdFx0aWYgKCB0YXJnZXRzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBtYXhEaXNwbGFjZW1lbnQgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0dmFyIHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciB0YXJnZXQgPSB0YXJnZXRzWyBpIF07XG5cblx0XHRcdFx0aWYgKCB0YXJnZXQuUE9TSVRJT04gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHZhciBhY2Nlc3NvciA9IHBhcnNlci5qc29uLmFjY2Vzc29yc1sgdGFyZ2V0LlBPU0lUSU9OIF07XG5cdFx0XHRcdFx0dmFyIG1pbiA9IGFjY2Vzc29yLm1pbjtcblx0XHRcdFx0XHR2YXIgbWF4ID0gYWNjZXNzb3IubWF4O1xuXG5cdFx0XHRcdFx0Ly8gZ2xURiByZXF1aXJlcyAnbWluJyBhbmQgJ21heCcsIGJ1dCBWUk0gKHdoaWNoIGV4dGVuZHMgZ2xURikgY3VycmVudGx5IGlnbm9yZXMgdGhhdCByZXF1aXJlbWVudC5cblxuXHRcdFx0XHRcdGlmICggbWluICE9PSB1bmRlZmluZWQgJiYgbWF4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHdlIG5lZWQgdG8gZ2V0IG1heCBvZiBhYnNvbHV0ZSBjb21wb25lbnRzIGJlY2F1c2UgdGFyZ2V0IHdlaWdodCBpcyBbLTEsMV1cblx0XHRcdFx0XHRcdHZlY3Rvci5zZXRYKCBNYXRoLm1heCggTWF0aC5hYnMoIG1pblsgMCBdICksIE1hdGguYWJzKCBtYXhbIDAgXSApICkgKTtcblx0XHRcdFx0XHRcdHZlY3Rvci5zZXRZKCBNYXRoLm1heCggTWF0aC5hYnMoIG1pblsgMSBdICksIE1hdGguYWJzKCBtYXhbIDEgXSApICkgKTtcblx0XHRcdFx0XHRcdHZlY3Rvci5zZXRaKCBNYXRoLm1heCggTWF0aC5hYnMoIG1pblsgMiBdICksIE1hdGguYWJzKCBtYXhbIDIgXSApICkgKTtcblxuXHRcdFx0XHRcdFx0Ly8gTm90ZTogdGhpcyBhc3N1bWVzIHRoYXQgdGhlIHN1bSBvZiBhbGwgd2VpZ2h0cyBpcyBhdCBtb3N0IDEuIFRoaXMgaXNuJ3QgcXVpdGUgY29ycmVjdCAtIGl0J3MgbW9yZSBjb25zZXJ2YXRpdmVcblx0XHRcdFx0XHRcdC8vIHRvIGFzc3VtZSB0aGF0IGVhY2ggdGFyZ2V0IGNhbiBoYXZlIGEgbWF4IHdlaWdodCBvZiAxLiBIb3dldmVyLCBmb3Igc29tZSB1c2UgY2FzZXMgLSBub3RhYmx5LCB3aGVuIG1vcnBoIHRhcmdldHNcblx0XHRcdFx0XHRcdC8vIGFyZSB1c2VkIHRvIGltcGxlbWVudCBrZXktZnJhbWUgYW5pbWF0aW9ucyBhbmQgYXMgc3VjaCBvbmx5IHR3byBhcmUgYWN0aXZlIGF0IGEgdGltZSAtIHRoaXMgcmVzdWx0cyBpbiB2ZXJ5IGxhcmdlXG5cdFx0XHRcdFx0XHQvLyBib3hlcy4gU28gZm9yIG5vdyB3ZSBtYWtlIGEgYm94IHRoYXQncyBzb21ldGltZXMgYSB0b3VjaCB0b28gc21hbGwgYnV0IGlzIGhvcGVmdWxseSBtb3N0bHkgb2YgcmVhc29uYWJsZSBzaXplLlxuXHRcdFx0XHRcdFx0bWF4RGlzcGxhY2VtZW50Lm1heCggdmVjdG9yICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HTFRGTG9hZGVyOiBNaXNzaW5nIG1pbi9tYXggcHJvcGVydGllcyBmb3IgYWNjZXNzb3IgUE9TSVRJT04uJyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcyBwZXIgY29tbWVudCBhYm92ZSB0aGlzIGJveCBpc24ndCBjb25zZXJ2YXRpdmUsIGJ1dCBoYXMgYSByZWFzb25hYmxlIHNpemUgZm9yIGEgdmVyeSBsYXJnZSBudW1iZXIgb2YgbW9ycGggdGFyZ2V0cy5cblx0XHRcdGJveC5leHBhbmRCeVZlY3RvciggbWF4RGlzcGxhY2VtZW50ICk7XG5cblx0XHR9XG5cblx0XHRnZW9tZXRyeS5ib3VuZGluZ0JveCA9IGJveDtcblxuXHRcdHZhciBzcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG5cblx0XHRib3guZ2V0Q2VudGVyKCBzcGhlcmUuY2VudGVyICk7XG5cdFx0c3BoZXJlLnJhZGl1cyA9IGJveC5taW4uZGlzdGFuY2VUbyggYm94Lm1heCApIC8gMjtcblxuXHRcdGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID0gc3BoZXJlO1xuXG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtCdWZmZXJHZW9tZXRyeX0gZ2VvbWV0cnlcblx0ICogQHBhcmFtIHtHTFRGLlByaW1pdGl2ZX0gcHJpbWl0aXZlRGVmXG5cdCAqIEBwYXJhbSB7R0xURlBhcnNlcn0gcGFyc2VyXG5cdCAqIEByZXR1cm4ge1Byb21pc2U8QnVmZmVyR2VvbWV0cnk+fVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRkUHJpbWl0aXZlQXR0cmlidXRlcyggZ2VvbWV0cnksIHByaW1pdGl2ZURlZiwgcGFyc2VyICkge1xuXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBwcmltaXRpdmVEZWYuYXR0cmlidXRlcztcblxuXHRcdHZhciBwZW5kaW5nID0gW107XG5cblx0XHRmdW5jdGlvbiBhc3NpZ25BdHRyaWJ1dGVBY2Nlc3NvciggYWNjZXNzb3JJbmRleCwgYXR0cmlidXRlTmFtZSApIHtcblxuXHRcdFx0cmV0dXJuIHBhcnNlci5nZXREZXBlbmRlbmN5KCAnYWNjZXNzb3InLCBhY2Nlc3NvckluZGV4IClcblx0XHRcdFx0LnRoZW4oIGZ1bmN0aW9uICggYWNjZXNzb3IgKSB7XG5cblx0XHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoIGF0dHJpYnV0ZU5hbWUsIGFjY2Vzc29yICk7XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGdsdGZBdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdHZhciB0aHJlZUF0dHJpYnV0ZU5hbWUgPSBBVFRSSUJVVEVTWyBnbHRmQXR0cmlidXRlTmFtZSBdIHx8IGdsdGZBdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdC8vIFNraXAgYXR0cmlidXRlcyBhbHJlYWR5IHByb3ZpZGVkIGJ5IGUuZy4gRHJhY28gZXh0ZW5zaW9uLlxuXHRcdFx0aWYgKCB0aHJlZUF0dHJpYnV0ZU5hbWUgaW4gZ2VvbWV0cnkuYXR0cmlidXRlcyApIGNvbnRpbnVlO1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIGFzc2lnbkF0dHJpYnV0ZUFjY2Vzc29yKCBhdHRyaWJ1dGVzWyBnbHRmQXR0cmlidXRlTmFtZSBdLCB0aHJlZUF0dHJpYnV0ZU5hbWUgKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBwcmltaXRpdmVEZWYuaW5kaWNlcyAhPT0gdW5kZWZpbmVkICYmICEgZ2VvbWV0cnkuaW5kZXggKSB7XG5cblx0XHRcdHZhciBhY2Nlc3NvciA9IHBhcnNlci5nZXREZXBlbmRlbmN5KCAnYWNjZXNzb3InLCBwcmltaXRpdmVEZWYuaW5kaWNlcyApLnRoZW4oIGZ1bmN0aW9uICggYWNjZXNzb3IgKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnkuc2V0SW5kZXgoIGFjY2Vzc29yICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCBhY2Nlc3NvciApO1xuXG5cdFx0fVxuXG5cdFx0YXNzaWduRXh0cmFzVG9Vc2VyRGF0YSggZ2VvbWV0cnksIHByaW1pdGl2ZURlZiApO1xuXG5cdFx0Y29tcHV0ZUJvdW5kcyggZ2VvbWV0cnksIHByaW1pdGl2ZURlZiwgcGFyc2VyICk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmcgKS50aGVuKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBwcmltaXRpdmVEZWYudGFyZ2V0cyAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdD8gYWRkTW9ycGhUYXJnZXRzKCBnZW9tZXRyeSwgcHJpbWl0aXZlRGVmLnRhcmdldHMsIHBhcnNlciApXG5cdFx0XHRcdDogZ2VvbWV0cnk7XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0J1ZmZlckdlb21ldHJ5fSBnZW9tZXRyeVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZHJhd01vZGVcblx0ICogQHJldHVybiB7QnVmZmVyR2VvbWV0cnl9XG5cdCAqL1xuXHRmdW5jdGlvbiB0b1RyaWFuZ2xlc0RyYXdNb2RlKCBnZW9tZXRyeSwgZHJhd01vZGUgKSB7XG5cblx0XHR2YXIgaW5kZXggPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuXG5cdFx0Ly8gZ2VuZXJhdGUgaW5kZXggaWYgbm90IHByZXNlbnRcblxuXHRcdGlmICggaW5kZXggPT09IG51bGwgKSB7XG5cblx0XHRcdHZhciBpbmRpY2VzID0gW107XG5cblx0XHRcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApO1xuXG5cdFx0XHRpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgcG9zaXRpb24uY291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cnkuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0XHRcdFx0aW5kZXggPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyLnRvVHJpYW5nbGVzRHJhd01vZGUoKTogVW5kZWZpbmVkIHBvc2l0aW9uIGF0dHJpYnV0ZS4gUHJvY2Vzc2luZyBub3QgcG9zc2libGUuJyApO1xuXHRcdFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHR2YXIgbnVtYmVyT2ZUcmlhbmdsZXMgPSBpbmRleC5jb3VudCAtIDI7XG5cdFx0dmFyIG5ld0luZGljZXMgPSBbXTtcblxuXHRcdGlmICggZHJhd01vZGUgPT09IFRyaWFuZ2xlRmFuRHJhd01vZGUgKSB7XG5cblx0XHRcdC8vIGdsLlRSSUFOR0xFX0ZBTlxuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDE7IGkgPD0gbnVtYmVyT2ZUcmlhbmdsZXM7IGkgKysgKSB7XG5cblx0XHRcdFx0bmV3SW5kaWNlcy5wdXNoKCBpbmRleC5nZXRYKCAwICkgKTtcblx0XHRcdFx0bmV3SW5kaWNlcy5wdXNoKCBpbmRleC5nZXRYKCBpICkgKTtcblx0XHRcdFx0bmV3SW5kaWNlcy5wdXNoKCBpbmRleC5nZXRYKCBpICsgMSApICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGdsLlRSSUFOR0xFX1NUUklQXG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG51bWJlck9mVHJpYW5nbGVzOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggaSAlIDIgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRuZXdJbmRpY2VzLnB1c2goIGluZGV4LmdldFgoIGkgKSApO1xuXHRcdFx0XHRcdG5ld0luZGljZXMucHVzaCggaW5kZXguZ2V0WCggaSArIDEgKSApO1xuXHRcdFx0XHRcdG5ld0luZGljZXMucHVzaCggaW5kZXguZ2V0WCggaSArIDIgKSApO1xuXG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdG5ld0luZGljZXMucHVzaCggaW5kZXguZ2V0WCggaSArIDIgKSApO1xuXHRcdFx0XHRcdG5ld0luZGljZXMucHVzaCggaW5kZXguZ2V0WCggaSArIDEgKSApO1xuXHRcdFx0XHRcdG5ld0luZGljZXMucHVzaCggaW5kZXguZ2V0WCggaSApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoICggbmV3SW5kaWNlcy5sZW5ndGggLyAzICkgIT09IG51bWJlck9mVHJpYW5nbGVzICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuR0xURkxvYWRlci50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IFVuYWJsZSB0byBnZW5lcmF0ZSBjb3JyZWN0IGFtb3VudCBvZiB0cmlhbmdsZXMuJyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZmluYWwgZ2VvbWV0cnlcblxuXHRcdHZhciBuZXdHZW9tZXRyeSA9IGdlb21ldHJ5LmNsb25lKCk7XG5cdFx0bmV3R2VvbWV0cnkuc2V0SW5kZXgoIG5ld0luZGljZXMgKTtcblxuXHRcdHJldHVybiBuZXdHZW9tZXRyeTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjZ2VvbWV0cnlcblx0ICpcblx0ICogQ3JlYXRlcyBCdWZmZXJHZW9tZXRyaWVzIGZyb20gcHJpbWl0aXZlcy5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheTxHTFRGLlByaW1pdGl2ZT59IHByaW1pdGl2ZXNcblx0ICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxCdWZmZXJHZW9tZXRyeT4+fVxuXHQgKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUubG9hZEdlb21ldHJpZXMgPSBmdW5jdGlvbiAoIHByaW1pdGl2ZXMgKSB7XG5cblx0XHR2YXIgcGFyc2VyID0gdGhpcztcblx0XHR2YXIgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcblx0XHR2YXIgY2FjaGUgPSB0aGlzLnByaW1pdGl2ZUNhY2hlO1xuXG5cdFx0ZnVuY3Rpb24gY3JlYXRlRHJhY29QcmltaXRpdmUoIHByaW1pdGl2ZSApIHtcblxuXHRcdFx0cmV0dXJuIGV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT04gXVxuXHRcdFx0XHQuZGVjb2RlUHJpbWl0aXZlKCBwcmltaXRpdmUsIHBhcnNlciApXG5cdFx0XHRcdC50aGVuKCBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGFkZFByaW1pdGl2ZUF0dHJpYnV0ZXMoIGdlb21ldHJ5LCBwcmltaXRpdmUsIHBhcnNlciApO1xuXG5cdFx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHRcdHZhciBwZW5kaW5nID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcHJpbWl0aXZlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHByaW1pdGl2ZSA9IHByaW1pdGl2ZXNbIGkgXTtcblx0XHRcdHZhciBjYWNoZUtleSA9IGNyZWF0ZVByaW1pdGl2ZUtleSggcHJpbWl0aXZlICk7XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSd2ZSBhbHJlYWR5IGNyZWF0ZWQgdGhpcyBnZW9tZXRyeVxuXHRcdFx0dmFyIGNhY2hlZCA9IGNhY2hlWyBjYWNoZUtleSBdO1xuXG5cdFx0XHRpZiAoIGNhY2hlZCApIHtcblxuXHRcdFx0XHQvLyBVc2UgdGhlIGNhY2hlZCBnZW9tZXRyeSBpZiBpdCBleGlzdHNcblx0XHRcdFx0cGVuZGluZy5wdXNoKCBjYWNoZWQucHJvbWlzZSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHZhciBnZW9tZXRyeVByb21pc2U7XG5cblx0XHRcdFx0aWYgKCBwcmltaXRpdmUuZXh0ZW5zaW9ucyAmJiBwcmltaXRpdmUuZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTiBdICkge1xuXG5cdFx0XHRcdFx0Ly8gVXNlIERSQUNPIGdlb21ldHJ5IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdGdlb21ldHJ5UHJvbWlzZSA9IGNyZWF0ZURyYWNvUHJpbWl0aXZlKCBwcmltaXRpdmUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBnZW9tZXRyeVxuXHRcdFx0XHRcdGdlb21ldHJ5UHJvbWlzZSA9IGFkZFByaW1pdGl2ZUF0dHJpYnV0ZXMoIG5ldyBCdWZmZXJHZW9tZXRyeSgpLCBwcmltaXRpdmUsIHBhcnNlciApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWNoZSB0aGlzIGdlb21ldHJ5XG5cdFx0XHRcdGNhY2hlWyBjYWNoZUtleSBdID0geyBwcmltaXRpdmU6IHByaW1pdGl2ZSwgcHJvbWlzZTogZ2VvbWV0cnlQcm9taXNlIH07XG5cblx0XHRcdFx0cGVuZGluZy5wdXNoKCBnZW9tZXRyeVByb21pc2UgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nICk7XG5cblx0fTtcblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNtZXNoZXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1lc2hJbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPEdyb3VwfE1lc2h8U2tpbm5lZE1lc2g+fVxuXHQgKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUubG9hZE1lc2ggPSBmdW5jdGlvbiAoIG1lc2hJbmRleCApIHtcblxuXHRcdHZhciBwYXJzZXIgPSB0aGlzO1xuXHRcdHZhciBqc29uID0gdGhpcy5qc29uO1xuXHRcdHZhciBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuXG5cdFx0dmFyIG1lc2hEZWYgPSBqc29uLm1lc2hlc1sgbWVzaEluZGV4IF07XG5cdFx0dmFyIHByaW1pdGl2ZXMgPSBtZXNoRGVmLnByaW1pdGl2ZXM7XG5cblx0XHR2YXIgcGVuZGluZyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHByaW1pdGl2ZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBtYXRlcmlhbCA9IHByaW1pdGl2ZXNbIGkgXS5tYXRlcmlhbCA9PT0gdW5kZWZpbmVkXG5cdFx0XHRcdD8gY3JlYXRlRGVmYXVsdE1hdGVyaWFsKCB0aGlzLmNhY2hlIClcblx0XHRcdFx0OiB0aGlzLmdldERlcGVuZGVuY3koICdtYXRlcmlhbCcsIHByaW1pdGl2ZXNbIGkgXS5tYXRlcmlhbCApO1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIG1hdGVyaWFsICk7XG5cblx0XHR9XG5cblx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5sb2FkR2VvbWV0cmllcyggcHJpbWl0aXZlcyApICk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmcgKS50aGVuKCBmdW5jdGlvbiAoIHJlc3VsdHMgKSB7XG5cblx0XHRcdHZhciBtYXRlcmlhbHMgPSByZXN1bHRzLnNsaWNlKCAwLCByZXN1bHRzLmxlbmd0aCAtIDEgKTtcblx0XHRcdHZhciBnZW9tZXRyaWVzID0gcmVzdWx0c1sgcmVzdWx0cy5sZW5ndGggLSAxIF07XG5cblx0XHRcdHZhciBtZXNoZXMgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gZ2VvbWV0cmllc1sgaSBdO1xuXHRcdFx0XHR2YXIgcHJpbWl0aXZlID0gcHJpbWl0aXZlc1sgaSBdO1xuXG5cdFx0XHRcdC8vIDEuIGNyZWF0ZSBNZXNoXG5cblx0XHRcdFx0dmFyIG1lc2g7XG5cblx0XHRcdFx0dmFyIG1hdGVyaWFsID0gbWF0ZXJpYWxzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFUyB8fFxuXHRcdFx0XHRcdHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfU1RSSVAgfHxcblx0XHRcdFx0XHRwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX0ZBTiB8fFxuXHRcdFx0XHRcdHByaW1pdGl2ZS5tb2RlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHQvLyAuaXNTa2lubmVkTWVzaCBpc24ndCBpbiBnbFRGIHNwZWMuIFNlZSAuX21hcmtEZWZzKClcblx0XHRcdFx0XHRtZXNoID0gbWVzaERlZi5pc1NraW5uZWRNZXNoID09PSB0cnVlXG5cdFx0XHRcdFx0XHQ/IG5ldyBTa2lubmVkTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsIClcblx0XHRcdFx0XHRcdDogbmV3IE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0aWYgKCBtZXNoLmlzU2tpbm5lZE1lc2ggPT09IHRydWUgJiYgISBtZXNoLmdlb21ldHJ5LmF0dHJpYnV0ZXMuc2tpbldlaWdodC5ub3JtYWxpemVkICkge1xuXG5cdFx0XHRcdFx0XHQvLyB3ZSBub3JtYWxpemUgZmxvYXRpbmcgcG9pbnQgc2tpbiB3ZWlnaHQgYXJyYXkgdG8gZml4IG1hbGZvcm1lZCBhc3NldHMgKHNlZSAjMTUzMTkpXG5cdFx0XHRcdFx0XHQvLyBpdCdzIGltcG9ydGFudCB0byBza2lwIHRoaXMgZm9yIG5vbi1mbG9hdDMyIGRhdGEgc2luY2Ugbm9ybWFsaXplU2tpbldlaWdodHMgYXNzdW1lcyBub24tbm9ybWFsaXplZCBpbnB1dHNcblx0XHRcdFx0XHRcdG1lc2gubm9ybWFsaXplU2tpbldlaWdodHMoKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggcHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9TVFJJUCApIHtcblxuXHRcdFx0XHRcdFx0bWVzaC5nZW9tZXRyeSA9IHRvVHJpYW5nbGVzRHJhd01vZGUoIG1lc2guZ2VvbWV0cnksIFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggcHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9GQU4gKSB7XG5cblx0XHRcdFx0XHRcdG1lc2guZ2VvbWV0cnkgPSB0b1RyaWFuZ2xlc0RyYXdNb2RlKCBtZXNoLmdlb21ldHJ5LCBUcmlhbmdsZUZhbkRyYXdNb2RlICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmICggcHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5MSU5FUyApIHtcblxuXHRcdFx0XHRcdG1lc2ggPSBuZXcgTGluZVNlZ21lbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLkxJTkVfU1RSSVAgKSB7XG5cblx0XHRcdFx0XHRtZXNoID0gbmV3IExpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuTElORV9MT09QICkge1xuXG5cdFx0XHRcdFx0bWVzaCA9IG5ldyBMaW5lTG9vcCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggcHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5QT0lOVFMgKSB7XG5cblx0XHRcdFx0XHRtZXNoID0gbmV3IFBvaW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IFByaW1pdGl2ZSBtb2RlIHVuc3VwcG9ydGVkOiAnICsgcHJpbWl0aXZlLm1vZGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBPYmplY3Qua2V5cyggbWVzaC5nZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMgKS5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0dXBkYXRlTW9ycGhUYXJnZXRzKCBtZXNoLCBtZXNoRGVmICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1lc2gubmFtZSA9IHBhcnNlci5jcmVhdGVVbmlxdWVOYW1lKCBtZXNoRGVmLm5hbWUgfHwgKCAnbWVzaF8nICsgbWVzaEluZGV4ICkgKTtcblxuXHRcdFx0XHRhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKCBtZXNoLCBtZXNoRGVmICk7XG5cblx0XHRcdFx0aWYgKCBwcmltaXRpdmUuZXh0ZW5zaW9ucyApIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YSggZXh0ZW5zaW9ucywgbWVzaCwgcHJpbWl0aXZlICk7XG5cblx0XHRcdFx0cGFyc2VyLmFzc2lnbkZpbmFsTWF0ZXJpYWwoIG1lc2ggKTtcblxuXHRcdFx0XHRtZXNoZXMucHVzaCggbWVzaCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWVzaGVzLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdFx0XHRyZXR1cm4gbWVzaGVzWyAwIF07XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGdyb3VwID0gbmV3IEdyb3VwKCk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBtZXNoZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Z3JvdXAuYWRkKCBtZXNoZXNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBncm91cDtcblxuXHRcdH0gKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjY2FtZXJhc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gY2FtZXJhSW5kZXhcblx0ICogQHJldHVybiB7UHJvbWlzZTxUSFJFRS5DYW1lcmE+fVxuXHQgKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUubG9hZENhbWVyYSA9IGZ1bmN0aW9uICggY2FtZXJhSW5kZXggKSB7XG5cblx0XHR2YXIgY2FtZXJhO1xuXHRcdHZhciBjYW1lcmFEZWYgPSB0aGlzLmpzb24uY2FtZXJhc1sgY2FtZXJhSW5kZXggXTtcblx0XHR2YXIgcGFyYW1zID0gY2FtZXJhRGVmWyBjYW1lcmFEZWYudHlwZSBdO1xuXG5cdFx0aWYgKCAhIHBhcmFtcyApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkxvYWRlcjogTWlzc2luZyBjYW1lcmEgcGFyYW1ldGVycy4nICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRpZiAoIGNhbWVyYURlZi50eXBlID09PSAncGVyc3BlY3RpdmUnICkge1xuXG5cdFx0XHRjYW1lcmEgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIE1hdGhVdGlscy5yYWRUb0RlZyggcGFyYW1zLnlmb3YgKSwgcGFyYW1zLmFzcGVjdFJhdGlvIHx8IDEsIHBhcmFtcy56bmVhciB8fCAxLCBwYXJhbXMuemZhciB8fCAyZTYgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGNhbWVyYURlZi50eXBlID09PSAnb3J0aG9ncmFwaGljJyApIHtcblxuXHRcdFx0Y2FtZXJhID0gbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYSggLSBwYXJhbXMueG1hZywgcGFyYW1zLnhtYWcsIHBhcmFtcy55bWFnLCAtIHBhcmFtcy55bWFnLCBwYXJhbXMuem5lYXIsIHBhcmFtcy56ZmFyICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGNhbWVyYURlZi5uYW1lICkgY2FtZXJhLm5hbWUgPSB0aGlzLmNyZWF0ZVVuaXF1ZU5hbWUoIGNhbWVyYURlZi5uYW1lICk7XG5cblx0XHRhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKCBjYW1lcmEsIGNhbWVyYURlZiApO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSggY2FtZXJhICk7XG5cblx0fTtcblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI3NraW5zXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBza2luSW5kZXhcblx0ICogQHJldHVybiB7UHJvbWlzZTxPYmplY3Q+fVxuXHQgKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUubG9hZFNraW4gPSBmdW5jdGlvbiAoIHNraW5JbmRleCApIHtcblxuXHRcdHZhciBza2luRGVmID0gdGhpcy5qc29uLnNraW5zWyBza2luSW5kZXggXTtcblxuXHRcdHZhciBza2luRW50cnkgPSB7IGpvaW50czogc2tpbkRlZi5qb2ludHMgfTtcblxuXHRcdGlmICggc2tpbkRlZi5pbnZlcnNlQmluZE1hdHJpY2VzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoIHNraW5FbnRyeSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jeSggJ2FjY2Vzc29yJywgc2tpbkRlZi5pbnZlcnNlQmluZE1hdHJpY2VzICkudGhlbiggZnVuY3Rpb24gKCBhY2Nlc3NvciApIHtcblxuXHRcdFx0c2tpbkVudHJ5LmludmVyc2VCaW5kTWF0cmljZXMgPSBhY2Nlc3NvcjtcblxuXHRcdFx0cmV0dXJuIHNraW5FbnRyeTtcblxuXHRcdH0gKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjYW5pbWF0aW9uc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gYW5pbWF0aW9uSW5kZXhcblx0ICogQHJldHVybiB7UHJvbWlzZTxBbmltYXRpb25DbGlwPn1cblx0ICovXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLmxvYWRBbmltYXRpb24gPSBmdW5jdGlvbiAoIGFuaW1hdGlvbkluZGV4ICkge1xuXG5cdFx0dmFyIGpzb24gPSB0aGlzLmpzb247XG5cblx0XHR2YXIgYW5pbWF0aW9uRGVmID0ganNvbi5hbmltYXRpb25zWyBhbmltYXRpb25JbmRleCBdO1xuXG5cdFx0dmFyIHBlbmRpbmdOb2RlcyA9IFtdO1xuXHRcdHZhciBwZW5kaW5nSW5wdXRBY2Nlc3NvcnMgPSBbXTtcblx0XHR2YXIgcGVuZGluZ091dHB1dEFjY2Vzc29ycyA9IFtdO1xuXHRcdHZhciBwZW5kaW5nU2FtcGxlcnMgPSBbXTtcblx0XHR2YXIgcGVuZGluZ1RhcmdldHMgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBhbmltYXRpb25EZWYuY2hhbm5lbHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjaGFubmVsID0gYW5pbWF0aW9uRGVmLmNoYW5uZWxzWyBpIF07XG5cdFx0XHR2YXIgc2FtcGxlciA9IGFuaW1hdGlvbkRlZi5zYW1wbGVyc1sgY2hhbm5lbC5zYW1wbGVyIF07XG5cdFx0XHR2YXIgdGFyZ2V0ID0gY2hhbm5lbC50YXJnZXQ7XG5cdFx0XHR2YXIgbmFtZSA9IHRhcmdldC5ub2RlICE9PSB1bmRlZmluZWQgPyB0YXJnZXQubm9kZSA6IHRhcmdldC5pZDsgLy8gTk9URTogdGFyZ2V0LmlkIGlzIGRlcHJlY2F0ZWQuXG5cdFx0XHR2YXIgaW5wdXQgPSBhbmltYXRpb25EZWYucGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkID8gYW5pbWF0aW9uRGVmLnBhcmFtZXRlcnNbIHNhbXBsZXIuaW5wdXQgXSA6IHNhbXBsZXIuaW5wdXQ7XG5cdFx0XHR2YXIgb3V0cHV0ID0gYW5pbWF0aW9uRGVmLnBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCA/IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzWyBzYW1wbGVyLm91dHB1dCBdIDogc2FtcGxlci5vdXRwdXQ7XG5cblx0XHRcdHBlbmRpbmdOb2Rlcy5wdXNoKCB0aGlzLmdldERlcGVuZGVuY3koICdub2RlJywgbmFtZSApICk7XG5cdFx0XHRwZW5kaW5nSW5wdXRBY2Nlc3NvcnMucHVzaCggdGhpcy5nZXREZXBlbmRlbmN5KCAnYWNjZXNzb3InLCBpbnB1dCApICk7XG5cdFx0XHRwZW5kaW5nT3V0cHV0QWNjZXNzb3JzLnB1c2goIHRoaXMuZ2V0RGVwZW5kZW5jeSggJ2FjY2Vzc29yJywgb3V0cHV0ICkgKTtcblx0XHRcdHBlbmRpbmdTYW1wbGVycy5wdXNoKCBzYW1wbGVyICk7XG5cdFx0XHRwZW5kaW5nVGFyZ2V0cy5wdXNoKCB0YXJnZXQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggW1xuXG5cdFx0XHRQcm9taXNlLmFsbCggcGVuZGluZ05vZGVzICksXG5cdFx0XHRQcm9taXNlLmFsbCggcGVuZGluZ0lucHV0QWNjZXNzb3JzICksXG5cdFx0XHRQcm9taXNlLmFsbCggcGVuZGluZ091dHB1dEFjY2Vzc29ycyApLFxuXHRcdFx0UHJvbWlzZS5hbGwoIHBlbmRpbmdTYW1wbGVycyApLFxuXHRcdFx0UHJvbWlzZS5hbGwoIHBlbmRpbmdUYXJnZXRzIClcblxuXHRcdF0gKS50aGVuKCBmdW5jdGlvbiAoIGRlcGVuZGVuY2llcyApIHtcblxuXHRcdFx0dmFyIG5vZGVzID0gZGVwZW5kZW5jaWVzWyAwIF07XG5cdFx0XHR2YXIgaW5wdXRBY2Nlc3NvcnMgPSBkZXBlbmRlbmNpZXNbIDEgXTtcblx0XHRcdHZhciBvdXRwdXRBY2Nlc3NvcnMgPSBkZXBlbmRlbmNpZXNbIDIgXTtcblx0XHRcdHZhciBzYW1wbGVycyA9IGRlcGVuZGVuY2llc1sgMyBdO1xuXHRcdFx0dmFyIHRhcmdldHMgPSBkZXBlbmRlbmNpZXNbIDQgXTtcblxuXHRcdFx0dmFyIHRyYWNrcyA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbm9kZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIG5vZGUgPSBub2Rlc1sgaSBdO1xuXHRcdFx0XHR2YXIgaW5wdXRBY2Nlc3NvciA9IGlucHV0QWNjZXNzb3JzWyBpIF07XG5cdFx0XHRcdHZhciBvdXRwdXRBY2Nlc3NvciA9IG91dHB1dEFjY2Vzc29yc1sgaSBdO1xuXHRcdFx0XHR2YXIgc2FtcGxlciA9IHNhbXBsZXJzWyBpIF07XG5cdFx0XHRcdHZhciB0YXJnZXQgPSB0YXJnZXRzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBub2RlID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcblxuXHRcdFx0XHRub2RlLnVwZGF0ZU1hdHJpeCgpO1xuXHRcdFx0XHRub2RlLm1hdHJpeEF1dG9VcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdHZhciBUeXBlZEtleWZyYW1lVHJhY2s7XG5cblx0XHRcdFx0c3dpdGNoICggUEFUSF9QUk9QRVJUSUVTWyB0YXJnZXQucGF0aCBdICkge1xuXG5cdFx0XHRcdFx0Y2FzZSBQQVRIX1BST1BFUlRJRVMud2VpZ2h0czpcblxuXHRcdFx0XHRcdFx0VHlwZWRLZXlmcmFtZVRyYWNrID0gTnVtYmVyS2V5ZnJhbWVUcmFjaztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBQQVRIX1BST1BFUlRJRVMucm90YXRpb246XG5cblx0XHRcdFx0XHRcdFR5cGVkS2V5ZnJhbWVUcmFjayA9IFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFBBVEhfUFJPUEVSVElFUy5wb3NpdGlvbjpcblx0XHRcdFx0XHRjYXNlIFBBVEhfUFJPUEVSVElFUy5zY2FsZTpcblx0XHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0XHRUeXBlZEtleWZyYW1lVHJhY2sgPSBWZWN0b3JLZXlmcmFtZVRyYWNrO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB0YXJnZXROYW1lID0gbm9kZS5uYW1lID8gbm9kZS5uYW1lIDogbm9kZS51dWlkO1xuXG5cdFx0XHRcdHZhciBpbnRlcnBvbGF0aW9uID0gc2FtcGxlci5pbnRlcnBvbGF0aW9uICE9PSB1bmRlZmluZWQgPyBJTlRFUlBPTEFUSU9OWyBzYW1wbGVyLmludGVycG9sYXRpb24gXSA6IEludGVycG9sYXRlTGluZWFyO1xuXG5cdFx0XHRcdHZhciB0YXJnZXROYW1lcyA9IFtdO1xuXG5cdFx0XHRcdGlmICggUEFUSF9QUk9QRVJUSUVTWyB0YXJnZXQucGF0aCBdID09PSBQQVRIX1BST1BFUlRJRVMud2VpZ2h0cyApIHtcblxuXHRcdFx0XHRcdC8vIE5vZGUgbWF5IGJlIGEgR3JvdXAgKGdsVEYgbWVzaCB3aXRoIHNldmVyYWwgcHJpbWl0aXZlcykgb3IgYSBNZXNoLlxuXHRcdFx0XHRcdG5vZGUudHJhdmVyc2UoIGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG9iamVjdC5pc01lc2ggPT09IHRydWUgJiYgb2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyApIHtcblxuXHRcdFx0XHRcdFx0XHR0YXJnZXROYW1lcy5wdXNoKCBvYmplY3QubmFtZSA/IG9iamVjdC5uYW1lIDogb2JqZWN0LnV1aWQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0YXJnZXROYW1lcy5wdXNoKCB0YXJnZXROYW1lICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBvdXRwdXRBcnJheSA9IG91dHB1dEFjY2Vzc29yLmFycmF5O1xuXG5cdFx0XHRcdGlmICggb3V0cHV0QWNjZXNzb3Iubm9ybWFsaXplZCApIHtcblxuXHRcdFx0XHRcdHZhciBzY2FsZTtcblxuXHRcdFx0XHRcdGlmICggb3V0cHV0QXJyYXkuY29uc3RydWN0b3IgPT09IEludDhBcnJheSApIHtcblxuXHRcdFx0XHRcdFx0c2NhbGUgPSAxIC8gMTI3O1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggb3V0cHV0QXJyYXkuY29uc3RydWN0b3IgPT09IFVpbnQ4QXJyYXkgKSB7XG5cblx0XHRcdFx0XHRcdHNjYWxlID0gMSAvIDI1NTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIG91dHB1dEFycmF5LmNvbnN0cnVjdG9yID09IEludDE2QXJyYXkgKSB7XG5cblx0XHRcdFx0XHRcdHNjYWxlID0gMSAvIDMyNzY3O1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggb3V0cHV0QXJyYXkuY29uc3RydWN0b3IgPT09IFVpbnQxNkFycmF5ICkge1xuXG5cdFx0XHRcdFx0XHRzY2FsZSA9IDEgLyA2NTUzNTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIG91dHB1dCBhY2Nlc3NvciBjb21wb25lbnQgdHlwZS4nICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgc2NhbGVkID0gbmV3IEZsb2F0MzJBcnJheSggb3V0cHV0QXJyYXkubGVuZ3RoICk7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gb3V0cHV0QXJyYXkubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdHNjYWxlZFsgaiBdID0gb3V0cHV0QXJyYXlbIGogXSAqIHNjYWxlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0QXJyYXkgPSBzY2FsZWQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSB0YXJnZXROYW1lcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdHZhciB0cmFjayA9IG5ldyBUeXBlZEtleWZyYW1lVHJhY2soXG5cdFx0XHRcdFx0XHR0YXJnZXROYW1lc1sgaiBdICsgJy4nICsgUEFUSF9QUk9QRVJUSUVTWyB0YXJnZXQucGF0aCBdLFxuXHRcdFx0XHRcdFx0aW5wdXRBY2Nlc3Nvci5hcnJheSxcblx0XHRcdFx0XHRcdG91dHB1dEFycmF5LFxuXHRcdFx0XHRcdFx0aW50ZXJwb2xhdGlvblxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHQvLyBPdmVycmlkZSBpbnRlcnBvbGF0aW9uIHdpdGggY3VzdG9tIGZhY3RvcnkgbWV0aG9kLlxuXHRcdFx0XHRcdGlmICggc2FtcGxlci5pbnRlcnBvbGF0aW9uID09PSAnQ1VCSUNTUExJTkUnICkge1xuXG5cdFx0XHRcdFx0XHR0cmFjay5jcmVhdGVJbnRlcnBvbGFudCA9IGZ1bmN0aW9uIEludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZSggcmVzdWx0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgQ1VCSUNTUExJTkUga2V5ZnJhbWUgaW4gZ2xURiBoYXMgdGhyZWUgb3V0cHV0IHZhbHVlcyBmb3IgZWFjaCBpbnB1dCB2YWx1ZSxcblx0XHRcdFx0XHRcdFx0Ly8gcmVwcmVzZW50aW5nIGluVGFuZ2VudCwgc3BsaW5lVmVydGV4LCBhbmQgb3V0VGFuZ2VudC4gQXMgYSByZXN1bHQsIHRyYWNrLmdldFZhbHVlU2l6ZSgpXG5cdFx0XHRcdFx0XHRcdC8vIG11c3QgYmUgZGl2aWRlZCBieSB0aHJlZSB0byBnZXQgdGhlIGludGVycG9sYW50J3Mgc2FtcGxlU2l6ZSBhcmd1bWVudC5cblxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbmV3IEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50KCB0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSAvIDMsIHJlc3VsdCApO1xuXG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHQvLyBNYXJrIGFzIENVQklDU1BMSU5FLiBgdHJhY2suZ2V0SW50ZXJwb2xhdGlvbigpYCBkb2Vzbid0IHN1cHBvcnQgY3VzdG9tIGludGVycG9sYW50cy5cblx0XHRcdFx0XHRcdHRyYWNrLmNyZWF0ZUludGVycG9sYW50LmlzSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kR0xURkN1YmljU3BsaW5lID0gdHJ1ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRyYWNrcy5wdXNoKCB0cmFjayApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbmFtZSA9IGFuaW1hdGlvbkRlZi5uYW1lID8gYW5pbWF0aW9uRGVmLm5hbWUgOiAnYW5pbWF0aW9uXycgKyBhbmltYXRpb25JbmRleDtcblxuXHRcdFx0cmV0dXJuIG5ldyBBbmltYXRpb25DbGlwKCBuYW1lLCB1bmRlZmluZWQsIHRyYWNrcyApO1xuXG5cdFx0fSApO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNub2Rlcy1hbmQtaGllcmFyY2h5XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBub2RlSW5kZXhcblx0ICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QzRD59XG5cdCAqL1xuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5sb2FkTm9kZSA9IGZ1bmN0aW9uICggbm9kZUluZGV4ICkge1xuXG5cdFx0dmFyIGpzb24gPSB0aGlzLmpzb247XG5cdFx0dmFyIGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG5cdFx0dmFyIHBhcnNlciA9IHRoaXM7XG5cblx0XHR2YXIgbm9kZURlZiA9IGpzb24ubm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0Ly8gcmVzZXJ2ZSBub2RlJ3MgbmFtZSBiZWZvcmUgaXRzIGRlcGVuZGVuY2llcywgc28gdGhlIHJvb3QgaGFzIHRoZSBpbnRlbmRlZCBuYW1lLlxuXHRcdHZhciBub2RlTmFtZSA9IG5vZGVEZWYubmFtZSA/IHBhcnNlci5jcmVhdGVVbmlxdWVOYW1lKCBub2RlRGVmLm5hbWUgKSA6ICcnO1xuXG5cdFx0cmV0dXJuICggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgcGVuZGluZyA9IFtdO1xuXG5cdFx0XHRpZiAoIG5vZGVEZWYubWVzaCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmdldERlcGVuZGVuY3koICdtZXNoJywgbm9kZURlZi5tZXNoICkudGhlbiggZnVuY3Rpb24gKCBtZXNoICkge1xuXG5cdFx0XHRcdFx0dmFyIG5vZGUgPSBwYXJzZXIuX2dldE5vZGVSZWYoIHBhcnNlci5tZXNoQ2FjaGUsIG5vZGVEZWYubWVzaCwgbWVzaCApO1xuXG5cdFx0XHRcdFx0Ly8gaWYgd2VpZ2h0cyBhcmUgcHJvdmlkZWQgb24gdGhlIG5vZGUsIG92ZXJyaWRlIHdlaWdodHMgb24gdGhlIG1lc2guXG5cdFx0XHRcdFx0aWYgKCBub2RlRGVmLndlaWdodHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0bm9kZS50cmF2ZXJzZSggZnVuY3Rpb24gKCBvICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggISBvLmlzTWVzaCApIHJldHVybjtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbm9kZURlZi53ZWlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0by5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXSA9IG5vZGVEZWYud2VpZ2h0c1sgaSBdO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cblx0XHRcdFx0fSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBub2RlRGVmLmNhbWVyYSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmdldERlcGVuZGVuY3koICdjYW1lcmEnLCBub2RlRGVmLmNhbWVyYSApLnRoZW4oIGZ1bmN0aW9uICggY2FtZXJhICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlci5fZ2V0Tm9kZVJlZiggcGFyc2VyLmNhbWVyYUNhY2hlLCBub2RlRGVmLmNhbWVyYSwgY2FtZXJhICk7XG5cblx0XHRcdFx0fSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cGFyc2VyLl9pbnZva2VBbGwoIGZ1bmN0aW9uICggZXh0ICkge1xuXG5cdFx0XHRcdHJldHVybiBleHQuY3JlYXRlTm9kZUF0dGFjaG1lbnQgJiYgZXh0LmNyZWF0ZU5vZGVBdHRhY2htZW50KCBub2RlSW5kZXggKTtcblxuXHRcdFx0fSApLmZvckVhY2goIGZ1bmN0aW9uICggcHJvbWlzZSApIHtcblxuXHRcdFx0XHRwZW5kaW5nLnB1c2goIHByb21pc2UgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmcgKTtcblxuXHRcdH0oKSApLnRoZW4oIGZ1bmN0aW9uICggb2JqZWN0cyApIHtcblxuXHRcdFx0dmFyIG5vZGU7XG5cblx0XHRcdC8vIC5pc0JvbmUgaXNuJ3QgaW4gZ2xURiBzcGVjLiBTZWUgLl9tYXJrRGVmc1xuXHRcdFx0aWYgKCBub2RlRGVmLmlzQm9uZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRub2RlID0gbmV3IEJvbmUoKTtcblxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0cy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRcdG5vZGUgPSBuZXcgR3JvdXAoKTtcblxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0cy5sZW5ndGggPT09IDEgKSB7XG5cblx0XHRcdFx0bm9kZSA9IG9iamVjdHNbIDAgXTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRub2RlID0gbmV3IE9iamVjdDNEKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBub2RlICE9PSBvYmplY3RzWyAwIF0gKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRub2RlLmFkZCggb2JqZWN0c1sgaSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbm9kZURlZi5uYW1lICkge1xuXG5cdFx0XHRcdG5vZGUudXNlckRhdGEubmFtZSA9IG5vZGVEZWYubmFtZTtcblx0XHRcdFx0bm9kZS5uYW1lID0gbm9kZU5hbWU7XG5cblx0XHRcdH1cblxuXHRcdFx0YXNzaWduRXh0cmFzVG9Vc2VyRGF0YSggbm9kZSwgbm9kZURlZiApO1xuXG5cdFx0XHRpZiAoIG5vZGVEZWYuZXh0ZW5zaW9ucyApIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YSggZXh0ZW5zaW9ucywgbm9kZSwgbm9kZURlZiApO1xuXG5cdFx0XHRpZiAoIG5vZGVEZWYubWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dmFyIG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0XHRcdG1hdHJpeC5mcm9tQXJyYXkoIG5vZGVEZWYubWF0cml4ICk7XG5cdFx0XHRcdG5vZGUuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoIG5vZGVEZWYudHJhbnNsYXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdG5vZGUucG9zaXRpb24uZnJvbUFycmF5KCBub2RlRGVmLnRyYW5zbGF0aW9uICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbm9kZURlZi5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0bm9kZS5xdWF0ZXJuaW9uLmZyb21BcnJheSggbm9kZURlZi5yb3RhdGlvbiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG5vZGVEZWYuc2NhbGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdG5vZGUuc2NhbGUuZnJvbUFycmF5KCBub2RlRGVmLnNjYWxlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KCBub2RlLCB7IHR5cGU6ICdub2RlcycsIGluZGV4OiBub2RlSW5kZXggfSApO1xuXG5cdFx0XHRyZXR1cm4gbm9kZTtcblxuXHRcdH0gKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjc2NlbmVzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzY2VuZUluZGV4XG5cdCAqIEByZXR1cm4ge1Byb21pc2U8R3JvdXA+fVxuXHQgKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUubG9hZFNjZW5lID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gc2NlbmUgbm9kZSBoaWVyYWNoeSBidWlsZGVyXG5cblx0XHRmdW5jdGlvbiBidWlsZE5vZGVIaWVyYWNoeSggbm9kZUlkLCBwYXJlbnRPYmplY3QsIGpzb24sIHBhcnNlciApIHtcblxuXHRcdFx0dmFyIG5vZGVEZWYgPSBqc29uLm5vZGVzWyBub2RlSWQgXTtcblxuXHRcdFx0cmV0dXJuIHBhcnNlci5nZXREZXBlbmRlbmN5KCAnbm9kZScsIG5vZGVJZCApLnRoZW4oIGZ1bmN0aW9uICggbm9kZSApIHtcblxuXHRcdFx0XHRpZiAoIG5vZGVEZWYuc2tpbiA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIG5vZGU7XG5cblx0XHRcdFx0Ly8gYnVpbGQgc2tlbGV0b24gaGVyZSBhcyB3ZWxsXG5cblx0XHRcdFx0dmFyIHNraW5FbnRyeTtcblxuXHRcdFx0XHRyZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3koICdza2luJywgbm9kZURlZi5za2luICkudGhlbiggZnVuY3Rpb24gKCBza2luICkge1xuXG5cdFx0XHRcdFx0c2tpbkVudHJ5ID0gc2tpbjtcblxuXHRcdFx0XHRcdHZhciBwZW5kaW5nSm9pbnRzID0gW107XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc2tpbkVudHJ5LmpvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0cGVuZGluZ0pvaW50cy5wdXNoKCBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ25vZGUnLCBza2luRW50cnkuam9pbnRzWyBpIF0gKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nSm9pbnRzICk7XG5cblx0XHRcdFx0fSApLnRoZW4oIGZ1bmN0aW9uICggam9pbnROb2RlcyApIHtcblxuXHRcdFx0XHRcdG5vZGUudHJhdmVyc2UoIGZ1bmN0aW9uICggbWVzaCApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCAhIG1lc2guaXNNZXNoICkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0XHR2YXIgYm9uZXMgPSBbXTtcblx0XHRcdFx0XHRcdHZhciBib25lSW52ZXJzZXMgPSBbXTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGpvaW50Tm9kZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIGpvaW50Tm9kZSA9IGpvaW50Tm9kZXNbIGogXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGpvaW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGJvbmVzLnB1c2goIGpvaW50Tm9kZSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFyIG1hdCA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIHNraW5FbnRyeS5pbnZlcnNlQmluZE1hdHJpY2VzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdG1hdC5mcm9tQXJyYXkoIHNraW5FbnRyeS5pbnZlcnNlQmluZE1hdHJpY2VzLmFycmF5LCBqICogMTYgKTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdGJvbmVJbnZlcnNlcy5wdXNoKCBtYXQgKTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkxvYWRlcjogSm9pbnQgXCIlc1wiIGNvdWxkIG5vdCBiZSBmb3VuZC4nLCBza2luRW50cnkuam9pbnRzWyBqIF0gKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0bWVzaC5iaW5kKCBuZXcgU2tlbGV0b24oIGJvbmVzLCBib25lSW52ZXJzZXMgKSwgbWVzaC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9ICkudGhlbiggZnVuY3Rpb24gKCBub2RlICkge1xuXG5cdFx0XHRcdC8vIGJ1aWxkIG5vZGUgaGllcmFjaHlcblxuXHRcdFx0XHRwYXJlbnRPYmplY3QuYWRkKCBub2RlICk7XG5cblx0XHRcdFx0dmFyIHBlbmRpbmcgPSBbXTtcblxuXHRcdFx0XHRpZiAoIG5vZGVEZWYuY2hpbGRyZW4gKSB7XG5cblx0XHRcdFx0XHR2YXIgY2hpbGRyZW4gPSBub2RlRGVmLmNoaWxkcmVuO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlblsgaSBdO1xuXHRcdFx0XHRcdFx0cGVuZGluZy5wdXNoKCBidWlsZE5vZGVIaWVyYWNoeSggY2hpbGQsIG5vZGUsIGpzb24sIHBhcnNlciApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gbG9hZFNjZW5lKCBzY2VuZUluZGV4ICkge1xuXG5cdFx0XHR2YXIganNvbiA9IHRoaXMuanNvbjtcblx0XHRcdHZhciBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuXHRcdFx0dmFyIHNjZW5lRGVmID0gdGhpcy5qc29uLnNjZW5lc1sgc2NlbmVJbmRleCBdO1xuXHRcdFx0dmFyIHBhcnNlciA9IHRoaXM7XG5cblx0XHRcdC8vIExvYWRlciByZXR1cm5zIEdyb3VwLCBub3QgU2NlbmUuXG5cdFx0XHQvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzE4MzQyI2lzc3VlY29tbWVudC01Nzg5ODExNzJcblx0XHRcdHZhciBzY2VuZSA9IG5ldyBHcm91cCgpO1xuXHRcdFx0aWYgKCBzY2VuZURlZi5uYW1lICkgc2NlbmUubmFtZSA9IHBhcnNlci5jcmVhdGVVbmlxdWVOYW1lKCBzY2VuZURlZi5uYW1lICk7XG5cblx0XHRcdGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoIHNjZW5lLCBzY2VuZURlZiApO1xuXG5cdFx0XHRpZiAoIHNjZW5lRGVmLmV4dGVuc2lvbnMgKSBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoIGV4dGVuc2lvbnMsIHNjZW5lLCBzY2VuZURlZiApO1xuXG5cdFx0XHR2YXIgbm9kZUlkcyA9IHNjZW5lRGVmLm5vZGVzIHx8IFtdO1xuXG5cdFx0XHR2YXIgcGVuZGluZyA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbm9kZUlkcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRwZW5kaW5nLnB1c2goIGJ1aWxkTm9kZUhpZXJhY2h5KCBub2RlSWRzWyBpIF0sIHNjZW5lLCBqc29uLCBwYXJzZXIgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApLnRoZW4oIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRyZXR1cm4gc2NlbmU7XG5cblx0XHRcdH0gKTtcblxuXHRcdH07XG5cblx0fSgpO1xuXG5cdHJldHVybiBHTFRGTG9hZGVyO1xuXG59ICkoKTtcblxudmFyIFRHQUxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuXHRMb2FkZXIkMS5jYWxsKCB0aGlzLCBtYW5hZ2VyICk7XG5cbn07XG5cblRHQUxvYWRlci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMb2FkZXIkMS5wcm90b3R5cGUgKSwge1xuXG5cdGNvbnN0cnVjdG9yOiBUR0FMb2FkZXIsXG5cblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHR2YXIgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKCk7XG5cblx0XHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcblx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcblxuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG5cdFx0XHR0ZXh0dXJlLmltYWdlID0gc2NvcGUucGFyc2UoIGJ1ZmZlciApO1xuXHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdGlmICggb25Mb2FkICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0b25Mb2FkKCB0ZXh0dXJlICk7XG5cblx0XHRcdH1cblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdH0sXG5cblx0cGFyc2U6IGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG5cdFx0Ly8gcmVmZXJlbmNlIGZyb20gdnRoaWJhdWx0LCBodHRwczovL2dpdGh1Yi5jb20vdnRoaWJhdWx0L3JvQnJvd3Nlci9ibG9iL21hc3Rlci9zcmMvTG9hZGVycy9UYXJnYS5qc1xuXG5cdFx0ZnVuY3Rpb24gdGdhQ2hlY2tIZWFkZXIoIGhlYWRlciApIHtcblxuXHRcdFx0c3dpdGNoICggaGVhZGVyLmltYWdlX3R5cGUgKSB7XG5cblx0XHRcdFx0Ly8gY2hlY2sgaW5kZXhlZCB0eXBlXG5cblx0XHRcdFx0Y2FzZSBUR0FfVFlQRV9JTkRFWEVEOlxuXHRcdFx0XHRjYXNlIFRHQV9UWVBFX1JMRV9JTkRFWEVEOlxuXHRcdFx0XHRcdGlmICggaGVhZGVyLmNvbG9ybWFwX2xlbmd0aCA+IDI1NiB8fCBoZWFkZXIuY29sb3JtYXBfc2l6ZSAhPT0gMjQgfHwgaGVhZGVyLmNvbG9ybWFwX3R5cGUgIT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5UR0FMb2FkZXI6IEludmFsaWQgdHlwZSBjb2xvcm1hcCBkYXRhIGZvciBpbmRleGVkIHR5cGUuJyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHQvLyBjaGVjayBjb2xvcm1hcCB0eXBlXG5cblx0XHRcdFx0Y2FzZSBUR0FfVFlQRV9SR0I6XG5cdFx0XHRcdGNhc2UgVEdBX1RZUEVfR1JFWTpcblx0XHRcdFx0Y2FzZSBUR0FfVFlQRV9STEVfUkdCOlxuXHRcdFx0XHRjYXNlIFRHQV9UWVBFX1JMRV9HUkVZOlxuXHRcdFx0XHRcdGlmICggaGVhZGVyLmNvbG9ybWFwX3R5cGUgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5UR0FMb2FkZXI6IEludmFsaWQgdHlwZSBjb2xvcm1hcCBkYXRhIGZvciBjb2xvcm1hcCB0eXBlLicgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Ly8gV2hhdCB0aGUgbmVlZCBvZiBhIGZpbGUgd2l0aG91dCBkYXRhID9cblxuXHRcdFx0XHRjYXNlIFRHQV9UWVBFX05PX0RBVEE6XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlRHQUxvYWRlcjogTm8gZGF0YS4nICk7XG5cblx0XHRcdFx0XHQvLyBJbnZhbGlkIHR5cGUgP1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlRHQUxvYWRlcjogSW52YWxpZCB0eXBlIFwiJXNcIi4nLCBoZWFkZXIuaW1hZ2VfdHlwZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGNoZWNrIGltYWdlIHdpZHRoIGFuZCBoZWlnaHRcblxuXHRcdFx0aWYgKCBoZWFkZXIud2lkdGggPD0gMCB8fCBoZWFkZXIuaGVpZ2h0IDw9IDAgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlRHQUxvYWRlcjogSW52YWxpZCBpbWFnZSBzaXplLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjaGVjayBpbWFnZSBwaXhlbCBzaXplXG5cblx0XHRcdGlmICggaGVhZGVyLnBpeGVsX3NpemUgIT09IDggJiYgaGVhZGVyLnBpeGVsX3NpemUgIT09IDE2ICYmXG5cdFx0XHRcdGhlYWRlci5waXhlbF9zaXplICE9PSAyNCAmJiBoZWFkZXIucGl4ZWxfc2l6ZSAhPT0gMzIgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlRHQUxvYWRlcjogSW52YWxpZCBwaXhlbCBzaXplIFwiJXNcIi4nLCBoZWFkZXIucGl4ZWxfc2l6ZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBwYXJzZSB0Z2EgaW1hZ2UgYnVmZmVyXG5cblx0XHRmdW5jdGlvbiB0Z2FQYXJzZSggdXNlX3JsZSwgdXNlX3BhbCwgaGVhZGVyLCBvZmZzZXQsIGRhdGEgKSB7XG5cblx0XHRcdHZhciBwaXhlbF9kYXRhLFxuXHRcdFx0XHRwaXhlbF9zaXplLFxuXHRcdFx0XHRwaXhlbF90b3RhbCxcblx0XHRcdFx0cGFsZXR0ZXM7XG5cblx0XHRcdHBpeGVsX3NpemUgPSBoZWFkZXIucGl4ZWxfc2l6ZSA+PiAzO1xuXHRcdFx0cGl4ZWxfdG90YWwgPSBoZWFkZXIud2lkdGggKiBoZWFkZXIuaGVpZ2h0ICogcGl4ZWxfc2l6ZTtcblxuXHRcdFx0IC8vIHJlYWQgcGFsZXR0ZXNcblxuXHRcdFx0IGlmICggdXNlX3BhbCApIHtcblxuXHRcdFx0XHQgcGFsZXR0ZXMgPSBkYXRhLnN1YmFycmF5KCBvZmZzZXQsIG9mZnNldCArPSBoZWFkZXIuY29sb3JtYXBfbGVuZ3RoICogKCBoZWFkZXIuY29sb3JtYXBfc2l6ZSA+PiAzICkgKTtcblxuXHRcdFx0IH1cblxuXHRcdFx0IC8vIHJlYWQgUkxFXG5cblx0XHRcdCBpZiAoIHVzZV9ybGUgKSB7XG5cblx0XHRcdFx0IHBpeGVsX2RhdGEgPSBuZXcgVWludDhBcnJheSggcGl4ZWxfdG90YWwgKTtcblxuXHRcdFx0XHR2YXIgYywgY291bnQsIGk7XG5cdFx0XHRcdHZhciBzaGlmdCA9IDA7XG5cdFx0XHRcdHZhciBwaXhlbHMgPSBuZXcgVWludDhBcnJheSggcGl4ZWxfc2l6ZSApO1xuXG5cdFx0XHRcdHdoaWxlICggc2hpZnQgPCBwaXhlbF90b3RhbCApIHtcblxuXHRcdFx0XHRcdGMgPSBkYXRhWyBvZmZzZXQgKysgXTtcblx0XHRcdFx0XHRjb3VudCA9ICggYyAmIDB4N2YgKSArIDE7XG5cblx0XHRcdFx0XHQvLyBSTEUgcGl4ZWxzXG5cblx0XHRcdFx0XHRpZiAoIGMgJiAweDgwICkge1xuXG5cdFx0XHRcdFx0XHQvLyBiaW5kIHBpeGVsIHRtcCBhcnJheVxuXG5cdFx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IHBpeGVsX3NpemU7ICsrIGkgKSB7XG5cblx0XHRcdFx0XHRcdFx0cGl4ZWxzWyBpIF0gPSBkYXRhWyBvZmZzZXQgKysgXTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBjb3B5IHBpeGVsIGFycmF5XG5cblx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgY291bnQ7ICsrIGkgKSB7XG5cblx0XHRcdFx0XHRcdFx0cGl4ZWxfZGF0YS5zZXQoIHBpeGVscywgc2hpZnQgKyBpICogcGl4ZWxfc2l6ZSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHNoaWZ0ICs9IHBpeGVsX3NpemUgKiBjb3VudDtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIHJhdyBwaXhlbHNcblxuXHRcdFx0XHRcdFx0Y291bnQgKj0gcGl4ZWxfc2l6ZTtcblxuXHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBjb3VudDsgKysgaSApIHtcblxuXHRcdFx0XHRcdFx0XHRwaXhlbF9kYXRhWyBzaGlmdCArIGkgXSA9IGRhdGFbIG9mZnNldCArKyBdO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHNoaWZ0ICs9IGNvdW50O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0IH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gcmF3IHBpeGVsc1xuXG5cdFx0XHRcdHBpeGVsX2RhdGEgPSBkYXRhLnN1YmFycmF5KFxuXHRcdFx0XHRcdCBvZmZzZXQsIG9mZnNldCArPSAoIHVzZV9wYWwgPyBoZWFkZXIud2lkdGggKiBoZWFkZXIuaGVpZ2h0IDogcGl4ZWxfdG90YWwgKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHQgfVxuXG5cdFx0XHQgcmV0dXJuIHtcblx0XHRcdFx0cGl4ZWxfZGF0YTogcGl4ZWxfZGF0YSxcblx0XHRcdFx0cGFsZXR0ZXM6IHBhbGV0dGVzXG5cdFx0XHQgfTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRnYUdldEltYWdlRGF0YThiaXRzKCBpbWFnZURhdGEsIHlfc3RhcnQsIHlfc3RlcCwgeV9lbmQsIHhfc3RhcnQsIHhfc3RlcCwgeF9lbmQsIGltYWdlLCBwYWxldHRlcyApIHtcblxuXHRcdFx0dmFyIGNvbG9ybWFwID0gcGFsZXR0ZXM7XG5cdFx0XHR2YXIgY29sb3IsIGkgPSAwLCB4LCB5O1xuXHRcdFx0dmFyIHdpZHRoID0gaGVhZGVyLndpZHRoO1xuXG5cdFx0XHRmb3IgKCB5ID0geV9zdGFydDsgeSAhPT0geV9lbmQ7IHkgKz0geV9zdGVwICkge1xuXG5cdFx0XHRcdGZvciAoIHggPSB4X3N0YXJ0OyB4ICE9PSB4X2VuZDsgeCArPSB4X3N0ZXAsIGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb2xvciA9IGltYWdlWyBpIF07XG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAzIF0gPSAyNTU7XG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAyIF0gPSBjb2xvcm1hcFsgKCBjb2xvciAqIDMgKSArIDAgXTtcblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDEgXSA9IGNvbG9ybWFwWyAoIGNvbG9yICogMyApICsgMSBdO1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMCBdID0gY29sb3JtYXBbICggY29sb3IgKiAzICkgKyAyIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpbWFnZURhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0Z2FHZXRJbWFnZURhdGExNmJpdHMoIGltYWdlRGF0YSwgeV9zdGFydCwgeV9zdGVwLCB5X2VuZCwgeF9zdGFydCwgeF9zdGVwLCB4X2VuZCwgaW1hZ2UgKSB7XG5cblx0XHRcdHZhciBjb2xvciwgaSA9IDAsIHgsIHk7XG5cdFx0XHR2YXIgd2lkdGggPSBoZWFkZXIud2lkdGg7XG5cblx0XHRcdGZvciAoIHkgPSB5X3N0YXJ0OyB5ICE9PSB5X2VuZDsgeSArPSB5X3N0ZXAgKSB7XG5cblx0XHRcdFx0Zm9yICggeCA9IHhfc3RhcnQ7IHggIT09IHhfZW5kOyB4ICs9IHhfc3RlcCwgaSArPSAyICkge1xuXG5cdFx0XHRcdFx0Y29sb3IgPSBpbWFnZVsgaSArIDAgXSArICggaW1hZ2VbIGkgKyAxIF0gPDwgOCApOyAvLyBJbnZlcnNlZCA/XG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAwIF0gPSAoIGNvbG9yICYgMHg3QzAwICkgPj4gNztcblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDEgXSA9ICggY29sb3IgJiAweDAzRTAgKSA+PiAyO1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMiBdID0gKCBjb2xvciAmIDB4MDAxRiApID4+IDM7XG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAzIF0gPSAoIGNvbG9yICYgMHg4MDAwICkgPyAwIDogMjU1O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaW1hZ2VEYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdGdhR2V0SW1hZ2VEYXRhMjRiaXRzKCBpbWFnZURhdGEsIHlfc3RhcnQsIHlfc3RlcCwgeV9lbmQsIHhfc3RhcnQsIHhfc3RlcCwgeF9lbmQsIGltYWdlICkge1xuXG5cdFx0XHR2YXIgaSA9IDAsIHgsIHk7XG5cdFx0XHR2YXIgd2lkdGggPSBoZWFkZXIud2lkdGg7XG5cblx0XHRcdGZvciAoIHkgPSB5X3N0YXJ0OyB5ICE9PSB5X2VuZDsgeSArPSB5X3N0ZXAgKSB7XG5cblx0XHRcdFx0Zm9yICggeCA9IHhfc3RhcnQ7IHggIT09IHhfZW5kOyB4ICs9IHhfc3RlcCwgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAzIF0gPSAyNTU7XG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAyIF0gPSBpbWFnZVsgaSArIDAgXTtcblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDEgXSA9IGltYWdlWyBpICsgMSBdO1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMCBdID0gaW1hZ2VbIGkgKyAyIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpbWFnZURhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0Z2FHZXRJbWFnZURhdGEzMmJpdHMoIGltYWdlRGF0YSwgeV9zdGFydCwgeV9zdGVwLCB5X2VuZCwgeF9zdGFydCwgeF9zdGVwLCB4X2VuZCwgaW1hZ2UgKSB7XG5cblx0XHRcdHZhciBpID0gMCwgeCwgeTtcblx0XHRcdHZhciB3aWR0aCA9IGhlYWRlci53aWR0aDtcblxuXHRcdFx0Zm9yICggeSA9IHlfc3RhcnQ7IHkgIT09IHlfZW5kOyB5ICs9IHlfc3RlcCApIHtcblxuXHRcdFx0XHRmb3IgKCB4ID0geF9zdGFydDsgeCAhPT0geF9lbmQ7IHggKz0geF9zdGVwLCBpICs9IDQgKSB7XG5cblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDIgXSA9IGltYWdlWyBpICsgMCBdO1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMSBdID0gaW1hZ2VbIGkgKyAxIF07XG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAwIF0gPSBpbWFnZVsgaSArIDIgXTtcblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDMgXSA9IGltYWdlWyBpICsgMyBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaW1hZ2VEYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdGdhR2V0SW1hZ2VEYXRhR3JleThiaXRzKCBpbWFnZURhdGEsIHlfc3RhcnQsIHlfc3RlcCwgeV9lbmQsIHhfc3RhcnQsIHhfc3RlcCwgeF9lbmQsIGltYWdlICkge1xuXG5cdFx0XHR2YXIgY29sb3IsIGkgPSAwLCB4LCB5O1xuXHRcdFx0dmFyIHdpZHRoID0gaGVhZGVyLndpZHRoO1xuXG5cdFx0XHRmb3IgKCB5ID0geV9zdGFydDsgeSAhPT0geV9lbmQ7IHkgKz0geV9zdGVwICkge1xuXG5cdFx0XHRcdGZvciAoIHggPSB4X3N0YXJ0OyB4ICE9PSB4X2VuZDsgeCArPSB4X3N0ZXAsIGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb2xvciA9IGltYWdlWyBpIF07XG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAwIF0gPSBjb2xvcjtcblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDEgXSA9IGNvbG9yO1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMiBdID0gY29sb3I7XG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAzIF0gPSAyNTU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpbWFnZURhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0Z2FHZXRJbWFnZURhdGFHcmV5MTZiaXRzKCBpbWFnZURhdGEsIHlfc3RhcnQsIHlfc3RlcCwgeV9lbmQsIHhfc3RhcnQsIHhfc3RlcCwgeF9lbmQsIGltYWdlICkge1xuXG5cdFx0XHR2YXIgaSA9IDAsIHgsIHk7XG5cdFx0XHR2YXIgd2lkdGggPSBoZWFkZXIud2lkdGg7XG5cblx0XHRcdGZvciAoIHkgPSB5X3N0YXJ0OyB5ICE9PSB5X2VuZDsgeSArPSB5X3N0ZXAgKSB7XG5cblx0XHRcdFx0Zm9yICggeCA9IHhfc3RhcnQ7IHggIT09IHhfZW5kOyB4ICs9IHhfc3RlcCwgaSArPSAyICkge1xuXG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAwIF0gPSBpbWFnZVsgaSArIDAgXTtcblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDEgXSA9IGltYWdlWyBpICsgMCBdO1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMiBdID0gaW1hZ2VbIGkgKyAwIF07XG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAzIF0gPSBpbWFnZVsgaSArIDEgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGltYWdlRGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFRnYVJHQkEoIGRhdGEsIHdpZHRoLCBoZWlnaHQsIGltYWdlLCBwYWxldHRlICkge1xuXG5cdFx0XHR2YXIgeF9zdGFydCxcblx0XHRcdFx0eV9zdGFydCxcblx0XHRcdFx0eF9zdGVwLFxuXHRcdFx0XHR5X3N0ZXAsXG5cdFx0XHRcdHhfZW5kLFxuXHRcdFx0XHR5X2VuZDtcblxuXHRcdFx0c3dpdGNoICggKCBoZWFkZXIuZmxhZ3MgJiBUR0FfT1JJR0lOX01BU0sgKSA+PiBUR0FfT1JJR0lOX1NISUZUICkge1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGNhc2UgVEdBX09SSUdJTl9VTDpcblx0XHRcdFx0XHR4X3N0YXJ0ID0gMDtcblx0XHRcdFx0XHR4X3N0ZXAgPSAxO1xuXHRcdFx0XHRcdHhfZW5kID0gd2lkdGg7XG5cdFx0XHRcdFx0eV9zdGFydCA9IDA7XG5cdFx0XHRcdFx0eV9zdGVwID0gMTtcblx0XHRcdFx0XHR5X2VuZCA9IGhlaWdodDtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFRHQV9PUklHSU5fQkw6XG5cdFx0XHRcdFx0eF9zdGFydCA9IDA7XG5cdFx0XHRcdFx0eF9zdGVwID0gMTtcblx0XHRcdFx0XHR4X2VuZCA9IHdpZHRoO1xuXHRcdFx0XHRcdHlfc3RhcnQgPSBoZWlnaHQgLSAxO1xuXHRcdFx0XHRcdHlfc3RlcCA9IC0gMTtcblx0XHRcdFx0XHR5X2VuZCA9IC0gMTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFRHQV9PUklHSU5fVVI6XG5cdFx0XHRcdFx0eF9zdGFydCA9IHdpZHRoIC0gMTtcblx0XHRcdFx0XHR4X3N0ZXAgPSAtIDE7XG5cdFx0XHRcdFx0eF9lbmQgPSAtIDE7XG5cdFx0XHRcdFx0eV9zdGFydCA9IDA7XG5cdFx0XHRcdFx0eV9zdGVwID0gMTtcblx0XHRcdFx0XHR5X2VuZCA9IGhlaWdodDtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFRHQV9PUklHSU5fQlI6XG5cdFx0XHRcdFx0eF9zdGFydCA9IHdpZHRoIC0gMTtcblx0XHRcdFx0XHR4X3N0ZXAgPSAtIDE7XG5cdFx0XHRcdFx0eF9lbmQgPSAtIDE7XG5cdFx0XHRcdFx0eV9zdGFydCA9IGhlaWdodCAtIDE7XG5cdFx0XHRcdFx0eV9zdGVwID0gLSAxO1xuXHRcdFx0XHRcdHlfZW5kID0gLSAxO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdXNlX2dyZXkgKSB7XG5cblx0XHRcdFx0c3dpdGNoICggaGVhZGVyLnBpeGVsX3NpemUgKSB7XG5cblx0XHRcdFx0XHRjYXNlIDg6XG5cdFx0XHRcdFx0XHR0Z2FHZXRJbWFnZURhdGFHcmV5OGJpdHMoIGRhdGEsIHlfc3RhcnQsIHlfc3RlcCwgeV9lbmQsIHhfc3RhcnQsIHhfc3RlcCwgeF9lbmQsIGltYWdlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgMTY6XG5cdFx0XHRcdFx0XHR0Z2FHZXRJbWFnZURhdGFHcmV5MTZiaXRzKCBkYXRhLCB5X3N0YXJ0LCB5X3N0ZXAsIHlfZW5kLCB4X3N0YXJ0LCB4X3N0ZXAsIHhfZW5kLCBpbWFnZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlRHQUxvYWRlcjogRm9ybWF0IG5vdCBzdXBwb3J0ZWQuJyApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHN3aXRjaCAoIGhlYWRlci5waXhlbF9zaXplICkge1xuXG5cdFx0XHRcdFx0Y2FzZSA4OlxuXHRcdFx0XHRcdFx0dGdhR2V0SW1hZ2VEYXRhOGJpdHMoIGRhdGEsIHlfc3RhcnQsIHlfc3RlcCwgeV9lbmQsIHhfc3RhcnQsIHhfc3RlcCwgeF9lbmQsIGltYWdlLCBwYWxldHRlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgMTY6XG5cdFx0XHRcdFx0XHR0Z2FHZXRJbWFnZURhdGExNmJpdHMoIGRhdGEsIHlfc3RhcnQsIHlfc3RlcCwgeV9lbmQsIHhfc3RhcnQsIHhfc3RlcCwgeF9lbmQsIGltYWdlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgMjQ6XG5cdFx0XHRcdFx0XHR0Z2FHZXRJbWFnZURhdGEyNGJpdHMoIGRhdGEsIHlfc3RhcnQsIHlfc3RlcCwgeV9lbmQsIHhfc3RhcnQsIHhfc3RlcCwgeF9lbmQsIGltYWdlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgMzI6XG5cdFx0XHRcdFx0XHR0Z2FHZXRJbWFnZURhdGEzMmJpdHMoIGRhdGEsIHlfc3RhcnQsIHlfc3RlcCwgeV9lbmQsIHhfc3RhcnQsIHhfc3RlcCwgeF9lbmQsIGltYWdlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVEdBTG9hZGVyOiBGb3JtYXQgbm90IHN1cHBvcnRlZC4nICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9hZCBpbWFnZSBkYXRhIGFjY29yZGluZyB0byBzcGVjaWZpYyBtZXRob2Rcblx0XHRcdC8vIHZhciBmdW5jID0gJ3RnYUdldEltYWdlRGF0YScgKyAodXNlX2dyZXkgPyAnR3JleScgOiAnJykgKyAoaGVhZGVyLnBpeGVsX3NpemUpICsgJ2JpdHMnO1xuXHRcdFx0Ly8gZnVuYyhkYXRhLCB5X3N0YXJ0LCB5X3N0ZXAsIHlfZW5kLCB4X3N0YXJ0LCB4X3N0ZXAsIHhfZW5kLCB3aWR0aCwgaW1hZ2UsIHBhbGV0dGUgKTtcblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0Ly8gVEdBIGNvbnN0YW50c1xuXG5cdFx0dmFyIFRHQV9UWVBFX05PX0RBVEEgPSAwLFxuXHRcdFx0VEdBX1RZUEVfSU5ERVhFRCA9IDEsXG5cdFx0XHRUR0FfVFlQRV9SR0IgPSAyLFxuXHRcdFx0VEdBX1RZUEVfR1JFWSA9IDMsXG5cdFx0XHRUR0FfVFlQRV9STEVfSU5ERVhFRCA9IDksXG5cdFx0XHRUR0FfVFlQRV9STEVfUkdCID0gMTAsXG5cdFx0XHRUR0FfVFlQRV9STEVfR1JFWSA9IDExLFxuXG5cdFx0XHRUR0FfT1JJR0lOX01BU0sgPSAweDMwLFxuXHRcdFx0VEdBX09SSUdJTl9TSElGVCA9IDB4MDQsXG5cdFx0XHRUR0FfT1JJR0lOX0JMID0gMHgwMCxcblx0XHRcdFRHQV9PUklHSU5fQlIgPSAweDAxLFxuXHRcdFx0VEdBX09SSUdJTl9VTCA9IDB4MDIsXG5cdFx0XHRUR0FfT1JJR0lOX1VSID0gMHgwMztcblxuXHRcdGlmICggYnVmZmVyLmxlbmd0aCA8IDE5ICkgY29uc29sZS5lcnJvciggJ1RIUkVFLlRHQUxvYWRlcjogTm90IGVub3VnaCBkYXRhIHRvIGNvbnRhaW4gaGVhZGVyLicgKTtcblxuXHRcdHZhciBjb250ZW50ID0gbmV3IFVpbnQ4QXJyYXkoIGJ1ZmZlciApLFxuXHRcdFx0b2Zmc2V0ID0gMCxcblx0XHRcdGhlYWRlciA9IHtcblx0XHRcdFx0aWRfbGVuZ3RoOiBjb250ZW50WyBvZmZzZXQgKysgXSxcblx0XHRcdFx0Y29sb3JtYXBfdHlwZTogY29udGVudFsgb2Zmc2V0ICsrIF0sXG5cdFx0XHRcdGltYWdlX3R5cGU6IGNvbnRlbnRbIG9mZnNldCArKyBdLFxuXHRcdFx0XHRjb2xvcm1hcF9pbmRleDogY29udGVudFsgb2Zmc2V0ICsrIF0gfCBjb250ZW50WyBvZmZzZXQgKysgXSA8PCA4LFxuXHRcdFx0XHRjb2xvcm1hcF9sZW5ndGg6IGNvbnRlbnRbIG9mZnNldCArKyBdIHwgY29udGVudFsgb2Zmc2V0ICsrIF0gPDwgOCxcblx0XHRcdFx0Y29sb3JtYXBfc2l6ZTogY29udGVudFsgb2Zmc2V0ICsrIF0sXG5cdFx0XHRcdG9yaWdpbjogW1xuXHRcdFx0XHRcdGNvbnRlbnRbIG9mZnNldCArKyBdIHwgY29udGVudFsgb2Zmc2V0ICsrIF0gPDwgOCxcblx0XHRcdFx0XHRjb250ZW50WyBvZmZzZXQgKysgXSB8IGNvbnRlbnRbIG9mZnNldCArKyBdIDw8IDhcblx0XHRcdFx0XSxcblx0XHRcdFx0d2lkdGg6IGNvbnRlbnRbIG9mZnNldCArKyBdIHwgY29udGVudFsgb2Zmc2V0ICsrIF0gPDwgOCxcblx0XHRcdFx0aGVpZ2h0OiBjb250ZW50WyBvZmZzZXQgKysgXSB8IGNvbnRlbnRbIG9mZnNldCArKyBdIDw8IDgsXG5cdFx0XHRcdHBpeGVsX3NpemU6IGNvbnRlbnRbIG9mZnNldCArKyBdLFxuXHRcdFx0XHRmbGFnczogY29udGVudFsgb2Zmc2V0ICsrIF1cblx0XHRcdH07XG5cblx0XHQvLyBjaGVjayB0Z2EgaWYgaXQgaXMgdmFsaWQgZm9ybWF0XG5cblx0XHR0Z2FDaGVja0hlYWRlciggaGVhZGVyICk7XG5cblx0XHRpZiAoIGhlYWRlci5pZF9sZW5ndGggKyBvZmZzZXQgPiBidWZmZXIubGVuZ3RoICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVEdBTG9hZGVyOiBObyBkYXRhLicgKTtcblxuXHRcdH1cblxuXHRcdC8vIHNraXAgdGhlIG5lZWRuJ3QgZGF0YVxuXG5cdFx0b2Zmc2V0ICs9IGhlYWRlci5pZF9sZW5ndGg7XG5cblx0XHQvLyBnZXQgdGFyZ2EgaW5mb3JtYXRpb24gYWJvdXQgUkxFIGNvbXByZXNzaW9uIGFuZCBwYWxldHRlXG5cblx0XHR2YXIgdXNlX3JsZSA9IGZhbHNlLFxuXHRcdFx0dXNlX3BhbCA9IGZhbHNlLFxuXHRcdFx0dXNlX2dyZXkgPSBmYWxzZTtcblxuXHRcdHN3aXRjaCAoIGhlYWRlci5pbWFnZV90eXBlICkge1xuXG5cdFx0XHRjYXNlIFRHQV9UWVBFX1JMRV9JTkRFWEVEOlxuXHRcdFx0XHR1c2VfcmxlID0gdHJ1ZTtcblx0XHRcdFx0dXNlX3BhbCA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFRHQV9UWVBFX0lOREVYRUQ6XG5cdFx0XHRcdHVzZV9wYWwgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBUR0FfVFlQRV9STEVfUkdCOlxuXHRcdFx0XHR1c2VfcmxlID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgVEdBX1RZUEVfUkdCOlxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBUR0FfVFlQRV9STEVfR1JFWTpcblx0XHRcdFx0dXNlX3JsZSA9IHRydWU7XG5cdFx0XHRcdHVzZV9ncmV5ID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgVEdBX1RZUEVfR1JFWTpcblx0XHRcdFx0dXNlX2dyZXkgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHR2YXIgdXNlT2Zmc2NyZWVuID0gdHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCc7XG5cblx0XHR2YXIgY2FudmFzID0gdXNlT2Zmc2NyZWVuID8gbmV3IE9mZnNjcmVlbkNhbnZhcyggaGVhZGVyLndpZHRoLCBoZWFkZXIuaGVpZ2h0ICkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xuXHRcdGNhbnZhcy53aWR0aCA9IGhlYWRlci53aWR0aDtcblx0XHRjYW52YXMuaGVpZ2h0ID0gaGVhZGVyLmhlaWdodDtcblxuXHRcdHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcblx0XHR2YXIgaW1hZ2VEYXRhID0gY29udGV4dC5jcmVhdGVJbWFnZURhdGEoIGhlYWRlci53aWR0aCwgaGVhZGVyLmhlaWdodCApO1xuXG5cdFx0dmFyIHJlc3VsdCA9IHRnYVBhcnNlKCB1c2VfcmxlLCB1c2VfcGFsLCBoZWFkZXIsIG9mZnNldCwgY29udGVudCApO1xuXHRcdGdldFRnYVJHQkEoIGltYWdlRGF0YS5kYXRhLCBoZWFkZXIud2lkdGgsIGhlYWRlci5oZWlnaHQsIHJlc3VsdC5waXhlbF9kYXRhLCByZXN1bHQucGFsZXR0ZXMgKTtcblxuXHRcdGNvbnRleHQucHV0SW1hZ2VEYXRhKCBpbWFnZURhdGEsIDAsIDAgKTtcblxuXHRcdHJldHVybiBjYW52YXM7XG5cblx0fVxuXG59ICk7XG5cbnZhciBDb2xsYWRhTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xuXG5cdExvYWRlciQxLmNhbGwoIHRoaXMsIG1hbmFnZXIgKTtcblxufTtcblxuQ29sbGFkYUxvYWRlci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMb2FkZXIkMS5wcm90b3R5cGUgKSwge1xuXG5cdGNvbnN0cnVjdG9yOiBDb2xsYWRhTG9hZGVyLFxuXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dmFyIHBhdGggPSAoIHNjb3BlLnBhdGggPT09ICcnICkgPyBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSggdXJsICkgOiBzY29wZS5wYXRoO1xuXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XG5cdFx0bG9hZGVyLnNldFBhdGgoIHNjb3BlLnBhdGggKTtcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggc2NvcGUucmVxdWVzdEhlYWRlciApO1xuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHNjb3BlLndpdGhDcmVkZW50aWFscyApO1xuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcblxuXHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRvbkxvYWQoIHNjb3BlLnBhcnNlKCB0ZXh0LCBwYXRoICkgKTtcblxuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICkge1xuXG5cdFx0XHRcdFx0b25FcnJvciggZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdH0sXG5cblx0b3B0aW9uczoge1xuXG5cdFx0c2V0IGNvbnZlcnRVcEF4aXMoIHZhbHVlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBvcHRpb25zLmNvbnZlcnRVcEF4aXMoKSBoYXMgYmVlbiByZW1vdmVkLiBVcCBheGlzIGlzIGNvbnZlcnRlZCBhdXRvbWF0aWNhbGx5LicgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdHBhcnNlOiBmdW5jdGlvbiAoIHRleHQsIHBhdGggKSB7XG5cblx0XHRmdW5jdGlvbiBnZXRFbGVtZW50c0J5VGFnTmFtZSggeG1sLCBuYW1lICkge1xuXG5cdFx0XHQvLyBOb24gcmVjdXJzaXZlIHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgpIC4uLlxuXG5cdFx0XHR2YXIgYXJyYXkgPSBbXTtcblx0XHRcdHZhciBjaGlsZE5vZGVzID0geG1sLmNoaWxkTm9kZXM7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlTmFtZSA9PT0gbmFtZSApIHtcblxuXHRcdFx0XHRcdGFycmF5LnB1c2goIGNoaWxkICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhcnJheTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlU3RyaW5ncyggdGV4dCApIHtcblxuXHRcdFx0aWYgKCB0ZXh0Lmxlbmd0aCA9PT0gMCApIHJldHVybiBbXTtcblxuXHRcdFx0dmFyIHBhcnRzID0gdGV4dC50cmltKCkuc3BsaXQoIC9cXHMrLyApO1xuXHRcdFx0dmFyIGFycmF5ID0gbmV3IEFycmF5KCBwYXJ0cy5sZW5ndGggKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcGFydHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRhcnJheVsgaSBdID0gcGFydHNbIGkgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYXJyYXk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUZsb2F0cyggdGV4dCApIHtcblxuXHRcdFx0aWYgKCB0ZXh0Lmxlbmd0aCA9PT0gMCApIHJldHVybiBbXTtcblxuXHRcdFx0dmFyIHBhcnRzID0gdGV4dC50cmltKCkuc3BsaXQoIC9cXHMrLyApO1xuXHRcdFx0dmFyIGFycmF5ID0gbmV3IEFycmF5KCBwYXJ0cy5sZW5ndGggKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcGFydHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRhcnJheVsgaSBdID0gcGFyc2VGbG9hdCggcGFydHNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhcnJheTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlSW50cyggdGV4dCApIHtcblxuXHRcdFx0aWYgKCB0ZXh0Lmxlbmd0aCA9PT0gMCApIHJldHVybiBbXTtcblxuXHRcdFx0dmFyIHBhcnRzID0gdGV4dC50cmltKCkuc3BsaXQoIC9cXHMrLyApO1xuXHRcdFx0dmFyIGFycmF5ID0gbmV3IEFycmF5KCBwYXJ0cy5sZW5ndGggKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcGFydHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRhcnJheVsgaSBdID0gcGFyc2VJbnQoIHBhcnRzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYXJyYXk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUlkKCB0ZXh0ICkge1xuXG5cdFx0XHRyZXR1cm4gdGV4dC5zdWJzdHJpbmcoIDEgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlSWQoKSB7XG5cblx0XHRcdHJldHVybiAndGhyZWVfZGVmYXVsdF8nICsgKCBjb3VudCArKyApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNFbXB0eSggb2JqZWN0ICkge1xuXG5cdFx0XHRyZXR1cm4gT2JqZWN0LmtleXMoIG9iamVjdCApLmxlbmd0aCA9PT0gMDtcblxuXHRcdH1cblxuXHRcdC8vIGFzc2V0XG5cblx0XHRmdW5jdGlvbiBwYXJzZUFzc2V0KCB4bWwgKSB7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHVuaXQ6IHBhcnNlQXNzZXRVbml0KCBnZXRFbGVtZW50c0J5VGFnTmFtZSggeG1sLCAndW5pdCcgKVsgMCBdICksXG5cdFx0XHRcdHVwQXhpczogcGFyc2VBc3NldFVwQXhpcyggZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHhtbCwgJ3VwX2F4aXMnIClbIDAgXSApXG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VBc3NldFVuaXQoIHhtbCApIHtcblxuXHRcdFx0aWYgKCAoIHhtbCAhPT0gdW5kZWZpbmVkICkgJiYgKCB4bWwuaGFzQXR0cmlidXRlKCAnbWV0ZXInICkgPT09IHRydWUgKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gcGFyc2VGbG9hdCggeG1sLmdldEF0dHJpYnV0ZSggJ21ldGVyJyApICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIDE7IC8vIGRlZmF1bHQgMSBtZXRlclxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUFzc2V0VXBBeGlzKCB4bWwgKSB7XG5cblx0XHRcdHJldHVybiB4bWwgIT09IHVuZGVmaW5lZCA/IHhtbC50ZXh0Q29udGVudCA6ICdZX1VQJztcblxuXHRcdH1cblxuXHRcdC8vIGxpYnJhcnlcblxuXHRcdGZ1bmN0aW9uIHBhcnNlTGlicmFyeSggeG1sLCBsaWJyYXJ5TmFtZSwgbm9kZU5hbWUsIHBhcnNlciApIHtcblxuXHRcdFx0dmFyIGxpYnJhcnkgPSBnZXRFbGVtZW50c0J5VGFnTmFtZSggeG1sLCBsaWJyYXJ5TmFtZSApWyAwIF07XG5cblx0XHRcdGlmICggbGlicmFyeSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZhciBlbGVtZW50cyA9IGdldEVsZW1lbnRzQnlUYWdOYW1lKCBsaWJyYXJ5LCBub2RlTmFtZSApO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHBhcnNlciggZWxlbWVudHNbIGkgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRMaWJyYXJ5KCBkYXRhLCBidWlsZGVyICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgbmFtZSBpbiBkYXRhICkge1xuXG5cdFx0XHRcdHZhciBvYmplY3QgPSBkYXRhWyBuYW1lIF07XG5cdFx0XHRcdG9iamVjdC5idWlsZCA9IGJ1aWxkZXIoIGRhdGFbIG5hbWUgXSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBnZXRcblxuXHRcdGZ1bmN0aW9uIGdldEJ1aWxkKCBkYXRhLCBidWlsZGVyICkge1xuXG5cdFx0XHRpZiAoIGRhdGEuYnVpbGQgIT09IHVuZGVmaW5lZCApIHJldHVybiBkYXRhLmJ1aWxkO1xuXG5cdFx0XHRkYXRhLmJ1aWxkID0gYnVpbGRlciggZGF0YSApO1xuXG5cdFx0XHRyZXR1cm4gZGF0YS5idWlsZDtcblxuXHRcdH1cblxuXHRcdC8vIGFuaW1hdGlvblxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VBbmltYXRpb24oIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdHNvdXJjZXM6IHt9LFxuXHRcdFx0XHRzYW1wbGVyczoge30sXG5cdFx0XHRcdGNoYW5uZWxzOiB7fVxuXHRcdFx0fTtcblxuXHRcdFx0dmFyIGhhc0NoaWxkcmVuID0gZmFsc2U7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0dmFyIGlkO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnc291cmNlJzpcblx0XHRcdFx0XHRcdGlkID0gY2hpbGQuZ2V0QXR0cmlidXRlKCAnaWQnICk7XG5cdFx0XHRcdFx0XHRkYXRhLnNvdXJjZXNbIGlkIF0gPSBwYXJzZVNvdXJjZSggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnc2FtcGxlcic6XG5cdFx0XHRcdFx0XHRpZCA9IGNoaWxkLmdldEF0dHJpYnV0ZSggJ2lkJyApO1xuXHRcdFx0XHRcdFx0ZGF0YS5zYW1wbGVyc1sgaWQgXSA9IHBhcnNlQW5pbWF0aW9uU2FtcGxlciggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnY2hhbm5lbCc6XG5cdFx0XHRcdFx0XHRpZCA9IGNoaWxkLmdldEF0dHJpYnV0ZSggJ3RhcmdldCcgKTtcblx0XHRcdFx0XHRcdGRhdGEuY2hhbm5lbHNbIGlkIF0gPSBwYXJzZUFuaW1hdGlvbkNoYW5uZWwoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2FuaW1hdGlvbic6XG5cdFx0XHRcdFx0XHQvLyBoaWVyYXJjaHkgb2YgcmVsYXRlZCBhbmltYXRpb25zXG5cdFx0XHRcdFx0XHRwYXJzZUFuaW1hdGlvbiggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGhhc0NoaWxkcmVuID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCBjaGlsZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc0NoaWxkcmVuID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBzaW5jZSAnaWQnIGF0dHJpYnV0ZXMgY2FuIGJlIG9wdGlvbmFsLCBpdCdzIG5lY2Vzc2FyeSB0byBnZW5lcmF0ZSBhIFVVSUQgZm9yIHVucWl1ZSBhc3NpZ25tZW50XG5cblx0XHRcdFx0bGlicmFyeS5hbmltYXRpb25zWyB4bWwuZ2V0QXR0cmlidXRlKCAnaWQnICkgfHwgTWF0aFV0aWxzLmdlbmVyYXRlVVVJRCgpIF0gPSBkYXRhO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUFuaW1hdGlvblNhbXBsZXIoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdGlucHV0czoge30sXG5cdFx0XHR9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnaW5wdXQnOlxuXHRcdFx0XHRcdFx0dmFyIGlkID0gcGFyc2VJZCggY2hpbGQuZ2V0QXR0cmlidXRlKCAnc291cmNlJyApICk7XG5cdFx0XHRcdFx0XHR2YXIgc2VtYW50aWMgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzZW1hbnRpYycgKTtcblx0XHRcdFx0XHRcdGRhdGEuaW5wdXRzWyBzZW1hbnRpYyBdID0gaWQ7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUFuaW1hdGlvbkNoYW5uZWwoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7fTtcblxuXHRcdFx0dmFyIHRhcmdldCA9IHhtbC5nZXRBdHRyaWJ1dGUoICd0YXJnZXQnICk7XG5cblx0XHRcdC8vIHBhcnNpbmcgU0lEIEFkZHJlc3NpbmcgU3ludGF4XG5cblx0XHRcdHZhciBwYXJ0cyA9IHRhcmdldC5zcGxpdCggJy8nICk7XG5cblx0XHRcdHZhciBpZCA9IHBhcnRzLnNoaWZ0KCk7XG5cdFx0XHR2YXIgc2lkID0gcGFydHMuc2hpZnQoKTtcblxuXHRcdFx0Ly8gY2hlY2sgc2VsZWN0aW9uIHN5bnRheFxuXG5cdFx0XHR2YXIgYXJyYXlTeW50YXggPSAoIHNpZC5pbmRleE9mKCAnKCcgKSAhPT0gLSAxICk7XG5cdFx0XHR2YXIgbWVtYmVyU3ludGF4ID0gKCBzaWQuaW5kZXhPZiggJy4nICkgIT09IC0gMSApO1xuXG5cdFx0XHRpZiAoIG1lbWJlclN5bnRheCApIHtcblxuXHRcdFx0XHQvLyAgbWVtYmVyIHNlbGVjdGlvbiBhY2Nlc3NcblxuXHRcdFx0XHRwYXJ0cyA9IHNpZC5zcGxpdCggJy4nICk7XG5cdFx0XHRcdHNpZCA9IHBhcnRzLnNoaWZ0KCk7XG5cdFx0XHRcdGRhdGEubWVtYmVyID0gcGFydHMuc2hpZnQoKTtcblxuXHRcdFx0fSBlbHNlIGlmICggYXJyYXlTeW50YXggKSB7XG5cblx0XHRcdFx0Ly8gYXJyYXktYWNjZXNzIHN5bnRheC4gY2FuIGJlIHVzZWQgdG8gZXhwcmVzcyBmaWVsZHMgaW4gb25lLWRpbWVuc2lvbmFsIHZlY3RvcnMgb3IgdHdvLWRpbWVuc2lvbmFsIG1hdHJpY2VzLlxuXG5cdFx0XHRcdHZhciBpbmRpY2VzID0gc2lkLnNwbGl0KCAnKCcgKTtcblx0XHRcdFx0c2lkID0gaW5kaWNlcy5zaGlmdCgpO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0aW5kaWNlc1sgaSBdID0gcGFyc2VJbnQoIGluZGljZXNbIGkgXS5yZXBsYWNlKCAvXFwpLywgJycgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkYXRhLmluZGljZXMgPSBpbmRpY2VzO1xuXG5cdFx0XHR9XG5cblx0XHRcdGRhdGEuaWQgPSBpZDtcblx0XHRcdGRhdGEuc2lkID0gc2lkO1xuXG5cdFx0XHRkYXRhLmFycmF5U3ludGF4ID0gYXJyYXlTeW50YXg7XG5cdFx0XHRkYXRhLm1lbWJlclN5bnRheCA9IG1lbWJlclN5bnRheDtcblxuXHRcdFx0ZGF0YS5zYW1wbGVyID0gcGFyc2VJZCggeG1sLmdldEF0dHJpYnV0ZSggJ3NvdXJjZScgKSApO1xuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkQW5pbWF0aW9uKCBkYXRhICkge1xuXG5cdFx0XHR2YXIgdHJhY2tzID0gW107XG5cblx0XHRcdHZhciBjaGFubmVscyA9IGRhdGEuY2hhbm5lbHM7XG5cdFx0XHR2YXIgc2FtcGxlcnMgPSBkYXRhLnNhbXBsZXJzO1xuXHRcdFx0dmFyIHNvdXJjZXMgPSBkYXRhLnNvdXJjZXM7XG5cblx0XHRcdGZvciAoIHZhciB0YXJnZXQgaW4gY2hhbm5lbHMgKSB7XG5cblx0XHRcdFx0aWYgKCBjaGFubmVscy5oYXNPd25Qcm9wZXJ0eSggdGFyZ2V0ICkgKSB7XG5cblx0XHRcdFx0XHR2YXIgY2hhbm5lbCA9IGNoYW5uZWxzWyB0YXJnZXQgXTtcblx0XHRcdFx0XHR2YXIgc2FtcGxlciA9IHNhbXBsZXJzWyBjaGFubmVsLnNhbXBsZXIgXTtcblxuXHRcdFx0XHRcdHZhciBpbnB1dElkID0gc2FtcGxlci5pbnB1dHMuSU5QVVQ7XG5cdFx0XHRcdFx0dmFyIG91dHB1dElkID0gc2FtcGxlci5pbnB1dHMuT1VUUFVUO1xuXG5cdFx0XHRcdFx0dmFyIGlucHV0U291cmNlID0gc291cmNlc1sgaW5wdXRJZCBdO1xuXHRcdFx0XHRcdHZhciBvdXRwdXRTb3VyY2UgPSBzb3VyY2VzWyBvdXRwdXRJZCBdO1xuXG5cdFx0XHRcdFx0dmFyIGFuaW1hdGlvbiA9IGJ1aWxkQW5pbWF0aW9uQ2hhbm5lbCggY2hhbm5lbCwgaW5wdXRTb3VyY2UsIG91dHB1dFNvdXJjZSApO1xuXG5cdFx0XHRcdFx0Y3JlYXRlS2V5ZnJhbWVUcmFja3MoIGFuaW1hdGlvbiwgdHJhY2tzICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cmFja3M7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRBbmltYXRpb24oIGlkICkge1xuXG5cdFx0XHRyZXR1cm4gZ2V0QnVpbGQoIGxpYnJhcnkuYW5pbWF0aW9uc1sgaWQgXSwgYnVpbGRBbmltYXRpb24gKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkQW5pbWF0aW9uQ2hhbm5lbCggY2hhbm5lbCwgaW5wdXRTb3VyY2UsIG91dHB1dFNvdXJjZSApIHtcblxuXHRcdFx0dmFyIG5vZGUgPSBsaWJyYXJ5Lm5vZGVzWyBjaGFubmVsLmlkIF07XG5cdFx0XHR2YXIgb2JqZWN0M0QgPSBnZXROb2RlKCBub2RlLmlkICk7XG5cblx0XHRcdHZhciB0cmFuc2Zvcm0gPSBub2RlLnRyYW5zZm9ybXNbIGNoYW5uZWwuc2lkIF07XG5cdFx0XHR2YXIgZGVmYXVsdE1hdHJpeCA9IG5vZGUubWF0cml4LmNsb25lKCkudHJhbnNwb3NlKCk7XG5cblx0XHRcdHZhciB0aW1lLCBzdHJpZGU7XG5cdFx0XHR2YXIgaSwgaWwsIGosIGpsO1xuXG5cdFx0XHR2YXIgZGF0YSA9IHt9O1xuXG5cdFx0XHQvLyB0aGUgY29sbGFkYSBzcGVjIGFsbG93cyB0aGUgYW5pbWF0aW9uIG9mIGRhdGEgaW4gdmFyaW91cyB3YXlzLlxuXHRcdFx0Ly8gZGVwZW5kaW5nIG9uIHRoZSB0cmFuc2Zvcm0gdHlwZSAobWF0cml4LCB0cmFuc2xhdGUsIHJvdGF0ZSwgc2NhbGUpLCB3ZSBleGVjdXRlIGRpZmZlcmVudCBsb2dpY1xuXG5cdFx0XHRzd2l0Y2ggKCB0cmFuc2Zvcm0gKSB7XG5cblx0XHRcdFx0Y2FzZSAnbWF0cml4JzpcblxuXHRcdFx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGlucHV0U291cmNlLmFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHR0aW1lID0gaW5wdXRTb3VyY2UuYXJyYXlbIGkgXTtcblx0XHRcdFx0XHRcdHN0cmlkZSA9IGkgKiBvdXRwdXRTb3VyY2Uuc3RyaWRlO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGRhdGFbIHRpbWUgXSA9PT0gdW5kZWZpbmVkICkgZGF0YVsgdGltZSBdID0ge307XG5cblx0XHRcdFx0XHRcdGlmICggY2hhbm5lbC5hcnJheVN5bnRheCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSBvdXRwdXRTb3VyY2UuYXJyYXlbIHN0cmlkZSBdO1xuXHRcdFx0XHRcdFx0XHR2YXIgaW5kZXggPSBjaGFubmVsLmluZGljZXNbIDAgXSArIDQgKiBjaGFubmVsLmluZGljZXNbIDEgXTtcblxuXHRcdFx0XHRcdFx0XHRkYXRhWyB0aW1lIF1bIGluZGV4IF0gPSB2YWx1ZTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCBqID0gMCwgamwgPSBvdXRwdXRTb3VyY2Uuc3RyaWRlOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRkYXRhWyB0aW1lIF1bIGogXSA9IG91dHB1dFNvdXJjZS5hcnJheVsgc3RyaWRlICsgaiBdO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAndHJhbnNsYXRlJzpcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBBbmltYXRpb24gdHJhbnNmb3JtIHR5cGUgXCIlc1wiIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJywgdHJhbnNmb3JtICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAncm90YXRlJzpcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBBbmltYXRpb24gdHJhbnNmb3JtIHR5cGUgXCIlc1wiIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJywgdHJhbnNmb3JtICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnc2NhbGUnOlxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IEFuaW1hdGlvbiB0cmFuc2Zvcm0gdHlwZSBcIiVzXCIgbm90IHlldCBpbXBsZW1lbnRlZC4nLCB0cmFuc2Zvcm0gKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIga2V5ZnJhbWVzID0gcHJlcGFyZUFuaW1hdGlvbkRhdGEoIGRhdGEsIGRlZmF1bHRNYXRyaXggKTtcblxuXHRcdFx0dmFyIGFuaW1hdGlvbiA9IHtcblx0XHRcdFx0bmFtZTogb2JqZWN0M0QudXVpZCxcblx0XHRcdFx0a2V5ZnJhbWVzOiBrZXlmcmFtZXNcblx0XHRcdH07XG5cblx0XHRcdHJldHVybiBhbmltYXRpb247XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwcmVwYXJlQW5pbWF0aW9uRGF0YSggZGF0YSwgZGVmYXVsdE1hdHJpeCApIHtcblxuXHRcdFx0dmFyIGtleWZyYW1lcyA9IFtdO1xuXG5cdFx0XHQvLyB0cmFuc2ZlciBkYXRhIGludG8gYSBzb3J0YWJsZSBhcnJheVxuXG5cdFx0XHRmb3IgKCB2YXIgdGltZSBpbiBkYXRhICkge1xuXG5cdFx0XHRcdGtleWZyYW1lcy5wdXNoKCB7IHRpbWU6IHBhcnNlRmxvYXQoIHRpbWUgKSwgdmFsdWU6IGRhdGFbIHRpbWUgXSB9ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZW5zdXJlIGtleWZyYW1lcyBhcmUgc29ydGVkIGJ5IHRpbWVcblxuXHRcdFx0a2V5ZnJhbWVzLnNvcnQoIGFzY2VuZGluZyApO1xuXG5cdFx0XHQvLyBub3cgd2UgY2xlYW4gdXAgYWxsIGFuaW1hdGlvbiBkYXRhLCBzbyB3ZSBjYW4gdXNlIHRoZW0gZm9yIGtleWZyYW1lIHRyYWNrc1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCAxNjsgaSArKyApIHtcblxuXHRcdFx0XHR0cmFuc2Zvcm1BbmltYXRpb25EYXRhKCBrZXlmcmFtZXMsIGksIGRlZmF1bHRNYXRyaXguZWxlbWVudHNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBrZXlmcmFtZXM7XG5cblx0XHRcdC8vIGFycmF5IHNvcnQgZnVuY3Rpb25cblxuXHRcdFx0ZnVuY3Rpb24gYXNjZW5kaW5nKCBhLCBiICkge1xuXG5cdFx0XHRcdHJldHVybiBhLnRpbWUgLSBiLnRpbWU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHZhciBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0dmFyIHNjYWxlID0gbmV3IFZlY3RvcjMoKTtcblx0XHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVLZXlmcmFtZVRyYWNrcyggYW5pbWF0aW9uLCB0cmFja3MgKSB7XG5cblx0XHRcdHZhciBrZXlmcmFtZXMgPSBhbmltYXRpb24ua2V5ZnJhbWVzO1xuXHRcdFx0dmFyIG5hbWUgPSBhbmltYXRpb24ubmFtZTtcblxuXHRcdFx0dmFyIHRpbWVzID0gW107XG5cdFx0XHR2YXIgcG9zaXRpb25EYXRhID0gW107XG5cdFx0XHR2YXIgcXVhdGVybmlvbkRhdGEgPSBbXTtcblx0XHRcdHZhciBzY2FsZURhdGEgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ga2V5ZnJhbWVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGtleWZyYW1lID0ga2V5ZnJhbWVzWyBpIF07XG5cblx0XHRcdFx0dmFyIHRpbWUgPSBrZXlmcmFtZS50aW1lO1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBrZXlmcmFtZS52YWx1ZTtcblxuXHRcdFx0XHRtYXRyaXguZnJvbUFycmF5KCB2YWx1ZSApLnRyYW5zcG9zZSgpO1xuXHRcdFx0XHRtYXRyaXguZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKTtcblxuXHRcdFx0XHR0aW1lcy5wdXNoKCB0aW1lICk7XG5cdFx0XHRcdHBvc2l0aW9uRGF0YS5wdXNoKCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56ICk7XG5cdFx0XHRcdHF1YXRlcm5pb25EYXRhLnB1c2goIHF1YXRlcm5pb24ueCwgcXVhdGVybmlvbi55LCBxdWF0ZXJuaW9uLnosIHF1YXRlcm5pb24udyApO1xuXHRcdFx0XHRzY2FsZURhdGEucHVzaCggc2NhbGUueCwgc2NhbGUueSwgc2NhbGUueiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcG9zaXRpb25EYXRhLmxlbmd0aCA+IDAgKSB0cmFja3MucHVzaCggbmV3IFZlY3RvcktleWZyYW1lVHJhY2soIG5hbWUgKyAnLnBvc2l0aW9uJywgdGltZXMsIHBvc2l0aW9uRGF0YSApICk7XG5cdFx0XHRpZiAoIHF1YXRlcm5pb25EYXRhLmxlbmd0aCA+IDAgKSB0cmFja3MucHVzaCggbmV3IFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrKCBuYW1lICsgJy5xdWF0ZXJuaW9uJywgdGltZXMsIHF1YXRlcm5pb25EYXRhICkgKTtcblx0XHRcdGlmICggc2NhbGVEYXRhLmxlbmd0aCA+IDAgKSB0cmFja3MucHVzaCggbmV3IFZlY3RvcktleWZyYW1lVHJhY2soIG5hbWUgKyAnLnNjYWxlJywgdGltZXMsIHNjYWxlRGF0YSApICk7XG5cblx0XHRcdHJldHVybiB0cmFja3M7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmFuc2Zvcm1BbmltYXRpb25EYXRhKCBrZXlmcmFtZXMsIHByb3BlcnR5LCBkZWZhdWx0VmFsdWUgKSB7XG5cblx0XHRcdHZhciBrZXlmcmFtZTtcblxuXHRcdFx0dmFyIGVtcHR5ID0gdHJ1ZTtcblx0XHRcdHZhciBpLCBsO1xuXG5cdFx0XHQvLyBjaGVjaywgaWYgdmFsdWVzIG9mIGEgcHJvcGVydHkgYXJlIG1pc3NpbmcgaW4gb3VyIGtleWZyYW1lc1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IGtleWZyYW1lcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGtleWZyYW1lID0ga2V5ZnJhbWVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBrZXlmcmFtZS52YWx1ZVsgcHJvcGVydHkgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0a2V5ZnJhbWUudmFsdWVbIHByb3BlcnR5IF0gPSBudWxsOyAvLyBtYXJrIGFzIG1pc3NpbmdcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0ZW1wdHkgPSBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbXB0eSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHQvLyBubyB2YWx1ZXMgYXQgYWxsLCBzbyB3ZSBzZXQgYSBkZWZhdWx0IHZhbHVlXG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBrZXlmcmFtZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGtleWZyYW1lID0ga2V5ZnJhbWVzWyBpIF07XG5cblx0XHRcdFx0XHRrZXlmcmFtZS52YWx1ZVsgcHJvcGVydHkgXSA9IGRlZmF1bHRWYWx1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gZmlsbGluZyBnYXBzXG5cblx0XHRcdFx0Y3JlYXRlTWlzc2luZ0tleWZyYW1lcygga2V5ZnJhbWVzLCBwcm9wZXJ0eSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVNaXNzaW5nS2V5ZnJhbWVzKCBrZXlmcmFtZXMsIHByb3BlcnR5ICkge1xuXG5cdFx0XHR2YXIgcHJldiwgbmV4dDtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ga2V5ZnJhbWVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGtleWZyYW1lID0ga2V5ZnJhbWVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBrZXlmcmFtZS52YWx1ZVsgcHJvcGVydHkgXSA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdHByZXYgPSBnZXRQcmV2KCBrZXlmcmFtZXMsIGksIHByb3BlcnR5ICk7XG5cdFx0XHRcdFx0bmV4dCA9IGdldE5leHQoIGtleWZyYW1lcywgaSwgcHJvcGVydHkgKTtcblxuXHRcdFx0XHRcdGlmICggcHJldiA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0a2V5ZnJhbWUudmFsdWVbIHByb3BlcnR5IF0gPSBuZXh0LnZhbHVlWyBwcm9wZXJ0eSBdO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIG5leHQgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdGtleWZyYW1lLnZhbHVlWyBwcm9wZXJ0eSBdID0gcHJldi52YWx1ZVsgcHJvcGVydHkgXTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aW50ZXJwb2xhdGUoIGtleWZyYW1lLCBwcmV2LCBuZXh0LCBwcm9wZXJ0eSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0UHJldigga2V5ZnJhbWVzLCBpLCBwcm9wZXJ0eSApIHtcblxuXHRcdFx0d2hpbGUgKCBpID49IDAgKSB7XG5cblx0XHRcdFx0dmFyIGtleWZyYW1lID0ga2V5ZnJhbWVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBrZXlmcmFtZS52YWx1ZVsgcHJvcGVydHkgXSAhPT0gbnVsbCApIHJldHVybiBrZXlmcmFtZTtcblxuXHRcdFx0XHRpIC0tO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0TmV4dCgga2V5ZnJhbWVzLCBpLCBwcm9wZXJ0eSApIHtcblxuXHRcdFx0d2hpbGUgKCBpIDwga2V5ZnJhbWVzLmxlbmd0aCApIHtcblxuXHRcdFx0XHR2YXIga2V5ZnJhbWUgPSBrZXlmcmFtZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGtleWZyYW1lLnZhbHVlWyBwcm9wZXJ0eSBdICE9PSBudWxsICkgcmV0dXJuIGtleWZyYW1lO1xuXG5cdFx0XHRcdGkgKys7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpbnRlcnBvbGF0ZSgga2V5LCBwcmV2LCBuZXh0LCBwcm9wZXJ0eSApIHtcblxuXHRcdFx0aWYgKCAoIG5leHQudGltZSAtIHByZXYudGltZSApID09PSAwICkge1xuXG5cdFx0XHRcdGtleS52YWx1ZVsgcHJvcGVydHkgXSA9IHByZXYudmFsdWVbIHByb3BlcnR5IF07XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0XHRrZXkudmFsdWVbIHByb3BlcnR5IF0gPSAoICgga2V5LnRpbWUgLSBwcmV2LnRpbWUgKSAqICggbmV4dC52YWx1ZVsgcHJvcGVydHkgXSAtIHByZXYudmFsdWVbIHByb3BlcnR5IF0gKSAvICggbmV4dC50aW1lIC0gcHJldi50aW1lICkgKSArIHByZXYudmFsdWVbIHByb3BlcnR5IF07XG5cblx0XHR9XG5cblx0XHQvLyBhbmltYXRpb24gY2xpcHNcblxuXHRcdGZ1bmN0aW9uIHBhcnNlQW5pbWF0aW9uQ2xpcCggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0bmFtZTogeG1sLmdldEF0dHJpYnV0ZSggJ2lkJyApIHx8ICdkZWZhdWx0Jyxcblx0XHRcdFx0c3RhcnQ6IHBhcnNlRmxvYXQoIHhtbC5nZXRBdHRyaWJ1dGUoICdzdGFydCcgKSB8fCAwICksXG5cdFx0XHRcdGVuZDogcGFyc2VGbG9hdCggeG1sLmdldEF0dHJpYnV0ZSggJ2VuZCcgKSB8fCAwICksXG5cdFx0XHRcdGFuaW1hdGlvbnM6IFtdXG5cdFx0XHR9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnaW5zdGFuY2VfYW5pbWF0aW9uJzpcblx0XHRcdFx0XHRcdGRhdGEuYW5pbWF0aW9ucy5wdXNoKCBwYXJzZUlkKCBjaGlsZC5nZXRBdHRyaWJ1dGUoICd1cmwnICkgKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGxpYnJhcnkuY2xpcHNbIHhtbC5nZXRBdHRyaWJ1dGUoICdpZCcgKSBdID0gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkQW5pbWF0aW9uQ2xpcCggZGF0YSApIHtcblxuXHRcdFx0dmFyIHRyYWNrcyA9IFtdO1xuXG5cdFx0XHR2YXIgbmFtZSA9IGRhdGEubmFtZTtcblx0XHRcdHZhciBkdXJhdGlvbiA9ICggZGF0YS5lbmQgLSBkYXRhLnN0YXJ0ICkgfHwgLSAxO1xuXHRcdFx0dmFyIGFuaW1hdGlvbnMgPSBkYXRhLmFuaW1hdGlvbnM7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBhbmltYXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBhbmltYXRpb25UcmFja3MgPSBnZXRBbmltYXRpb24oIGFuaW1hdGlvbnNbIGkgXSApO1xuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBhbmltYXRpb25UcmFja3MubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHR0cmFja3MucHVzaCggYW5pbWF0aW9uVHJhY2tzWyBqIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBBbmltYXRpb25DbGlwKCBuYW1lLCBkdXJhdGlvbiwgdHJhY2tzICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRBbmltYXRpb25DbGlwKCBpZCApIHtcblxuXHRcdFx0cmV0dXJuIGdldEJ1aWxkKCBsaWJyYXJ5LmNsaXBzWyBpZCBdLCBidWlsZEFuaW1hdGlvbkNsaXAgKTtcblxuXHRcdH1cblxuXHRcdC8vIGNvbnRyb2xsZXJcblxuXHRcdGZ1bmN0aW9uIHBhcnNlQ29udHJvbGxlciggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHt9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnc2tpbic6XG5cdFx0XHRcdFx0XHQvLyB0aGVyZSBpcyBleGFjdGx5IG9uZSBza2luIHBlciBjb250cm9sbGVyXG5cdFx0XHRcdFx0XHRkYXRhLmlkID0gcGFyc2VJZCggY2hpbGQuZ2V0QXR0cmlidXRlKCAnc291cmNlJyApICk7XG5cdFx0XHRcdFx0XHRkYXRhLnNraW4gPSBwYXJzZVNraW4oIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ21vcnBoJzpcblx0XHRcdFx0XHRcdGRhdGEuaWQgPSBwYXJzZUlkKCBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzb3VyY2UnICkgKTtcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IE1vcnBoIHRhcmdldCBhbmltYXRpb24gbm90IHN1cHBvcnRlZCB5ZXQuJyApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGxpYnJhcnkuY29udHJvbGxlcnNbIHhtbC5nZXRBdHRyaWJ1dGUoICdpZCcgKSBdID0gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlU2tpbiggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0c291cmNlczoge31cblx0XHRcdH07XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdiaW5kX3NoYXBlX21hdHJpeCc6XG5cdFx0XHRcdFx0XHRkYXRhLmJpbmRTaGFwZU1hdHJpeCA9IHBhcnNlRmxvYXRzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdzb3VyY2UnOlxuXHRcdFx0XHRcdFx0dmFyIGlkID0gY2hpbGQuZ2V0QXR0cmlidXRlKCAnaWQnICk7XG5cdFx0XHRcdFx0XHRkYXRhLnNvdXJjZXNbIGlkIF0gPSBwYXJzZVNvdXJjZSggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnam9pbnRzJzpcblx0XHRcdFx0XHRcdGRhdGEuam9pbnRzID0gcGFyc2VKb2ludHMoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3ZlcnRleF93ZWlnaHRzJzpcblx0XHRcdFx0XHRcdGRhdGEudmVydGV4V2VpZ2h0cyA9IHBhcnNlVmVydGV4V2VpZ2h0cyggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlSm9pbnRzKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRpbnB1dHM6IHt9XG5cdFx0XHR9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnaW5wdXQnOlxuXHRcdFx0XHRcdFx0dmFyIHNlbWFudGljID0gY2hpbGQuZ2V0QXR0cmlidXRlKCAnc2VtYW50aWMnICk7XG5cdFx0XHRcdFx0XHR2YXIgaWQgPSBwYXJzZUlkKCBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzb3VyY2UnICkgKTtcblx0XHRcdFx0XHRcdGRhdGEuaW5wdXRzWyBzZW1hbnRpYyBdID0gaWQ7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZVZlcnRleFdlaWdodHMoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdGlucHV0czoge31cblx0XHRcdH07XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdpbnB1dCc6XG5cdFx0XHRcdFx0XHR2YXIgc2VtYW50aWMgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzZW1hbnRpYycgKTtcblx0XHRcdFx0XHRcdHZhciBpZCA9IHBhcnNlSWQoIGNoaWxkLmdldEF0dHJpYnV0ZSggJ3NvdXJjZScgKSApO1xuXHRcdFx0XHRcdFx0dmFyIG9mZnNldCA9IHBhcnNlSW50KCBjaGlsZC5nZXRBdHRyaWJ1dGUoICdvZmZzZXQnICkgKTtcblx0XHRcdFx0XHRcdGRhdGEuaW5wdXRzWyBzZW1hbnRpYyBdID0geyBpZDogaWQsIG9mZnNldDogb2Zmc2V0IH07XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3Zjb3VudCc6XG5cdFx0XHRcdFx0XHRkYXRhLnZjb3VudCA9IHBhcnNlSW50cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndic6XG5cdFx0XHRcdFx0XHRkYXRhLnYgPSBwYXJzZUludHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZENvbnRyb2xsZXIoIGRhdGEgKSB7XG5cblx0XHRcdHZhciBidWlsZCA9IHtcblx0XHRcdFx0aWQ6IGRhdGEuaWRcblx0XHRcdH07XG5cblx0XHRcdHZhciBnZW9tZXRyeSA9IGxpYnJhcnkuZ2VvbWV0cmllc1sgYnVpbGQuaWQgXTtcblxuXHRcdFx0aWYgKCBkYXRhLnNraW4gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRidWlsZC5za2luID0gYnVpbGRTa2luKCBkYXRhLnNraW4gKTtcblxuXHRcdFx0XHQvLyB3ZSBlbmhhbmNlIHRoZSAnc291cmNlcycgcHJvcGVydHkgb2YgdGhlIGNvcnJlc3BvbmRpbmcgZ2VvbWV0cnkgd2l0aCBvdXIgc2tpbiBkYXRhXG5cblx0XHRcdFx0Z2VvbWV0cnkuc291cmNlcy5za2luSW5kaWNlcyA9IGJ1aWxkLnNraW4uaW5kaWNlcztcblx0XHRcdFx0Z2VvbWV0cnkuc291cmNlcy5za2luV2VpZ2h0cyA9IGJ1aWxkLnNraW4ud2VpZ2h0cztcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYnVpbGQ7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZFNraW4oIGRhdGEgKSB7XG5cblx0XHRcdHZhciBCT05FX0xJTUlUID0gNDtcblxuXHRcdFx0dmFyIGJ1aWxkID0ge1xuXHRcdFx0XHRqb2ludHM6IFtdLCAvLyB0aGlzIG11c3QgYmUgYW4gYXJyYXkgdG8gcHJlc2VydmUgdGhlIGpvaW50IG9yZGVyXG5cdFx0XHRcdGluZGljZXM6IHtcblx0XHRcdFx0XHRhcnJheTogW10sXG5cdFx0XHRcdFx0c3RyaWRlOiBCT05FX0xJTUlUXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHdlaWdodHM6IHtcblx0XHRcdFx0XHRhcnJheTogW10sXG5cdFx0XHRcdFx0c3RyaWRlOiBCT05FX0xJTUlUXG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdHZhciBzb3VyY2VzID0gZGF0YS5zb3VyY2VzO1xuXHRcdFx0dmFyIHZlcnRleFdlaWdodHMgPSBkYXRhLnZlcnRleFdlaWdodHM7XG5cblx0XHRcdHZhciB2Y291bnQgPSB2ZXJ0ZXhXZWlnaHRzLnZjb3VudDtcblx0XHRcdHZhciB2ID0gdmVydGV4V2VpZ2h0cy52O1xuXHRcdFx0dmFyIGpvaW50T2Zmc2V0ID0gdmVydGV4V2VpZ2h0cy5pbnB1dHMuSk9JTlQub2Zmc2V0O1xuXHRcdFx0dmFyIHdlaWdodE9mZnNldCA9IHZlcnRleFdlaWdodHMuaW5wdXRzLldFSUdIVC5vZmZzZXQ7XG5cblx0XHRcdHZhciBqb2ludFNvdXJjZSA9IGRhdGEuc291cmNlc1sgZGF0YS5qb2ludHMuaW5wdXRzLkpPSU5UIF07XG5cdFx0XHR2YXIgaW52ZXJzZVNvdXJjZSA9IGRhdGEuc291cmNlc1sgZGF0YS5qb2ludHMuaW5wdXRzLklOVl9CSU5EX01BVFJJWCBdO1xuXG5cdFx0XHR2YXIgd2VpZ2h0cyA9IHNvdXJjZXNbIHZlcnRleFdlaWdodHMuaW5wdXRzLldFSUdIVC5pZCBdLmFycmF5O1xuXHRcdFx0dmFyIHN0cmlkZSA9IDA7XG5cblx0XHRcdHZhciBpLCBqLCBsO1xuXG5cdFx0XHQvLyBwcm9jY2VzIHNraW4gZGF0YSBmb3IgZWFjaCB2ZXJ0ZXhcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSB2Y291bnQubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgam9pbnRDb3VudCA9IHZjb3VudFsgaSBdOyAvLyB0aGlzIGlzIHRoZSBhbW91bnQgb2Ygam9pbnRzIHRoYXQgYWZmZWN0IGEgc2luZ2xlIHZlcnRleFxuXHRcdFx0XHR2YXIgdmVydGV4U2tpbkRhdGEgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IGpvaW50Q291bnQ7IGogKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgc2tpbkluZGV4ID0gdlsgc3RyaWRlICsgam9pbnRPZmZzZXQgXTtcblx0XHRcdFx0XHR2YXIgd2VpZ2h0SWQgPSB2WyBzdHJpZGUgKyB3ZWlnaHRPZmZzZXQgXTtcblx0XHRcdFx0XHR2YXIgc2tpbldlaWdodCA9IHdlaWdodHNbIHdlaWdodElkIF07XG5cblx0XHRcdFx0XHR2ZXJ0ZXhTa2luRGF0YS5wdXNoKCB7IGluZGV4OiBza2luSW5kZXgsIHdlaWdodDogc2tpbldlaWdodCB9ICk7XG5cblx0XHRcdFx0XHRzdHJpZGUgKz0gMjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gd2Ugc29ydCB0aGUgam9pbnRzIGluIGRlc2NlbmRpbmcgb3JkZXIgYmFzZWQgb24gdGhlIHdlaWdodHMuXG5cdFx0XHRcdC8vIHRoaXMgZW5zdXJlcywgd2Ugb25seSBwcm9jY2VkIHRoZSBtb3N0IGltcG9ydGFudCBqb2ludHMgb2YgdGhlIHZlcnRleFxuXG5cdFx0XHRcdHZlcnRleFNraW5EYXRhLnNvcnQoIGRlc2NlbmRpbmcgKTtcblxuXHRcdFx0XHQvLyBub3cgd2UgcHJvdmlkZSBmb3IgZWFjaCB2ZXJ0ZXggYSBzZXQgb2YgZm91ciBpbmRleCBhbmQgd2VpZ2h0IHZhbHVlcy5cblx0XHRcdFx0Ly8gdGhlIG9yZGVyIG9mIHRoZSBza2luIGRhdGEgbWF0Y2hlcyB0aGUgb3JkZXIgb2YgdmVydGljZXNcblxuXHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IEJPTkVfTElNSVQ7IGogKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgZCA9IHZlcnRleFNraW5EYXRhWyBqIF07XG5cblx0XHRcdFx0XHRpZiAoIGQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0YnVpbGQuaW5kaWNlcy5hcnJheS5wdXNoKCBkLmluZGV4ICk7XG5cdFx0XHRcdFx0XHRidWlsZC53ZWlnaHRzLmFycmF5LnB1c2goIGQud2VpZ2h0ICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRidWlsZC5pbmRpY2VzLmFycmF5LnB1c2goIDAgKTtcblx0XHRcdFx0XHRcdGJ1aWxkLndlaWdodHMuYXJyYXkucHVzaCggMCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBzZXR1cCBiaW5kIG1hdHJpeFxuXG5cdFx0XHRpZiAoIGRhdGEuYmluZFNoYXBlTWF0cml4ICkge1xuXG5cdFx0XHRcdGJ1aWxkLmJpbmRNYXRyaXggPSBuZXcgTWF0cml4NCgpLmZyb21BcnJheSggZGF0YS5iaW5kU2hhcGVNYXRyaXggKS50cmFuc3Bvc2UoKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRidWlsZC5iaW5kTWF0cml4ID0gbmV3IE1hdHJpeDQoKS5pZGVudGl0eSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHByb2Nlc3MgYm9uZXMgYW5kIGludmVyc2UgYmluZCBtYXRyaXggZGF0YVxuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IGpvaW50U291cmNlLmFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIG5hbWUgPSBqb2ludFNvdXJjZS5hcnJheVsgaSBdO1xuXHRcdFx0XHR2YXIgYm9uZUludmVyc2UgPSBuZXcgTWF0cml4NCgpLmZyb21BcnJheSggaW52ZXJzZVNvdXJjZS5hcnJheSwgaSAqIGludmVyc2VTb3VyY2Uuc3RyaWRlICkudHJhbnNwb3NlKCk7XG5cblx0XHRcdFx0YnVpbGQuam9pbnRzLnB1c2goIHsgbmFtZTogbmFtZSwgYm9uZUludmVyc2U6IGJvbmVJbnZlcnNlIH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYnVpbGQ7XG5cblx0XHRcdC8vIGFycmF5IHNvcnQgZnVuY3Rpb25cblxuXHRcdFx0ZnVuY3Rpb24gZGVzY2VuZGluZyggYSwgYiApIHtcblxuXHRcdFx0XHRyZXR1cm4gYi53ZWlnaHQgLSBhLndlaWdodDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0Q29udHJvbGxlciggaWQgKSB7XG5cblx0XHRcdHJldHVybiBnZXRCdWlsZCggbGlicmFyeS5jb250cm9sbGVyc1sgaWQgXSwgYnVpbGRDb250cm9sbGVyICk7XG5cblx0XHR9XG5cblx0XHQvLyBpbWFnZVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VJbWFnZSggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0aW5pdF9mcm9tOiBnZXRFbGVtZW50c0J5VGFnTmFtZSggeG1sLCAnaW5pdF9mcm9tJyApWyAwIF0udGV4dENvbnRlbnRcblx0XHRcdH07XG5cblx0XHRcdGxpYnJhcnkuaW1hZ2VzWyB4bWwuZ2V0QXR0cmlidXRlKCAnaWQnICkgXSA9IGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZEltYWdlKCBkYXRhICkge1xuXG5cdFx0XHRpZiAoIGRhdGEuYnVpbGQgIT09IHVuZGVmaW5lZCApIHJldHVybiBkYXRhLmJ1aWxkO1xuXG5cdFx0XHRyZXR1cm4gZGF0YS5pbml0X2Zyb207XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRJbWFnZSggaWQgKSB7XG5cblx0XHRcdHZhciBkYXRhID0gbGlicmFyeS5pbWFnZXNbIGlkIF07XG5cblx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiBnZXRCdWlsZCggZGF0YSwgYnVpbGRJbWFnZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IENvdWxkblxcJ3QgZmluZCBpbWFnZSB3aXRoIElEOicsIGlkICk7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0Ly8gZWZmZWN0XG5cblx0XHRmdW5jdGlvbiBwYXJzZUVmZmVjdCggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHt9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAncHJvZmlsZV9DT01NT04nOlxuXHRcdFx0XHRcdFx0ZGF0YS5wcm9maWxlID0gcGFyc2VFZmZlY3RQcm9maWxlQ09NTU9OKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGxpYnJhcnkuZWZmZWN0c1sgeG1sLmdldEF0dHJpYnV0ZSggJ2lkJyApIF0gPSBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VFZmZlY3RQcm9maWxlQ09NTU9OKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRzdXJmYWNlczoge30sXG5cdFx0XHRcdHNhbXBsZXJzOiB7fVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ25ld3BhcmFtJzpcblx0XHRcdFx0XHRcdHBhcnNlRWZmZWN0TmV3cGFyYW0oIGNoaWxkLCBkYXRhICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3RlY2huaXF1ZSc6XG5cdFx0XHRcdFx0XHRkYXRhLnRlY2huaXF1ZSA9IHBhcnNlRWZmZWN0VGVjaG5pcXVlKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdleHRyYSc6XG5cdFx0XHRcdFx0XHRkYXRhLmV4dHJhID0gcGFyc2VFZmZlY3RFeHRyYSggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlRWZmZWN0TmV3cGFyYW0oIHhtbCwgZGF0YSApIHtcblxuXHRcdFx0dmFyIHNpZCA9IHhtbC5nZXRBdHRyaWJ1dGUoICdzaWQnICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdzdXJmYWNlJzpcblx0XHRcdFx0XHRcdGRhdGEuc3VyZmFjZXNbIHNpZCBdID0gcGFyc2VFZmZlY3RTdXJmYWNlKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdzYW1wbGVyMkQnOlxuXHRcdFx0XHRcdFx0ZGF0YS5zYW1wbGVyc1sgc2lkIF0gPSBwYXJzZUVmZmVjdFNhbXBsZXIoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlRWZmZWN0U3VyZmFjZSggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHt9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnaW5pdF9mcm9tJzpcblx0XHRcdFx0XHRcdGRhdGEuaW5pdF9mcm9tID0gY2hpbGQudGV4dENvbnRlbnQ7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUVmZmVjdFNhbXBsZXIoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ3NvdXJjZSc6XG5cdFx0XHRcdFx0XHRkYXRhLnNvdXJjZSA9IGNoaWxkLnRleHRDb250ZW50O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VFZmZlY3RUZWNobmlxdWUoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2NvbnN0YW50Jzpcblx0XHRcdFx0XHRjYXNlICdsYW1iZXJ0Jzpcblx0XHRcdFx0XHRjYXNlICdibGlubic6XG5cdFx0XHRcdFx0Y2FzZSAncGhvbmcnOlxuXHRcdFx0XHRcdFx0ZGF0YS50eXBlID0gY2hpbGQubm9kZU5hbWU7XG5cdFx0XHRcdFx0XHRkYXRhLnBhcmFtZXRlcnMgPSBwYXJzZUVmZmVjdFBhcmFtZXRlcnMoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUVmZmVjdFBhcmFtZXRlcnMoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2VtaXNzaW9uJzpcblx0XHRcdFx0XHRjYXNlICdkaWZmdXNlJzpcblx0XHRcdFx0XHRjYXNlICdzcGVjdWxhcic6XG5cdFx0XHRcdFx0Y2FzZSAnYnVtcCc6XG5cdFx0XHRcdFx0Y2FzZSAnYW1iaWVudCc6XG5cdFx0XHRcdFx0Y2FzZSAnc2hpbmluZXNzJzpcblx0XHRcdFx0XHRjYXNlICd0cmFuc3BhcmVuY3knOlxuXHRcdFx0XHRcdFx0ZGF0YVsgY2hpbGQubm9kZU5hbWUgXSA9IHBhcnNlRWZmZWN0UGFyYW1ldGVyKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAndHJhbnNwYXJlbnQnOlxuXHRcdFx0XHRcdFx0ZGF0YVsgY2hpbGQubm9kZU5hbWUgXSA9IHtcblx0XHRcdFx0XHRcdFx0b3BhcXVlOiBjaGlsZC5nZXRBdHRyaWJ1dGUoICdvcGFxdWUnICksXG5cdFx0XHRcdFx0XHRcdGRhdGE6IHBhcnNlRWZmZWN0UGFyYW1ldGVyKCBjaGlsZCApXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VFZmZlY3RQYXJhbWV0ZXIoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2NvbG9yJzpcblx0XHRcdFx0XHRcdGRhdGFbIGNoaWxkLm5vZGVOYW1lIF0gPSBwYXJzZUZsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnZmxvYXQnOlxuXHRcdFx0XHRcdFx0ZGF0YVsgY2hpbGQubm9kZU5hbWUgXSA9IHBhcnNlRmxvYXQoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3RleHR1cmUnOlxuXHRcdFx0XHRcdFx0ZGF0YVsgY2hpbGQubm9kZU5hbWUgXSA9IHsgaWQ6IGNoaWxkLmdldEF0dHJpYnV0ZSggJ3RleHR1cmUnICksIGV4dHJhOiBwYXJzZUVmZmVjdFBhcmFtZXRlclRleHR1cmUoIGNoaWxkICkgfTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlRWZmZWN0UGFyYW1ldGVyVGV4dHVyZSggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0dGVjaG5pcXVlOiB7fVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2V4dHJhJzpcblx0XHRcdFx0XHRcdHBhcnNlRWZmZWN0UGFyYW1ldGVyVGV4dHVyZUV4dHJhKCBjaGlsZCwgZGF0YSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VFZmZlY3RQYXJhbWV0ZXJUZXh0dXJlRXh0cmEoIHhtbCwgZGF0YSApIHtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ3RlY2huaXF1ZSc6XG5cdFx0XHRcdFx0XHRwYXJzZUVmZmVjdFBhcmFtZXRlclRleHR1cmVFeHRyYVRlY2huaXF1ZSggY2hpbGQsIGRhdGEgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VFZmZlY3RQYXJhbWV0ZXJUZXh0dXJlRXh0cmFUZWNobmlxdWUoIHhtbCwgZGF0YSApIHtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ3JlcGVhdFUnOlxuXHRcdFx0XHRcdGNhc2UgJ3JlcGVhdFYnOlxuXHRcdFx0XHRcdGNhc2UgJ29mZnNldFUnOlxuXHRcdFx0XHRcdGNhc2UgJ29mZnNldFYnOlxuXHRcdFx0XHRcdFx0ZGF0YS50ZWNobmlxdWVbIGNoaWxkLm5vZGVOYW1lIF0gPSBwYXJzZUZsb2F0KCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd3cmFwVSc6XG5cdFx0XHRcdFx0Y2FzZSAnd3JhcFYnOlxuXG5cdFx0XHRcdFx0XHQvLyBzb21lIGZpbGVzIGhhdmUgdmFsdWVzIGZvciB3cmFwVS93cmFwViB3aGljaCBiZWNvbWUgTmFOIHZpYSBwYXJzZUludFxuXG5cdFx0XHRcdFx0XHRpZiAoIGNoaWxkLnRleHRDb250ZW50LnRvVXBwZXJDYXNlKCkgPT09ICdUUlVFJyApIHtcblxuXHRcdFx0XHRcdFx0XHRkYXRhLnRlY2huaXF1ZVsgY2hpbGQubm9kZU5hbWUgXSA9IDE7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNoaWxkLnRleHRDb250ZW50LnRvVXBwZXJDYXNlKCkgPT09ICdGQUxTRScgKSB7XG5cblx0XHRcdFx0XHRcdFx0ZGF0YS50ZWNobmlxdWVbIGNoaWxkLm5vZGVOYW1lIF0gPSAwO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdGRhdGEudGVjaG5pcXVlWyBjaGlsZC5ub2RlTmFtZSBdID0gcGFyc2VJbnQoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUVmZmVjdEV4dHJhKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge307XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICd0ZWNobmlxdWUnOlxuXHRcdFx0XHRcdFx0ZGF0YS50ZWNobmlxdWUgPSBwYXJzZUVmZmVjdEV4dHJhVGVjaG5pcXVlKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VFZmZlY3RFeHRyYVRlY2huaXF1ZSggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHt9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnZG91YmxlX3NpZGVkJzpcblx0XHRcdFx0XHRcdGRhdGFbIGNoaWxkLm5vZGVOYW1lIF0gPSBwYXJzZUludCggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkRWZmZWN0KCBkYXRhICkge1xuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEVmZmVjdCggaWQgKSB7XG5cblx0XHRcdHJldHVybiBnZXRCdWlsZCggbGlicmFyeS5lZmZlY3RzWyBpZCBdLCBidWlsZEVmZmVjdCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gbWF0ZXJpYWxcblxuXHRcdGZ1bmN0aW9uIHBhcnNlTWF0ZXJpYWwoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdG5hbWU6IHhtbC5nZXRBdHRyaWJ1dGUoICduYW1lJyApXG5cdFx0XHR9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnaW5zdGFuY2VfZWZmZWN0Jzpcblx0XHRcdFx0XHRcdGRhdGEudXJsID0gcGFyc2VJZCggY2hpbGQuZ2V0QXR0cmlidXRlKCAndXJsJyApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0bGlicmFyeS5tYXRlcmlhbHNbIHhtbC5nZXRBdHRyaWJ1dGUoICdpZCcgKSBdID0gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFRleHR1cmVMb2FkZXIoIGltYWdlICkge1xuXG5cdFx0XHR2YXIgbG9hZGVyO1xuXG5cdFx0XHR2YXIgZXh0ZW5zaW9uID0gaW1hZ2Uuc2xpY2UoICggaW1hZ2UubGFzdEluZGV4T2YoICcuJyApIC0gMSA+Pj4gMCApICsgMiApOyAvLyBodHRwOi8vd3d3LmpzdGlwcy5jby9lbi9qYXZhc2NyaXB0L2dldC1maWxlLWV4dGVuc2lvbi9cblx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRzd2l0Y2ggKCBleHRlbnNpb24gKSB7XG5cblx0XHRcdFx0Y2FzZSAndGdhJzpcblx0XHRcdFx0XHRsb2FkZXIgPSB0Z2FMb2FkZXI7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRsb2FkZXIgPSB0ZXh0dXJlTG9hZGVyO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBsb2FkZXI7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZE1hdGVyaWFsKCBkYXRhICkge1xuXG5cdFx0XHR2YXIgZWZmZWN0ID0gZ2V0RWZmZWN0KCBkYXRhLnVybCApO1xuXHRcdFx0dmFyIHRlY2huaXF1ZSA9IGVmZmVjdC5wcm9maWxlLnRlY2huaXF1ZTtcblx0XHRcdHZhciBleHRyYSA9IGVmZmVjdC5wcm9maWxlLmV4dHJhO1xuXG5cdFx0XHR2YXIgbWF0ZXJpYWw7XG5cblx0XHRcdHN3aXRjaCAoIHRlY2huaXF1ZS50eXBlICkge1xuXG5cdFx0XHRcdGNhc2UgJ3Bob25nJzpcblx0XHRcdFx0Y2FzZSAnYmxpbm4nOlxuXHRcdFx0XHRcdG1hdGVyaWFsID0gbmV3IE1lc2hQaG9uZ01hdGVyaWFsKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbGFtYmVydCc6XG5cdFx0XHRcdFx0bWF0ZXJpYWwgPSBuZXcgTWVzaExhbWJlcnRNYXRlcmlhbCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0bWF0ZXJpYWwgPSBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0XHRtYXRlcmlhbC5uYW1lID0gZGF0YS5uYW1lIHx8ICcnO1xuXG5cdFx0XHRmdW5jdGlvbiBnZXRUZXh0dXJlKCB0ZXh0dXJlT2JqZWN0ICkge1xuXG5cdFx0XHRcdHZhciBzYW1wbGVyID0gZWZmZWN0LnByb2ZpbGUuc2FtcGxlcnNbIHRleHR1cmVPYmplY3QuaWQgXTtcblx0XHRcdFx0dmFyIGltYWdlID0gbnVsbDtcblxuXHRcdFx0XHQvLyBnZXQgaW1hZ2VcblxuXHRcdFx0XHRpZiAoIHNhbXBsZXIgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHZhciBzdXJmYWNlID0gZWZmZWN0LnByb2ZpbGUuc3VyZmFjZXNbIHNhbXBsZXIuc291cmNlIF07XG5cdFx0XHRcdFx0aW1hZ2UgPSBnZXRJbWFnZSggc3VyZmFjZS5pbml0X2Zyb20gKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogVW5kZWZpbmVkIHNhbXBsZXIuIEFjY2VzcyBpbWFnZSBkaXJlY3RseSAoc2VlICMxMjUzMCkuJyApO1xuXHRcdFx0XHRcdGltYWdlID0gZ2V0SW1hZ2UoIHRleHR1cmVPYmplY3QuaWQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY3JlYXRlIHRleHR1cmUgaWYgaW1hZ2UgaXMgYXZhaWFibGVcblxuXHRcdFx0XHRpZiAoIGltYWdlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0dmFyIGxvYWRlciA9IGdldFRleHR1cmVMb2FkZXIoIGltYWdlICk7XG5cblx0XHRcdFx0XHRpZiAoIGxvYWRlciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgdGV4dHVyZSA9IGxvYWRlci5sb2FkKCBpbWFnZSApO1xuXG5cdFx0XHRcdFx0XHR2YXIgZXh0cmEgPSB0ZXh0dXJlT2JqZWN0LmV4dHJhO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGV4dHJhICE9PSB1bmRlZmluZWQgJiYgZXh0cmEudGVjaG5pcXVlICE9PSB1bmRlZmluZWQgJiYgaXNFbXB0eSggZXh0cmEudGVjaG5pcXVlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciB0ZWNobmlxdWUgPSBleHRyYS50ZWNobmlxdWU7XG5cblx0XHRcdFx0XHRcdFx0dGV4dHVyZS53cmFwUyA9IHRlY2huaXF1ZS53cmFwVSA/IFJlcGVhdFdyYXBwaW5nIDogQ2xhbXBUb0VkZ2VXcmFwcGluZztcblx0XHRcdFx0XHRcdFx0dGV4dHVyZS53cmFwVCA9IHRlY2huaXF1ZS53cmFwViA/IFJlcGVhdFdyYXBwaW5nIDogQ2xhbXBUb0VkZ2VXcmFwcGluZztcblxuXHRcdFx0XHRcdFx0XHR0ZXh0dXJlLm9mZnNldC5zZXQoIHRlY2huaXF1ZS5vZmZzZXRVIHx8IDAsIHRlY2huaXF1ZS5vZmZzZXRWIHx8IDAgKTtcblx0XHRcdFx0XHRcdFx0dGV4dHVyZS5yZXBlYXQuc2V0KCB0ZWNobmlxdWUucmVwZWF0VSB8fCAxLCB0ZWNobmlxdWUucmVwZWF0ViB8fCAxICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0dGV4dHVyZS53cmFwUyA9IFJlcGVhdFdyYXBwaW5nO1xuXHRcdFx0XHRcdFx0XHR0ZXh0dXJlLndyYXBUID0gUmVwZWF0V3JhcHBpbmc7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBMb2FkZXIgZm9yIHRleHR1cmUgJXMgbm90IGZvdW5kLicsIGltYWdlICk7XG5cblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBDb3VsZG5cXCd0IGNyZWF0ZSB0ZXh0dXJlIHdpdGggSUQ6JywgdGV4dHVyZU9iamVjdC5pZCApO1xuXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBwYXJhbWV0ZXJzID0gdGVjaG5pcXVlLnBhcmFtZXRlcnM7XG5cblx0XHRcdGZvciAoIHZhciBrZXkgaW4gcGFyYW1ldGVycyApIHtcblxuXHRcdFx0XHR2YXIgcGFyYW1ldGVyID0gcGFyYW1ldGVyc1sga2V5IF07XG5cblx0XHRcdFx0c3dpdGNoICgga2V5ICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnZGlmZnVzZSc6XG5cdFx0XHRcdFx0XHRpZiAoIHBhcmFtZXRlci5jb2xvciApIG1hdGVyaWFsLmNvbG9yLmZyb21BcnJheSggcGFyYW1ldGVyLmNvbG9yICk7XG5cdFx0XHRcdFx0XHRpZiAoIHBhcmFtZXRlci50ZXh0dXJlICkgbWF0ZXJpYWwubWFwID0gZ2V0VGV4dHVyZSggcGFyYW1ldGVyLnRleHR1cmUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3NwZWN1bGFyJzpcblx0XHRcdFx0XHRcdGlmICggcGFyYW1ldGVyLmNvbG9yICYmIG1hdGVyaWFsLnNwZWN1bGFyICkgbWF0ZXJpYWwuc3BlY3VsYXIuZnJvbUFycmF5KCBwYXJhbWV0ZXIuY29sb3IgKTtcblx0XHRcdFx0XHRcdGlmICggcGFyYW1ldGVyLnRleHR1cmUgKSBtYXRlcmlhbC5zcGVjdWxhck1hcCA9IGdldFRleHR1cmUoIHBhcmFtZXRlci50ZXh0dXJlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdidW1wJzpcblx0XHRcdFx0XHRcdGlmICggcGFyYW1ldGVyLnRleHR1cmUgKSBtYXRlcmlhbC5ub3JtYWxNYXAgPSBnZXRUZXh0dXJlKCBwYXJhbWV0ZXIudGV4dHVyZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnYW1iaWVudCc6XG5cdFx0XHRcdFx0XHRpZiAoIHBhcmFtZXRlci50ZXh0dXJlICkgbWF0ZXJpYWwubGlnaHRNYXAgPSBnZXRUZXh0dXJlKCBwYXJhbWV0ZXIudGV4dHVyZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnc2hpbmluZXNzJzpcblx0XHRcdFx0XHRcdGlmICggcGFyYW1ldGVyLmZsb2F0ICYmIG1hdGVyaWFsLnNoaW5pbmVzcyApIG1hdGVyaWFsLnNoaW5pbmVzcyA9IHBhcmFtZXRlci5mbG9hdDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2VtaXNzaW9uJzpcblx0XHRcdFx0XHRcdGlmICggcGFyYW1ldGVyLmNvbG9yICYmIG1hdGVyaWFsLmVtaXNzaXZlICkgbWF0ZXJpYWwuZW1pc3NpdmUuZnJvbUFycmF5KCBwYXJhbWV0ZXIuY29sb3IgKTtcblx0XHRcdFx0XHRcdGlmICggcGFyYW1ldGVyLnRleHR1cmUgKSBtYXRlcmlhbC5lbWlzc2l2ZU1hcCA9IGdldFRleHR1cmUoIHBhcmFtZXRlci50ZXh0dXJlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly9cblxuXHRcdFx0dmFyIHRyYW5zcGFyZW50ID0gcGFyYW1ldGVyc1sgJ3RyYW5zcGFyZW50JyBdO1xuXHRcdFx0dmFyIHRyYW5zcGFyZW5jeSA9IHBhcmFtZXRlcnNbICd0cmFuc3BhcmVuY3knIF07XG5cblx0XHRcdC8vIDx0cmFuc3BhcmVuY3k+IGRvZXMgbm90IGV4aXN0IGJ1dCA8dHJhbnNwYXJlbnQ+XG5cblx0XHRcdGlmICggdHJhbnNwYXJlbmN5ID09PSB1bmRlZmluZWQgJiYgdHJhbnNwYXJlbnQgKSB7XG5cblx0XHRcdFx0dHJhbnNwYXJlbmN5ID0ge1xuXHRcdFx0XHRcdGZsb2F0OiAxXG5cdFx0XHRcdH07XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gPHRyYW5zcGFyZW50PiBkb2VzIG5vdCBleGlzdCBidXQgPHRyYW5zcGFyZW5jeT5cblxuXHRcdFx0aWYgKCB0cmFuc3BhcmVudCA9PT0gdW5kZWZpbmVkICYmIHRyYW5zcGFyZW5jeSApIHtcblxuXHRcdFx0XHR0cmFuc3BhcmVudCA9IHtcblx0XHRcdFx0XHRvcGFxdWU6ICdBX09ORScsXG5cdFx0XHRcdFx0ZGF0YToge1xuXHRcdFx0XHRcdFx0Y29sb3I6IFsgMSwgMSwgMSwgMSBdXG5cdFx0XHRcdFx0fSB9O1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdHJhbnNwYXJlbnQgJiYgdHJhbnNwYXJlbmN5ICkge1xuXG5cdFx0XHRcdC8vIGhhbmRsZSBjYXNlIGlmIGEgdGV4dHVyZSBleGlzdHMgYnV0IG5vIGNvbG9yXG5cblx0XHRcdFx0aWYgKCB0cmFuc3BhcmVudC5kYXRhLnRleHR1cmUgKSB7XG5cblx0XHRcdFx0XHQvLyB3ZSBkbyBub3Qgc2V0IGFuIGFscGhhIG1hcCAoc2VlICMxMzc5MilcblxuXHRcdFx0XHRcdG1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dmFyIGNvbG9yID0gdHJhbnNwYXJlbnQuZGF0YS5jb2xvcjtcblxuXHRcdFx0XHRcdHN3aXRjaCAoIHRyYW5zcGFyZW50Lm9wYXF1ZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnQV9PTkUnOlxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbC5vcGFjaXR5ID0gY29sb3JbIDMgXSAqIHRyYW5zcGFyZW5jeS5mbG9hdDtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdSR0JfWkVSTyc6XG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsLm9wYWNpdHkgPSAxIC0gKCBjb2xvclsgMCBdICogdHJhbnNwYXJlbmN5LmZsb2F0ICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnQV9aRVJPJzpcblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwub3BhY2l0eSA9IDEgLSAoIGNvbG9yWyAzIF0gKiB0cmFuc3BhcmVuY3kuZmxvYXQgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdSR0JfT05FJzpcblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwub3BhY2l0eSA9IGNvbG9yWyAwIF0gKiB0cmFuc3BhcmVuY3kuZmxvYXQ7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogSW52YWxpZCBvcGFxdWUgdHlwZSBcIiVzXCIgb2YgdHJhbnNwYXJlbnQgdGFnLicsIHRyYW5zcGFyZW50Lm9wYXF1ZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5vcGFjaXR5IDwgMSApIG1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly9cblxuXHRcdFx0aWYgKCBleHRyYSAhPT0gdW5kZWZpbmVkICYmIGV4dHJhLnRlY2huaXF1ZSAhPT0gdW5kZWZpbmVkICYmIGV4dHJhLnRlY2huaXF1ZS5kb3VibGVfc2lkZWQgPT09IDEgKSB7XG5cblx0XHRcdFx0bWF0ZXJpYWwuc2lkZSA9IERvdWJsZVNpZGU7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGVyaWFsO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0TWF0ZXJpYWwoIGlkICkge1xuXG5cdFx0XHRyZXR1cm4gZ2V0QnVpbGQoIGxpYnJhcnkubWF0ZXJpYWxzWyBpZCBdLCBidWlsZE1hdGVyaWFsICk7XG5cblx0XHR9XG5cblx0XHQvLyBjYW1lcmFcblxuXHRcdGZ1bmN0aW9uIHBhcnNlQ2FtZXJhKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRuYW1lOiB4bWwuZ2V0QXR0cmlidXRlKCAnbmFtZScgKVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ29wdGljcyc6XG5cdFx0XHRcdFx0XHRkYXRhLm9wdGljcyA9IHBhcnNlQ2FtZXJhT3B0aWNzKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGxpYnJhcnkuY2FtZXJhc1sgeG1sLmdldEF0dHJpYnV0ZSggJ2lkJyApIF0gPSBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VDYW1lcmFPcHRpY3MoIHhtbCApIHtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICd0ZWNobmlxdWVfY29tbW9uJzpcblx0XHRcdFx0XHRcdHJldHVybiBwYXJzZUNhbWVyYVRlY2huaXF1ZSggY2hpbGQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHt9O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VDYW1lcmFUZWNobmlxdWUoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdwZXJzcGVjdGl2ZSc6XG5cdFx0XHRcdFx0Y2FzZSAnb3J0aG9ncmFwaGljJzpcblxuXHRcdFx0XHRcdFx0ZGF0YS50ZWNobmlxdWUgPSBjaGlsZC5ub2RlTmFtZTtcblx0XHRcdFx0XHRcdGRhdGEucGFyYW1ldGVycyA9IHBhcnNlQ2FtZXJhUGFyYW1ldGVycyggY2hpbGQgKTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VDYW1lcmFQYXJhbWV0ZXJzKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge307XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAneGZvdic6XG5cdFx0XHRcdFx0Y2FzZSAneWZvdic6XG5cdFx0XHRcdFx0Y2FzZSAneG1hZyc6XG5cdFx0XHRcdFx0Y2FzZSAneW1hZyc6XG5cdFx0XHRcdFx0Y2FzZSAnem5lYXInOlxuXHRcdFx0XHRcdGNhc2UgJ3pmYXInOlxuXHRcdFx0XHRcdGNhc2UgJ2FzcGVjdF9yYXRpbyc6XG5cdFx0XHRcdFx0XHRkYXRhWyBjaGlsZC5ub2RlTmFtZSBdID0gcGFyc2VGbG9hdCggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkQ2FtZXJhKCBkYXRhICkge1xuXG5cdFx0XHR2YXIgY2FtZXJhO1xuXG5cdFx0XHRzd2l0Y2ggKCBkYXRhLm9wdGljcy50ZWNobmlxdWUgKSB7XG5cblx0XHRcdFx0Y2FzZSAncGVyc3BlY3RpdmUnOlxuXHRcdFx0XHRcdGNhbWVyYSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYShcblx0XHRcdFx0XHRcdGRhdGEub3B0aWNzLnBhcmFtZXRlcnMueWZvdixcblx0XHRcdFx0XHRcdGRhdGEub3B0aWNzLnBhcmFtZXRlcnMuYXNwZWN0X3JhdGlvLFxuXHRcdFx0XHRcdFx0ZGF0YS5vcHRpY3MucGFyYW1ldGVycy56bmVhcixcblx0XHRcdFx0XHRcdGRhdGEub3B0aWNzLnBhcmFtZXRlcnMuemZhclxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnb3J0aG9ncmFwaGljJzpcblx0XHRcdFx0XHR2YXIgeW1hZyA9IGRhdGEub3B0aWNzLnBhcmFtZXRlcnMueW1hZztcblx0XHRcdFx0XHR2YXIgeG1hZyA9IGRhdGEub3B0aWNzLnBhcmFtZXRlcnMueG1hZztcblx0XHRcdFx0XHR2YXIgYXNwZWN0UmF0aW8gPSBkYXRhLm9wdGljcy5wYXJhbWV0ZXJzLmFzcGVjdF9yYXRpbztcblxuXHRcdFx0XHRcdHhtYWcgPSAoIHhtYWcgPT09IHVuZGVmaW5lZCApID8gKCB5bWFnICogYXNwZWN0UmF0aW8gKSA6IHhtYWc7XG5cdFx0XHRcdFx0eW1hZyA9ICggeW1hZyA9PT0gdW5kZWZpbmVkICkgPyAoIHhtYWcgLyBhc3BlY3RSYXRpbyApIDogeW1hZztcblxuXHRcdFx0XHRcdHhtYWcgKj0gMC41O1xuXHRcdFx0XHRcdHltYWcgKj0gMC41O1xuXG5cdFx0XHRcdFx0Y2FtZXJhID0gbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYShcblx0XHRcdFx0XHRcdC0geG1hZywgeG1hZywgeW1hZywgLSB5bWFnLCAvLyBsZWZ0LCByaWdodCwgdG9wLCBib3R0b21cblx0XHRcdFx0XHRcdGRhdGEub3B0aWNzLnBhcmFtZXRlcnMuem5lYXIsXG5cdFx0XHRcdFx0XHRkYXRhLm9wdGljcy5wYXJhbWV0ZXJzLnpmYXJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0Y2FtZXJhID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdFx0Y2FtZXJhLm5hbWUgPSBkYXRhLm5hbWUgfHwgJyc7XG5cblx0XHRcdHJldHVybiBjYW1lcmE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRDYW1lcmEoIGlkICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IGxpYnJhcnkuY2FtZXJhc1sgaWQgXTtcblxuXHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGdldEJ1aWxkKCBkYXRhLCBidWlsZENhbWVyYSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IENvdWxkblxcJ3QgZmluZCBjYW1lcmEgd2l0aCBJRDonLCBpZCApO1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdC8vIGxpZ2h0XG5cblx0XHRmdW5jdGlvbiBwYXJzZUxpZ2h0KCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge307XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICd0ZWNobmlxdWVfY29tbW9uJzpcblx0XHRcdFx0XHRcdGRhdGEgPSBwYXJzZUxpZ2h0VGVjaG5pcXVlKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGxpYnJhcnkubGlnaHRzWyB4bWwuZ2V0QXR0cmlidXRlKCAnaWQnICkgXSA9IGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUxpZ2h0VGVjaG5pcXVlKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge307XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdkaXJlY3Rpb25hbCc6XG5cdFx0XHRcdFx0Y2FzZSAncG9pbnQnOlxuXHRcdFx0XHRcdGNhc2UgJ3Nwb3QnOlxuXHRcdFx0XHRcdGNhc2UgJ2FtYmllbnQnOlxuXG5cdFx0XHRcdFx0XHRkYXRhLnRlY2huaXF1ZSA9IGNoaWxkLm5vZGVOYW1lO1xuXHRcdFx0XHRcdFx0ZGF0YS5wYXJhbWV0ZXJzID0gcGFyc2VMaWdodFBhcmFtZXRlcnMoIGNoaWxkICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VMaWdodFBhcmFtZXRlcnMoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2NvbG9yJzpcblx0XHRcdFx0XHRcdHZhciBhcnJheSA9IHBhcnNlRmxvYXRzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0ZGF0YS5jb2xvciA9IG5ldyBDb2xvcigpLmZyb21BcnJheSggYXJyYXkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnZmFsbG9mZl9hbmdsZSc6XG5cdFx0XHRcdFx0XHRkYXRhLmZhbGxvZmZBbmdsZSA9IHBhcnNlRmxvYXQoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3F1YWRyYXRpY19hdHRlbnVhdGlvbic6XG5cdFx0XHRcdFx0XHR2YXIgZiA9IHBhcnNlRmxvYXQoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRkYXRhLmRpc3RhbmNlID0gZiA/IE1hdGguc3FydCggMSAvIGYgKSA6IDA7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZExpZ2h0KCBkYXRhICkge1xuXG5cdFx0XHR2YXIgbGlnaHQ7XG5cblx0XHRcdHN3aXRjaCAoIGRhdGEudGVjaG5pcXVlICkge1xuXG5cdFx0XHRcdGNhc2UgJ2RpcmVjdGlvbmFsJzpcblx0XHRcdFx0XHRsaWdodCA9IG5ldyBEaXJlY3Rpb25hbExpZ2h0KCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAncG9pbnQnOlxuXHRcdFx0XHRcdGxpZ2h0ID0gbmV3IFBvaW50TGlnaHQoKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdzcG90Jzpcblx0XHRcdFx0XHRsaWdodCA9IG5ldyBTcG90TGlnaHQoKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdhbWJpZW50Jzpcblx0XHRcdFx0XHRsaWdodCA9IG5ldyBBbWJpZW50TGlnaHQoKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGRhdGEucGFyYW1ldGVycy5jb2xvciApIGxpZ2h0LmNvbG9yLmNvcHkoIGRhdGEucGFyYW1ldGVycy5jb2xvciApO1xuXHRcdFx0aWYgKCBkYXRhLnBhcmFtZXRlcnMuZGlzdGFuY2UgKSBsaWdodC5kaXN0YW5jZSA9IGRhdGEucGFyYW1ldGVycy5kaXN0YW5jZTtcblxuXHRcdFx0cmV0dXJuIGxpZ2h0O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0TGlnaHQoIGlkICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IGxpYnJhcnkubGlnaHRzWyBpZCBdO1xuXG5cdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gZ2V0QnVpbGQoIGRhdGEsIGJ1aWxkTGlnaHQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBDb3VsZG5cXCd0IGZpbmQgbGlnaHQgd2l0aCBJRDonLCBpZCApO1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdC8vIGdlb21ldHJ5XG5cblx0XHRmdW5jdGlvbiBwYXJzZUdlb21ldHJ5KCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRuYW1lOiB4bWwuZ2V0QXR0cmlidXRlKCAnbmFtZScgKSxcblx0XHRcdFx0c291cmNlczoge30sXG5cdFx0XHRcdHZlcnRpY2VzOiB7fSxcblx0XHRcdFx0cHJpbWl0aXZlczogW11cblx0XHRcdH07XG5cblx0XHRcdHZhciBtZXNoID0gZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHhtbCwgJ21lc2gnIClbIDAgXTtcblxuXHRcdFx0Ly8gdGhlIGZvbGxvd2luZyB0YWdzIGluc2lkZSBnZW9tZXRyeSBhcmUgbm90IHN1cHBvcnRlZCB5ZXQgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMTI2MDYpOiBjb252ZXhfbWVzaCwgc3BsaW5lLCBicmVwXG5cdFx0XHRpZiAoIG1lc2ggPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbWVzaC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSBtZXNoLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0dmFyIGlkID0gY2hpbGQuZ2V0QXR0cmlidXRlKCAnaWQnICk7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdzb3VyY2UnOlxuXHRcdFx0XHRcdFx0ZGF0YS5zb3VyY2VzWyBpZCBdID0gcGFyc2VTb3VyY2UoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3ZlcnRpY2VzJzpcblx0XHRcdFx0XHRcdC8vIGRhdGEuc291cmNlc1sgaWQgXSA9IGRhdGEuc291cmNlc1sgcGFyc2VJZCggZ2V0RWxlbWVudHNCeVRhZ05hbWUoIGNoaWxkLCAnaW5wdXQnIClbIDAgXS5nZXRBdHRyaWJ1dGUoICdzb3VyY2UnICkgKSBdO1xuXHRcdFx0XHRcdFx0ZGF0YS52ZXJ0aWNlcyA9IHBhcnNlR2VvbWV0cnlWZXJ0aWNlcyggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAncG9seWdvbnMnOlxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogVW5zdXBwb3J0ZWQgcHJpbWl0aXZlIHR5cGU6ICcsIGNoaWxkLm5vZGVOYW1lICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2xpbmVzJzpcblx0XHRcdFx0XHRjYXNlICdsaW5lc3RyaXBzJzpcblx0XHRcdFx0XHRjYXNlICdwb2x5bGlzdCc6XG5cdFx0XHRcdFx0Y2FzZSAndHJpYW5nbGVzJzpcblx0XHRcdFx0XHRcdGRhdGEucHJpbWl0aXZlcy5wdXNoKCBwYXJzZUdlb21ldHJ5UHJpbWl0aXZlKCBjaGlsZCApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyggY2hpbGQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0bGlicmFyeS5nZW9tZXRyaWVzWyB4bWwuZ2V0QXR0cmlidXRlKCAnaWQnICkgXSA9IGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZVNvdXJjZSggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0YXJyYXk6IFtdLFxuXHRcdFx0XHRzdHJpZGU6IDNcblx0XHRcdH07XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2Zsb2F0X2FycmF5Jzpcblx0XHRcdFx0XHRcdGRhdGEuYXJyYXkgPSBwYXJzZUZsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnTmFtZV9hcnJheSc6XG5cdFx0XHRcdFx0XHRkYXRhLmFycmF5ID0gcGFyc2VTdHJpbmdzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd0ZWNobmlxdWVfY29tbW9uJzpcblx0XHRcdFx0XHRcdHZhciBhY2Nlc3NvciA9IGdldEVsZW1lbnRzQnlUYWdOYW1lKCBjaGlsZCwgJ2FjY2Vzc29yJyApWyAwIF07XG5cblx0XHRcdFx0XHRcdGlmICggYWNjZXNzb3IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRkYXRhLnN0cmlkZSA9IHBhcnNlSW50KCBhY2Nlc3Nvci5nZXRBdHRyaWJ1dGUoICdzdHJpZGUnICkgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUdlb21ldHJ5VmVydGljZXMoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGRhdGFbIGNoaWxkLmdldEF0dHJpYnV0ZSggJ3NlbWFudGljJyApIF0gPSBwYXJzZUlkKCBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzb3VyY2UnICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlR2VvbWV0cnlQcmltaXRpdmUoIHhtbCApIHtcblxuXHRcdFx0dmFyIHByaW1pdGl2ZSA9IHtcblx0XHRcdFx0dHlwZTogeG1sLm5vZGVOYW1lLFxuXHRcdFx0XHRtYXRlcmlhbDogeG1sLmdldEF0dHJpYnV0ZSggJ21hdGVyaWFsJyApLFxuXHRcdFx0XHRjb3VudDogcGFyc2VJbnQoIHhtbC5nZXRBdHRyaWJ1dGUoICdjb3VudCcgKSApLFxuXHRcdFx0XHRpbnB1dHM6IHt9LFxuXHRcdFx0XHRzdHJpZGU6IDAsXG5cdFx0XHRcdGhhc1VWOiBmYWxzZVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2lucHV0Jzpcblx0XHRcdFx0XHRcdHZhciBpZCA9IHBhcnNlSWQoIGNoaWxkLmdldEF0dHJpYnV0ZSggJ3NvdXJjZScgKSApO1xuXHRcdFx0XHRcdFx0dmFyIHNlbWFudGljID0gY2hpbGQuZ2V0QXR0cmlidXRlKCAnc2VtYW50aWMnICk7XG5cdFx0XHRcdFx0XHR2YXIgb2Zmc2V0ID0gcGFyc2VJbnQoIGNoaWxkLmdldEF0dHJpYnV0ZSggJ29mZnNldCcgKSApO1xuXHRcdFx0XHRcdFx0dmFyIHNldCA9IHBhcnNlSW50KCBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzZXQnICkgKTtcblx0XHRcdFx0XHRcdHZhciBpbnB1dG5hbWUgPSAoIHNldCA+IDAgPyBzZW1hbnRpYyArIHNldCA6IHNlbWFudGljICk7XG5cdFx0XHRcdFx0XHRwcmltaXRpdmUuaW5wdXRzWyBpbnB1dG5hbWUgXSA9IHsgaWQ6IGlkLCBvZmZzZXQ6IG9mZnNldCB9O1xuXHRcdFx0XHRcdFx0cHJpbWl0aXZlLnN0cmlkZSA9IE1hdGgubWF4KCBwcmltaXRpdmUuc3RyaWRlLCBvZmZzZXQgKyAxICk7XG5cdFx0XHRcdFx0XHRpZiAoIHNlbWFudGljID09PSAnVEVYQ09PUkQnICkgcHJpbWl0aXZlLmhhc1VWID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndmNvdW50Jzpcblx0XHRcdFx0XHRcdHByaW1pdGl2ZS52Y291bnQgPSBwYXJzZUludHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3AnOlxuXHRcdFx0XHRcdFx0cHJpbWl0aXZlLnAgPSBwYXJzZUludHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHByaW1pdGl2ZTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdyb3VwUHJpbWl0aXZlcyggcHJpbWl0aXZlcyApIHtcblxuXHRcdFx0dmFyIGJ1aWxkID0ge307XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHByaW1pdGl2ZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBwcmltaXRpdmUgPSBwcmltaXRpdmVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBidWlsZFsgcHJpbWl0aXZlLnR5cGUgXSA9PT0gdW5kZWZpbmVkICkgYnVpbGRbIHByaW1pdGl2ZS50eXBlIF0gPSBbXTtcblxuXHRcdFx0XHRidWlsZFsgcHJpbWl0aXZlLnR5cGUgXS5wdXNoKCBwcmltaXRpdmUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYnVpbGQ7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjaGVja1VWQ29vcmRpbmF0ZXMoIHByaW1pdGl2ZXMgKSB7XG5cblx0XHRcdHZhciBjb3VudCA9IDA7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHByaW1pdGl2ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgcHJpbWl0aXZlID0gcHJpbWl0aXZlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggcHJpbWl0aXZlLmhhc1VWID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Y291bnQgKys7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggY291bnQgPiAwICYmIGNvdW50IDwgcHJpbWl0aXZlcy5sZW5ndGggKSB7XG5cblx0XHRcdFx0cHJpbWl0aXZlcy51dnNOZWVkc0ZpeCA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkR2VvbWV0cnkoIGRhdGEgKSB7XG5cblx0XHRcdHZhciBidWlsZCA9IHt9O1xuXG5cdFx0XHR2YXIgc291cmNlcyA9IGRhdGEuc291cmNlcztcblx0XHRcdHZhciB2ZXJ0aWNlcyA9IGRhdGEudmVydGljZXM7XG5cdFx0XHR2YXIgcHJpbWl0aXZlcyA9IGRhdGEucHJpbWl0aXZlcztcblxuXHRcdFx0aWYgKCBwcmltaXRpdmVzLmxlbmd0aCA9PT0gMCApIHJldHVybiB7fTtcblxuXHRcdFx0Ly8gb3VyIGdvYWwgaXMgdG8gY3JlYXRlIG9uZSBidWZmZXIgZ2VvbWV0cnkgZm9yIGEgc2luZ2xlIHR5cGUgb2YgcHJpbWl0aXZlc1xuXHRcdFx0Ly8gZmlyc3QsIHdlIGdyb3VwIGFsbCBwcmltaXRpdmVzIGJ5IHRoZWlyIHR5cGVcblxuXHRcdFx0dmFyIGdyb3VwZWRQcmltaXRpdmVzID0gZ3JvdXBQcmltaXRpdmVzKCBwcmltaXRpdmVzICk7XG5cblx0XHRcdGZvciAoIHZhciB0eXBlIGluIGdyb3VwZWRQcmltaXRpdmVzICkge1xuXG5cdFx0XHRcdHZhciBwcmltaXRpdmVUeXBlID0gZ3JvdXBlZFByaW1pdGl2ZXNbIHR5cGUgXTtcblxuXHRcdFx0XHQvLyBzZWNvbmQsIGVuc3VyZSBjb25zaXN0ZW50IHV2IGNvb3JkaW5hdGVzIGZvciBlYWNoIHR5cGUgb2YgcHJpbWl0aXZlcyAocG9seWxpc3QsdHJpYW5nbGVzIG9yIGxpbmVzKVxuXG5cdFx0XHRcdGNoZWNrVVZDb29yZGluYXRlcyggcHJpbWl0aXZlVHlwZSApO1xuXG5cdFx0XHRcdC8vIHRoaXJkLCBjcmVhdGUgYSBidWZmZXIgZ2VvbWV0cnkgZm9yIGVhY2ggdHlwZSBvZiBwcmltaXRpdmVzXG5cblx0XHRcdFx0YnVpbGRbIHR5cGUgXSA9IGJ1aWxkR2VvbWV0cnlUeXBlKCBwcmltaXRpdmVUeXBlLCBzb3VyY2VzLCB2ZXJ0aWNlcyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBidWlsZDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkR2VvbWV0cnlUeXBlKCBwcmltaXRpdmVzLCBzb3VyY2VzLCB2ZXJ0aWNlcyApIHtcblxuXHRcdFx0dmFyIGJ1aWxkID0ge307XG5cblx0XHRcdHZhciBwb3NpdGlvbiA9IHsgYXJyYXk6IFtdLCBzdHJpZGU6IDAgfTtcblx0XHRcdHZhciBub3JtYWwgPSB7IGFycmF5OiBbXSwgc3RyaWRlOiAwIH07XG5cdFx0XHR2YXIgdXYgPSB7IGFycmF5OiBbXSwgc3RyaWRlOiAwIH07XG5cdFx0XHR2YXIgdXYyID0geyBhcnJheTogW10sIHN0cmlkZTogMCB9O1xuXHRcdFx0dmFyIGNvbG9yID0geyBhcnJheTogW10sIHN0cmlkZTogMCB9O1xuXG5cdFx0XHR2YXIgc2tpbkluZGV4ID0geyBhcnJheTogW10sIHN0cmlkZTogNCB9O1xuXHRcdFx0dmFyIHNraW5XZWlnaHQgPSB7IGFycmF5OiBbXSwgc3RyaWRlOiA0IH07XG5cblx0XHRcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXG5cdFx0XHR2YXIgbWF0ZXJpYWxLZXlzID0gW107XG5cblx0XHRcdHZhciBzdGFydCA9IDA7XG5cblx0XHRcdGZvciAoIHZhciBwID0gMDsgcCA8IHByaW1pdGl2ZXMubGVuZ3RoOyBwICsrICkge1xuXG5cdFx0XHRcdHZhciBwcmltaXRpdmUgPSBwcmltaXRpdmVzWyBwIF07XG5cdFx0XHRcdHZhciBpbnB1dHMgPSBwcmltaXRpdmUuaW5wdXRzO1xuXG5cdFx0XHRcdC8vIGdyb3Vwc1xuXG5cdFx0XHRcdHZhciBjb3VudCA9IDA7XG5cblx0XHRcdFx0c3dpdGNoICggcHJpbWl0aXZlLnR5cGUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdsaW5lcyc6XG5cdFx0XHRcdFx0Y2FzZSAnbGluZXN0cmlwcyc6XG5cdFx0XHRcdFx0XHRjb3VudCA9IHByaW1pdGl2ZS5jb3VudCAqIDI7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3RyaWFuZ2xlcyc6XG5cdFx0XHRcdFx0XHRjb3VudCA9IHByaW1pdGl2ZS5jb3VudCAqIDM7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3BvbHlsaXN0JzpcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGcgPSAwOyBnIDwgcHJpbWl0aXZlLmNvdW50OyBnICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciB2YyA9IHByaW1pdGl2ZS52Y291bnRbIGcgXTtcblxuXHRcdFx0XHRcdFx0XHRzd2l0Y2ggKCB2YyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgMzpcblx0XHRcdFx0XHRcdFx0XHRcdGNvdW50ICs9IDM7IC8vIHNpbmdsZSB0cmlhbmdsZVxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRjYXNlIDQ6XG5cdFx0XHRcdFx0XHRcdFx0XHRjb3VudCArPSA2OyAvLyBxdWFkLCBzdWJkaXZpZGVkIGludG8gdHdvIHRyaWFuZ2xlc1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdFx0Y291bnQgKz0gKCB2YyAtIDIgKSAqIDM7IC8vIHBvbHlsaXN0IHdpdGggbW9yZSB0aGFuIGZvdXIgdmVydGljZXNcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBVbmtub3cgcHJpbWl0aXZlIHR5cGU6JywgcHJpbWl0aXZlLnR5cGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cnkuYWRkR3JvdXAoIHN0YXJ0LCBjb3VudCwgcCApO1xuXHRcdFx0XHRzdGFydCArPSBjb3VudDtcblxuXHRcdFx0XHQvLyBtYXRlcmlhbFxuXG5cdFx0XHRcdGlmICggcHJpbWl0aXZlLm1hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0bWF0ZXJpYWxLZXlzLnB1c2goIHByaW1pdGl2ZS5tYXRlcmlhbCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBnZW9tZXRyeSBkYXRhXG5cblx0XHRcdFx0Zm9yICggdmFyIG5hbWUgaW4gaW5wdXRzICkge1xuXG5cdFx0XHRcdFx0dmFyIGlucHV0ID0gaW5wdXRzWyBuYW1lIF07XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBuYW1lIClcdHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnVkVSVEVYJzpcblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGtleSBpbiB2ZXJ0aWNlcyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHZhciBpZCA9IHZlcnRpY2VzWyBrZXkgXTtcblxuXHRcdFx0XHRcdFx0XHRcdHN3aXRjaCAoIGtleSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAnUE9TSVRJT04nOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgcHJldkxlbmd0aCA9IHBvc2l0aW9uLmFycmF5Lmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnVpbGRHZW9tZXRyeURhdGEoIHByaW1pdGl2ZSwgc291cmNlc1sgaWQgXSwgaW5wdXQub2Zmc2V0LCBwb3NpdGlvbi5hcnJheSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwb3NpdGlvbi5zdHJpZGUgPSBzb3VyY2VzWyBpZCBdLnN0cmlkZTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHNvdXJjZXMuc2tpbldlaWdodHMgJiYgc291cmNlcy5za2luSW5kaWNlcyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJ1aWxkR2VvbWV0cnlEYXRhKCBwcmltaXRpdmUsIHNvdXJjZXMuc2tpbkluZGljZXMsIGlucHV0Lm9mZnNldCwgc2tpbkluZGV4LmFycmF5ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnVpbGRHZW9tZXRyeURhdGEoIHByaW1pdGl2ZSwgc291cmNlcy5za2luV2VpZ2h0cywgaW5wdXQub2Zmc2V0LCBza2luV2VpZ2h0LmFycmF5ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIHNlZSAjMzgwM1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggcHJpbWl0aXZlLmhhc1VWID09PSBmYWxzZSAmJiBwcmltaXRpdmVzLnV2c05lZWRzRml4ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIGNvdW50ID0gKCBwb3NpdGlvbi5hcnJheS5sZW5ndGggLSBwcmV2TGVuZ3RoICkgLyBwb3NpdGlvbi5zdHJpZGU7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gZmlsbCBtaXNzaW5nIHV2IGNvb3JkaW5hdGVzXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHV2LmFycmF5LnB1c2goIDAsIDAgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ05PUk1BTCc6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJ1aWxkR2VvbWV0cnlEYXRhKCBwcmltaXRpdmUsIHNvdXJjZXNbIGlkIF0sIGlucHV0Lm9mZnNldCwgbm9ybWFsLmFycmF5ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vcm1hbC5zdHJpZGUgPSBzb3VyY2VzWyBpZCBdLnN0cmlkZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ0NPTE9SJzpcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnVpbGRHZW9tZXRyeURhdGEoIHByaW1pdGl2ZSwgc291cmNlc1sgaWQgXSwgaW5wdXQub2Zmc2V0LCBjb2xvci5hcnJheSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjb2xvci5zdHJpZGUgPSBzb3VyY2VzWyBpZCBdLnN0cmlkZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ1RFWENPT1JEJzpcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnVpbGRHZW9tZXRyeURhdGEoIHByaW1pdGl2ZSwgc291cmNlc1sgaWQgXSwgaW5wdXQub2Zmc2V0LCB1di5hcnJheSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR1di5zdHJpZGUgPSBzb3VyY2VzWyBpZCBdLnN0cmlkZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ1RFWENPT1JEMSc6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJ1aWxkR2VvbWV0cnlEYXRhKCBwcmltaXRpdmUsIHNvdXJjZXNbIGlkIF0sIGlucHV0Lm9mZnNldCwgdXYyLmFycmF5ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHV2LnN0cmlkZSA9IHNvdXJjZXNbIGlkIF0uc3RyaWRlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogU2VtYW50aWMgXCIlc1wiIG5vdCBoYW5kbGVkIGluIGdlb21ldHJ5IGJ1aWxkIHByb2Nlc3MuJywga2V5ICk7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdOT1JNQUwnOlxuXHRcdFx0XHRcdFx0XHRidWlsZEdlb21ldHJ5RGF0YSggcHJpbWl0aXZlLCBzb3VyY2VzWyBpbnB1dC5pZCBdLCBpbnB1dC5vZmZzZXQsIG5vcm1hbC5hcnJheSApO1xuXHRcdFx0XHRcdFx0XHRub3JtYWwuc3RyaWRlID0gc291cmNlc1sgaW5wdXQuaWQgXS5zdHJpZGU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdDT0xPUic6XG5cdFx0XHRcdFx0XHRcdGJ1aWxkR2VvbWV0cnlEYXRhKCBwcmltaXRpdmUsIHNvdXJjZXNbIGlucHV0LmlkIF0sIGlucHV0Lm9mZnNldCwgY29sb3IuYXJyYXkgKTtcblx0XHRcdFx0XHRcdFx0Y29sb3Iuc3RyaWRlID0gc291cmNlc1sgaW5wdXQuaWQgXS5zdHJpZGU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdURVhDT09SRCc6XG5cdFx0XHRcdFx0XHRcdGJ1aWxkR2VvbWV0cnlEYXRhKCBwcmltaXRpdmUsIHNvdXJjZXNbIGlucHV0LmlkIF0sIGlucHV0Lm9mZnNldCwgdXYuYXJyYXkgKTtcblx0XHRcdFx0XHRcdFx0dXYuc3RyaWRlID0gc291cmNlc1sgaW5wdXQuaWQgXS5zdHJpZGU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdURVhDT09SRDEnOlxuXHRcdFx0XHRcdFx0XHRidWlsZEdlb21ldHJ5RGF0YSggcHJpbWl0aXZlLCBzb3VyY2VzWyBpbnB1dC5pZCBdLCBpbnB1dC5vZmZzZXQsIHV2Mi5hcnJheSApO1xuXHRcdFx0XHRcdFx0XHR1djIuc3RyaWRlID0gc291cmNlc1sgaW5wdXQuaWQgXS5zdHJpZGU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0XHRpZiAoIHBvc2l0aW9uLmFycmF5Lmxlbmd0aCA+IDAgKSBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbi5hcnJheSwgcG9zaXRpb24uc3RyaWRlICkgKTtcblx0XHRcdGlmICggbm9ybWFsLmFycmF5Lmxlbmd0aCA+IDAgKSBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFsLmFycmF5LCBub3JtYWwuc3RyaWRlICkgKTtcblx0XHRcdGlmICggY29sb3IuYXJyYXkubGVuZ3RoID4gMCApIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGNvbG9yLmFycmF5LCBjb2xvci5zdHJpZGUgKSApO1xuXHRcdFx0aWYgKCB1di5hcnJheS5sZW5ndGggPiAwICkgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXYuYXJyYXksIHV2LnN0cmlkZSApICk7XG5cdFx0XHRpZiAoIHV2Mi5hcnJheS5sZW5ndGggPiAwICkgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAndXYyJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2Mi5hcnJheSwgdXYyLnN0cmlkZSApICk7XG5cblx0XHRcdGlmICggc2tpbkluZGV4LmFycmF5Lmxlbmd0aCA+IDAgKSBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdza2luSW5kZXgnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggc2tpbkluZGV4LmFycmF5LCBza2luSW5kZXguc3RyaWRlICkgKTtcblx0XHRcdGlmICggc2tpbldlaWdodC5hcnJheS5sZW5ndGggPiAwICkgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnc2tpbldlaWdodCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBza2luV2VpZ2h0LmFycmF5LCBza2luV2VpZ2h0LnN0cmlkZSApICk7XG5cblx0XHRcdGJ1aWxkLmRhdGEgPSBnZW9tZXRyeTtcblx0XHRcdGJ1aWxkLnR5cGUgPSBwcmltaXRpdmVzWyAwIF0udHlwZTtcblx0XHRcdGJ1aWxkLm1hdGVyaWFsS2V5cyA9IG1hdGVyaWFsS2V5cztcblxuXHRcdFx0cmV0dXJuIGJ1aWxkO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRHZW9tZXRyeURhdGEoIHByaW1pdGl2ZSwgc291cmNlLCBvZmZzZXQsIGFycmF5ICkge1xuXG5cdFx0XHR2YXIgaW5kaWNlcyA9IHByaW1pdGl2ZS5wO1xuXHRcdFx0dmFyIHN0cmlkZSA9IHByaW1pdGl2ZS5zdHJpZGU7XG5cdFx0XHR2YXIgdmNvdW50ID0gcHJpbWl0aXZlLnZjb3VudDtcblxuXHRcdFx0ZnVuY3Rpb24gcHVzaFZlY3RvciggaSApIHtcblxuXHRcdFx0XHR2YXIgaW5kZXggPSBpbmRpY2VzWyBpICsgb2Zmc2V0IF0gKiBzb3VyY2VTdHJpZGU7XG5cdFx0XHRcdHZhciBsZW5ndGggPSBpbmRleCArIHNvdXJjZVN0cmlkZTtcblxuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArKyApIHtcblxuXHRcdFx0XHRcdGFycmF5LnB1c2goIHNvdXJjZUFycmF5WyBpbmRleCBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBzb3VyY2VBcnJheSA9IHNvdXJjZS5hcnJheTtcblx0XHRcdHZhciBzb3VyY2VTdHJpZGUgPSBzb3VyY2Uuc3RyaWRlO1xuXG5cdFx0XHRpZiAoIHByaW1pdGl2ZS52Y291bnQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR2YXIgaW5kZXggPSAwO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHZjb3VudC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGNvdW50ID0gdmNvdW50WyBpIF07XG5cblx0XHRcdFx0XHRpZiAoIGNvdW50ID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgYSA9IGluZGV4ICsgc3RyaWRlICogMDtcblx0XHRcdFx0XHRcdHZhciBiID0gaW5kZXggKyBzdHJpZGUgKiAxO1xuXHRcdFx0XHRcdFx0dmFyIGMgPSBpbmRleCArIHN0cmlkZSAqIDI7XG5cdFx0XHRcdFx0XHR2YXIgZCA9IGluZGV4ICsgc3RyaWRlICogMztcblxuXHRcdFx0XHRcdFx0cHVzaFZlY3RvciggYSApOyBwdXNoVmVjdG9yKCBiICk7IHB1c2hWZWN0b3IoIGQgKTtcblx0XHRcdFx0XHRcdHB1c2hWZWN0b3IoIGIgKTsgcHVzaFZlY3RvciggYyApOyBwdXNoVmVjdG9yKCBkICk7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb3VudCA9PT0gMyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGEgPSBpbmRleCArIHN0cmlkZSAqIDA7XG5cdFx0XHRcdFx0XHR2YXIgYiA9IGluZGV4ICsgc3RyaWRlICogMTtcblx0XHRcdFx0XHRcdHZhciBjID0gaW5kZXggKyBzdHJpZGUgKiAyO1xuXG5cdFx0XHRcdFx0XHRwdXNoVmVjdG9yKCBhICk7IHB1c2hWZWN0b3IoIGIgKTsgcHVzaFZlY3RvciggYyApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY291bnQgPiA0ICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgayA9IDEsIGtsID0gKCBjb3VudCAtIDIgKTsgayA8PSBrbDsgayArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgYSA9IGluZGV4ICsgc3RyaWRlICogMDtcblx0XHRcdFx0XHRcdFx0dmFyIGIgPSBpbmRleCArIHN0cmlkZSAqIGs7XG5cdFx0XHRcdFx0XHRcdHZhciBjID0gaW5kZXggKyBzdHJpZGUgKiAoIGsgKyAxICk7XG5cblx0XHRcdFx0XHRcdFx0cHVzaFZlY3RvciggYSApOyBwdXNoVmVjdG9yKCBiICk7IHB1c2hWZWN0b3IoIGMgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aW5kZXggKz0gc3RyaWRlICogY291bnQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSBzdHJpZGUgKSB7XG5cblx0XHRcdFx0XHRwdXNoVmVjdG9yKCBpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRHZW9tZXRyeSggaWQgKSB7XG5cblx0XHRcdHJldHVybiBnZXRCdWlsZCggbGlicmFyeS5nZW9tZXRyaWVzWyBpZCBdLCBidWlsZEdlb21ldHJ5ICk7XG5cblx0XHR9XG5cblx0XHQvLyBraW5lbWF0aWNzXG5cblx0XHRmdW5jdGlvbiBwYXJzZUtpbmVtYXRpY3NNb2RlbCggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0bmFtZTogeG1sLmdldEF0dHJpYnV0ZSggJ25hbWUnICkgfHwgJycsXG5cdFx0XHRcdGpvaW50czoge30sXG5cdFx0XHRcdGxpbmtzOiBbXVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAndGVjaG5pcXVlX2NvbW1vbic6XG5cdFx0XHRcdFx0XHRwYXJzZUtpbmVtYXRpY3NUZWNobmlxdWVDb21tb24oIGNoaWxkLCBkYXRhICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0bGlicmFyeS5raW5lbWF0aWNzTW9kZWxzWyB4bWwuZ2V0QXR0cmlidXRlKCAnaWQnICkgXSA9IGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZEtpbmVtYXRpY3NNb2RlbCggZGF0YSApIHtcblxuXHRcdFx0aWYgKCBkYXRhLmJ1aWxkICE9PSB1bmRlZmluZWQgKSByZXR1cm4gZGF0YS5idWlsZDtcblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRLaW5lbWF0aWNzTW9kZWwoIGlkICkge1xuXG5cdFx0XHRyZXR1cm4gZ2V0QnVpbGQoIGxpYnJhcnkua2luZW1hdGljc01vZGVsc1sgaWQgXSwgYnVpbGRLaW5lbWF0aWNzTW9kZWwgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlS2luZW1hdGljc1RlY2huaXF1ZUNvbW1vbiggeG1sLCBkYXRhICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdqb2ludCc6XG5cdFx0XHRcdFx0XHRkYXRhLmpvaW50c1sgY2hpbGQuZ2V0QXR0cmlidXRlKCAnc2lkJyApIF0gPSBwYXJzZUtpbmVtYXRpY3NKb2ludCggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnbGluayc6XG5cdFx0XHRcdFx0XHRkYXRhLmxpbmtzLnB1c2goIHBhcnNlS2luZW1hdGljc0xpbmsoIGNoaWxkICkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VLaW5lbWF0aWNzSm9pbnQoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGE7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ3ByaXNtYXRpYyc6XG5cdFx0XHRcdFx0Y2FzZSAncmV2b2x1dGUnOlxuXHRcdFx0XHRcdFx0ZGF0YSA9IHBhcnNlS2luZW1hdGljc0pvaW50UGFyYW1ldGVyKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VLaW5lbWF0aWNzSm9pbnRQYXJhbWV0ZXIoIHhtbCwgZGF0YSApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdHNpZDogeG1sLmdldEF0dHJpYnV0ZSggJ3NpZCcgKSxcblx0XHRcdFx0bmFtZTogeG1sLmdldEF0dHJpYnV0ZSggJ25hbWUnICkgfHwgJycsXG5cdFx0XHRcdGF4aXM6IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdGxpbWl0czoge1xuXHRcdFx0XHRcdG1pbjogMCxcblx0XHRcdFx0XHRtYXg6IDBcblx0XHRcdFx0fSxcblx0XHRcdFx0dHlwZTogeG1sLm5vZGVOYW1lLFxuXHRcdFx0XHRzdGF0aWM6IGZhbHNlLFxuXHRcdFx0XHR6ZXJvUG9zaXRpb246IDAsXG5cdFx0XHRcdG1pZGRsZVBvc2l0aW9uOiAwXG5cdFx0XHR9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdheGlzJzpcblx0XHRcdFx0XHRcdHZhciBhcnJheSA9IHBhcnNlRmxvYXRzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0ZGF0YS5heGlzLmZyb21BcnJheSggYXJyYXkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2xpbWl0cyc6XG5cdFx0XHRcdFx0XHR2YXIgbWF4ID0gY2hpbGQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoICdtYXgnIClbIDAgXTtcblx0XHRcdFx0XHRcdHZhciBtaW4gPSBjaGlsZC5nZXRFbGVtZW50c0J5VGFnTmFtZSggJ21pbicgKVsgMCBdO1xuXG5cdFx0XHRcdFx0XHRkYXRhLmxpbWl0cy5tYXggPSBwYXJzZUZsb2F0KCBtYXgudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGRhdGEubGltaXRzLm1pbiA9IHBhcnNlRmxvYXQoIG1pbi50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIG1pbiBpcyBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gbWF4LCBjb25zaWRlciB0aGUgam9pbnQgc3RhdGljXG5cblx0XHRcdGlmICggZGF0YS5saW1pdHMubWluID49IGRhdGEubGltaXRzLm1heCApIHtcblxuXHRcdFx0XHRkYXRhLnN0YXRpYyA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY2FsY3VsYXRlIG1pZGRsZSBwb3NpdGlvblxuXG5cdFx0XHRkYXRhLm1pZGRsZVBvc2l0aW9uID0gKCBkYXRhLmxpbWl0cy5taW4gKyBkYXRhLmxpbWl0cy5tYXggKSAvIDIuMDtcblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUtpbmVtYXRpY3NMaW5rKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRzaWQ6IHhtbC5nZXRBdHRyaWJ1dGUoICdzaWQnICksXG5cdFx0XHRcdG5hbWU6IHhtbC5nZXRBdHRyaWJ1dGUoICduYW1lJyApIHx8ICcnLFxuXHRcdFx0XHRhdHRhY2htZW50czogW10sXG5cdFx0XHRcdHRyYW5zZm9ybXM6IFtdXG5cdFx0XHR9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdhdHRhY2htZW50X2Z1bGwnOlxuXHRcdFx0XHRcdFx0ZGF0YS5hdHRhY2htZW50cy5wdXNoKCBwYXJzZUtpbmVtYXRpY3NBdHRhY2htZW50KCBjaGlsZCApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ21hdHJpeCc6XG5cdFx0XHRcdFx0Y2FzZSAndHJhbnNsYXRlJzpcblx0XHRcdFx0XHRjYXNlICdyb3RhdGUnOlxuXHRcdFx0XHRcdFx0ZGF0YS50cmFuc2Zvcm1zLnB1c2goIHBhcnNlS2luZW1hdGljc1RyYW5zZm9ybSggY2hpbGQgKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VLaW5lbWF0aWNzQXR0YWNobWVudCggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0am9pbnQ6IHhtbC5nZXRBdHRyaWJ1dGUoICdqb2ludCcgKS5zcGxpdCggJy8nICkucG9wKCksXG5cdFx0XHRcdHRyYW5zZm9ybXM6IFtdLFxuXHRcdFx0XHRsaW5rczogW11cblx0XHRcdH07XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2xpbmsnOlxuXHRcdFx0XHRcdFx0ZGF0YS5saW5rcy5wdXNoKCBwYXJzZUtpbmVtYXRpY3NMaW5rKCBjaGlsZCApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ21hdHJpeCc6XG5cdFx0XHRcdFx0Y2FzZSAndHJhbnNsYXRlJzpcblx0XHRcdFx0XHRjYXNlICdyb3RhdGUnOlxuXHRcdFx0XHRcdFx0ZGF0YS50cmFuc2Zvcm1zLnB1c2goIHBhcnNlS2luZW1hdGljc1RyYW5zZm9ybSggY2hpbGQgKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VLaW5lbWF0aWNzVHJhbnNmb3JtKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHR0eXBlOiB4bWwubm9kZU5hbWVcblx0XHRcdH07XG5cblx0XHRcdHZhciBhcnJheSA9IHBhcnNlRmxvYXRzKCB4bWwudGV4dENvbnRlbnQgKTtcblxuXHRcdFx0c3dpdGNoICggZGF0YS50eXBlICkge1xuXG5cdFx0XHRcdGNhc2UgJ21hdHJpeCc6XG5cdFx0XHRcdFx0ZGF0YS5vYmogPSBuZXcgTWF0cml4NCgpO1xuXHRcdFx0XHRcdGRhdGEub2JqLmZyb21BcnJheSggYXJyYXkgKS50cmFuc3Bvc2UoKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICd0cmFuc2xhdGUnOlxuXHRcdFx0XHRcdGRhdGEub2JqID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0XHRkYXRhLm9iai5mcm9tQXJyYXkoIGFycmF5ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAncm90YXRlJzpcblx0XHRcdFx0XHRkYXRhLm9iaiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdFx0ZGF0YS5vYmouZnJvbUFycmF5KCBhcnJheSApO1xuXHRcdFx0XHRcdGRhdGEuYW5nbGUgPSBNYXRoVXRpbHMuZGVnVG9SYWQoIGFycmF5WyAzIF0gKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdC8vIHBoeXNpY3NcblxuXHRcdGZ1bmN0aW9uIHBhcnNlUGh5c2ljc01vZGVsKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRuYW1lOiB4bWwuZ2V0QXR0cmlidXRlKCAnbmFtZScgKSB8fCAnJyxcblx0XHRcdFx0cmlnaWRCb2RpZXM6IHt9XG5cdFx0XHR9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdyaWdpZF9ib2R5Jzpcblx0XHRcdFx0XHRcdGRhdGEucmlnaWRCb2RpZXNbIGNoaWxkLmdldEF0dHJpYnV0ZSggJ25hbWUnICkgXSA9IHt9O1xuXHRcdFx0XHRcdFx0cGFyc2VQaHlzaWNzUmlnaWRCb2R5KCBjaGlsZCwgZGF0YS5yaWdpZEJvZGllc1sgY2hpbGQuZ2V0QXR0cmlidXRlKCAnbmFtZScgKSBdICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0bGlicmFyeS5waHlzaWNzTW9kZWxzWyB4bWwuZ2V0QXR0cmlidXRlKCAnaWQnICkgXSA9IGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZVBoeXNpY3NSaWdpZEJvZHkoIHhtbCwgZGF0YSApIHtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAndGVjaG5pcXVlX2NvbW1vbic6XG5cdFx0XHRcdFx0XHRwYXJzZVBoeXNpY3NUZWNobmlxdWVDb21tb24oIGNoaWxkLCBkYXRhICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlUGh5c2ljc1RlY2huaXF1ZUNvbW1vbiggeG1sLCBkYXRhICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdpbmVydGlhJzpcblx0XHRcdFx0XHRcdGRhdGEuaW5lcnRpYSA9IHBhcnNlRmxvYXRzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdtYXNzJzpcblx0XHRcdFx0XHRcdGRhdGEubWFzcyA9IHBhcnNlRmxvYXRzKCBjaGlsZC50ZXh0Q29udGVudCApWyAwIF07XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIHNjZW5lXG5cblx0XHRmdW5jdGlvbiBwYXJzZUtpbmVtYXRpY3NTY2VuZSggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0YmluZEpvaW50QXhpczogW11cblx0XHRcdH07XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2JpbmRfam9pbnRfYXhpcyc6XG5cdFx0XHRcdFx0XHRkYXRhLmJpbmRKb2ludEF4aXMucHVzaCggcGFyc2VLaW5lbWF0aWNzQmluZEpvaW50QXhpcyggY2hpbGQgKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGxpYnJhcnkua2luZW1hdGljc1NjZW5lc1sgcGFyc2VJZCggeG1sLmdldEF0dHJpYnV0ZSggJ3VybCcgKSApIF0gPSBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VLaW5lbWF0aWNzQmluZEpvaW50QXhpcyggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0dGFyZ2V0OiB4bWwuZ2V0QXR0cmlidXRlKCAndGFyZ2V0JyApLnNwbGl0KCAnLycgKS5wb3AoKVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnYXhpcyc6XG5cdFx0XHRcdFx0XHR2YXIgcGFyYW0gPSBjaGlsZC5nZXRFbGVtZW50c0J5VGFnTmFtZSggJ3BhcmFtJyApWyAwIF07XG5cdFx0XHRcdFx0XHRkYXRhLmF4aXMgPSBwYXJhbS50ZXh0Q29udGVudDtcblx0XHRcdFx0XHRcdHZhciB0bXBKb2ludEluZGV4ID0gZGF0YS5heGlzLnNwbGl0KCAnaW5zdF8nICkucG9wKCkuc3BsaXQoICdheGlzJyApWyAwIF07XG5cdFx0XHRcdFx0XHRkYXRhLmpvaW50SW5kZXggPSB0bXBKb2ludEluZGV4LnN1YnN0ciggMCwgdG1wSm9pbnRJbmRleC5sZW5ndGggLSAxICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZEtpbmVtYXRpY3NTY2VuZSggZGF0YSApIHtcblxuXHRcdFx0aWYgKCBkYXRhLmJ1aWxkICE9PSB1bmRlZmluZWQgKSByZXR1cm4gZGF0YS5idWlsZDtcblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRLaW5lbWF0aWNzU2NlbmUoIGlkICkge1xuXG5cdFx0XHRyZXR1cm4gZ2V0QnVpbGQoIGxpYnJhcnkua2luZW1hdGljc1NjZW5lc1sgaWQgXSwgYnVpbGRLaW5lbWF0aWNzU2NlbmUgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldHVwS2luZW1hdGljcygpIHtcblxuXHRcdFx0dmFyIGtpbmVtYXRpY3NNb2RlbElkID0gT2JqZWN0LmtleXMoIGxpYnJhcnkua2luZW1hdGljc01vZGVscyApWyAwIF07XG5cdFx0XHR2YXIga2luZW1hdGljc1NjZW5lSWQgPSBPYmplY3Qua2V5cyggbGlicmFyeS5raW5lbWF0aWNzU2NlbmVzIClbIDAgXTtcblx0XHRcdHZhciB2aXN1YWxTY2VuZUlkID0gT2JqZWN0LmtleXMoIGxpYnJhcnkudmlzdWFsU2NlbmVzIClbIDAgXTtcblxuXHRcdFx0aWYgKCBraW5lbWF0aWNzTW9kZWxJZCA9PT0gdW5kZWZpbmVkIHx8IGtpbmVtYXRpY3NTY2VuZUlkID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRcdHZhciBraW5lbWF0aWNzTW9kZWwgPSBnZXRLaW5lbWF0aWNzTW9kZWwoIGtpbmVtYXRpY3NNb2RlbElkICk7XG5cdFx0XHR2YXIga2luZW1hdGljc1NjZW5lID0gZ2V0S2luZW1hdGljc1NjZW5lKCBraW5lbWF0aWNzU2NlbmVJZCApO1xuXHRcdFx0dmFyIHZpc3VhbFNjZW5lID0gZ2V0VmlzdWFsU2NlbmUoIHZpc3VhbFNjZW5lSWQgKTtcblxuXHRcdFx0dmFyIGJpbmRKb2ludEF4aXMgPSBraW5lbWF0aWNzU2NlbmUuYmluZEpvaW50QXhpcztcblx0XHRcdHZhciBqb2ludE1hcCA9IHt9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBiaW5kSm9pbnRBeGlzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGF4aXMgPSBiaW5kSm9pbnRBeGlzWyBpIF07XG5cblx0XHRcdFx0Ly8gdGhlIHJlc3VsdCBvZiB0aGUgZm9sbG93aW5nIHF1ZXJ5IGlzIGFuIGVsZW1lbnQgb2YgdHlwZSAndHJhbnNsYXRlJywgJ3JvdGF0ZScsJ3NjYWxlJyBvciAnbWF0cml4J1xuXG5cdFx0XHRcdHZhciB0YXJnZXRFbGVtZW50ID0gY29sbGFkYS5xdWVyeVNlbGVjdG9yKCAnW3NpZD1cIicgKyBheGlzLnRhcmdldCArICdcIl0nICk7XG5cblx0XHRcdFx0aWYgKCB0YXJnZXRFbGVtZW50ICkge1xuXG5cdFx0XHRcdFx0Ly8gZ2V0IHRoZSBwYXJlbnQgb2YgdGhlIHRyYW5zZm9ybSBlbGVtZW50XG5cblx0XHRcdFx0XHR2YXIgcGFyZW50VmlzdWFsRWxlbWVudCA9IHRhcmdldEVsZW1lbnQucGFyZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIGNvbm5lY3QgdGhlIGpvaW50IG9mIHRoZSBraW5lbWF0aWNzIG1vZGVsIHdpdGggdGhlIGVsZW1lbnQgaW4gdGhlIHZpc3VhbCBzY2VuZVxuXG5cdFx0XHRcdFx0Y29ubmVjdCggYXhpcy5qb2ludEluZGV4LCBwYXJlbnRWaXN1YWxFbGVtZW50ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGNvbm5lY3QoIGpvaW50SW5kZXgsIHZpc3VhbEVsZW1lbnQgKSB7XG5cblx0XHRcdFx0dmFyIHZpc3VhbEVsZW1lbnROYW1lID0gdmlzdWFsRWxlbWVudC5nZXRBdHRyaWJ1dGUoICduYW1lJyApO1xuXHRcdFx0XHR2YXIgam9pbnQgPSBraW5lbWF0aWNzTW9kZWwuam9pbnRzWyBqb2ludEluZGV4IF07XG5cblx0XHRcdFx0dmlzdWFsU2NlbmUudHJhdmVyc2UoIGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0XHRcdFx0aWYgKCBvYmplY3QubmFtZSA9PT0gdmlzdWFsRWxlbWVudE5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdGpvaW50TWFwWyBqb2ludEluZGV4IF0gPSB7XG5cdFx0XHRcdFx0XHRcdG9iamVjdDogb2JqZWN0LFxuXHRcdFx0XHRcdFx0XHR0cmFuc2Zvcm1zOiBidWlsZFRyYW5zZm9ybUxpc3QoIHZpc3VhbEVsZW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0am9pbnQ6IGpvaW50LFxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbjogam9pbnQuemVyb1Bvc2l0aW9uXG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbTAgPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0XHRraW5lbWF0aWNzID0ge1xuXG5cdFx0XHRcdGpvaW50czoga2luZW1hdGljc01vZGVsICYmIGtpbmVtYXRpY3NNb2RlbC5qb2ludHMsXG5cblx0XHRcdFx0Z2V0Sm9pbnRWYWx1ZTogZnVuY3Rpb24gKCBqb2ludEluZGV4ICkge1xuXG5cdFx0XHRcdFx0dmFyIGpvaW50RGF0YSA9IGpvaW50TWFwWyBqb2ludEluZGV4IF07XG5cblx0XHRcdFx0XHRpZiAoIGpvaW50RGF0YSApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGpvaW50RGF0YS5wb3NpdGlvbjtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IEpvaW50ICcgKyBqb2ludEluZGV4ICsgJyBkb2VzblxcJ3QgZXhpc3QuJyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0c2V0Sm9pbnRWYWx1ZTogZnVuY3Rpb24gKCBqb2ludEluZGV4LCB2YWx1ZSApIHtcblxuXHRcdFx0XHRcdHZhciBqb2ludERhdGEgPSBqb2ludE1hcFsgam9pbnRJbmRleCBdO1xuXG5cdFx0XHRcdFx0aWYgKCBqb2ludERhdGEgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBqb2ludCA9IGpvaW50RGF0YS5qb2ludDtcblxuXHRcdFx0XHRcdFx0aWYgKCB2YWx1ZSA+IGpvaW50LmxpbWl0cy5tYXggfHwgdmFsdWUgPCBqb2ludC5saW1pdHMubWluICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IEpvaW50ICcgKyBqb2ludEluZGV4ICsgJyB2YWx1ZSAnICsgdmFsdWUgKyAnIG91dHNpZGUgb2YgbGltaXRzIChtaW46ICcgKyBqb2ludC5saW1pdHMubWluICsgJywgbWF4OiAnICsgam9pbnQubGltaXRzLm1heCArICcpLicgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggam9pbnQuc3RhdGljICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IEpvaW50ICcgKyBqb2ludEluZGV4ICsgJyBpcyBzdGF0aWMuJyApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBvYmplY3QgPSBqb2ludERhdGEub2JqZWN0O1xuXHRcdFx0XHRcdFx0XHR2YXIgYXhpcyA9IGpvaW50LmF4aXM7XG5cdFx0XHRcdFx0XHRcdHZhciB0cmFuc2Zvcm1zID0gam9pbnREYXRhLnRyYW5zZm9ybXM7XG5cblx0XHRcdFx0XHRcdFx0bWF0cml4LmlkZW50aXR5KCk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gZWFjaCB1cGRhdGUsIHdlIGhhdmUgdG8gYXBwbHkgYWxsIHRyYW5zZm9ybXMgaW4gdGhlIGNvcnJlY3Qgb3JkZXJcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHZhciB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm1zWyBpIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBpZiB0aGVyZSBpcyBhIGNvbm5lY3Rpb24gb2YgdGhlIHRyYW5zZm9ybSBub2RlIHdpdGggYSBqb2ludCwgYXBwbHkgdGhlIGpvaW50IHZhbHVlXG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIHRyYW5zZm9ybS5zaWQgJiYgdHJhbnNmb3JtLnNpZC5pbmRleE9mKCBqb2ludEluZGV4ICkgIT09IC0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0c3dpdGNoICggam9pbnQudHlwZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlICdyZXZvbHV0ZSc6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF0cml4Lm11bHRpcGx5KCBtMC5tYWtlUm90YXRpb25BeGlzKCBheGlzLCBNYXRoVXRpbHMuZGVnVG9SYWQoIHZhbHVlICkgKSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3ByaXNtYXRpYyc6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF0cml4Lm11bHRpcGx5KCBtMC5tYWtlVHJhbnNsYXRpb24oIGF4aXMueCAqIHZhbHVlLCBheGlzLnkgKiB2YWx1ZSwgYXhpcy56ICogdmFsdWUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogVW5rbm93biBqb2ludCB0eXBlOiAnICsgam9pbnQudHlwZSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRzd2l0Y2ggKCB0cmFuc2Zvcm0udHlwZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlICdtYXRyaXgnOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1hdHJpeC5tdWx0aXBseSggdHJhbnNmb3JtLm9iaiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3RyYW5zbGF0ZSc6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF0cml4Lm11bHRpcGx5KCBtMC5tYWtlVHJhbnNsYXRpb24oIHRyYW5zZm9ybS5vYmoueCwgdHJhbnNmb3JtLm9iai55LCB0cmFuc2Zvcm0ub2JqLnogKSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3NjYWxlJzpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXRyaXguc2NhbGUoIHRyYW5zZm9ybS5vYmogKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlICdyb3RhdGUnOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1hdHJpeC5tdWx0aXBseSggbTAubWFrZVJvdGF0aW9uQXhpcyggdHJhbnNmb3JtLm9iaiwgdHJhbnNmb3JtLmFuZ2xlICkgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRvYmplY3QubWF0cml4LmNvcHkoIG1hdHJpeCApO1xuXHRcdFx0XHRcdFx0XHRvYmplY3QubWF0cml4LmRlY29tcG9zZSggb2JqZWN0LnBvc2l0aW9uLCBvYmplY3QucXVhdGVybmlvbiwgb2JqZWN0LnNjYWxlICk7XG5cblx0XHRcdFx0XHRcdFx0am9pbnRNYXBbIGpvaW50SW5kZXggXS5wb3NpdGlvbiA9IHZhbHVlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6ICcgKyBqb2ludEluZGV4ICsgJyBkb2VzIG5vdCBleGlzdC4nICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRUcmFuc2Zvcm1MaXN0KCBub2RlICkge1xuXG5cdFx0XHR2YXIgdHJhbnNmb3JtcyA9IFtdO1xuXG5cdFx0XHR2YXIgeG1sID0gY29sbGFkYS5xdWVyeVNlbGVjdG9yKCAnW2lkPVwiJyArIG5vZGUuaWQgKyAnXCJdJyApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdtYXRyaXgnOlxuXHRcdFx0XHRcdFx0dmFyIGFycmF5ID0gcGFyc2VGbG9hdHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHR2YXIgbWF0cml4ID0gbmV3IE1hdHJpeDQoKS5mcm9tQXJyYXkoIGFycmF5ICkudHJhbnNwb3NlKCk7XG5cdFx0XHRcdFx0XHR0cmFuc2Zvcm1zLnB1c2goIHtcblx0XHRcdFx0XHRcdFx0c2lkOiBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzaWQnICksXG5cdFx0XHRcdFx0XHRcdHR5cGU6IGNoaWxkLm5vZGVOYW1lLFxuXHRcdFx0XHRcdFx0XHRvYmo6IG1hdHJpeFxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd0cmFuc2xhdGUnOlxuXHRcdFx0XHRcdGNhc2UgJ3NjYWxlJzpcblx0XHRcdFx0XHRcdHZhciBhcnJheSA9IHBhcnNlRmxvYXRzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0dmFyIHZlY3RvciA9IG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KCBhcnJheSApO1xuXHRcdFx0XHRcdFx0dHJhbnNmb3Jtcy5wdXNoKCB7XG5cdFx0XHRcdFx0XHRcdHNpZDogY2hpbGQuZ2V0QXR0cmlidXRlKCAnc2lkJyApLFxuXHRcdFx0XHRcdFx0XHR0eXBlOiBjaGlsZC5ub2RlTmFtZSxcblx0XHRcdFx0XHRcdFx0b2JqOiB2ZWN0b3Jcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAncm90YXRlJzpcblx0XHRcdFx0XHRcdHZhciBhcnJheSA9IHBhcnNlRmxvYXRzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0dmFyIHZlY3RvciA9IG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KCBhcnJheSApO1xuXHRcdFx0XHRcdFx0dmFyIGFuZ2xlID0gTWF0aFV0aWxzLmRlZ1RvUmFkKCBhcnJheVsgMyBdICk7XG5cdFx0XHRcdFx0XHR0cmFuc2Zvcm1zLnB1c2goIHtcblx0XHRcdFx0XHRcdFx0c2lkOiBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzaWQnICksXG5cdFx0XHRcdFx0XHRcdHR5cGU6IGNoaWxkLm5vZGVOYW1lLFxuXHRcdFx0XHRcdFx0XHRvYmo6IHZlY3Rvcixcblx0XHRcdFx0XHRcdFx0YW5nbGU6IGFuZ2xlXG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRyYW5zZm9ybXM7XG5cblx0XHR9XG5cblx0XHQvLyBub2Rlc1xuXG5cdFx0ZnVuY3Rpb24gcHJlcGFyZU5vZGVzKCB4bWwgKSB7XG5cblx0XHRcdHZhciBlbGVtZW50cyA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggJ25vZGUnICk7XG5cblx0XHRcdC8vIGVuc3VyZSBhbGwgbm9kZSBlbGVtZW50cyBoYXZlIGlkIGF0dHJpYnV0ZXNcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBlbGVtZW50ID0gZWxlbWVudHNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGVsZW1lbnQuaGFzQXR0cmlidXRlKCAnaWQnICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoICdpZCcsIGdlbmVyYXRlSWQoKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dmFyIG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0dmFyIHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRmdW5jdGlvbiBwYXJzZU5vZGUoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdG5hbWU6IHhtbC5nZXRBdHRyaWJ1dGUoICduYW1lJyApIHx8ICcnLFxuXHRcdFx0XHR0eXBlOiB4bWwuZ2V0QXR0cmlidXRlKCAndHlwZScgKSxcblx0XHRcdFx0aWQ6IHhtbC5nZXRBdHRyaWJ1dGUoICdpZCcgKSxcblx0XHRcdFx0c2lkOiB4bWwuZ2V0QXR0cmlidXRlKCAnc2lkJyApLFxuXHRcdFx0XHRtYXRyaXg6IG5ldyBNYXRyaXg0KCksXG5cdFx0XHRcdG5vZGVzOiBbXSxcblx0XHRcdFx0aW5zdGFuY2VDYW1lcmFzOiBbXSxcblx0XHRcdFx0aW5zdGFuY2VDb250cm9sbGVyczogW10sXG5cdFx0XHRcdGluc3RhbmNlTGlnaHRzOiBbXSxcblx0XHRcdFx0aW5zdGFuY2VHZW9tZXRyaWVzOiBbXSxcblx0XHRcdFx0aW5zdGFuY2VOb2RlczogW10sXG5cdFx0XHRcdHRyYW5zZm9ybXM6IHt9XG5cdFx0XHR9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdub2RlJzpcblx0XHRcdFx0XHRcdGRhdGEubm9kZXMucHVzaCggY2hpbGQuZ2V0QXR0cmlidXRlKCAnaWQnICkgKTtcblx0XHRcdFx0XHRcdHBhcnNlTm9kZSggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnaW5zdGFuY2VfY2FtZXJhJzpcblx0XHRcdFx0XHRcdGRhdGEuaW5zdGFuY2VDYW1lcmFzLnB1c2goIHBhcnNlSWQoIGNoaWxkLmdldEF0dHJpYnV0ZSggJ3VybCcgKSApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2luc3RhbmNlX2NvbnRyb2xsZXInOlxuXHRcdFx0XHRcdFx0ZGF0YS5pbnN0YW5jZUNvbnRyb2xsZXJzLnB1c2goIHBhcnNlTm9kZUluc3RhbmNlKCBjaGlsZCApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2luc3RhbmNlX2xpZ2h0Jzpcblx0XHRcdFx0XHRcdGRhdGEuaW5zdGFuY2VMaWdodHMucHVzaCggcGFyc2VJZCggY2hpbGQuZ2V0QXR0cmlidXRlKCAndXJsJyApICkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnaW5zdGFuY2VfZ2VvbWV0cnknOlxuXHRcdFx0XHRcdFx0ZGF0YS5pbnN0YW5jZUdlb21ldHJpZXMucHVzaCggcGFyc2VOb2RlSW5zdGFuY2UoIGNoaWxkICkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnaW5zdGFuY2Vfbm9kZSc6XG5cdFx0XHRcdFx0XHRkYXRhLmluc3RhbmNlTm9kZXMucHVzaCggcGFyc2VJZCggY2hpbGQuZ2V0QXR0cmlidXRlKCAndXJsJyApICkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnbWF0cml4Jzpcblx0XHRcdFx0XHRcdHZhciBhcnJheSA9IHBhcnNlRmxvYXRzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0ZGF0YS5tYXRyaXgubXVsdGlwbHkoIG1hdHJpeC5mcm9tQXJyYXkoIGFycmF5ICkudHJhbnNwb3NlKCkgKTtcblx0XHRcdFx0XHRcdGRhdGEudHJhbnNmb3Jtc1sgY2hpbGQuZ2V0QXR0cmlidXRlKCAnc2lkJyApIF0gPSBjaGlsZC5ub2RlTmFtZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndHJhbnNsYXRlJzpcblx0XHRcdFx0XHRcdHZhciBhcnJheSA9IHBhcnNlRmxvYXRzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0dmVjdG9yLmZyb21BcnJheSggYXJyYXkgKTtcblx0XHRcdFx0XHRcdGRhdGEubWF0cml4Lm11bHRpcGx5KCBtYXRyaXgubWFrZVRyYW5zbGF0aW9uKCB2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci56ICkgKTtcblx0XHRcdFx0XHRcdGRhdGEudHJhbnNmb3Jtc1sgY2hpbGQuZ2V0QXR0cmlidXRlKCAnc2lkJyApIF0gPSBjaGlsZC5ub2RlTmFtZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAncm90YXRlJzpcblx0XHRcdFx0XHRcdHZhciBhcnJheSA9IHBhcnNlRmxvYXRzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0dmFyIGFuZ2xlID0gTWF0aFV0aWxzLmRlZ1RvUmFkKCBhcnJheVsgMyBdICk7XG5cdFx0XHRcdFx0XHRkYXRhLm1hdHJpeC5tdWx0aXBseSggbWF0cml4Lm1ha2VSb3RhdGlvbkF4aXMoIHZlY3Rvci5mcm9tQXJyYXkoIGFycmF5ICksIGFuZ2xlICkgKTtcblx0XHRcdFx0XHRcdGRhdGEudHJhbnNmb3Jtc1sgY2hpbGQuZ2V0QXR0cmlidXRlKCAnc2lkJyApIF0gPSBjaGlsZC5ub2RlTmFtZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnc2NhbGUnOlxuXHRcdFx0XHRcdFx0dmFyIGFycmF5ID0gcGFyc2VGbG9hdHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRkYXRhLm1hdHJpeC5zY2FsZSggdmVjdG9yLmZyb21BcnJheSggYXJyYXkgKSApO1xuXHRcdFx0XHRcdFx0ZGF0YS50cmFuc2Zvcm1zWyBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzaWQnICkgXSA9IGNoaWxkLm5vZGVOYW1lO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdleHRyYSc6XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyggY2hpbGQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNOb2RlKCBkYXRhLmlkICkgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogVGhlcmUgaXMgYWxyZWFkeSBhIG5vZGUgd2l0aCBJRCAlcy4gRXhjbHVkZSBjdXJyZW50IG5vZGUgZnJvbSBmdXJ0aGVyIHByb2Nlc3NpbmcuJywgZGF0YS5pZCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGxpYnJhcnkubm9kZXNbIGRhdGEuaWQgXSA9IGRhdGE7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZU5vZGVJbnN0YW5jZSggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0aWQ6IHBhcnNlSWQoIHhtbC5nZXRBdHRyaWJ1dGUoICd1cmwnICkgKSxcblx0XHRcdFx0bWF0ZXJpYWxzOiB7fSxcblx0XHRcdFx0c2tlbGV0b25zOiBbXVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdiaW5kX21hdGVyaWFsJzpcblx0XHRcdFx0XHRcdHZhciBpbnN0YW5jZXMgPSBjaGlsZC5nZXRFbGVtZW50c0J5VGFnTmFtZSggJ2luc3RhbmNlX21hdGVyaWFsJyApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBpbnN0YW5jZXMubGVuZ3RoOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBpbnN0YW5jZSA9IGluc3RhbmNlc1sgaiBdO1xuXHRcdFx0XHRcdFx0XHR2YXIgc3ltYm9sID0gaW5zdGFuY2UuZ2V0QXR0cmlidXRlKCAnc3ltYm9sJyApO1xuXHRcdFx0XHRcdFx0XHR2YXIgdGFyZ2V0ID0gaW5zdGFuY2UuZ2V0QXR0cmlidXRlKCAndGFyZ2V0JyApO1xuXG5cdFx0XHRcdFx0XHRcdGRhdGEubWF0ZXJpYWxzWyBzeW1ib2wgXSA9IHBhcnNlSWQoIHRhcmdldCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnc2tlbGV0b24nOlxuXHRcdFx0XHRcdFx0ZGF0YS5za2VsZXRvbnMucHVzaCggcGFyc2VJZCggY2hpbGQudGV4dENvbnRlbnQgKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRTa2VsZXRvbiggc2tlbGV0b25zLCBqb2ludHMgKSB7XG5cblx0XHRcdHZhciBib25lRGF0YSA9IFtdO1xuXHRcdFx0dmFyIHNvcnRlZEJvbmVEYXRhID0gW107XG5cblx0XHRcdHZhciBpLCBqLCBkYXRhO1xuXG5cdFx0XHQvLyBhIHNrZWxldG9uIGNhbiBoYXZlIG11bHRpcGxlIHJvb3QgYm9uZXMuIGNvbGxhZGEgZXhwcmVzc2VzIHRoaXNcblx0XHRcdC8vIHNpdHV0YXRpb24gd2l0aCBtdWx0aXBsZSBcInNrZWxldG9uXCIgdGFncyBwZXIgY29udHJvbGxlciBpbnN0YW5jZVxuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IHNrZWxldG9ucy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIHNrZWxldG9uID0gc2tlbGV0b25zWyBpIF07XG5cblx0XHRcdFx0dmFyIHJvb3Q7XG5cblx0XHRcdFx0aWYgKCBoYXNOb2RlKCBza2VsZXRvbiApICkge1xuXG5cdFx0XHRcdFx0cm9vdCA9IGdldE5vZGUoIHNrZWxldG9uICk7XG5cdFx0XHRcdFx0YnVpbGRCb25lSGllcmFyY2h5KCByb290LCBqb2ludHMsIGJvbmVEYXRhICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggaGFzVmlzdWFsU2NlbmUoIHNrZWxldG9uICkgKSB7XG5cblx0XHRcdFx0XHQvLyBoYW5kbGUgY2FzZSB3aGVyZSB0aGUgc2tlbGV0b24gcmVmZXJzIHRvIHRoZSB2aXN1YWwgc2NlbmUgKCMxMzMzNSlcblxuXHRcdFx0XHRcdHZhciB2aXN1YWxTY2VuZSA9IGxpYnJhcnkudmlzdWFsU2NlbmVzWyBza2VsZXRvbiBdO1xuXHRcdFx0XHRcdHZhciBjaGlsZHJlbiA9IHZpc3VhbFNjZW5lLmNoaWxkcmVuO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlblsgaiBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGNoaWxkLnR5cGUgPT09ICdKT0lOVCcgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHJvb3QgPSBnZXROb2RlKCBjaGlsZC5pZCApO1xuXHRcdFx0XHRcdFx0XHRidWlsZEJvbmVIaWVyYXJjaHkoIHJvb3QsIGpvaW50cywgYm9uZURhdGEgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogVW5hYmxlIHRvIGZpbmQgcm9vdCBib25lIG9mIHNrZWxldG9uIHdpdGggSUQ6Jywgc2tlbGV0b24gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gc29ydCBib25lIGRhdGEgKHRoZSBvcmRlciBpcyBkZWZpbmVkIGluIHRoZSBjb3JyZXNwb25kaW5nIGNvbnRyb2xsZXIpXG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgam9pbnRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IGJvbmVEYXRhLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRcdGRhdGEgPSBib25lRGF0YVsgaiBdO1xuXG5cdFx0XHRcdFx0aWYgKCBkYXRhLmJvbmUubmFtZSA9PT0gam9pbnRzWyBpIF0ubmFtZSApIHtcblxuXHRcdFx0XHRcdFx0c29ydGVkQm9uZURhdGFbIGkgXSA9IGRhdGE7XG5cdFx0XHRcdFx0XHRkYXRhLnByb2Nlc3NlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gYWRkIHVucHJvY2Vzc2VkIGJvbmUgZGF0YSBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0XG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgYm9uZURhdGEubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGRhdGEgPSBib25lRGF0YVsgaSBdO1xuXG5cdFx0XHRcdGlmICggZGF0YS5wcm9jZXNzZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0c29ydGVkQm9uZURhdGEucHVzaCggZGF0YSApO1xuXHRcdFx0XHRcdGRhdGEucHJvY2Vzc2VkID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gc2V0dXAgYXJyYXlzIGZvciBza2VsZXRvbiBjcmVhdGlvblxuXG5cdFx0XHR2YXIgYm9uZXMgPSBbXTtcblx0XHRcdHZhciBib25lSW52ZXJzZXMgPSBbXTtcblxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBzb3J0ZWRCb25lRGF0YS5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0ZGF0YSA9IHNvcnRlZEJvbmVEYXRhWyBpIF07XG5cblx0XHRcdFx0Ym9uZXMucHVzaCggZGF0YS5ib25lICk7XG5cdFx0XHRcdGJvbmVJbnZlcnNlcy5wdXNoKCBkYXRhLmJvbmVJbnZlcnNlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBTa2VsZXRvbiggYm9uZXMsIGJvbmVJbnZlcnNlcyApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRCb25lSGllcmFyY2h5KCByb290LCBqb2ludHMsIGJvbmVEYXRhICkge1xuXG5cdFx0XHQvLyBzZXR1cCBib25lIGRhdGEgZnJvbSB2aXN1YWwgc2NlbmVcblxuXHRcdFx0cm9vdC50cmF2ZXJzZSggZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRcdFx0aWYgKCBvYmplY3QuaXNCb25lID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0dmFyIGJvbmVJbnZlcnNlO1xuXG5cdFx0XHRcdFx0Ly8gcmV0cmlldmUgdGhlIGJvbmVJbnZlcnNlIGZyb20gdGhlIGNvbnRyb2xsZXIgZGF0YVxuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgam9pbnRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGpvaW50ID0gam9pbnRzWyBpIF07XG5cblx0XHRcdFx0XHRcdGlmICggam9pbnQubmFtZSA9PT0gb2JqZWN0Lm5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ym9uZUludmVyc2UgPSBqb2ludC5ib25lSW52ZXJzZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggYm9uZUludmVyc2UgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gVW5mb3J0dW5hdGVseSwgdGhlcmUgY2FuIGJlIGpvaW50cyBpbiB0aGUgdmlzdWFsIHNjZW5lIHRoYXQgYXJlIG5vdCBwYXJ0IG9mIHRoZVxuXHRcdFx0XHRcdFx0Ly8gY29ycmVzcG9uZGluZyBjb250cm9sbGVyLiBJbiB0aGlzIGNhc2UsIHdlIGhhdmUgdG8gY3JlYXRlIGEgZHVtbXkgYm9uZUludmVyc2UgbWF0cml4XG5cdFx0XHRcdFx0XHQvLyBmb3IgdGhlIHJlc3BlY3RpdmUgYm9uZS4gVGhpcyBib25lIHdvbid0IGFmZmVjdCBhbnkgdmVydGljZXMsIGJlY2F1c2UgdGhlcmUgYXJlIG5vIHNraW4gaW5kaWNlc1xuXHRcdFx0XHRcdFx0Ly8gYW5kIHdlaWdodHMgZGVmaW5lZCBmb3IgaXQuIEJ1dCB3ZSBzdGlsbCBoYXZlIHRvIGFkZCB0aGUgYm9uZSB0byB0aGUgc29ydGVkIGJvbmUgbGlzdCBpbiBvcmRlciB0b1xuXHRcdFx0XHRcdFx0Ly8gZW5zdXJlIGEgY29ycmVjdCBhbmltYXRpb24gb2YgdGhlIG1vZGVsLlxuXG5cdFx0XHRcdFx0XHRib25lSW52ZXJzZSA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRib25lRGF0YS5wdXNoKCB7IGJvbmU6IG9iamVjdCwgYm9uZUludmVyc2U6IGJvbmVJbnZlcnNlLCBwcm9jZXNzZWQ6IGZhbHNlIH0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkTm9kZSggZGF0YSApIHtcblxuXHRcdFx0dmFyIG9iamVjdHMgPSBbXTtcblxuXHRcdFx0dmFyIG1hdHJpeCA9IGRhdGEubWF0cml4O1xuXHRcdFx0dmFyIG5vZGVzID0gZGF0YS5ub2Rlcztcblx0XHRcdHZhciB0eXBlID0gZGF0YS50eXBlO1xuXHRcdFx0dmFyIGluc3RhbmNlQ2FtZXJhcyA9IGRhdGEuaW5zdGFuY2VDYW1lcmFzO1xuXHRcdFx0dmFyIGluc3RhbmNlQ29udHJvbGxlcnMgPSBkYXRhLmluc3RhbmNlQ29udHJvbGxlcnM7XG5cdFx0XHR2YXIgaW5zdGFuY2VMaWdodHMgPSBkYXRhLmluc3RhbmNlTGlnaHRzO1xuXHRcdFx0dmFyIGluc3RhbmNlR2VvbWV0cmllcyA9IGRhdGEuaW5zdGFuY2VHZW9tZXRyaWVzO1xuXHRcdFx0dmFyIGluc3RhbmNlTm9kZXMgPSBkYXRhLmluc3RhbmNlTm9kZXM7XG5cblx0XHRcdC8vIG5vZGVzXG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0b2JqZWN0cy5wdXNoKCBnZXROb2RlKCBub2Rlc1sgaSBdICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBpbnN0YW5jZSBjYW1lcmFzXG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluc3RhbmNlQ2FtZXJhcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBpbnN0YW5jZUNhbWVyYSA9IGdldENhbWVyYSggaW5zdGFuY2VDYW1lcmFzWyBpIF0gKTtcblxuXHRcdFx0XHRpZiAoIGluc3RhbmNlQ2FtZXJhICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0b2JqZWN0cy5wdXNoKCBpbnN0YW5jZUNhbWVyYS5jbG9uZSgpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGluc3RhbmNlIGNvbnRyb2xsZXJzXG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluc3RhbmNlQ29udHJvbGxlcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgaW5zdGFuY2UgPSBpbnN0YW5jZUNvbnRyb2xsZXJzWyBpIF07XG5cdFx0XHRcdHZhciBjb250cm9sbGVyID0gZ2V0Q29udHJvbGxlciggaW5zdGFuY2UuaWQgKTtcblx0XHRcdFx0dmFyIGdlb21ldHJpZXMgPSBnZXRHZW9tZXRyeSggY29udHJvbGxlci5pZCApO1xuXHRcdFx0XHR2YXIgbmV3T2JqZWN0cyA9IGJ1aWxkT2JqZWN0cyggZ2VvbWV0cmllcywgaW5zdGFuY2UubWF0ZXJpYWxzICk7XG5cblx0XHRcdFx0dmFyIHNrZWxldG9ucyA9IGluc3RhbmNlLnNrZWxldG9ucztcblx0XHRcdFx0dmFyIGpvaW50cyA9IGNvbnRyb2xsZXIuc2tpbi5qb2ludHM7XG5cblx0XHRcdFx0dmFyIHNrZWxldG9uID0gYnVpbGRTa2VsZXRvbiggc2tlbGV0b25zLCBqb2ludHMgKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gbmV3T2JqZWN0cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdHZhciBvYmplY3QgPSBuZXdPYmplY3RzWyBqIF07XG5cblx0XHRcdFx0XHRpZiAoIG9iamVjdC5pc1NraW5uZWRNZXNoICkge1xuXG5cdFx0XHRcdFx0XHRvYmplY3QuYmluZCggc2tlbGV0b24sIGNvbnRyb2xsZXIuc2tpbi5iaW5kTWF0cml4ICk7XG5cdFx0XHRcdFx0XHRvYmplY3Qubm9ybWFsaXplU2tpbldlaWdodHMoKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG9iamVjdHMucHVzaCggb2JqZWN0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGluc3RhbmNlIGxpZ2h0c1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbnN0YW5jZUxpZ2h0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBpbnN0YW5jZUxpZ2h0ID0gZ2V0TGlnaHQoIGluc3RhbmNlTGlnaHRzWyBpIF0gKTtcblxuXHRcdFx0XHRpZiAoIGluc3RhbmNlTGlnaHQgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRvYmplY3RzLnB1c2goIGluc3RhbmNlTGlnaHQuY2xvbmUoKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBpbnN0YW5jZSBnZW9tZXRyaWVzXG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluc3RhbmNlR2VvbWV0cmllcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBpbnN0YW5jZSA9IGluc3RhbmNlR2VvbWV0cmllc1sgaSBdO1xuXG5cdFx0XHRcdC8vIGEgc2luZ2xlIGdlb21ldHJ5IGluc3RhbmNlIGluIGNvbGxhZGEgY2FuIGxlYWQgdG8gbXVsdGlwbGUgb2JqZWN0M0RzLlxuXHRcdFx0XHQvLyB0aGlzIGlzIHRoZSBjYXNlIHdoZW4gcHJpbWl0aXZlcyBhcmUgY29tYmluZWQgbGlrZSB0cmlhbmdsZXMgYW5kIGxpbmVzXG5cblx0XHRcdFx0dmFyIGdlb21ldHJpZXMgPSBnZXRHZW9tZXRyeSggaW5zdGFuY2UuaWQgKTtcblx0XHRcdFx0dmFyIG5ld09iamVjdHMgPSBidWlsZE9iamVjdHMoIGdlb21ldHJpZXMsIGluc3RhbmNlLm1hdGVyaWFscyApO1xuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBuZXdPYmplY3RzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0b2JqZWN0cy5wdXNoKCBuZXdPYmplY3RzWyBqIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaW5zdGFuY2Ugbm9kZXNcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5zdGFuY2VOb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdG9iamVjdHMucHVzaCggZ2V0Tm9kZSggaW5zdGFuY2VOb2Rlc1sgaSBdICkuY2xvbmUoKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBvYmplY3Q7XG5cblx0XHRcdGlmICggbm9kZXMubGVuZ3RoID09PSAwICYmIG9iamVjdHMubGVuZ3RoID09PSAxICkge1xuXG5cdFx0XHRcdG9iamVjdCA9IG9iamVjdHNbIDAgXTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRvYmplY3QgPSAoIHR5cGUgPT09ICdKT0lOVCcgKSA/IG5ldyBCb25lKCkgOiBuZXcgR3JvdXAoKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdG9iamVjdC5hZGQoIG9iamVjdHNbIGkgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRvYmplY3QubmFtZSA9ICggdHlwZSA9PT0gJ0pPSU5UJyApID8gZGF0YS5zaWQgOiBkYXRhLm5hbWU7XG5cdFx0XHRvYmplY3QubWF0cml4LmNvcHkoIG1hdHJpeCApO1xuXHRcdFx0b2JqZWN0Lm1hdHJpeC5kZWNvbXBvc2UoIG9iamVjdC5wb3NpdGlvbiwgb2JqZWN0LnF1YXRlcm5pb24sIG9iamVjdC5zY2FsZSApO1xuXG5cdFx0XHRyZXR1cm4gb2JqZWN0O1xuXG5cdFx0fVxuXG5cdFx0dmFyIGZhbGxiYWNrTWF0ZXJpYWwgPSBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4ZmYwMGZmIH0gKTtcblxuXHRcdGZ1bmN0aW9uIHJlc29sdmVNYXRlcmlhbEJpbmRpbmcoIGtleXMsIGluc3RhbmNlTWF0ZXJpYWxzICkge1xuXG5cdFx0XHR2YXIgbWF0ZXJpYWxzID0gW107XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgaWQgPSBpbnN0YW5jZU1hdGVyaWFsc1sga2V5c1sgaSBdIF07XG5cblx0XHRcdFx0aWYgKCBpZCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogTWF0ZXJpYWwgd2l0aCBrZXkgJXMgbm90IGZvdW5kLiBBcHBseSBmYWxsYmFjayBtYXRlcmlhbC4nLCBrZXlzWyBpIF0gKTtcblx0XHRcdFx0XHRtYXRlcmlhbHMucHVzaCggZmFsbGJhY2tNYXRlcmlhbCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbHMucHVzaCggZ2V0TWF0ZXJpYWwoIGlkICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGVyaWFscztcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkT2JqZWN0cyggZ2VvbWV0cmllcywgaW5zdGFuY2VNYXRlcmlhbHMgKSB7XG5cblx0XHRcdHZhciBvYmplY3RzID0gW107XG5cblx0XHRcdGZvciAoIHZhciB0eXBlIGluIGdlb21ldHJpZXMgKSB7XG5cblx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gZ2VvbWV0cmllc1sgdHlwZSBdO1xuXG5cdFx0XHRcdHZhciBtYXRlcmlhbHMgPSByZXNvbHZlTWF0ZXJpYWxCaW5kaW5nKCBnZW9tZXRyeS5tYXRlcmlhbEtleXMsIGluc3RhbmNlTWF0ZXJpYWxzICk7XG5cblx0XHRcdFx0Ly8gaGFuZGxlIGNhc2UgaWYgbm8gbWF0ZXJpYWxzIGFyZSBkZWZpbmVkXG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbHMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRcdFx0aWYgKCB0eXBlID09PSAnbGluZXMnIHx8IHR5cGUgPT09ICdsaW5lc3RyaXBzJyApIHtcblxuXHRcdFx0XHRcdFx0bWF0ZXJpYWxzLnB1c2goIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCgpICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRtYXRlcmlhbHMucHVzaCggbmV3IE1lc2hQaG9uZ01hdGVyaWFsKCkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmVnYXJkIHNraW5uaW5nXG5cblx0XHRcdFx0dmFyIHNraW5uaW5nID0gKCBnZW9tZXRyeS5kYXRhLmF0dHJpYnV0ZXMuc2tpbkluZGV4ICE9PSB1bmRlZmluZWQgKTtcblxuXHRcdFx0XHRpZiAoIHNraW5uaW5nICkge1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbWF0ZXJpYWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdG1hdGVyaWFsc1sgaSBdLnNraW5uaW5nID0gdHJ1ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY2hvb3NlIGJldHdlZW4gYSBzaW5nbGUgb3IgbXVsdGkgbWF0ZXJpYWxzIChtYXRlcmlhbCBhcnJheSlcblxuXHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSAoIG1hdGVyaWFscy5sZW5ndGggPT09IDEgKSA/IG1hdGVyaWFsc1sgMCBdIDogbWF0ZXJpYWxzO1xuXG5cdFx0XHRcdC8vIG5vdyBjcmVhdGUgYSBzcGVjaWZpYyAzRCBvYmplY3RcblxuXHRcdFx0XHR2YXIgb2JqZWN0O1xuXG5cdFx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdsaW5lcyc6XG5cdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgTGluZVNlZ21lbnRzKCBnZW9tZXRyeS5kYXRhLCBtYXRlcmlhbCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdsaW5lc3RyaXBzJzpcblx0XHRcdFx0XHRcdG9iamVjdCA9IG5ldyBMaW5lKCBnZW9tZXRyeS5kYXRhLCBtYXRlcmlhbCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd0cmlhbmdsZXMnOlxuXHRcdFx0XHRcdGNhc2UgJ3BvbHlsaXN0Jzpcblx0XHRcdFx0XHRcdGlmICggc2tpbm5pbmcgKSB7XG5cblx0XHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFNraW5uZWRNZXNoKCBnZW9tZXRyeS5kYXRhLCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdG9iamVjdCA9IG5ldyBNZXNoKCBnZW9tZXRyeS5kYXRhLCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvYmplY3RzLnB1c2goIG9iamVjdCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvYmplY3RzO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFzTm9kZSggaWQgKSB7XG5cblx0XHRcdHJldHVybiBsaWJyYXJ5Lm5vZGVzWyBpZCBdICE9PSB1bmRlZmluZWQ7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXROb2RlKCBpZCApIHtcblxuXHRcdFx0cmV0dXJuIGdldEJ1aWxkKCBsaWJyYXJ5Lm5vZGVzWyBpZCBdLCBidWlsZE5vZGUgKTtcblxuXHRcdH1cblxuXHRcdC8vIHZpc3VhbCBzY2VuZXNcblxuXHRcdGZ1bmN0aW9uIHBhcnNlVmlzdWFsU2NlbmUoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdG5hbWU6IHhtbC5nZXRBdHRyaWJ1dGUoICduYW1lJyApLFxuXHRcdFx0XHRjaGlsZHJlbjogW11cblx0XHRcdH07XG5cblx0XHRcdHByZXBhcmVOb2RlcyggeG1sICk7XG5cblx0XHRcdHZhciBlbGVtZW50cyA9IGdldEVsZW1lbnRzQnlUYWdOYW1lKCB4bWwsICdub2RlJyApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0ZGF0YS5jaGlsZHJlbi5wdXNoKCBwYXJzZU5vZGUoIGVsZW1lbnRzWyBpIF0gKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGxpYnJhcnkudmlzdWFsU2NlbmVzWyB4bWwuZ2V0QXR0cmlidXRlKCAnaWQnICkgXSA9IGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZFZpc3VhbFNjZW5lKCBkYXRhICkge1xuXG5cdFx0XHR2YXIgZ3JvdXAgPSBuZXcgR3JvdXAoKTtcblx0XHRcdGdyb3VwLm5hbWUgPSBkYXRhLm5hbWU7XG5cblx0XHRcdHZhciBjaGlsZHJlbiA9IGRhdGEuY2hpbGRyZW47XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlblsgaSBdO1xuXG5cdFx0XHRcdGdyb3VwLmFkZCggZ2V0Tm9kZSggY2hpbGQuaWQgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBncm91cDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhc1Zpc3VhbFNjZW5lKCBpZCApIHtcblxuXHRcdFx0cmV0dXJuIGxpYnJhcnkudmlzdWFsU2NlbmVzWyBpZCBdICE9PSB1bmRlZmluZWQ7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRWaXN1YWxTY2VuZSggaWQgKSB7XG5cblx0XHRcdHJldHVybiBnZXRCdWlsZCggbGlicmFyeS52aXN1YWxTY2VuZXNbIGlkIF0sIGJ1aWxkVmlzdWFsU2NlbmUgKTtcblxuXHRcdH1cblxuXHRcdC8vIHNjZW5lc1xuXG5cdFx0ZnVuY3Rpb24gcGFyc2VTY2VuZSggeG1sICkge1xuXG5cdFx0XHR2YXIgaW5zdGFuY2UgPSBnZXRFbGVtZW50c0J5VGFnTmFtZSggeG1sLCAnaW5zdGFuY2VfdmlzdWFsX3NjZW5lJyApWyAwIF07XG5cdFx0XHRyZXR1cm4gZ2V0VmlzdWFsU2NlbmUoIHBhcnNlSWQoIGluc3RhbmNlLmdldEF0dHJpYnV0ZSggJ3VybCcgKSApICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXR1cEFuaW1hdGlvbnMoKSB7XG5cblx0XHRcdHZhciBjbGlwcyA9IGxpYnJhcnkuY2xpcHM7XG5cblx0XHRcdGlmICggaXNFbXB0eSggY2xpcHMgKSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRpZiAoIGlzRW1wdHkoIGxpYnJhcnkuYW5pbWF0aW9ucyApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdC8vIGlmIHRoZXJlIGFyZSBhbmltYXRpb25zIGJ1dCBubyBjbGlwcywgd2UgY3JlYXRlIGEgZGVmYXVsdCBjbGlwIGZvciBwbGF5YmFja1xuXG5cdFx0XHRcdFx0dmFyIHRyYWNrcyA9IFtdO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGlkIGluIGxpYnJhcnkuYW5pbWF0aW9ucyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGFuaW1hdGlvblRyYWNrcyA9IGdldEFuaW1hdGlvbiggaWQgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYW5pbWF0aW9uVHJhY2tzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dHJhY2tzLnB1c2goIGFuaW1hdGlvblRyYWNrc1sgaSBdICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGFuaW1hdGlvbnMucHVzaCggbmV3IEFuaW1hdGlvbkNsaXAoICdkZWZhdWx0JywgLSAxLCB0cmFja3MgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaWQgaW4gY2xpcHMgKSB7XG5cblx0XHRcdFx0XHRhbmltYXRpb25zLnB1c2goIGdldEFuaW1hdGlvbkNsaXAoIGlkICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHBhcnNlciBlcnJvciBlbGVtZW50IGludG8gdGV4dCB3aXRoIGVhY2ggY2hpbGQgZWxlbWVudHMgdGV4dFxuXHRcdC8vIHNlcGFyYXRlZCBieSBuZXcgbGluZXMuXG5cblx0XHRmdW5jdGlvbiBwYXJzZXJFcnJvclRvVGV4dCggcGFyc2VyRXJyb3IgKSB7XG5cblx0XHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRcdHZhciBzdGFjayA9IFsgcGFyc2VyRXJyb3IgXTtcblxuXHRcdFx0d2hpbGUgKCBzdGFjay5sZW5ndGggKSB7XG5cblx0XHRcdFx0dmFyIG5vZGUgPSBzdGFjay5zaGlmdCgpO1xuXG5cdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgKSB7XG5cblx0XHRcdFx0XHRyZXN1bHQgKz0gbm9kZS50ZXh0Q29udGVudDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cmVzdWx0ICs9ICdcXG4nO1xuXHRcdFx0XHRcdHN0YWNrLnB1c2guYXBwbHkoIHN0YWNrLCBub2RlLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlc3VsdC50cmltKCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRleHQubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRyZXR1cm4geyBzY2VuZTogbmV3IFNjZW5lKCkgfTtcblxuXHRcdH1cblxuXHRcdHZhciB4bWwgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKCB0ZXh0LCAnYXBwbGljYXRpb24veG1sJyApO1xuXG5cdFx0dmFyIGNvbGxhZGEgPSBnZXRFbGVtZW50c0J5VGFnTmFtZSggeG1sLCAnQ09MTEFEQScgKVsgMCBdO1xuXG5cdFx0dmFyIHBhcnNlckVycm9yID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCAncGFyc2VyZXJyb3InIClbIDAgXTtcblx0XHRpZiAoIHBhcnNlckVycm9yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIENocm9tZSB3aWxsIHJldHVybiBwYXJzZXIgZXJyb3Igd2l0aCBhIGRpdiBpbiBpdFxuXG5cdFx0XHR2YXIgZXJyb3JFbGVtZW50ID0gZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHBhcnNlckVycm9yLCAnZGl2JyApWyAwIF07XG5cdFx0XHR2YXIgZXJyb3JUZXh0O1xuXG5cdFx0XHRpZiAoIGVycm9yRWxlbWVudCApIHtcblxuXHRcdFx0XHRlcnJvclRleHQgPSBlcnJvckVsZW1lbnQudGV4dENvbnRlbnQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0ZXJyb3JUZXh0ID0gcGFyc2VyRXJyb3JUb1RleHQoIHBhcnNlckVycm9yICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IEZhaWxlZCB0byBwYXJzZSBjb2xsYWRhIGZpbGUuXFxuJywgZXJyb3JUZXh0ICk7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0Ly8gbWV0YWRhdGFcblxuXHRcdHZhciB2ZXJzaW9uID0gY29sbGFkYS5nZXRBdHRyaWJ1dGUoICd2ZXJzaW9uJyApO1xuXHRcdGNvbnNvbGUubG9nKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogRmlsZSB2ZXJzaW9uJywgdmVyc2lvbiApO1xuXG5cdFx0dmFyIGFzc2V0ID0gcGFyc2VBc3NldCggZ2V0RWxlbWVudHNCeVRhZ05hbWUoIGNvbGxhZGEsICdhc3NldCcgKVsgMCBdICk7XG5cdFx0dmFyIHRleHR1cmVMb2FkZXIgPSBuZXcgVGV4dHVyZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0dGV4dHVyZUxvYWRlci5zZXRQYXRoKCB0aGlzLnJlc291cmNlUGF0aCB8fCBwYXRoICkuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcblxuXHRcdHZhciB0Z2FMb2FkZXI7XG5cblx0XHRpZiAoIFRHQUxvYWRlciApIHtcblxuXHRcdFx0dGdhTG9hZGVyID0gbmV3IFRHQUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0XHR0Z2FMb2FkZXIuc2V0UGF0aCggdGhpcy5yZXNvdXJjZVBhdGggfHwgcGF0aCApO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdHZhciBhbmltYXRpb25zID0gW107XG5cdFx0dmFyIGtpbmVtYXRpY3MgPSB7fTtcblx0XHR2YXIgY291bnQgPSAwO1xuXG5cdFx0Ly9cblxuXHRcdHZhciBsaWJyYXJ5ID0ge1xuXHRcdFx0YW5pbWF0aW9uczoge30sXG5cdFx0XHRjbGlwczoge30sXG5cdFx0XHRjb250cm9sbGVyczoge30sXG5cdFx0XHRpbWFnZXM6IHt9LFxuXHRcdFx0ZWZmZWN0czoge30sXG5cdFx0XHRtYXRlcmlhbHM6IHt9LFxuXHRcdFx0Y2FtZXJhczoge30sXG5cdFx0XHRsaWdodHM6IHt9LFxuXHRcdFx0Z2VvbWV0cmllczoge30sXG5cdFx0XHRub2Rlczoge30sXG5cdFx0XHR2aXN1YWxTY2VuZXM6IHt9LFxuXHRcdFx0a2luZW1hdGljc01vZGVsczoge30sXG5cdFx0XHRwaHlzaWNzTW9kZWxzOiB7fSxcblx0XHRcdGtpbmVtYXRpY3NTY2VuZXM6IHt9XG5cdFx0fTtcblxuXHRcdHBhcnNlTGlicmFyeSggY29sbGFkYSwgJ2xpYnJhcnlfYW5pbWF0aW9ucycsICdhbmltYXRpb24nLCBwYXJzZUFuaW1hdGlvbiApO1xuXHRcdHBhcnNlTGlicmFyeSggY29sbGFkYSwgJ2xpYnJhcnlfYW5pbWF0aW9uX2NsaXBzJywgJ2FuaW1hdGlvbl9jbGlwJywgcGFyc2VBbmltYXRpb25DbGlwICk7XG5cdFx0cGFyc2VMaWJyYXJ5KCBjb2xsYWRhLCAnbGlicmFyeV9jb250cm9sbGVycycsICdjb250cm9sbGVyJywgcGFyc2VDb250cm9sbGVyICk7XG5cdFx0cGFyc2VMaWJyYXJ5KCBjb2xsYWRhLCAnbGlicmFyeV9pbWFnZXMnLCAnaW1hZ2UnLCBwYXJzZUltYWdlICk7XG5cdFx0cGFyc2VMaWJyYXJ5KCBjb2xsYWRhLCAnbGlicmFyeV9lZmZlY3RzJywgJ2VmZmVjdCcsIHBhcnNlRWZmZWN0ICk7XG5cdFx0cGFyc2VMaWJyYXJ5KCBjb2xsYWRhLCAnbGlicmFyeV9tYXRlcmlhbHMnLCAnbWF0ZXJpYWwnLCBwYXJzZU1hdGVyaWFsICk7XG5cdFx0cGFyc2VMaWJyYXJ5KCBjb2xsYWRhLCAnbGlicmFyeV9jYW1lcmFzJywgJ2NhbWVyYScsIHBhcnNlQ2FtZXJhICk7XG5cdFx0cGFyc2VMaWJyYXJ5KCBjb2xsYWRhLCAnbGlicmFyeV9saWdodHMnLCAnbGlnaHQnLCBwYXJzZUxpZ2h0ICk7XG5cdFx0cGFyc2VMaWJyYXJ5KCBjb2xsYWRhLCAnbGlicmFyeV9nZW9tZXRyaWVzJywgJ2dlb21ldHJ5JywgcGFyc2VHZW9tZXRyeSApO1xuXHRcdHBhcnNlTGlicmFyeSggY29sbGFkYSwgJ2xpYnJhcnlfbm9kZXMnLCAnbm9kZScsIHBhcnNlTm9kZSApO1xuXHRcdHBhcnNlTGlicmFyeSggY29sbGFkYSwgJ2xpYnJhcnlfdmlzdWFsX3NjZW5lcycsICd2aXN1YWxfc2NlbmUnLCBwYXJzZVZpc3VhbFNjZW5lICk7XG5cdFx0cGFyc2VMaWJyYXJ5KCBjb2xsYWRhLCAnbGlicmFyeV9raW5lbWF0aWNzX21vZGVscycsICdraW5lbWF0aWNzX21vZGVsJywgcGFyc2VLaW5lbWF0aWNzTW9kZWwgKTtcblx0XHRwYXJzZUxpYnJhcnkoIGNvbGxhZGEsICdsaWJyYXJ5X3BoeXNpY3NfbW9kZWxzJywgJ3BoeXNpY3NfbW9kZWwnLCBwYXJzZVBoeXNpY3NNb2RlbCApO1xuXHRcdHBhcnNlTGlicmFyeSggY29sbGFkYSwgJ3NjZW5lJywgJ2luc3RhbmNlX2tpbmVtYXRpY3Nfc2NlbmUnLCBwYXJzZUtpbmVtYXRpY3NTY2VuZSApO1xuXG5cdFx0YnVpbGRMaWJyYXJ5KCBsaWJyYXJ5LmFuaW1hdGlvbnMsIGJ1aWxkQW5pbWF0aW9uICk7XG5cdFx0YnVpbGRMaWJyYXJ5KCBsaWJyYXJ5LmNsaXBzLCBidWlsZEFuaW1hdGlvbkNsaXAgKTtcblx0XHRidWlsZExpYnJhcnkoIGxpYnJhcnkuY29udHJvbGxlcnMsIGJ1aWxkQ29udHJvbGxlciApO1xuXHRcdGJ1aWxkTGlicmFyeSggbGlicmFyeS5pbWFnZXMsIGJ1aWxkSW1hZ2UgKTtcblx0XHRidWlsZExpYnJhcnkoIGxpYnJhcnkuZWZmZWN0cywgYnVpbGRFZmZlY3QgKTtcblx0XHRidWlsZExpYnJhcnkoIGxpYnJhcnkubWF0ZXJpYWxzLCBidWlsZE1hdGVyaWFsICk7XG5cdFx0YnVpbGRMaWJyYXJ5KCBsaWJyYXJ5LmNhbWVyYXMsIGJ1aWxkQ2FtZXJhICk7XG5cdFx0YnVpbGRMaWJyYXJ5KCBsaWJyYXJ5LmxpZ2h0cywgYnVpbGRMaWdodCApO1xuXHRcdGJ1aWxkTGlicmFyeSggbGlicmFyeS5nZW9tZXRyaWVzLCBidWlsZEdlb21ldHJ5ICk7XG5cdFx0YnVpbGRMaWJyYXJ5KCBsaWJyYXJ5LnZpc3VhbFNjZW5lcywgYnVpbGRWaXN1YWxTY2VuZSApO1xuXG5cdFx0c2V0dXBBbmltYXRpb25zKCk7XG5cdFx0c2V0dXBLaW5lbWF0aWNzKCk7XG5cblx0XHR2YXIgc2NlbmUgPSBwYXJzZVNjZW5lKCBnZXRFbGVtZW50c0J5VGFnTmFtZSggY29sbGFkYSwgJ3NjZW5lJyApWyAwIF0gKTtcblx0XHRzY2VuZS5hbmltYXRpb25zID0gYW5pbWF0aW9ucztcblxuXHRcdGlmICggYXNzZXQudXBBeGlzID09PSAnWl9VUCcgKSB7XG5cblx0XHRcdHNjZW5lLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBuZXcgRXVsZXIoIC0gTWF0aC5QSSAvIDIsIDAsIDAgKSApO1xuXG5cdFx0fVxuXG5cdFx0c2NlbmUuc2NhbGUubXVsdGlwbHlTY2FsYXIoIGFzc2V0LnVuaXQgKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRnZXQgYW5pbWF0aW9ucygpIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBQbGVhc2UgYWNjZXNzIGFuaW1hdGlvbnMgb3ZlciBzY2VuZS5hbmltYXRpb25zIG5vdy4nICk7XG5cdFx0XHRcdHJldHVybiBhbmltYXRpb25zO1xuXG5cdFx0XHR9LFxuXHRcdFx0a2luZW1hdGljczoga2luZW1hdGljcyxcblx0XHRcdGxpYnJhcnk6IGxpYnJhcnksXG5cdFx0XHRzY2VuZTogc2NlbmVcblx0XHR9O1xuXG5cdH1cblxufSApO1xuXG52YXIgT0JKTG9hZGVyID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0Ly8gbyBvYmplY3RfbmFtZSB8IGcgZ3JvdXBfbmFtZVxuXHR2YXIgb2JqZWN0X3BhdHRlcm4gPSAvXltvZ11cXHMqKC4rKT8vO1xuXHQvLyBtdGxsaWIgZmlsZV9yZWZlcmVuY2Vcblx0dmFyIG1hdGVyaWFsX2xpYnJhcnlfcGF0dGVybiA9IC9ebXRsbGliIC87XG5cdC8vIHVzZW10bCBtYXRlcmlhbF9uYW1lXG5cdHZhciBtYXRlcmlhbF91c2VfcGF0dGVybiA9IC9edXNlbXRsIC87XG5cdC8vIHVzZW1hcCBtYXBfbmFtZVxuXHR2YXIgbWFwX3VzZV9wYXR0ZXJuID0gL151c2VtYXAgLztcblxuXHR2YXIgdkEgPSBuZXcgVmVjdG9yMygpO1xuXHR2YXIgdkIgPSBuZXcgVmVjdG9yMygpO1xuXHR2YXIgdkMgPSBuZXcgVmVjdG9yMygpO1xuXG5cdHZhciBhYiA9IG5ldyBWZWN0b3IzKCk7XG5cdHZhciBjYiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0ZnVuY3Rpb24gUGFyc2VyU3RhdGUoKSB7XG5cblx0XHR2YXIgc3RhdGUgPSB7XG5cdFx0XHRvYmplY3RzOiBbXSxcblx0XHRcdG9iamVjdDoge30sXG5cblx0XHRcdHZlcnRpY2VzOiBbXSxcblx0XHRcdG5vcm1hbHM6IFtdLFxuXHRcdFx0Y29sb3JzOiBbXSxcblx0XHRcdHV2czogW10sXG5cblx0XHRcdG1hdGVyaWFsczoge30sXG5cdFx0XHRtYXRlcmlhbExpYnJhcmllczogW10sXG5cblx0XHRcdHN0YXJ0T2JqZWN0OiBmdW5jdGlvbiAoIG5hbWUsIGZyb21EZWNsYXJhdGlvbiApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGUgY3VycmVudCBvYmplY3QgKGluaXRpYWwgZnJvbSByZXNldCkgaXMgbm90IGZyb20gYSBnL28gZGVjbGFyYXRpb24gaW4gdGhlIHBhcnNlZFxuXHRcdFx0XHQvLyBmaWxlLiBXZSBuZWVkIHRvIHVzZSBpdCBmb3IgdGhlIGZpcnN0IHBhcnNlZCBnL28gdG8ga2VlcCB0aGluZ3MgaW4gc3luYy5cblx0XHRcdFx0aWYgKCB0aGlzLm9iamVjdCAmJiB0aGlzLm9iamVjdC5mcm9tRGVjbGFyYXRpb24gPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0dGhpcy5vYmplY3QubmFtZSA9IG5hbWU7XG5cdFx0XHRcdFx0dGhpcy5vYmplY3QuZnJvbURlY2xhcmF0aW9uID0gKCBmcm9tRGVjbGFyYXRpb24gIT09IGZhbHNlICk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcHJldmlvdXNNYXRlcmlhbCA9ICggdGhpcy5vYmplY3QgJiYgdHlwZW9mIHRoaXMub2JqZWN0LmN1cnJlbnRNYXRlcmlhbCA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMub2JqZWN0LmN1cnJlbnRNYXRlcmlhbCgpIDogdW5kZWZpbmVkICk7XG5cblx0XHRcdFx0aWYgKCB0aGlzLm9iamVjdCAmJiB0eXBlb2YgdGhpcy5vYmplY3QuX2ZpbmFsaXplID09PSAnZnVuY3Rpb24nICkge1xuXG5cdFx0XHRcdFx0dGhpcy5vYmplY3QuX2ZpbmFsaXplKCB0cnVlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMub2JqZWN0ID0ge1xuXHRcdFx0XHRcdG5hbWU6IG5hbWUgfHwgJycsXG5cdFx0XHRcdFx0ZnJvbURlY2xhcmF0aW9uOiAoIGZyb21EZWNsYXJhdGlvbiAhPT0gZmFsc2UgKSxcblxuXHRcdFx0XHRcdGdlb21ldHJ5OiB7XG5cdFx0XHRcdFx0XHR2ZXJ0aWNlczogW10sXG5cdFx0XHRcdFx0XHRub3JtYWxzOiBbXSxcblx0XHRcdFx0XHRcdGNvbG9yczogW10sXG5cdFx0XHRcdFx0XHR1dnM6IFtdLFxuXHRcdFx0XHRcdFx0aGFzVVZJbmRpY2VzOiBmYWxzZVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0bWF0ZXJpYWxzOiBbXSxcblx0XHRcdFx0XHRzbW9vdGg6IHRydWUsXG5cblx0XHRcdFx0XHRzdGFydE1hdGVyaWFsOiBmdW5jdGlvbiAoIG5hbWUsIGxpYnJhcmllcyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHByZXZpb3VzID0gdGhpcy5fZmluYWxpemUoIGZhbHNlICk7XG5cblx0XHRcdFx0XHRcdC8vIE5ldyB1c2VtdGwgZGVjbGFyYXRpb24gb3ZlcndyaXRlcyBhbiBpbmhlcml0ZWQgbWF0ZXJpYWwsIGV4Y2VwdCBpZiBmYWNlcyB3ZXJlIGRlY2xhcmVkXG5cdFx0XHRcdFx0XHQvLyBhZnRlciB0aGUgbWF0ZXJpYWwsIHRoZW4gaXQgbXVzdCBiZSBwcmVzZXJ2ZWQgZm9yIHByb3BlciBNdWx0aU1hdGVyaWFsIGNvbnRpbnVhdGlvbi5cblx0XHRcdFx0XHRcdGlmICggcHJldmlvdXMgJiYgKCBwcmV2aW91cy5pbmhlcml0ZWQgfHwgcHJldmlvdXMuZ3JvdXBDb3VudCA8PSAwICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0dGhpcy5tYXRlcmlhbHMuc3BsaWNlKCBwcmV2aW91cy5pbmRleCwgMSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHZhciBtYXRlcmlhbCA9IHtcblx0XHRcdFx0XHRcdFx0aW5kZXg6IHRoaXMubWF0ZXJpYWxzLmxlbmd0aCxcblx0XHRcdFx0XHRcdFx0bmFtZTogbmFtZSB8fCAnJyxcblx0XHRcdFx0XHRcdFx0bXRsbGliOiAoIEFycmF5LmlzQXJyYXkoIGxpYnJhcmllcyApICYmIGxpYnJhcmllcy5sZW5ndGggPiAwID8gbGlicmFyaWVzWyBsaWJyYXJpZXMubGVuZ3RoIC0gMSBdIDogJycgKSxcblx0XHRcdFx0XHRcdFx0c21vb3RoOiAoIHByZXZpb3VzICE9PSB1bmRlZmluZWQgPyBwcmV2aW91cy5zbW9vdGggOiB0aGlzLnNtb290aCApLFxuXHRcdFx0XHRcdFx0XHRncm91cFN0YXJ0OiAoIHByZXZpb3VzICE9PSB1bmRlZmluZWQgPyBwcmV2aW91cy5ncm91cEVuZCA6IDAgKSxcblx0XHRcdFx0XHRcdFx0Z3JvdXBFbmQ6IC0gMSxcblx0XHRcdFx0XHRcdFx0Z3JvdXBDb3VudDogLSAxLFxuXHRcdFx0XHRcdFx0XHRpbmhlcml0ZWQ6IGZhbHNlLFxuXG5cdFx0XHRcdFx0XHRcdGNsb25lOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGNsb25lZCA9IHtcblx0XHRcdFx0XHRcdFx0XHRcdGluZGV4OiAoIHR5cGVvZiBpbmRleCA9PT0gJ251bWJlcicgPyBpbmRleCA6IHRoaXMuaW5kZXggKSxcblx0XHRcdFx0XHRcdFx0XHRcdG5hbWU6IHRoaXMubmFtZSxcblx0XHRcdFx0XHRcdFx0XHRcdG10bGxpYjogdGhpcy5tdGxsaWIsXG5cdFx0XHRcdFx0XHRcdFx0XHRzbW9vdGg6IHRoaXMuc21vb3RoLFxuXHRcdFx0XHRcdFx0XHRcdFx0Z3JvdXBTdGFydDogMCxcblx0XHRcdFx0XHRcdFx0XHRcdGdyb3VwRW5kOiAtIDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRncm91cENvdW50OiAtIDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRpbmhlcml0ZWQ6IGZhbHNlXG5cdFx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0XHRjbG9uZWQuY2xvbmUgPSB0aGlzLmNsb25lLmJpbmQoIGNsb25lZCApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBjbG9uZWQ7XG5cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0dGhpcy5tYXRlcmlhbHMucHVzaCggbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIG1hdGVyaWFsO1xuXG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdGN1cnJlbnRNYXRlcmlhbDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMubWF0ZXJpYWxzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMubWF0ZXJpYWxzWyB0aGlzLm1hdGVyaWFscy5sZW5ndGggLSAxIF07XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRfZmluYWxpemU6IGZ1bmN0aW9uICggZW5kICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgbGFzdE11bHRpTWF0ZXJpYWwgPSB0aGlzLmN1cnJlbnRNYXRlcmlhbCgpO1xuXHRcdFx0XHRcdFx0aWYgKCBsYXN0TXVsdGlNYXRlcmlhbCAmJiBsYXN0TXVsdGlNYXRlcmlhbC5ncm91cEVuZCA9PT0gLSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdGxhc3RNdWx0aU1hdGVyaWFsLmdyb3VwRW5kID0gdGhpcy5nZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggLyAzO1xuXHRcdFx0XHRcdFx0XHRsYXN0TXVsdGlNYXRlcmlhbC5ncm91cENvdW50ID0gbGFzdE11bHRpTWF0ZXJpYWwuZ3JvdXBFbmQgLSBsYXN0TXVsdGlNYXRlcmlhbC5ncm91cFN0YXJ0O1xuXHRcdFx0XHRcdFx0XHRsYXN0TXVsdGlNYXRlcmlhbC5pbmhlcml0ZWQgPSBmYWxzZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJZ25vcmUgb2JqZWN0cyB0YWlsIG1hdGVyaWFscyBpZiBubyBmYWNlIGRlY2xhcmF0aW9ucyBmb2xsb3dlZCB0aGVtIGJlZm9yZSBhIG5ldyBvL2cgc3RhcnRlZC5cblx0XHRcdFx0XHRcdGlmICggZW5kICYmIHRoaXMubWF0ZXJpYWxzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIG1pID0gdGhpcy5tYXRlcmlhbHMubGVuZ3RoIC0gMTsgbWkgPj0gMDsgbWkgLS0gKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIHRoaXMubWF0ZXJpYWxzWyBtaSBdLmdyb3VwQ291bnQgPD0gMCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5tYXRlcmlhbHMuc3BsaWNlKCBtaSwgMSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBHdWFyYW50ZWUgYXQgbGVhc3Qgb25lIGVtcHR5IG1hdGVyaWFsLCB0aGlzIG1ha2VzIHRoZSBjcmVhdGlvbiBsYXRlciBtb3JlIHN0cmFpZ2h0IGZvcndhcmQuXG5cdFx0XHRcdFx0XHRpZiAoIGVuZCAmJiB0aGlzLm1hdGVyaWFscy5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0dGhpcy5tYXRlcmlhbHMucHVzaCgge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWU6ICcnLFxuXHRcdFx0XHRcdFx0XHRcdHNtb290aDogdGhpcy5zbW9vdGhcblx0XHRcdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiBsYXN0TXVsdGlNYXRlcmlhbDtcblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBJbmhlcml0IHByZXZpb3VzIG9iamVjdHMgbWF0ZXJpYWwuXG5cdFx0XHRcdC8vIFNwZWMgdGVsbHMgdXMgdGhhdCBhIGRlY2xhcmVkIG1hdGVyaWFsIG11c3QgYmUgc2V0IHRvIGFsbCBvYmplY3RzIHVudGlsIGEgbmV3IG1hdGVyaWFsIGlzIGRlY2xhcmVkLlxuXHRcdFx0XHQvLyBJZiBhIHVzZW10bCBkZWNsYXJhdGlvbiBpcyBlbmNvdW50ZXJlZCB3aGlsZSB0aGlzIG5ldyBvYmplY3QgaXMgYmVpbmcgcGFyc2VkLCBpdCB3aWxsXG5cdFx0XHRcdC8vIG92ZXJ3cml0ZSB0aGUgaW5oZXJpdGVkIG1hdGVyaWFsLiBFeGNlcHRpb24gYmVpbmcgdGhhdCB0aGVyZSB3YXMgYWxyZWFkeSBmYWNlIGRlY2xhcmF0aW9uc1xuXHRcdFx0XHQvLyB0byB0aGUgaW5oZXJpdGVkIG1hdGVyaWFsLCB0aGVuIGl0IHdpbGwgYmUgcHJlc2VydmVkIGZvciBwcm9wZXIgTXVsdGlNYXRlcmlhbCBjb250aW51YXRpb24uXG5cblx0XHRcdFx0aWYgKCBwcmV2aW91c01hdGVyaWFsICYmIHByZXZpb3VzTWF0ZXJpYWwubmFtZSAmJiB0eXBlb2YgcHJldmlvdXNNYXRlcmlhbC5jbG9uZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblxuXHRcdFx0XHRcdHZhciBkZWNsYXJlZCA9IHByZXZpb3VzTWF0ZXJpYWwuY2xvbmUoIDAgKTtcblx0XHRcdFx0XHRkZWNsYXJlZC5pbmhlcml0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHRoaXMub2JqZWN0Lm1hdGVyaWFscy5wdXNoKCBkZWNsYXJlZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLm9iamVjdHMucHVzaCggdGhpcy5vYmplY3QgKTtcblxuXHRcdFx0fSxcblxuXHRcdFx0ZmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRpZiAoIHRoaXMub2JqZWN0ICYmIHR5cGVvZiB0aGlzLm9iamVjdC5fZmluYWxpemUgPT09ICdmdW5jdGlvbicgKSB7XG5cblx0XHRcdFx0XHR0aGlzLm9iamVjdC5fZmluYWxpemUoIHRydWUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sXG5cblx0XHRcdHBhcnNlVmVydGV4SW5kZXg6IGZ1bmN0aW9uICggdmFsdWUsIGxlbiApIHtcblxuXHRcdFx0XHR2YXIgaW5kZXggPSBwYXJzZUludCggdmFsdWUsIDEwICk7XG5cdFx0XHRcdHJldHVybiAoIGluZGV4ID49IDAgPyBpbmRleCAtIDEgOiBpbmRleCArIGxlbiAvIDMgKSAqIDM7XG5cblx0XHRcdH0sXG5cblx0XHRcdHBhcnNlTm9ybWFsSW5kZXg6IGZ1bmN0aW9uICggdmFsdWUsIGxlbiApIHtcblxuXHRcdFx0XHR2YXIgaW5kZXggPSBwYXJzZUludCggdmFsdWUsIDEwICk7XG5cdFx0XHRcdHJldHVybiAoIGluZGV4ID49IDAgPyBpbmRleCAtIDEgOiBpbmRleCArIGxlbiAvIDMgKSAqIDM7XG5cblx0XHRcdH0sXG5cblx0XHRcdHBhcnNlVVZJbmRleDogZnVuY3Rpb24gKCB2YWx1ZSwgbGVuICkge1xuXG5cdFx0XHRcdHZhciBpbmRleCA9IHBhcnNlSW50KCB2YWx1ZSwgMTAgKTtcblx0XHRcdFx0cmV0dXJuICggaW5kZXggPj0gMCA/IGluZGV4IC0gMSA6IGluZGV4ICsgbGVuIC8gMiApICogMjtcblxuXHRcdFx0fSxcblxuXHRcdFx0YWRkVmVydGV4OiBmdW5jdGlvbiAoIGEsIGIsIGMgKSB7XG5cblx0XHRcdFx0dmFyIHNyYyA9IHRoaXMudmVydGljZXM7XG5cdFx0XHRcdHZhciBkc3QgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS52ZXJ0aWNlcztcblxuXHRcdFx0XHRkc3QucHVzaCggc3JjWyBhICsgMCBdLCBzcmNbIGEgKyAxIF0sIHNyY1sgYSArIDIgXSApO1xuXHRcdFx0XHRkc3QucHVzaCggc3JjWyBiICsgMCBdLCBzcmNbIGIgKyAxIF0sIHNyY1sgYiArIDIgXSApO1xuXHRcdFx0XHRkc3QucHVzaCggc3JjWyBjICsgMCBdLCBzcmNbIGMgKyAxIF0sIHNyY1sgYyArIDIgXSApO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRhZGRWZXJ0ZXhQb2ludDogZnVuY3Rpb24gKCBhICkge1xuXG5cdFx0XHRcdHZhciBzcmMgPSB0aGlzLnZlcnRpY2VzO1xuXHRcdFx0XHR2YXIgZHN0ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnkudmVydGljZXM7XG5cblx0XHRcdFx0ZHN0LnB1c2goIHNyY1sgYSArIDAgXSwgc3JjWyBhICsgMSBdLCBzcmNbIGEgKyAyIF0gKTtcblxuXHRcdFx0fSxcblxuXHRcdFx0YWRkVmVydGV4TGluZTogZnVuY3Rpb24gKCBhICkge1xuXG5cdFx0XHRcdHZhciBzcmMgPSB0aGlzLnZlcnRpY2VzO1xuXHRcdFx0XHR2YXIgZHN0ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnkudmVydGljZXM7XG5cblx0XHRcdFx0ZHN0LnB1c2goIHNyY1sgYSArIDAgXSwgc3JjWyBhICsgMSBdLCBzcmNbIGEgKyAyIF0gKTtcblxuXHRcdFx0fSxcblxuXHRcdFx0YWRkTm9ybWFsOiBmdW5jdGlvbiAoIGEsIGIsIGMgKSB7XG5cblx0XHRcdFx0dmFyIHNyYyA9IHRoaXMubm9ybWFscztcblx0XHRcdFx0dmFyIGRzdCA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5Lm5vcm1hbHM7XG5cblx0XHRcdFx0ZHN0LnB1c2goIHNyY1sgYSArIDAgXSwgc3JjWyBhICsgMSBdLCBzcmNbIGEgKyAyIF0gKTtcblx0XHRcdFx0ZHN0LnB1c2goIHNyY1sgYiArIDAgXSwgc3JjWyBiICsgMSBdLCBzcmNbIGIgKyAyIF0gKTtcblx0XHRcdFx0ZHN0LnB1c2goIHNyY1sgYyArIDAgXSwgc3JjWyBjICsgMSBdLCBzcmNbIGMgKyAyIF0gKTtcblxuXHRcdFx0fSxcblxuXHRcdFx0YWRkRmFjZU5vcm1hbDogZnVuY3Rpb24gKCBhLCBiLCBjICkge1xuXG5cdFx0XHRcdHZhciBzcmMgPSB0aGlzLnZlcnRpY2VzO1xuXHRcdFx0XHR2YXIgZHN0ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnkubm9ybWFscztcblxuXHRcdFx0XHR2QS5mcm9tQXJyYXkoIHNyYywgYSApO1xuXHRcdFx0XHR2Qi5mcm9tQXJyYXkoIHNyYywgYiApO1xuXHRcdFx0XHR2Qy5mcm9tQXJyYXkoIHNyYywgYyApO1xuXG5cdFx0XHRcdGNiLnN1YlZlY3RvcnMoIHZDLCB2QiApO1xuXHRcdFx0XHRhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcblx0XHRcdFx0Y2IuY3Jvc3MoIGFiICk7XG5cblx0XHRcdFx0Y2Iubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0ZHN0LnB1c2goIGNiLngsIGNiLnksIGNiLnogKTtcblx0XHRcdFx0ZHN0LnB1c2goIGNiLngsIGNiLnksIGNiLnogKTtcblx0XHRcdFx0ZHN0LnB1c2goIGNiLngsIGNiLnksIGNiLnogKTtcblxuXHRcdFx0fSxcblxuXHRcdFx0YWRkQ29sb3I6IGZ1bmN0aW9uICggYSwgYiwgYyApIHtcblxuXHRcdFx0XHR2YXIgc3JjID0gdGhpcy5jb2xvcnM7XG5cdFx0XHRcdHZhciBkc3QgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS5jb2xvcnM7XG5cblx0XHRcdFx0aWYgKCBzcmNbIGEgXSAhPT0gdW5kZWZpbmVkICkgZHN0LnB1c2goIHNyY1sgYSArIDAgXSwgc3JjWyBhICsgMSBdLCBzcmNbIGEgKyAyIF0gKTtcblx0XHRcdFx0aWYgKCBzcmNbIGIgXSAhPT0gdW5kZWZpbmVkICkgZHN0LnB1c2goIHNyY1sgYiArIDAgXSwgc3JjWyBiICsgMSBdLCBzcmNbIGIgKyAyIF0gKTtcblx0XHRcdFx0aWYgKCBzcmNbIGMgXSAhPT0gdW5kZWZpbmVkICkgZHN0LnB1c2goIHNyY1sgYyArIDAgXSwgc3JjWyBjICsgMSBdLCBzcmNbIGMgKyAyIF0gKTtcblxuXHRcdFx0fSxcblxuXHRcdFx0YWRkVVY6IGZ1bmN0aW9uICggYSwgYiwgYyApIHtcblxuXHRcdFx0XHR2YXIgc3JjID0gdGhpcy51dnM7XG5cdFx0XHRcdHZhciBkc3QgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS51dnM7XG5cblx0XHRcdFx0ZHN0LnB1c2goIHNyY1sgYSArIDAgXSwgc3JjWyBhICsgMSBdICk7XG5cdFx0XHRcdGRzdC5wdXNoKCBzcmNbIGIgKyAwIF0sIHNyY1sgYiArIDEgXSApO1xuXHRcdFx0XHRkc3QucHVzaCggc3JjWyBjICsgMCBdLCBzcmNbIGMgKyAxIF0gKTtcblxuXHRcdFx0fSxcblxuXHRcdFx0YWRkRGVmYXVsdFVWOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0dmFyIGRzdCA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5LnV2cztcblxuXHRcdFx0XHRkc3QucHVzaCggMCwgMCApO1xuXHRcdFx0XHRkc3QucHVzaCggMCwgMCApO1xuXHRcdFx0XHRkc3QucHVzaCggMCwgMCApO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRhZGRVVkxpbmU6IGZ1bmN0aW9uICggYSApIHtcblxuXHRcdFx0XHR2YXIgc3JjID0gdGhpcy51dnM7XG5cdFx0XHRcdHZhciBkc3QgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS51dnM7XG5cblx0XHRcdFx0ZHN0LnB1c2goIHNyY1sgYSArIDAgXSwgc3JjWyBhICsgMSBdICk7XG5cblx0XHRcdH0sXG5cblx0XHRcdGFkZEZhY2U6IGZ1bmN0aW9uICggYSwgYiwgYywgdWEsIHViLCB1YywgbmEsIG5iLCBuYyApIHtcblxuXHRcdFx0XHR2YXIgdkxlbiA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuXG5cdFx0XHRcdHZhciBpYSA9IHRoaXMucGFyc2VWZXJ0ZXhJbmRleCggYSwgdkxlbiApO1xuXHRcdFx0XHR2YXIgaWIgPSB0aGlzLnBhcnNlVmVydGV4SW5kZXgoIGIsIHZMZW4gKTtcblx0XHRcdFx0dmFyIGljID0gdGhpcy5wYXJzZVZlcnRleEluZGV4KCBjLCB2TGVuICk7XG5cblx0XHRcdFx0dGhpcy5hZGRWZXJ0ZXgoIGlhLCBpYiwgaWMgKTtcblx0XHRcdFx0dGhpcy5hZGRDb2xvciggaWEsIGliLCBpYyApO1xuXG5cdFx0XHRcdC8vIG5vcm1hbHNcblxuXHRcdFx0XHRpZiAoIG5hICE9PSB1bmRlZmluZWQgJiYgbmEgIT09ICcnICkge1xuXG5cdFx0XHRcdFx0dmFyIG5MZW4gPSB0aGlzLm5vcm1hbHMubGVuZ3RoO1xuXG5cdFx0XHRcdFx0aWEgPSB0aGlzLnBhcnNlTm9ybWFsSW5kZXgoIG5hLCBuTGVuICk7XG5cdFx0XHRcdFx0aWIgPSB0aGlzLnBhcnNlTm9ybWFsSW5kZXgoIG5iLCBuTGVuICk7XG5cdFx0XHRcdFx0aWMgPSB0aGlzLnBhcnNlTm9ybWFsSW5kZXgoIG5jLCBuTGVuICk7XG5cblx0XHRcdFx0XHR0aGlzLmFkZE5vcm1hbCggaWEsIGliLCBpYyApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLmFkZEZhY2VOb3JtYWwoIGlhLCBpYiwgaWMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdXZzXG5cblx0XHRcdFx0aWYgKCB1YSAhPT0gdW5kZWZpbmVkICYmIHVhICE9PSAnJyApIHtcblxuXHRcdFx0XHRcdHZhciB1dkxlbiA9IHRoaXMudXZzLmxlbmd0aDtcblxuXHRcdFx0XHRcdGlhID0gdGhpcy5wYXJzZVVWSW5kZXgoIHVhLCB1dkxlbiApO1xuXHRcdFx0XHRcdGliID0gdGhpcy5wYXJzZVVWSW5kZXgoIHViLCB1dkxlbiApO1xuXHRcdFx0XHRcdGljID0gdGhpcy5wYXJzZVVWSW5kZXgoIHVjLCB1dkxlbiApO1xuXG5cdFx0XHRcdFx0dGhpcy5hZGRVViggaWEsIGliLCBpYyApO1xuXG5cdFx0XHRcdFx0dGhpcy5vYmplY3QuZ2VvbWV0cnkuaGFzVVZJbmRpY2VzID0gdHJ1ZTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gYWRkIHBsYWNlaG9sZGVyIHZhbHVlcyAoZm9yIGluY29uc2lzdGVudCBmYWNlIGRlZmluaXRpb25zKVxuXG5cdFx0XHRcdFx0dGhpcy5hZGREZWZhdWx0VVYoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sXG5cblx0XHRcdGFkZFBvaW50R2VvbWV0cnk6IGZ1bmN0aW9uICggdmVydGljZXMgKSB7XG5cblx0XHRcdFx0dGhpcy5vYmplY3QuZ2VvbWV0cnkudHlwZSA9ICdQb2ludHMnO1xuXG5cdFx0XHRcdHZhciB2TGVuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggdmFyIHZpID0gMCwgbCA9IHZlcnRpY2VzLmxlbmd0aDsgdmkgPCBsOyB2aSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBpbmRleCA9IHRoaXMucGFyc2VWZXJ0ZXhJbmRleCggdmVydGljZXNbIHZpIF0sIHZMZW4gKTtcblxuXHRcdFx0XHRcdHRoaXMuYWRkVmVydGV4UG9pbnQoIGluZGV4ICk7XG5cdFx0XHRcdFx0dGhpcy5hZGRDb2xvciggaW5kZXggKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sXG5cblx0XHRcdGFkZExpbmVHZW9tZXRyeTogZnVuY3Rpb24gKCB2ZXJ0aWNlcywgdXZzICkge1xuXG5cdFx0XHRcdHRoaXMub2JqZWN0Lmdlb21ldHJ5LnR5cGUgPSAnTGluZSc7XG5cblx0XHRcdFx0dmFyIHZMZW4gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcblx0XHRcdFx0dmFyIHV2TGVuID0gdGhpcy51dnMubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIHZhciB2aSA9IDAsIGwgPSB2ZXJ0aWNlcy5sZW5ndGg7IHZpIDwgbDsgdmkgKysgKSB7XG5cblx0XHRcdFx0XHR0aGlzLmFkZFZlcnRleExpbmUoIHRoaXMucGFyc2VWZXJ0ZXhJbmRleCggdmVydGljZXNbIHZpIF0sIHZMZW4gKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCB2YXIgdXZpID0gMCwgbCA9IHV2cy5sZW5ndGg7IHV2aSA8IGw7IHV2aSArKyApIHtcblxuXHRcdFx0XHRcdHRoaXMuYWRkVVZMaW5lKCB0aGlzLnBhcnNlVVZJbmRleCggdXZzWyB1dmkgXSwgdXZMZW4gKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdHN0YXRlLnN0YXJ0T2JqZWN0KCAnJywgZmFsc2UgKTtcblxuXHRcdHJldHVybiBzdGF0ZTtcblxuXHR9XG5cblx0Ly9cblxuXHRmdW5jdGlvbiBPQkpMb2FkZXIoIG1hbmFnZXIgKSB7XG5cblx0XHRMb2FkZXIkMS5jYWxsKCB0aGlzLCBtYW5hZ2VyICk7XG5cblx0XHR0aGlzLm1hdGVyaWFscyA9IG51bGw7XG5cblx0fVxuXG5cdE9CSkxvYWRlci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMb2FkZXIkMS5wcm90b3R5cGUgKSwge1xuXG5cdFx0Y29uc3RydWN0b3I6IE9CSkxvYWRlcixcblxuXHRcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHRcdHZhciBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XG5cdFx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggdGhpcy5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCB0aGlzLndpdGhDcmVkZW50aWFscyApO1xuXHRcdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHRvbkxvYWQoIHNjb3BlLnBhcnNlKCB0ZXh0ICkgKTtcblxuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdGlmICggb25FcnJvciApIHtcblxuXHRcdFx0XHRcdFx0b25FcnJvciggZSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdFx0fSxcblxuXHRcdHNldE1hdGVyaWFsczogZnVuY3Rpb24gKCBtYXRlcmlhbHMgKSB7XG5cblx0XHRcdHRoaXMubWF0ZXJpYWxzID0gbWF0ZXJpYWxzO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRwYXJzZTogZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG5cdFx0XHR2YXIgc3RhdGUgPSBuZXcgUGFyc2VyU3RhdGUoKTtcblxuXHRcdFx0aWYgKCB0ZXh0LmluZGV4T2YoICdcXHJcXG4nICkgIT09IC0gMSApIHtcblxuXHRcdFx0XHQvLyBUaGlzIGlzIGZhc3RlciB0aGFuIFN0cmluZy5zcGxpdCB3aXRoIHJlZ2V4IHRoYXQgc3BsaXRzIG9uIGJvdGhcblx0XHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggL1xcclxcbi9nLCAnXFxuJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGV4dC5pbmRleE9mKCAnXFxcXFxcbicgKSAhPT0gLSAxICkge1xuXG5cdFx0XHRcdC8vIGpvaW4gbGluZXMgc2VwYXJhdGVkIGJ5IGEgbGluZSBjb250aW51YXRpb24gY2hhcmFjdGVyIChcXClcblx0XHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggL1xcXFxcXG4vZywgJycgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KCAnXFxuJyApO1xuXHRcdFx0dmFyIGxpbmUgPSAnJywgbGluZUZpcnN0Q2hhciA9ICcnO1xuXHRcdFx0dmFyIGxpbmVMZW5ndGggPSAwO1xuXHRcdFx0dmFyIHJlc3VsdCA9IFtdO1xuXG5cdFx0XHQvLyBGYXN0ZXIgdG8ganVzdCB0cmltIGxlZnQgc2lkZSBvZiB0aGUgbGluZS4gVXNlIGlmIGF2YWlsYWJsZS5cblx0XHRcdHZhciB0cmltTGVmdCA9ICggdHlwZW9mICcnLnRyaW1MZWZ0ID09PSAnZnVuY3Rpb24nICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGxpbmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0bGluZSA9IGxpbmVzWyBpIF07XG5cblx0XHRcdFx0bGluZSA9IHRyaW1MZWZ0ID8gbGluZS50cmltTGVmdCgpIDogbGluZS50cmltKCk7XG5cblx0XHRcdFx0bGluZUxlbmd0aCA9IGxpbmUubGVuZ3RoO1xuXG5cdFx0XHRcdGlmICggbGluZUxlbmd0aCA9PT0gMCApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGxpbmVGaXJzdENoYXIgPSBsaW5lLmNoYXJBdCggMCApO1xuXG5cdFx0XHRcdC8vIEB0b2RvIGludm9rZSBwYXNzZWQgaW4gaGFuZGxlciBpZiBhbnlcblx0XHRcdFx0aWYgKCBsaW5lRmlyc3RDaGFyID09PSAnIycgKSBjb250aW51ZTtcblxuXHRcdFx0XHRpZiAoIGxpbmVGaXJzdENoYXIgPT09ICd2JyApIHtcblxuXHRcdFx0XHRcdHZhciBkYXRhID0gbGluZS5zcGxpdCggL1xccysvICk7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBkYXRhWyAwIF0gKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3YnOlxuXHRcdFx0XHRcdFx0XHRzdGF0ZS52ZXJ0aWNlcy5wdXNoKFxuXHRcdFx0XHRcdFx0XHRcdHBhcnNlRmxvYXQoIGRhdGFbIDEgXSApLFxuXHRcdFx0XHRcdFx0XHRcdHBhcnNlRmxvYXQoIGRhdGFbIDIgXSApLFxuXHRcdFx0XHRcdFx0XHRcdHBhcnNlRmxvYXQoIGRhdGFbIDMgXSApXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdGlmICggZGF0YS5sZW5ndGggPj0gNyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHN0YXRlLmNvbG9ycy5wdXNoKFxuXHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VGbG9hdCggZGF0YVsgNCBdICksXG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJzZUZsb2F0KCBkYXRhWyA1IF0gKSxcblx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlRmxvYXQoIGRhdGFbIDYgXSApXG5cblx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBpZiBubyBjb2xvcnMgYXJlIGRlZmluZWQsIGFkZCBwbGFjZWhvbGRlcnMgc28gY29sb3IgYW5kIHZlcnRleCBpbmRpY2VzIG1hdGNoXG5cblx0XHRcdFx0XHRcdFx0XHRzdGF0ZS5jb2xvcnMucHVzaCggdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ3ZuJzpcblx0XHRcdFx0XHRcdFx0c3RhdGUubm9ybWFscy5wdXNoKFxuXHRcdFx0XHRcdFx0XHRcdHBhcnNlRmxvYXQoIGRhdGFbIDEgXSApLFxuXHRcdFx0XHRcdFx0XHRcdHBhcnNlRmxvYXQoIGRhdGFbIDIgXSApLFxuXHRcdFx0XHRcdFx0XHRcdHBhcnNlRmxvYXQoIGRhdGFbIDMgXSApXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAndnQnOlxuXHRcdFx0XHRcdFx0XHRzdGF0ZS51dnMucHVzaChcblx0XHRcdFx0XHRcdFx0XHRwYXJzZUZsb2F0KCBkYXRhWyAxIF0gKSxcblx0XHRcdFx0XHRcdFx0XHRwYXJzZUZsb2F0KCBkYXRhWyAyIF0gKVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBsaW5lRmlyc3RDaGFyID09PSAnZicgKSB7XG5cblx0XHRcdFx0XHR2YXIgbGluZURhdGEgPSBsaW5lLnN1YnN0ciggMSApLnRyaW0oKTtcblx0XHRcdFx0XHR2YXIgdmVydGV4RGF0YSA9IGxpbmVEYXRhLnNwbGl0KCAvXFxzKy8gKTtcblx0XHRcdFx0XHR2YXIgZmFjZVZlcnRpY2VzID0gW107XG5cblx0XHRcdFx0XHQvLyBQYXJzZSB0aGUgZmFjZSB2ZXJ0ZXggZGF0YSBpbnRvIGFuIGVhc3kgdG8gd29yayB3aXRoIGZvcm1hdFxuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHZlcnRleERhdGEubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdHZhciB2ZXJ0ZXggPSB2ZXJ0ZXhEYXRhWyBqIF07XG5cblx0XHRcdFx0XHRcdGlmICggdmVydGV4Lmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHZlcnRleFBhcnRzID0gdmVydGV4LnNwbGl0KCAnLycgKTtcblx0XHRcdFx0XHRcdFx0ZmFjZVZlcnRpY2VzLnB1c2goIHZlcnRleFBhcnRzICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERyYXcgYW4gZWRnZSBiZXR3ZWVuIHRoZSBmaXJzdCB2ZXJ0ZXggYW5kIGFsbCBzdWJzZXF1ZW50IHZlcnRpY2VzIHRvIGZvcm0gYW4gbi1nb25cblxuXHRcdFx0XHRcdHZhciB2MSA9IGZhY2VWZXJ0aWNlc1sgMCBdO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAxLCBqbCA9IGZhY2VWZXJ0aWNlcy5sZW5ndGggLSAxOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdHZhciB2MiA9IGZhY2VWZXJ0aWNlc1sgaiBdO1xuXHRcdFx0XHRcdFx0dmFyIHYzID0gZmFjZVZlcnRpY2VzWyBqICsgMSBdO1xuXG5cdFx0XHRcdFx0XHRzdGF0ZS5hZGRGYWNlKFxuXHRcdFx0XHRcdFx0XHR2MVsgMCBdLCB2MlsgMCBdLCB2M1sgMCBdLFxuXHRcdFx0XHRcdFx0XHR2MVsgMSBdLCB2MlsgMSBdLCB2M1sgMSBdLFxuXHRcdFx0XHRcdFx0XHR2MVsgMiBdLCB2MlsgMiBdLCB2M1sgMiBdXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGxpbmVGaXJzdENoYXIgPT09ICdsJyApIHtcblxuXHRcdFx0XHRcdHZhciBsaW5lUGFydHMgPSBsaW5lLnN1YnN0cmluZyggMSApLnRyaW0oKS5zcGxpdCggJyAnICk7XG5cdFx0XHRcdFx0dmFyIGxpbmVWZXJ0aWNlcyA9IFtdLCBsaW5lVVZzID0gW107XG5cblx0XHRcdFx0XHRpZiAoIGxpbmUuaW5kZXhPZiggJy8nICkgPT09IC0gMSApIHtcblxuXHRcdFx0XHRcdFx0bGluZVZlcnRpY2VzID0gbGluZVBhcnRzO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGxpID0gMCwgbGxlbiA9IGxpbmVQYXJ0cy5sZW5ndGg7IGxpIDwgbGxlbjsgbGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHBhcnRzID0gbGluZVBhcnRzWyBsaSBdLnNwbGl0KCAnLycgKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHBhcnRzWyAwIF0gIT09ICcnICkgbGluZVZlcnRpY2VzLnB1c2goIHBhcnRzWyAwIF0gKTtcblx0XHRcdFx0XHRcdFx0aWYgKCBwYXJ0c1sgMSBdICE9PSAnJyApIGxpbmVVVnMucHVzaCggcGFydHNbIDEgXSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzdGF0ZS5hZGRMaW5lR2VvbWV0cnkoIGxpbmVWZXJ0aWNlcywgbGluZVVWcyApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGxpbmVGaXJzdENoYXIgPT09ICdwJyApIHtcblxuXHRcdFx0XHRcdHZhciBsaW5lRGF0YSA9IGxpbmUuc3Vic3RyKCAxICkudHJpbSgpO1xuXHRcdFx0XHRcdHZhciBwb2ludERhdGEgPSBsaW5lRGF0YS5zcGxpdCggJyAnICk7XG5cblx0XHRcdFx0XHRzdGF0ZS5hZGRQb2ludEdlb21ldHJ5KCBwb2ludERhdGEgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCAoIHJlc3VsdCA9IG9iamVjdF9wYXR0ZXJuLmV4ZWMoIGxpbmUgKSApICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0Ly8gbyBvYmplY3RfbmFtZVxuXHRcdFx0XHRcdC8vIG9yXG5cdFx0XHRcdFx0Ly8gZyBncm91cF9uYW1lXG5cblx0XHRcdFx0XHQvLyBXT1JLQVJPVU5EOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yODY5XG5cdFx0XHRcdFx0Ly8gdmFyIG5hbWUgPSByZXN1bHRbIDAgXS5zdWJzdHIoIDEgKS50cmltKCk7XG5cdFx0XHRcdFx0dmFyIG5hbWUgPSAoICcgJyArIHJlc3VsdFsgMCBdLnN1YnN0ciggMSApLnRyaW0oKSApLnN1YnN0ciggMSApO1xuXG5cdFx0XHRcdFx0c3RhdGUuc3RhcnRPYmplY3QoIG5hbWUgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbF91c2VfcGF0dGVybi50ZXN0KCBsaW5lICkgKSB7XG5cblx0XHRcdFx0XHQvLyBtYXRlcmlhbFxuXG5cdFx0XHRcdFx0c3RhdGUub2JqZWN0LnN0YXJ0TWF0ZXJpYWwoIGxpbmUuc3Vic3RyaW5nKCA3ICkudHJpbSgpLCBzdGF0ZS5tYXRlcmlhbExpYnJhcmllcyApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsX2xpYnJhcnlfcGF0dGVybi50ZXN0KCBsaW5lICkgKSB7XG5cblx0XHRcdFx0XHQvLyBtdGwgZmlsZVxuXG5cdFx0XHRcdFx0c3RhdGUubWF0ZXJpYWxMaWJyYXJpZXMucHVzaCggbGluZS5zdWJzdHJpbmcoIDcgKS50cmltKCkgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXBfdXNlX3BhdHRlcm4udGVzdCggbGluZSApICkge1xuXG5cdFx0XHRcdFx0Ly8gdGhlIGxpbmUgaXMgcGFyc2VkIGJ1dCBpZ25vcmVkIHNpbmNlIHRoZSBsb2FkZXIgYXNzdW1lcyB0ZXh0dXJlcyBhcmUgZGVmaW5lZCBNVEwgZmlsZXNcblx0XHRcdFx0XHQvLyAoYWNjb3JkaW5nIHRvIGh0dHBzOi8vd3d3Lm9raW5vLmNvbS9jb252L2ltcF93YXZlLmh0bSwgJ3VzZW1hcCcgaXMgdGhlIG9sZC1zdHlsZSBXYXZlZnJvbnQgdGV4dHVyZSByZWZlcmVuY2UgbWV0aG9kKVxuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT0JKTG9hZGVyOiBSZW5kZXJpbmcgaWRlbnRpZmllciBcInVzZW1hcFwiIG5vdCBzdXBwb3J0ZWQuIFRleHR1cmVzIG11c3QgYmUgZGVmaW5lZCBpbiBNVEwgZmlsZXMuJyApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGxpbmVGaXJzdENoYXIgPT09ICdzJyApIHtcblxuXHRcdFx0XHRcdHJlc3VsdCA9IGxpbmUuc3BsaXQoICcgJyApO1xuXG5cdFx0XHRcdFx0Ly8gc21vb3RoIHNoYWRpbmdcblxuXHRcdFx0XHRcdC8vIEB0b2RvIEhhbmRsZSBmaWxlcyB0aGF0IGhhdmUgdmFyeWluZyBzbW9vdGggdmFsdWVzIGZvciBhIHNldCBvZiBmYWNlcyBpbnNpZGUgb25lIGdlb21ldHJ5LFxuXHRcdFx0XHRcdC8vIGJ1dCBkb2VzIG5vdCBkZWZpbmUgYSB1c2VtdGwgZm9yIGVhY2ggZmFjZSBzZXQuXG5cdFx0XHRcdFx0Ly8gVGhpcyBzaG91bGQgYmUgZGV0ZWN0ZWQgYW5kIGEgZHVtbXkgbWF0ZXJpYWwgY3JlYXRlZCAobGF0ZXIgTXVsdGlNYXRlcmlhbCBhbmQgZ2VvbWV0cnkgZ3JvdXBzKS5cblx0XHRcdFx0XHQvLyBUaGlzIHJlcXVpcmVzIHNvbWUgY2FyZSB0byBub3QgY3JlYXRlIGV4dHJhIG1hdGVyaWFsIG9uIGVhY2ggc21vb3RoIHZhbHVlIGZvciBcIm5vcm1hbFwiIG9iaiBmaWxlcy5cblx0XHRcdFx0XHQvLyB3aGVyZSBleHBsaWNpdCB1c2VtdGwgZGVmaW5lcyBnZW9tZXRyeSBncm91cHMuXG5cdFx0XHRcdFx0Ly8gRXhhbXBsZSBhc3NldDogZXhhbXBsZXMvbW9kZWxzL29iai9jZXJiZXJ1cy9DZXJiZXJ1cy5vYmpcblxuXHRcdFx0XHRcdC8qXG5cdFx0XHRcdFx0ICogaHR0cDovL3BhdWxib3Vya2UubmV0L2RhdGFmb3JtYXRzL29iai9cblx0XHRcdFx0XHQgKiBvclxuXHRcdFx0XHRcdCAqIGh0dHA6Ly93d3cuY3MudXRhaC5lZHUvfmJvdWxvcy9jczM1MDUvb2JqX3NwZWMucGRmXG5cdFx0XHRcdFx0ICpcblx0XHRcdFx0XHQgKiBGcm9tIGNoYXB0ZXIgXCJHcm91cGluZ1wiIFN5bnRheCBleHBsYW5hdGlvbiBcInMgZ3JvdXBfbnVtYmVyXCI6XG5cdFx0XHRcdFx0ICogXCJncm91cF9udW1iZXIgaXMgdGhlIHNtb290aGluZyBncm91cCBudW1iZXIuIFRvIHR1cm4gb2ZmIHNtb290aGluZyBncm91cHMsIHVzZSBhIHZhbHVlIG9mIDAgb3Igb2ZmLlxuXHRcdFx0XHRcdCAqIFBvbHlnb25hbCBlbGVtZW50cyB1c2UgZ3JvdXAgbnVtYmVycyB0byBwdXQgZWxlbWVudHMgaW4gZGlmZmVyZW50IHNtb290aGluZyBncm91cHMuIEZvciBmcmVlLWZvcm1cblx0XHRcdFx0XHQgKiBzdXJmYWNlcywgc21vb3RoaW5nIGdyb3VwcyBhcmUgZWl0aGVyIHR1cm5lZCBvbiBvciBvZmY7IHRoZXJlIGlzIG5vIGRpZmZlcmVuY2UgYmV0d2VlbiB2YWx1ZXMgZ3JlYXRlclxuXHRcdFx0XHRcdCAqIHRoYW4gMC5cIlxuXHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdGlmICggcmVzdWx0Lmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9IHJlc3VsdFsgMSBdLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0c3RhdGUub2JqZWN0LnNtb290aCA9ICggdmFsdWUgIT09ICcwJyAmJiB2YWx1ZSAhPT0gJ29mZicgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFpCcnVzaCBjYW4gcHJvZHVjZSBcInNcIiBsaW5lcyAjMTE3MDdcblx0XHRcdFx0XHRcdHN0YXRlLm9iamVjdC5zbW9vdGggPSB0cnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIG1hdGVyaWFsID0gc3RhdGUub2JqZWN0LmN1cnJlbnRNYXRlcmlhbCgpO1xuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwgKSBtYXRlcmlhbC5zbW9vdGggPSBzdGF0ZS5vYmplY3Quc21vb3RoO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBIYW5kbGUgbnVsbCB0ZXJtaW5hdGVkIGZpbGVzIHdpdGhvdXQgZXhjZXB0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaW5lID09PSAnXFwwJyApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT0JKTG9hZGVyOiBVbmV4cGVjdGVkIGxpbmU6IFwiJyArIGxpbmUgKyAnXCInICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHN0YXRlLmZpbmFsaXplKCk7XG5cblx0XHRcdHZhciBjb250YWluZXIgPSBuZXcgR3JvdXAoKTtcblx0XHRcdGNvbnRhaW5lci5tYXRlcmlhbExpYnJhcmllcyA9IFtdLmNvbmNhdCggc3RhdGUubWF0ZXJpYWxMaWJyYXJpZXMgKTtcblxuXHRcdFx0dmFyIGhhc1ByaW1pdGl2ZXMgPSAhICggc3RhdGUub2JqZWN0cy5sZW5ndGggPT09IDEgJiYgc3RhdGUub2JqZWN0c1sgMCBdLmdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCA9PT0gMCApO1xuXG5cdFx0XHRpZiAoIGhhc1ByaW1pdGl2ZXMgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc3RhdGUub2JqZWN0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIG9iamVjdCA9IHN0YXRlLm9iamVjdHNbIGkgXTtcblx0XHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cdFx0XHRcdFx0dmFyIG1hdGVyaWFscyA9IG9iamVjdC5tYXRlcmlhbHM7XG5cdFx0XHRcdFx0dmFyIGlzTGluZSA9ICggZ2VvbWV0cnkudHlwZSA9PT0gJ0xpbmUnICk7XG5cdFx0XHRcdFx0dmFyIGlzUG9pbnRzID0gKCBnZW9tZXRyeS50eXBlID09PSAnUG9pbnRzJyApO1xuXHRcdFx0XHRcdHZhciBoYXNWZXJ0ZXhDb2xvcnMgPSBmYWxzZTtcblxuXHRcdFx0XHRcdC8vIFNraXAgby9nIGxpbmUgZGVjbGFyYXRpb25zIHRoYXQgZGlkIG5vdCBmb2xsb3cgd2l0aCBhbnkgZmFjZXNcblx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCA9PT0gMCApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0dmFyIGJ1ZmZlcmdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRcdFx0XHRidWZmZXJnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBnZW9tZXRyeS52ZXJ0aWNlcywgMyApICk7XG5cblx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5Lm5vcm1hbHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdFx0YnVmZmVyZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5Lm5vcm1hbHMsIDMgKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5jb2xvcnMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdFx0aGFzVmVydGV4Q29sb3JzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJ1ZmZlcmdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5LmNvbG9ycywgMyApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5Lmhhc1VWSW5kaWNlcyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0YnVmZmVyZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggZ2VvbWV0cnkudXZzLCAyICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIENyZWF0ZSBtYXRlcmlhbHNcblxuXHRcdFx0XHRcdHZhciBjcmVhdGVkTWF0ZXJpYWxzID0gW107XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgbWkgPSAwLCBtaUxlbiA9IG1hdGVyaWFscy5sZW5ndGg7IG1pIDwgbWlMZW47IG1pICsrICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgc291cmNlTWF0ZXJpYWwgPSBtYXRlcmlhbHNbIG1pIF07XG5cdFx0XHRcdFx0XHR2YXIgbWF0ZXJpYWxIYXNoID0gc291cmNlTWF0ZXJpYWwubmFtZSArICdfJyArIHNvdXJjZU1hdGVyaWFsLnNtb290aCArICdfJyArIGhhc1ZlcnRleENvbG9ycztcblx0XHRcdFx0XHRcdHZhciBtYXRlcmlhbCA9IHN0YXRlLm1hdGVyaWFsc1sgbWF0ZXJpYWxIYXNoIF07XG5cblx0XHRcdFx0XHRcdGlmICggdGhpcy5tYXRlcmlhbHMgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFscy5jcmVhdGUoIHNvdXJjZU1hdGVyaWFsLm5hbWUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBtdGwgZXRjLiBsb2FkZXJzIHByb2JhYmx5IGNhbid0IGNyZWF0ZSBsaW5lIG1hdGVyaWFscyBjb3JyZWN0bHksIGNvcHkgcHJvcGVydGllcyB0byBhIGxpbmUgbWF0ZXJpYWwuXG5cdFx0XHRcdFx0XHRcdGlmICggaXNMaW5lICYmIG1hdGVyaWFsICYmICEgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIExpbmVCYXNpY01hdGVyaWFsICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR2YXIgbWF0ZXJpYWxMaW5lID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCk7XG5cdFx0XHRcdFx0XHRcdFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggbWF0ZXJpYWxMaW5lLCBtYXRlcmlhbCApO1xuXHRcdFx0XHRcdFx0XHRcdG1hdGVyaWFsTGluZS5jb2xvci5jb3B5KCBtYXRlcmlhbC5jb2xvciApO1xuXHRcdFx0XHRcdFx0XHRcdG1hdGVyaWFsID0gbWF0ZXJpYWxMaW5lO1xuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGlzUG9pbnRzICYmIG1hdGVyaWFsICYmICEgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFBvaW50c01hdGVyaWFsICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR2YXIgbWF0ZXJpYWxQb2ludHMgPSBuZXcgUG9pbnRzTWF0ZXJpYWwoIHsgc2l6ZTogMTAsIHNpemVBdHRlbnVhdGlvbjogZmFsc2UgfSApO1xuXHRcdFx0XHRcdFx0XHRcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIG1hdGVyaWFsUG9pbnRzLCBtYXRlcmlhbCApO1xuXHRcdFx0XHRcdFx0XHRcdG1hdGVyaWFsUG9pbnRzLmNvbG9yLmNvcHkoIG1hdGVyaWFsLmNvbG9yICk7XG5cdFx0XHRcdFx0XHRcdFx0bWF0ZXJpYWxQb2ludHMubWFwID0gbWF0ZXJpYWwubWFwO1xuXHRcdFx0XHRcdFx0XHRcdG1hdGVyaWFsID0gbWF0ZXJpYWxQb2ludHM7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICggbWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGlzTGluZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCk7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggaXNQb2ludHMgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRtYXRlcmlhbCA9IG5ldyBQb2ludHNNYXRlcmlhbCggeyBzaXplOiAxLCBzaXplQXR0ZW51YXRpb246IGZhbHNlIH0gKTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwgPSBuZXcgTWVzaFBob25nTWF0ZXJpYWwoKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwubmFtZSA9IHNvdXJjZU1hdGVyaWFsLm5hbWU7XG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsLmZsYXRTaGFkaW5nID0gc291cmNlTWF0ZXJpYWwuc21vb3RoID8gZmFsc2UgOiB0cnVlO1xuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSBoYXNWZXJ0ZXhDb2xvcnM7XG5cblx0XHRcdFx0XHRcdFx0c3RhdGUubWF0ZXJpYWxzWyBtYXRlcmlhbEhhc2ggXSA9IG1hdGVyaWFsO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGNyZWF0ZWRNYXRlcmlhbHMucHVzaCggbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIENyZWF0ZSBtZXNoXG5cblx0XHRcdFx0XHR2YXIgbWVzaDtcblxuXHRcdFx0XHRcdGlmICggY3JlYXRlZE1hdGVyaWFscy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgbWkgPSAwLCBtaUxlbiA9IG1hdGVyaWFscy5sZW5ndGg7IG1pIDwgbWlMZW47IG1pICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBzb3VyY2VNYXRlcmlhbCA9IG1hdGVyaWFsc1sgbWkgXTtcblx0XHRcdFx0XHRcdFx0YnVmZmVyZ2VvbWV0cnkuYWRkR3JvdXAoIHNvdXJjZU1hdGVyaWFsLmdyb3VwU3RhcnQsIHNvdXJjZU1hdGVyaWFsLmdyb3VwQ291bnQsIG1pICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCBpc0xpbmUgKSB7XG5cblx0XHRcdFx0XHRcdFx0bWVzaCA9IG5ldyBMaW5lU2VnbWVudHMoIGJ1ZmZlcmdlb21ldHJ5LCBjcmVhdGVkTWF0ZXJpYWxzICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGlzUG9pbnRzICkge1xuXG5cdFx0XHRcdFx0XHRcdG1lc2ggPSBuZXcgUG9pbnRzKCBidWZmZXJnZW9tZXRyeSwgY3JlYXRlZE1hdGVyaWFscyApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdG1lc2ggPSBuZXcgTWVzaCggYnVmZmVyZ2VvbWV0cnksIGNyZWF0ZWRNYXRlcmlhbHMgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBpc0xpbmUgKSB7XG5cblx0XHRcdFx0XHRcdFx0bWVzaCA9IG5ldyBMaW5lU2VnbWVudHMoIGJ1ZmZlcmdlb21ldHJ5LCBjcmVhdGVkTWF0ZXJpYWxzWyAwIF0gKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggaXNQb2ludHMgKSB7XG5cblx0XHRcdFx0XHRcdFx0bWVzaCA9IG5ldyBQb2ludHMoIGJ1ZmZlcmdlb21ldHJ5LCBjcmVhdGVkTWF0ZXJpYWxzWyAwIF0gKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRtZXNoID0gbmV3IE1lc2goIGJ1ZmZlcmdlb21ldHJ5LCBjcmVhdGVkTWF0ZXJpYWxzWyAwIF0gKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bWVzaC5uYW1lID0gb2JqZWN0Lm5hbWU7XG5cblx0XHRcdFx0XHRjb250YWluZXIuYWRkKCBtZXNoICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgdGhlIGRlZmF1bHQgcGFyc2VyIHN0YXRlIG9iamVjdCB3aXRoIG5vIGdlb21ldHJ5IGRhdGEsIGludGVycHJldCBkYXRhIGFzIHBvaW50IGNsb3VkXG5cblx0XHRcdFx0aWYgKCBzdGF0ZS52ZXJ0aWNlcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0dmFyIG1hdGVyaWFsID0gbmV3IFBvaW50c01hdGVyaWFsKCB7IHNpemU6IDEsIHNpemVBdHRlbnVhdGlvbjogZmFsc2UgfSApO1xuXG5cdFx0XHRcdFx0dmFyIGJ1ZmZlcmdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRcdFx0XHRidWZmZXJnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBzdGF0ZS52ZXJ0aWNlcywgMyApICk7XG5cblx0XHRcdFx0XHRpZiAoIHN0YXRlLmNvbG9ycy5sZW5ndGggPiAwICYmIHN0YXRlLmNvbG9yc1sgMCBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdGJ1ZmZlcmdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHN0YXRlLmNvbG9ycywgMyApICk7XG5cdFx0XHRcdFx0XHRtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0cnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHBvaW50cyA9IG5ldyBQb2ludHMoIGJ1ZmZlcmdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXHRcdFx0XHRcdGNvbnRhaW5lci5hZGQoIHBvaW50cyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY29udGFpbmVyO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHRyZXR1cm4gT0JKTG9hZGVyO1xuXG59ICkoKTtcblxuLyoqXG4gKiBMb2FkcyBhIFdhdmVmcm9udCAubXRsIGZpbGUgc3BlY2lmeWluZyBtYXRlcmlhbHNcbiAqL1xuXG52YXIgTVRMTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xuXG5cdExvYWRlciQxLmNhbGwoIHRoaXMsIG1hbmFnZXIgKTtcblxufTtcblxuTVRMTG9hZGVyLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExvYWRlciQxLnByb3RvdHlwZSApLCB7XG5cblx0Y29uc3RydWN0b3I6IE1UTExvYWRlcixcblxuXHQvKipcblx0ICogTG9hZHMgYW5kIHBhcnNlcyBhIE1UTCBhc3NldCBmcm9tIGEgVVJMLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gVVJMIHRvIHRoZSBNVEwgZmlsZS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW29uTG9hZF0gLSBDYWxsYmFjayBpbnZva2VkIHdpdGggdGhlIGxvYWRlZCBvYmplY3QuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblByb2dyZXNzXSAtIENhbGxiYWNrIGZvciBkb3dubG9hZCBwcm9ncmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIC0gQ2FsbGJhY2sgZm9yIGRvd25sb2FkIGVycm9ycy5cblx0ICpcblx0ICogQHNlZSBzZXRQYXRoIHNldFJlc291cmNlUGF0aFxuXHQgKlxuXHQgKiBAbm90ZSBJbiBvcmRlciBmb3IgcmVsYXRpdmUgdGV4dHVyZSByZWZlcmVuY2VzIHRvIHJlc29sdmUgY29ycmVjdGx5XG5cdCAqIHlvdSBtdXN0IGNhbGwgc2V0UmVzb3VyY2VQYXRoKCkgZXhwbGljaXRseSBwcmlvciB0byBsb2FkLlxuXHQgKi9cblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHR2YXIgcGF0aCA9ICggdGhpcy5wYXRoID09PSAnJyApID8gTG9hZGVyVXRpbHMuZXh0cmFjdFVybEJhc2UoIHVybCApIDogdGhpcy5wYXRoO1xuXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XG5cdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHRoaXMucmVxdWVzdEhlYWRlciApO1xuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHRoaXMud2l0aENyZWRlbnRpYWxzICk7XG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG5cdFx0XHR0cnkge1xuXG5cdFx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIHRleHQsIHBhdGggKSApO1xuXG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRpZiAoIG9uRXJyb3IgKSB7XG5cblx0XHRcdFx0XHRvbkVycm9yKCBlICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXG5cdFx0XHR9XG5cblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0fSxcblxuXHRzZXRNYXRlcmlhbE9wdGlvbnM6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLm1hdGVyaWFsT3B0aW9ucyA9IHZhbHVlO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0LyoqXG5cdCAqIFBhcnNlcyBhIE1UTCBmaWxlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCAtIENvbnRlbnQgb2YgTVRMIGZpbGVcblx0ICogQHJldHVybiB7TVRMTG9hZGVyLk1hdGVyaWFsQ3JlYXRvcn1cblx0ICpcblx0ICogQHNlZSBzZXRQYXRoIHNldFJlc291cmNlUGF0aFxuXHQgKlxuXHQgKiBAbm90ZSBJbiBvcmRlciBmb3IgcmVsYXRpdmUgdGV4dHVyZSByZWZlcmVuY2VzIHRvIHJlc29sdmUgY29ycmVjdGx5XG5cdCAqIHlvdSBtdXN0IGNhbGwgc2V0UmVzb3VyY2VQYXRoKCkgZXhwbGljaXRseSBwcmlvciB0byBwYXJzZS5cblx0ICovXG5cdHBhcnNlOiBmdW5jdGlvbiAoIHRleHQsIHBhdGggKSB7XG5cblx0XHR2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KCAnXFxuJyApO1xuXHRcdHZhciBpbmZvID0ge307XG5cdFx0dmFyIGRlbGltaXRlcl9wYXR0ZXJuID0gL1xccysvO1xuXHRcdHZhciBtYXRlcmlhbHNJbmZvID0ge307XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBsaW5lID0gbGluZXNbIGkgXTtcblx0XHRcdGxpbmUgPSBsaW5lLnRyaW0oKTtcblxuXHRcdFx0aWYgKCBsaW5lLmxlbmd0aCA9PT0gMCB8fCBsaW5lLmNoYXJBdCggMCApID09PSAnIycgKSB7XG5cblx0XHRcdFx0Ly8gQmxhbmsgbGluZSBvciBjb21tZW50IGlnbm9yZVxuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcG9zID0gbGluZS5pbmRleE9mKCAnICcgKTtcblxuXHRcdFx0dmFyIGtleSA9ICggcG9zID49IDAgKSA/IGxpbmUuc3Vic3RyaW5nKCAwLCBwb3MgKSA6IGxpbmU7XG5cdFx0XHRrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0dmFyIHZhbHVlID0gKCBwb3MgPj0gMCApID8gbGluZS5zdWJzdHJpbmcoIHBvcyArIDEgKSA6ICcnO1xuXHRcdFx0dmFsdWUgPSB2YWx1ZS50cmltKCk7XG5cblx0XHRcdGlmICgga2V5ID09PSAnbmV3bXRsJyApIHtcblxuXHRcdFx0XHQvLyBOZXcgbWF0ZXJpYWxcblxuXHRcdFx0XHRpbmZvID0geyBuYW1lOiB2YWx1ZSB9O1xuXHRcdFx0XHRtYXRlcmlhbHNJbmZvWyB2YWx1ZSBdID0gaW5mbztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoIGtleSA9PT0gJ2thJyB8fCBrZXkgPT09ICdrZCcgfHwga2V5ID09PSAna3MnIHx8IGtleSA9PT0gJ2tlJyApIHtcblxuXHRcdFx0XHRcdHZhciBzcyA9IHZhbHVlLnNwbGl0KCBkZWxpbWl0ZXJfcGF0dGVybiwgMyApO1xuXHRcdFx0XHRcdGluZm9bIGtleSBdID0gWyBwYXJzZUZsb2F0KCBzc1sgMCBdICksIHBhcnNlRmxvYXQoIHNzWyAxIF0gKSwgcGFyc2VGbG9hdCggc3NbIDIgXSApIF07XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGluZm9bIGtleSBdID0gdmFsdWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR2YXIgbWF0ZXJpYWxDcmVhdG9yID0gbmV3IE1UTExvYWRlci5NYXRlcmlhbENyZWF0b3IoIHRoaXMucmVzb3VyY2VQYXRoIHx8IHBhdGgsIHRoaXMubWF0ZXJpYWxPcHRpb25zICk7XG5cdFx0bWF0ZXJpYWxDcmVhdG9yLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cdFx0bWF0ZXJpYWxDcmVhdG9yLnNldE1hbmFnZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdG1hdGVyaWFsQ3JlYXRvci5zZXRNYXRlcmlhbHMoIG1hdGVyaWFsc0luZm8gKTtcblx0XHRyZXR1cm4gbWF0ZXJpYWxDcmVhdG9yO1xuXG5cdH1cblxufSApO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBNVExMb2FkZXIuTWF0ZXJpYWxDcmVhdG9yXG4gKiBAcGFyYW0gYmFzZVVybCAtIFVybCByZWxhdGl2ZSB0byB3aGljaCB0ZXh0dXJlcyBhcmUgbG9hZGVkXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFNldCBvZiBvcHRpb25zIG9uIGhvdyB0byBjb25zdHJ1Y3QgdGhlIG1hdGVyaWFsc1xuICogICAgICAgICAgICAgICAgICBzaWRlOiBXaGljaCBzaWRlIHRvIGFwcGx5IHRoZSBtYXRlcmlhbFxuICogICAgICAgICAgICAgICAgICAgICAgICBGcm9udFNpZGUgKGRlZmF1bHQpLCBUSFJFRS5CYWNrU2lkZSwgVEhSRUUuRG91YmxlU2lkZVxuICogICAgICAgICAgICAgICAgICB3cmFwOiBXaGF0IHR5cGUgb2Ygd3JhcHBpbmcgdG8gYXBwbHkgZm9yIHRleHR1cmVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIFJlcGVhdFdyYXBwaW5nIChkZWZhdWx0KSwgVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZywgVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZ1xuICogICAgICAgICAgICAgICAgICBub3JtYWxpemVSR0I6IFJHQnMgbmVlZCB0byBiZSBub3JtYWxpemVkIHRvIDAtMSBmcm9tIDAtMjU1XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdDogZmFsc2UsIGFzc3VtZWQgdG8gYmUgYWxyZWFkeSBub3JtYWxpemVkXG4gKiAgICAgICAgICAgICAgICAgIGlnbm9yZVplcm9SR0JzOiBJZ25vcmUgdmFsdWVzIG9mIFJHQnMgKEthLEtkLEtzKSB0aGF0IGFyZSBhbGwgMCdzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0OiBmYWxzZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuTVRMTG9hZGVyLk1hdGVyaWFsQ3JlYXRvciA9IGZ1bmN0aW9uICggYmFzZVVybCwgb3B0aW9ucyApIHtcblxuXHR0aGlzLmJhc2VVcmwgPSBiYXNlVXJsIHx8ICcnO1xuXHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHR0aGlzLm1hdGVyaWFsc0luZm8gPSB7fTtcblx0dGhpcy5tYXRlcmlhbHMgPSB7fTtcblx0dGhpcy5tYXRlcmlhbHNBcnJheSA9IFtdO1xuXHR0aGlzLm5hbWVMb29rdXAgPSB7fTtcblxuXHR0aGlzLnNpZGUgPSAoIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuc2lkZSApID8gdGhpcy5vcHRpb25zLnNpZGUgOiBGcm9udFNpZGU7XG5cdHRoaXMud3JhcCA9ICggdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy53cmFwICkgPyB0aGlzLm9wdGlvbnMud3JhcCA6IFJlcGVhdFdyYXBwaW5nO1xuXG59O1xuXG5NVExMb2FkZXIuTWF0ZXJpYWxDcmVhdG9yLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogTVRMTG9hZGVyLk1hdGVyaWFsQ3JlYXRvcixcblxuXHRjcm9zc09yaWdpbjogJ2Fub255bW91cycsXG5cblx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRNYW5hZ2VyOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5tYW5hZ2VyID0gdmFsdWU7XG5cblx0fSxcblxuXHRzZXRNYXRlcmlhbHM6IGZ1bmN0aW9uICggbWF0ZXJpYWxzSW5mbyApIHtcblxuXHRcdHRoaXMubWF0ZXJpYWxzSW5mbyA9IHRoaXMuY29udmVydCggbWF0ZXJpYWxzSW5mbyApO1xuXHRcdHRoaXMubWF0ZXJpYWxzID0ge307XG5cdFx0dGhpcy5tYXRlcmlhbHNBcnJheSA9IFtdO1xuXHRcdHRoaXMubmFtZUxvb2t1cCA9IHt9O1xuXG5cdH0sXG5cblx0Y29udmVydDogZnVuY3Rpb24gKCBtYXRlcmlhbHNJbmZvICkge1xuXG5cdFx0aWYgKCAhIHRoaXMub3B0aW9ucyApIHJldHVybiBtYXRlcmlhbHNJbmZvO1xuXG5cdFx0dmFyIGNvbnZlcnRlZCA9IHt9O1xuXG5cdFx0Zm9yICggdmFyIG1uIGluIG1hdGVyaWFsc0luZm8gKSB7XG5cblx0XHRcdC8vIENvbnZlcnQgbWF0ZXJpYWxzIGluZm8gaW50byBub3JtYWxpemVkIGZvcm0gYmFzZWQgb24gb3B0aW9uc1xuXG5cdFx0XHR2YXIgbWF0ID0gbWF0ZXJpYWxzSW5mb1sgbW4gXTtcblxuXHRcdFx0dmFyIGNvdm1hdCA9IHt9O1xuXG5cdFx0XHRjb252ZXJ0ZWRbIG1uIF0gPSBjb3ZtYXQ7XG5cblx0XHRcdGZvciAoIHZhciBwcm9wIGluIG1hdCApIHtcblxuXHRcdFx0XHR2YXIgc2F2ZSA9IHRydWU7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IG1hdFsgcHJvcCBdO1xuXHRcdFx0XHR2YXIgbHByb3AgPSBwcm9wLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdFx0c3dpdGNoICggbHByb3AgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdrZCc6XG5cdFx0XHRcdFx0Y2FzZSAna2EnOlxuXHRcdFx0XHRcdGNhc2UgJ2tzJzpcblxuXHRcdFx0XHRcdFx0Ly8gRGlmZnVzZSBjb2xvciAoY29sb3IgdW5kZXIgd2hpdGUgbGlnaHQpIHVzaW5nIFJHQiB2YWx1ZXNcblxuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm5vcm1hbGl6ZVJHQiApIHtcblxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IFsgdmFsdWVbIDAgXSAvIDI1NSwgdmFsdWVbIDEgXSAvIDI1NSwgdmFsdWVbIDIgXSAvIDI1NSBdO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICggdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5pZ25vcmVaZXJvUkdCcyApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHZhbHVlWyAwIF0gPT09IDAgJiYgdmFsdWVbIDEgXSA9PT0gMCAmJiB2YWx1ZVsgMiBdID09PSAwICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gaWdub3JlXG5cblx0XHRcdFx0XHRcdFx0XHRzYXZlID0gZmFsc2U7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNhdmUgKSB7XG5cblx0XHRcdFx0XHRjb3ZtYXRbIGxwcm9wIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBjb252ZXJ0ZWQ7XG5cblx0fSxcblxuXHRwcmVsb2FkOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRmb3IgKCB2YXIgbW4gaW4gdGhpcy5tYXRlcmlhbHNJbmZvICkge1xuXG5cdFx0XHR0aGlzLmNyZWF0ZSggbW4gKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbiAoIG1hdGVyaWFsTmFtZSApIHtcblxuXHRcdHJldHVybiB0aGlzLm5hbWVMb29rdXBbIG1hdGVyaWFsTmFtZSBdO1xuXG5cdH0sXG5cblx0Z2V0QXNBcnJheTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGluZGV4ID0gMDtcblxuXHRcdGZvciAoIHZhciBtbiBpbiB0aGlzLm1hdGVyaWFsc0luZm8gKSB7XG5cblx0XHRcdHRoaXMubWF0ZXJpYWxzQXJyYXlbIGluZGV4IF0gPSB0aGlzLmNyZWF0ZSggbW4gKTtcblx0XHRcdHRoaXMubmFtZUxvb2t1cFsgbW4gXSA9IGluZGV4O1xuXHRcdFx0aW5kZXggKys7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5tYXRlcmlhbHNBcnJheTtcblxuXHR9LFxuXG5cdGNyZWF0ZTogZnVuY3Rpb24gKCBtYXRlcmlhbE5hbWUgKSB7XG5cblx0XHRpZiAoIHRoaXMubWF0ZXJpYWxzWyBtYXRlcmlhbE5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLmNyZWF0ZU1hdGVyaWFsXyggbWF0ZXJpYWxOYW1lICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5tYXRlcmlhbHNbIG1hdGVyaWFsTmFtZSBdO1xuXG5cdH0sXG5cblx0Y3JlYXRlTWF0ZXJpYWxfOiBmdW5jdGlvbiAoIG1hdGVyaWFsTmFtZSApIHtcblxuXHRcdC8vIENyZWF0ZSBtYXRlcmlhbFxuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblx0XHR2YXIgbWF0ID0gdGhpcy5tYXRlcmlhbHNJbmZvWyBtYXRlcmlhbE5hbWUgXTtcblx0XHR2YXIgcGFyYW1zID0ge1xuXG5cdFx0XHRuYW1lOiBtYXRlcmlhbE5hbWUsXG5cdFx0XHRzaWRlOiB0aGlzLnNpZGVcblxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiByZXNvbHZlVVJMKCBiYXNlVXJsLCB1cmwgKSB7XG5cblx0XHRcdGlmICggdHlwZW9mIHVybCAhPT0gJ3N0cmluZycgfHwgdXJsID09PSAnJyApXG5cdFx0XHRcdHJldHVybiAnJztcblxuXHRcdFx0Ly8gQWJzb2x1dGUgVVJMXG5cdFx0XHRpZiAoIC9eaHR0cHM/OlxcL1xcLy9pLnRlc3QoIHVybCApICkgcmV0dXJuIHVybDtcblxuXHRcdFx0cmV0dXJuIGJhc2VVcmwgKyB1cmw7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXRNYXBGb3JUeXBlKCBtYXBUeXBlLCB2YWx1ZSApIHtcblxuXHRcdFx0aWYgKCBwYXJhbXNbIG1hcFR5cGUgXSApIHJldHVybjsgLy8gS2VlcCB0aGUgZmlyc3QgZW5jb3VudGVyZWQgdGV4dHVyZVxuXG5cdFx0XHR2YXIgdGV4UGFyYW1zID0gc2NvcGUuZ2V0VGV4dHVyZVBhcmFtcyggdmFsdWUsIHBhcmFtcyApO1xuXHRcdFx0dmFyIG1hcCA9IHNjb3BlLmxvYWRUZXh0dXJlKCByZXNvbHZlVVJMKCBzY29wZS5iYXNlVXJsLCB0ZXhQYXJhbXMudXJsICkgKTtcblxuXHRcdFx0bWFwLnJlcGVhdC5jb3B5KCB0ZXhQYXJhbXMuc2NhbGUgKTtcblx0XHRcdG1hcC5vZmZzZXQuY29weSggdGV4UGFyYW1zLm9mZnNldCApO1xuXG5cdFx0XHRtYXAud3JhcFMgPSBzY29wZS53cmFwO1xuXHRcdFx0bWFwLndyYXBUID0gc2NvcGUud3JhcDtcblxuXHRcdFx0cGFyYW1zWyBtYXBUeXBlIF0gPSBtYXA7XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgcHJvcCBpbiBtYXQgKSB7XG5cblx0XHRcdHZhciB2YWx1ZSA9IG1hdFsgcHJvcCBdO1xuXHRcdFx0dmFyIG47XG5cblx0XHRcdGlmICggdmFsdWUgPT09ICcnICkgY29udGludWU7XG5cblx0XHRcdHN3aXRjaCAoIHByb3AudG9Mb3dlckNhc2UoKSApIHtcblxuXHRcdFx0XHQvLyBOcyBpcyBtYXRlcmlhbCBzcGVjdWxhciBleHBvbmVudFxuXG5cdFx0XHRcdGNhc2UgJ2tkJzpcblxuXHRcdFx0XHRcdC8vIERpZmZ1c2UgY29sb3IgKGNvbG9yIHVuZGVyIHdoaXRlIGxpZ2h0KSB1c2luZyBSR0IgdmFsdWVzXG5cblx0XHRcdFx0XHRwYXJhbXMuY29sb3IgPSBuZXcgQ29sb3IoKS5mcm9tQXJyYXkoIHZhbHVlICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdrcyc6XG5cblx0XHRcdFx0XHQvLyBTcGVjdWxhciBjb2xvciAoY29sb3Igd2hlbiBsaWdodCBpcyByZWZsZWN0ZWQgZnJvbSBzaGlueSBzdXJmYWNlKSB1c2luZyBSR0IgdmFsdWVzXG5cdFx0XHRcdFx0cGFyYW1zLnNwZWN1bGFyID0gbmV3IENvbG9yKCkuZnJvbUFycmF5KCB2YWx1ZSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAna2UnOlxuXG5cdFx0XHRcdFx0Ly8gRW1pc3NpdmUgdXNpbmcgUkdCIHZhbHVlc1xuXHRcdFx0XHRcdHBhcmFtcy5lbWlzc2l2ZSA9IG5ldyBDb2xvcigpLmZyb21BcnJheSggdmFsdWUgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ21hcF9rZCc6XG5cblx0XHRcdFx0XHQvLyBEaWZmdXNlIHRleHR1cmUgbWFwXG5cblx0XHRcdFx0XHRzZXRNYXBGb3JUeXBlKCAnbWFwJywgdmFsdWUgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ21hcF9rcyc6XG5cblx0XHRcdFx0XHQvLyBTcGVjdWxhciBtYXBcblxuXHRcdFx0XHRcdHNldE1hcEZvclR5cGUoICdzcGVjdWxhck1hcCcsIHZhbHVlICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdtYXBfa2UnOlxuXG5cdFx0XHRcdFx0Ly8gRW1pc3NpdmUgbWFwXG5cblx0XHRcdFx0XHRzZXRNYXBGb3JUeXBlKCAnZW1pc3NpdmVNYXAnLCB2YWx1ZSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbm9ybSc6XG5cblx0XHRcdFx0XHRzZXRNYXBGb3JUeXBlKCAnbm9ybWFsTWFwJywgdmFsdWUgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ21hcF9idW1wJzpcblx0XHRcdFx0Y2FzZSAnYnVtcCc6XG5cblx0XHRcdFx0XHQvLyBCdW1wIHRleHR1cmUgbWFwXG5cblx0XHRcdFx0XHRzZXRNYXBGb3JUeXBlKCAnYnVtcE1hcCcsIHZhbHVlICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdtYXBfZCc6XG5cblx0XHRcdFx0XHQvLyBBbHBoYSBtYXBcblxuXHRcdFx0XHRcdHNldE1hcEZvclR5cGUoICdhbHBoYU1hcCcsIHZhbHVlICk7XG5cdFx0XHRcdFx0cGFyYW1zLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ25zJzpcblxuXHRcdFx0XHRcdC8vIFRoZSBzcGVjdWxhciBleHBvbmVudCAoZGVmaW5lcyB0aGUgZm9jdXMgb2YgdGhlIHNwZWN1bGFyIGhpZ2hsaWdodClcblx0XHRcdFx0XHQvLyBBIGhpZ2ggZXhwb25lbnQgcmVzdWx0cyBpbiBhIHRpZ2h0LCBjb25jZW50cmF0ZWQgaGlnaGxpZ2h0LiBOcyB2YWx1ZXMgbm9ybWFsbHkgcmFuZ2UgZnJvbSAwIHRvIDEwMDAuXG5cblx0XHRcdFx0XHRwYXJhbXMuc2hpbmluZXNzID0gcGFyc2VGbG9hdCggdmFsdWUgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2QnOlxuXHRcdFx0XHRcdG4gPSBwYXJzZUZsb2F0KCB2YWx1ZSApO1xuXG5cdFx0XHRcdFx0aWYgKCBuIDwgMSApIHtcblxuXHRcdFx0XHRcdFx0cGFyYW1zLm9wYWNpdHkgPSBuO1xuXHRcdFx0XHRcdFx0cGFyYW1zLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3RyJzpcblx0XHRcdFx0XHRuID0gcGFyc2VGbG9hdCggdmFsdWUgKTtcblxuXHRcdFx0XHRcdGlmICggdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5pbnZlcnRUclByb3BlcnR5ICkgbiA9IDEgLSBuO1xuXG5cdFx0XHRcdFx0aWYgKCBuID4gMCApIHtcblxuXHRcdFx0XHRcdFx0cGFyYW1zLm9wYWNpdHkgPSAxIC0gbjtcblx0XHRcdFx0XHRcdHBhcmFtcy50cmFuc3BhcmVudCA9IHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5tYXRlcmlhbHNbIG1hdGVyaWFsTmFtZSBdID0gbmV3IE1lc2hQaG9uZ01hdGVyaWFsKCBwYXJhbXMgKTtcblx0XHRyZXR1cm4gdGhpcy5tYXRlcmlhbHNbIG1hdGVyaWFsTmFtZSBdO1xuXG5cdH0sXG5cblx0Z2V0VGV4dHVyZVBhcmFtczogZnVuY3Rpb24gKCB2YWx1ZSwgbWF0UGFyYW1zICkge1xuXG5cdFx0dmFyIHRleFBhcmFtcyA9IHtcblxuXHRcdFx0c2NhbGU6IG5ldyBWZWN0b3IyKCAxLCAxICksXG5cdFx0XHRvZmZzZXQ6IG5ldyBWZWN0b3IyKCAwLCAwIClcblxuXHRcdCB9O1xuXG5cdFx0dmFyIGl0ZW1zID0gdmFsdWUuc3BsaXQoIC9cXHMrLyApO1xuXHRcdHZhciBwb3M7XG5cblx0XHRwb3MgPSBpdGVtcy5pbmRleE9mKCAnLWJtJyApO1xuXG5cdFx0aWYgKCBwb3MgPj0gMCApIHtcblxuXHRcdFx0bWF0UGFyYW1zLmJ1bXBTY2FsZSA9IHBhcnNlRmxvYXQoIGl0ZW1zWyBwb3MgKyAxIF0gKTtcblx0XHRcdGl0ZW1zLnNwbGljZSggcG9zLCAyICk7XG5cblx0XHR9XG5cblx0XHRwb3MgPSBpdGVtcy5pbmRleE9mKCAnLXMnICk7XG5cblx0XHRpZiAoIHBvcyA+PSAwICkge1xuXG5cdFx0XHR0ZXhQYXJhbXMuc2NhbGUuc2V0KCBwYXJzZUZsb2F0KCBpdGVtc1sgcG9zICsgMSBdICksIHBhcnNlRmxvYXQoIGl0ZW1zWyBwb3MgKyAyIF0gKSApO1xuXHRcdFx0aXRlbXMuc3BsaWNlKCBwb3MsIDQgKTsgLy8gd2UgZXhwZWN0IDMgcGFyYW1ldGVycyBoZXJlIVxuXG5cdFx0fVxuXG5cdFx0cG9zID0gaXRlbXMuaW5kZXhPZiggJy1vJyApO1xuXG5cdFx0aWYgKCBwb3MgPj0gMCApIHtcblxuXHRcdFx0dGV4UGFyYW1zLm9mZnNldC5zZXQoIHBhcnNlRmxvYXQoIGl0ZW1zWyBwb3MgKyAxIF0gKSwgcGFyc2VGbG9hdCggaXRlbXNbIHBvcyArIDIgXSApICk7XG5cdFx0XHRpdGVtcy5zcGxpY2UoIHBvcywgNCApOyAvLyB3ZSBleHBlY3QgMyBwYXJhbWV0ZXJzIGhlcmUhXG5cblx0XHR9XG5cblx0XHR0ZXhQYXJhbXMudXJsID0gaXRlbXMuam9pbiggJyAnICkudHJpbSgpO1xuXHRcdHJldHVybiB0ZXhQYXJhbXM7XG5cblx0fSxcblxuXHRsb2FkVGV4dHVyZTogZnVuY3Rpb24gKCB1cmwsIG1hcHBpbmcsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdHZhciB0ZXh0dXJlO1xuXHRcdHZhciBtYW5hZ2VyID0gKCB0aGlzLm1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gdGhpcy5tYW5hZ2VyIDogRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXHRcdHZhciBsb2FkZXIgPSBtYW5hZ2VyLmdldEhhbmRsZXIoIHVybCApO1xuXG5cdFx0aWYgKCBsb2FkZXIgPT09IG51bGwgKSB7XG5cblx0XHRcdGxvYWRlciA9IG5ldyBUZXh0dXJlTG9hZGVyKCBtYW5hZ2VyICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGxvYWRlci5zZXRDcm9zc09yaWdpbiApIGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXHRcdHRleHR1cmUgPSBsb2FkZXIubG9hZCggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHRcdGlmICggbWFwcGluZyAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5tYXBwaW5nID0gbWFwcGluZztcblxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdH1cblxufTtcblxuLyohIGNoZXZyb3RhaW4gLSB2NC42LjAgKi9cbiFmdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPWUoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFwiY2hldnJvdGFpblwiLFtdLGUpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMuY2hldnJvdGFpbj1lKCk6dC5jaGV2cm90YWluPWUoKTt9KFwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6dW5kZWZpbmVkLGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXt9O2Z1bmN0aW9uIG4ocil7aWYoZVtyXSlyZXR1cm4gZVtyXS5leHBvcnRzO3ZhciBpPWVbcl09e2k6cixsOiExLGV4cG9ydHM6e319O3JldHVybiB0W3JdLmNhbGwoaS5leHBvcnRzLGksaS5leHBvcnRzLG4pLGkubD0hMCxpLmV4cG9ydHN9cmV0dXJuIG4ubT10LG4uYz1lLG4uZD1mdW5jdGlvbih0LGUscil7bi5vKHQsZSl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse2VudW1lcmFibGU6ITAsZ2V0OnJ9KTt9LG4ucj1mdW5jdGlvbih0KXtcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO30sbi50PWZ1bmN0aW9uKHQsZSl7aWYoMSZlJiYodD1uKHQpKSw4JmUpcmV0dXJuIHQ7aWYoNCZlJiZcIm9iamVjdFwiPT10eXBlb2YgdCYmdCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciByPU9iamVjdC5jcmVhdGUobnVsbCk7aWYobi5yKHIpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOnR9KSwyJmUmJlwic3RyaW5nXCIhPXR5cGVvZiB0KWZvcih2YXIgaSBpbiB0KW4uZChyLGksZnVuY3Rpb24oZSl7cmV0dXJuIHRbZV19LmJpbmQobnVsbCxpKSk7cmV0dXJuIHJ9LG4ubj1mdW5jdGlvbih0KXt2YXIgZT10JiZ0Ll9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gdC5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiB0fTtyZXR1cm4gbi5kKGUsXCJhXCIsZSksZX0sbi5vPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGUpfSxuLnA9XCJcIixuKG4ucz0xOCl9KFtmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4gdCYmMD09PXQubGVuZ3RofWZ1bmN0aW9uIGkodCl7cmV0dXJuIG51bGw9PXQ/W106T2JqZWN0LmtleXModCl9ZnVuY3Rpb24gbyh0KXtmb3IodmFyIGU9W10sbj1PYmplY3Qua2V5cyh0KSxyPTA7cjxuLmxlbmd0aDtyKyspZS5wdXNoKHRbbltyXV0pO3JldHVybiBlfWZ1bmN0aW9uIGEodCxlKXtmb3IodmFyIG49W10scj1pKHQpLG89MDtvPHIubGVuZ3RoO28rKyl7dmFyIGE9cltvXTtuLnB1c2goZS5jYWxsKG51bGwsdFthXSxhKSk7fXJldHVybiBufWZ1bmN0aW9uIHModCxlKXtmb3IodmFyIG49W10scj0wO3I8dC5sZW5ndGg7cisrKW4ucHVzaChlLmNhbGwobnVsbCx0W3JdLHIpKTtyZXR1cm4gbn1mdW5jdGlvbiB1KHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07QXJyYXkuaXNBcnJheShyKT9lPWUuY29uY2F0KHUocikpOmUucHVzaChyKTt9cmV0dXJuIGV9ZnVuY3Rpb24gYyh0KXtyZXR1cm4gcih0KT92b2lkIDA6dFswXX1mdW5jdGlvbiBwKHQpe3ZhciBlPXQmJnQubGVuZ3RoO3JldHVybiBlP3RbZS0xXTp2b2lkIDB9ZnVuY3Rpb24gbCh0LGUpe2lmKEFycmF5LmlzQXJyYXkodCkpZm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspZS5jYWxsKG51bGwsdFtuXSxuKTtlbHNlIHtpZighQyh0KSl0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO3ZhciByPWkodCk7Zm9yKG49MDtuPHIubGVuZ3RoO24rKyl7dmFyIG89cltuXSxhPXRbb107ZS5jYWxsKG51bGwsYSxvKTt9fX1mdW5jdGlvbiBoKHQpe3JldHVybiBcInN0cmluZ1wiPT10eXBlb2YgdH1mdW5jdGlvbiBmKHQpe3JldHVybiB2b2lkIDA9PT10fWZ1bmN0aW9uIGQodCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBGdW5jdGlvbn1mdW5jdGlvbiBFKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPTEpLHQuc2xpY2UoZSx0Lmxlbmd0aCl9ZnVuY3Rpb24gbSh0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0xKSx0LnNsaWNlKDAsdC5sZW5ndGgtZSl9ZnVuY3Rpb24geSh0LGUpe3ZhciBuPVtdO2lmKEFycmF5LmlzQXJyYXkodCkpZm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBpPXRbcl07ZS5jYWxsKG51bGwsaSkmJm4ucHVzaChpKTt9cmV0dXJuIG59ZnVuY3Rpb24gVCh0LGUpe3JldHVybiB5KHQsZnVuY3Rpb24odCl7cmV0dXJuICFlKHQpfSl9ZnVuY3Rpb24gdih0LGUpe2Zvcih2YXIgbj1PYmplY3Qua2V5cyh0KSxyPXt9LGk9MDtpPG4ubGVuZ3RoO2krKyl7dmFyIG89bltpXSxhPXRbb107ZShhKSYmKHJbb109YSk7fXJldHVybiByfWZ1bmN0aW9uIGcodCxlKXtyZXR1cm4gISFDKHQpJiZ0Lmhhc093blByb3BlcnR5KGUpfWZ1bmN0aW9uIF8odCxlKXtyZXR1cm4gdm9pZCAwIT09Tih0LGZ1bmN0aW9uKHQpe3JldHVybiB0PT09ZX0pfWZ1bmN0aW9uIFIodCl7Zm9yKHZhciBlPVtdLG49MDtuPHQubGVuZ3RoO24rKyllLnB1c2godFtuXSk7cmV0dXJuIGV9ZnVuY3Rpb24gQSh0KXt2YXIgZT17fTtmb3IodmFyIG4gaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmKGVbbl09dFtuXSk7cmV0dXJuIGV9ZnVuY3Rpb24gTih0LGUpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO2lmKGUuY2FsbChudWxsLHIpKXJldHVybiByfX1mdW5jdGlvbiBPKHQsZSl7Zm9yKHZhciBuPVtdLHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIGk9dFtyXTtlLmNhbGwobnVsbCxpKSYmbi5wdXNoKGkpO31yZXR1cm4gbn1mdW5jdGlvbiBTKHQsZSxuKXtmb3IodmFyIHI9QXJyYXkuaXNBcnJheSh0KSxhPXI/dDpvKHQpLHM9cj9bXTppKHQpLHU9bixjPTA7YzxhLmxlbmd0aDtjKyspdT1lLmNhbGwobnVsbCx1LGFbY10scj9jOnNbY10pO3JldHVybiB1fWZ1bmN0aW9uIEkodCl7cmV0dXJuIFQodCxmdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09dH0pfWZ1bmN0aW9uIEwodCxlKXt2b2lkIDA9PT1lJiYoZT1mdW5jdGlvbih0KXtyZXR1cm4gdH0pO3ZhciBuPVtdO3JldHVybiBTKHQsZnVuY3Rpb24odCxyKXt2YXIgaT1lKHIpO3JldHVybiBfKG4saSk/dDoobi5wdXNoKGkpLHQuY29uY2F0KHIpKX0sW10pfWZ1bmN0aW9uIGsodCl7Zm9yKHZhciBlPVtdLG49MTtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKWVbbi0xXT1hcmd1bWVudHNbbl07dmFyIHI9W251bGxdLmNvbmNhdChlKTtyZXR1cm4gRnVuY3Rpb24uYmluZC5hcHBseSh0LHIpfWZ1bmN0aW9uIFAodCl7cmV0dXJuIEFycmF5LmlzQXJyYXkodCl9ZnVuY3Rpb24geCh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIFJlZ0V4cH1mdW5jdGlvbiBDKHQpe3JldHVybiB0IGluc3RhbmNlb2YgT2JqZWN0fWZ1bmN0aW9uIE0odCxlKXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKylpZighZSh0W25dLG4pKXJldHVybiAhMTtyZXR1cm4gITB9ZnVuY3Rpb24gRih0LGUpe3JldHVybiBUKHQsZnVuY3Rpb24odCl7cmV0dXJuIF8oZSx0KX0pfWZ1bmN0aW9uIGIodCxlKXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKylpZihlKHRbbl0pKXJldHVybiAhMDtyZXR1cm4gITF9ZnVuY3Rpb24gRCh0LGUpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKWlmKHRbbl09PT1lKXJldHVybiBuO3JldHVybiAtMX1mdW5jdGlvbiB3KHQsZSl7dmFyIG49Uih0KTtyZXR1cm4gbi5zb3J0KGZ1bmN0aW9uKHQsbil7cmV0dXJuIGUodCktZShuKX0pLG59ZnVuY3Rpb24gVSh0LGUpe2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgRXJyb3IoXCJjYW4ndCB6aXBPYmplY3Qgd2l0aCBkaWZmZXJlbnQgbnVtYmVyIG9mIGtleXMgYW5kIHZhbHVlcyFcIik7Zm9yKHZhciBuPXt9LHI9MDtyPHQubGVuZ3RoO3IrKyluW3Rbcl1dPWVbcl07cmV0dXJuIG59ZnVuY3Rpb24gRyh0KXtmb3IodmFyIGU9W10sbj0xO248YXJndW1lbnRzLmxlbmd0aDtuKyspZVtuLTFdPWFyZ3VtZW50c1tuXTtmb3IodmFyIHI9MDtyPGUubGVuZ3RoO3IrKylmb3IodmFyIG89ZVtyXSxhPWkobykscz0wO3M8YS5sZW5ndGg7cysrKXt2YXIgdT1hW3NdO3RbdV09b1t1XTt9cmV0dXJuIHR9ZnVuY3Rpb24gQih0KXtmb3IodmFyIGU9W10sbj0xO248YXJndW1lbnRzLmxlbmd0aDtuKyspZVtuLTFdPWFyZ3VtZW50c1tuXTtmb3IodmFyIHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIG89ZVtyXTtpZighZihvKSlmb3IodmFyIGE9aShvKSxzPTA7czxhLmxlbmd0aDtzKyspe3ZhciB1PWFbc107Zyh0LHUpfHwodFt1XT1vW3VdKTt9fXJldHVybiB0fWZ1bmN0aW9uIEsoKXtmb3IodmFyIHQ9W10sZT0wO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspdFtlXT1hcmd1bWVudHNbZV07cmV0dXJuIEIuYXBwbHkobnVsbCxbe31dLmNvbmNhdCh0KSl9ZnVuY3Rpb24gVyh0LGUpe3ZhciBuPXt9O3JldHVybiBsKHQsZnVuY3Rpb24odCl7dmFyIHI9ZSh0KSxpPW5bcl07aT9pLnB1c2godCk6bltyXT1bdF07fSksbn1mdW5jdGlvbiBqKHQsZSl7Zm9yKHZhciBuPUEodCkscj1pKGUpLG89MDtvPHIubGVuZ3RoO28rKyl7dmFyIGE9cltvXSxzPWVbYV07blthXT1zO31yZXR1cm4gbn1mdW5jdGlvbiBWKCl7fWZ1bmN0aW9uIFkodCl7cmV0dXJuIHR9ZnVuY3Rpb24gSCh0KXtmb3IodmFyIGU9W10sbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO2UucHVzaCh2b2lkIDAhPT1yP3I6dm9pZCAwKTt9cmV0dXJuIGV9ZnVuY3Rpb24gWCh0KXtjb25zb2xlJiZjb25zb2xlLmVycm9yJiZjb25zb2xlLmVycm9yKFwiRXJyb3I6IFwiK3QpO31mdW5jdGlvbiB6KHQpe2NvbnNvbGUmJmNvbnNvbGUud2FybiYmY29uc29sZS53YXJuKFwiV2FybmluZzogXCIrdCk7fWZ1bmN0aW9uIHEoKXtyZXR1cm4gXCJmdW5jdGlvblwiPT10eXBlb2YgTWFwfWZ1bmN0aW9uICQodCxlKXtlLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIG49ZS5wcm90b3R5cGU7T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobikuZm9yRWFjaChmdW5jdGlvbihyKXtpZihcImNvbnN0cnVjdG9yXCIhPT1yKXt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4scik7aSYmKGkuZ2V0fHxpLnNldCk/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLHIsaSk6dC5wcm90b3R5cGVbcl09ZS5wcm90b3R5cGVbcl07fX0pO30pO31mdW5jdGlvbiBaKHQpe2Z1bmN0aW9uIGUoKXt9ZS5wcm90b3R5cGU9dDt2YXIgbj1uZXcgZTtmdW5jdGlvbiByKCl7cmV0dXJuIHR5cGVvZiBuLmJhcn1yZXR1cm4gcigpLHIoKSx0fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuaXNFbXB0eT1yLGUua2V5cz1pLGUudmFsdWVzPW8sZS5tYXBWYWx1ZXM9YSxlLm1hcD1zLGUuZmxhdHRlbj11LGUuZmlyc3Q9YyxlLmxhc3Q9cCxlLmZvckVhY2g9bCxlLmlzU3RyaW5nPWgsZS5pc1VuZGVmaW5lZD1mLGUuaXNGdW5jdGlvbj1kLGUuZHJvcD1FLGUuZHJvcFJpZ2h0PW0sZS5maWx0ZXI9eSxlLnJlamVjdD1ULGUucGljaz12LGUuaGFzPWcsZS5jb250YWlucz1fLGUuY2xvbmVBcnI9UixlLmNsb25lT2JqPUEsZS5maW5kPU4sZS5maW5kQWxsPU8sZS5yZWR1Y2U9UyxlLmNvbXBhY3Q9SSxlLnVuaXE9TCxlLnBhcnRpYWw9ayxlLmlzQXJyYXk9UCxlLmlzUmVnRXhwPXgsZS5pc09iamVjdD1DLGUuZXZlcnk9TSxlLmRpZmZlcmVuY2U9RixlLnNvbWU9YixlLmluZGV4T2Y9RCxlLnNvcnRCeT13LGUuemlwT2JqZWN0PVUsZS5hc3NpZ249RyxlLmFzc2lnbk5vT3ZlcndyaXRlPUIsZS5kZWZhdWx0cz1LLGUuZ3JvdXBCeT1XLGUubWVyZ2U9aixlLk5PT1A9VixlLklERU5USVRZPVksZS5wYWNrQXJyYXk9SCxlLlBSSU5UX0VSUk9SPVgsZS5QUklOVF9XQVJOSU5HPXosZS5pc0VTMjAxNU1hcFN1cHBvcnRlZD1xLGUuYXBwbHlNaXhpbnM9JCxlLnRvRmFzdFByb3BlcnRpZXM9Wjt9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcixpPXRoaXMmJnRoaXMuX19leHRlbmRzfHwocj1mdW5jdGlvbih0LGUpe3JldHVybiAocj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24odCxlKXt0Ll9fcHJvdG9fXz1lO318fGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuIGluIGUpZS5oYXNPd25Qcm9wZXJ0eShuKSYmKHRbbl09ZVtuXSk7fSkodCxlKX0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKCl7dGhpcy5jb25zdHJ1Y3Rvcj10O31yKHQsZSksdC5wcm90b3R5cGU9bnVsbD09PWU/T2JqZWN0LmNyZWF0ZShlKToobi5wcm90b3R5cGU9ZS5wcm90b3R5cGUsbmV3IG4pO30pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBvPW4oMCksYT1uKDIpLHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuZGVmaW5pdGlvbj10O31yZXR1cm4gdC5wcm90b3R5cGUuYWNjZXB0PWZ1bmN0aW9uKHQpe3QudmlzaXQodGhpcyksby5mb3JFYWNoKHRoaXMuZGVmaW5pdGlvbixmdW5jdGlvbihlKXtlLmFjY2VwdCh0KTt9KTt9LHR9KCk7ZS5BYnN0cmFjdFByb2R1Y3Rpb249czt2YXIgdT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3ZhciBuPXQuY2FsbCh0aGlzLFtdKXx8dGhpcztyZXR1cm4gbi5pZHg9MSxvLmFzc2lnbihuLG8ucGljayhlLGZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10fSkpLG59cmV0dXJuIGkoZSx0KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJkZWZpbml0aW9uXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB2b2lkIDAhPT10aGlzLnJlZmVyZW5jZWRSdWxlP3RoaXMucmVmZXJlbmNlZFJ1bGUuZGVmaW5pdGlvbjpbXX0sc2V0OmZ1bmN0aW9uKHQpe30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxlLnByb3RvdHlwZS5hY2NlcHQ9ZnVuY3Rpb24odCl7dC52aXNpdCh0aGlzKTt9LGV9KHMpO2UuTm9uVGVybWluYWw9dTt2YXIgYz1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3ZhciBuPXQuY2FsbCh0aGlzLGUuZGVmaW5pdGlvbil8fHRoaXM7cmV0dXJuIG4ub3JnVGV4dD1cIlwiLG8uYXNzaWduKG4sby5waWNrKGUsZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXR9KSksbn1yZXR1cm4gaShlLHQpLGV9KHMpO2UuUnVsZT1jO3ZhciBwPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7dmFyIG49dC5jYWxsKHRoaXMsZS5kZWZpbml0aW9uKXx8dGhpcztyZXR1cm4gby5hc3NpZ24obixvLnBpY2soZSxmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dH0pKSxufXJldHVybiBpKGUsdCksZX0ocyk7ZS5GbGF0PXA7dmFyIGw9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlKXt2YXIgbj10LmNhbGwodGhpcyxlLmRlZmluaXRpb24pfHx0aGlzO3JldHVybiBuLmlkeD0xLG8uYXNzaWduKG4sby5waWNrKGUsZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXR9KSksbn1yZXR1cm4gaShlLHQpLGV9KHMpO2UuT3B0aW9uPWw7dmFyIGg9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlKXt2YXIgbj10LmNhbGwodGhpcyxlLmRlZmluaXRpb24pfHx0aGlzO3JldHVybiBuLmlkeD0xLG8uYXNzaWduKG4sby5waWNrKGUsZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXR9KSksbn1yZXR1cm4gaShlLHQpLGV9KHMpO2UuUmVwZXRpdGlvbk1hbmRhdG9yeT1oO3ZhciBmPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7dmFyIG49dC5jYWxsKHRoaXMsZS5kZWZpbml0aW9uKXx8dGhpcztyZXR1cm4gbi5pZHg9MSxvLmFzc2lnbihuLG8ucGljayhlLGZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10fSkpLG59cmV0dXJuIGkoZSx0KSxlfShzKTtlLlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yPWY7dmFyIGQ9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlKXt2YXIgbj10LmNhbGwodGhpcyxlLmRlZmluaXRpb24pfHx0aGlzO3JldHVybiBuLmlkeD0xLG8uYXNzaWduKG4sby5waWNrKGUsZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXR9KSksbn1yZXR1cm4gaShlLHQpLGV9KHMpO2UuUmVwZXRpdGlvbj1kO3ZhciBFPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7dmFyIG49dC5jYWxsKHRoaXMsZS5kZWZpbml0aW9uKXx8dGhpcztyZXR1cm4gbi5pZHg9MSxvLmFzc2lnbihuLG8ucGljayhlLGZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10fSkpLG59cmV0dXJuIGkoZSx0KSxlfShzKTtlLlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yPUU7dmFyIG09ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlKXt2YXIgbj10LmNhbGwodGhpcyxlLmRlZmluaXRpb24pfHx0aGlzO3JldHVybiBuLmlkeD0xLG8uYXNzaWduKG4sby5waWNrKGUsZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXR9KSksbn1yZXR1cm4gaShlLHQpLGV9KHMpO2UuQWx0ZXJuYXRpb249bTt2YXIgeT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5pZHg9MSxvLmFzc2lnbih0aGlzLG8ucGljayh0LGZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10fSkpO31yZXR1cm4gdC5wcm90b3R5cGUuYWNjZXB0PWZ1bmN0aW9uKHQpe3QudmlzaXQodGhpcyk7fSx0fSgpO2Z1bmN0aW9uIFQodCl7ZnVuY3Rpb24gZSh0KXtyZXR1cm4gby5tYXAodCxUKX1pZih0IGluc3RhbmNlb2YgdSlyZXR1cm4ge3R5cGU6XCJOb25UZXJtaW5hbFwiLG5hbWU6dC5ub25UZXJtaW5hbE5hbWUsaWR4OnQuaWR4fTtpZih0IGluc3RhbmNlb2YgcClyZXR1cm4ge3R5cGU6XCJGbGF0XCIsZGVmaW5pdGlvbjplKHQuZGVmaW5pdGlvbil9O2lmKHQgaW5zdGFuY2VvZiBsKXJldHVybiB7dHlwZTpcIk9wdGlvblwiLGlkeDp0LmlkeCxkZWZpbml0aW9uOmUodC5kZWZpbml0aW9uKX07aWYodCBpbnN0YW5jZW9mIGgpcmV0dXJuIHt0eXBlOlwiUmVwZXRpdGlvbk1hbmRhdG9yeVwiLG5hbWU6dC5uYW1lLGlkeDp0LmlkeCxkZWZpbml0aW9uOmUodC5kZWZpbml0aW9uKX07aWYodCBpbnN0YW5jZW9mIGYpcmV0dXJuIHt0eXBlOlwiUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3JcIixuYW1lOnQubmFtZSxpZHg6dC5pZHgsc2VwYXJhdG9yOlQobmV3IHkoe3Rlcm1pbmFsVHlwZTp0LnNlcGFyYXRvcn0pKSxkZWZpbml0aW9uOmUodC5kZWZpbml0aW9uKX07aWYodCBpbnN0YW5jZW9mIEUpcmV0dXJuIHt0eXBlOlwiUmVwZXRpdGlvbldpdGhTZXBhcmF0b3JcIixuYW1lOnQubmFtZSxpZHg6dC5pZHgsc2VwYXJhdG9yOlQobmV3IHkoe3Rlcm1pbmFsVHlwZTp0LnNlcGFyYXRvcn0pKSxkZWZpbml0aW9uOmUodC5kZWZpbml0aW9uKX07aWYodCBpbnN0YW5jZW9mIGQpcmV0dXJuIHt0eXBlOlwiUmVwZXRpdGlvblwiLG5hbWU6dC5uYW1lLGlkeDp0LmlkeCxkZWZpbml0aW9uOmUodC5kZWZpbml0aW9uKX07aWYodCBpbnN0YW5jZW9mIG0pcmV0dXJuIHt0eXBlOlwiQWx0ZXJuYXRpb25cIixuYW1lOnQubmFtZSxpZHg6dC5pZHgsZGVmaW5pdGlvbjplKHQuZGVmaW5pdGlvbil9O2lmKHQgaW5zdGFuY2VvZiB5KXt2YXIgbj17dHlwZTpcIlRlcm1pbmFsXCIsbmFtZTphLnRva2VuTmFtZSh0LnRlcm1pbmFsVHlwZSksbGFiZWw6YS50b2tlbkxhYmVsKHQudGVybWluYWxUeXBlKSxpZHg6dC5pZHh9LHI9dC50ZXJtaW5hbFR5cGUuUEFUVEVSTjtyZXR1cm4gdC50ZXJtaW5hbFR5cGUuUEFUVEVSTiYmKG4ucGF0dGVybj1vLmlzUmVnRXhwKHIpP3Iuc291cmNlOnIpLG59aWYodCBpbnN0YW5jZW9mIGMpcmV0dXJuIHt0eXBlOlwiUnVsZVwiLG5hbWU6dC5uYW1lLG9yZ1RleHQ6dC5vcmdUZXh0LGRlZmluaXRpb246ZSh0LmRlZmluaXRpb24pfTt0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpfWUuVGVybWluYWw9eSxlLnNlcmlhbGl6ZUdyYW1tYXI9ZnVuY3Rpb24odCl7cmV0dXJuIG8ubWFwKHQsVCl9LGUuc2VyaWFsaXplUHJvZHVjdGlvbj1UO30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPW4oMCksaT1uKDQpLG89bigxNSksYT1uKDcpO2Z1bmN0aW9uIHModCl7cmV0dXJuIHIuaXNTdHJpbmcodC5MQUJFTCkmJlwiXCIhPT10LkxBQkVMfWZ1bmN0aW9uIHUodCl7cmV0dXJuIHIuaXNPYmplY3QodCkmJnQuaGFzT3duUHJvcGVydHkoXCJ0b2tlbk5hbWVcIikmJnIuaXNTdHJpbmcodC50b2tlbk5hbWUpP3QudG9rZW5OYW1lOmkuZnVuY3Rpb25OYW1lKHQpfWUudG9rZW5MYWJlbD1mdW5jdGlvbih0KXtyZXR1cm4gcyh0KT90LkxBQkVMOnUodCl9LGUuaGFzVG9rZW5MYWJlbD1zLGUudG9rZW5OYW1lPXU7dmFyIGM9XCJwYXJlbnRcIixwPVwiY2F0ZWdvcmllc1wiLGw9XCJsYWJlbFwiLGg9XCJncm91cFwiLGY9XCJwdXNoX21vZGVcIixkPVwicG9wX21vZGVcIixFPVwibG9uZ2VyX2FsdFwiLG09XCJsaW5lX2JyZWFrc1wiLHk9XCJzdGFydF9jaGFyc19oaW50XCI7ZnVuY3Rpb24gVCh0KXtyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9dC5uYW1lLG49dC5wYXR0ZXJuLG89e307aS5kZWZpbmVOYW1lUHJvcChvLGUpfHwoby50b2tlbk5hbWU9ZSk7ci5pc1VuZGVmaW5lZChuKXx8KG8uUEFUVEVSTj1uKTtpZihyLmhhcyh0LGMpKXRocm93IFwiVGhlIHBhcmVudCBwcm9wZXJ0eSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLlxcblNlZTogaHR0cHM6Ly9naXRodWIuY29tL1NBUC9jaGV2cm90YWluL2lzc3Vlcy81NjQjaXNzdWVjb21tZW50LTM0OTA2MjM0NiBmb3IgZGV0YWlscy5cIjtyLmhhcyh0LHApJiYoby5DQVRFR09SSUVTPXRbcF0pO2EuYXVnbWVudFRva2VuVHlwZXMoW29dKSxyLmhhcyh0LGwpJiYoby5MQUJFTD10W2xdKTtyLmhhcyh0LGgpJiYoby5HUk9VUD10W2hdKTtyLmhhcyh0LGQpJiYoby5QT1BfTU9ERT10W2RdKTtyLmhhcyh0LGYpJiYoby5QVVNIX01PREU9dFtmXSk7ci5oYXModCxFKSYmKG8uTE9OR0VSX0FMVD10W0VdKTtyLmhhcyh0LG0pJiYoby5MSU5FX0JSRUFLUz10W21dKTtyLmhhcyh0LHkpJiYoby5TVEFSVF9DSEFSU19ISU5UPXRbeV0pO3JldHVybiBvfSh0KX1lLmNyZWF0ZVRva2VuPVQsZS5FT0Y9VCh7bmFtZTpcIkVPRlwiLHBhdHRlcm46by5MZXhlci5OQX0pLGEuYXVnbWVudFRva2VuVHlwZXMoW2UuRU9GXSksZS5jcmVhdGVUb2tlbkluc3RhbmNlPWZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyl7cmV0dXJuIHtpbWFnZTplLHN0YXJ0T2Zmc2V0Om4sZW5kT2Zmc2V0OnIsc3RhcnRMaW5lOmksZW5kTGluZTpvLHN0YXJ0Q29sdW1uOmEsZW5kQ29sdW1uOnMsdG9rZW5UeXBlSWR4OnQudG9rZW5UeXBlSWR4LHRva2VuVHlwZTp0fX0sZS50b2tlbk1hdGNoZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gYS50b2tlblN0cnVjdHVyZWRNYXRjaGVyKHQsZSl9O30sZnVuY3Rpb24odCxlLG4pe3ZhciByLGk9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fChyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIChyPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbih0LGUpe3QuX19wcm90b19fPWU7fXx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIG4gaW4gZSllLmhhc093blByb3BlcnR5KG4pJiYodFtuXT1lW25dKTt9KSh0LGUpfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4oKXt0aGlzLmNvbnN0cnVjdG9yPXQ7fXIodCxlKSx0LnByb3RvdHlwZT1udWxsPT09ZT9PYmplY3QuY3JlYXRlKGUpOihuLnByb3RvdHlwZT1lLnByb3RvdHlwZSxuZXcgbik7fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG89big0KSxhPW4oMCkscz1uKDI2KSx1PW4oMiksYz1uKDIzKSxwPW4oMTYpLGw9bigxMCksaD1uKDI0KSxmPW4oMjUpLGQ9bigzMSksRT1uKDMyKSxtPW4oMzQpLHk9bigzNSksVD1uKDM2KSx2PW4oMzcpLGc9bigzOCk7ZS5FTkRfT0ZfRklMRT11LmNyZWF0ZVRva2VuSW5zdGFuY2UodS5FT0YsXCJcIixOYU4sTmFOLE5hTixOYU4sTmFOLE5hTiksT2JqZWN0LmZyZWV6ZShlLkVORF9PRl9GSUxFKSxlLkRFRkFVTFRfUEFSU0VSX0NPTkZJRz1PYmplY3QuZnJlZXplKHtyZWNvdmVyeUVuYWJsZWQ6ITEsbWF4TG9va2FoZWFkOjQsaWdub3JlZElzc3Vlczp7fSxkeW5hbWljVG9rZW5zRW5hYmxlZDohMSxvdXRwdXRDc3Q6ITAsZXJyb3JNZXNzYWdlUHJvdmlkZXI6bC5kZWZhdWx0UGFyc2VyRXJyb3JQcm92aWRlcixzZXJpYWxpemVkR3JhbW1hcjpudWxsfSksZS5ERUZBVUxUX1JVTEVfQ09ORklHPU9iamVjdC5mcmVlemUoe3JlY292ZXJ5VmFsdWVGdW5jOmZ1bmN0aW9uKCl7fSxyZXN5bmNFbmFibGVkOiEwfSksZnVuY3Rpb24odCl7dFt0LklOVkFMSURfUlVMRV9OQU1FPTBdPVwiSU5WQUxJRF9SVUxFX05BTUVcIix0W3QuRFVQTElDQVRFX1JVTEVfTkFNRT0xXT1cIkRVUExJQ0FURV9SVUxFX05BTUVcIix0W3QuSU5WQUxJRF9SVUxFX09WRVJSSURFPTJdPVwiSU5WQUxJRF9SVUxFX09WRVJSSURFXCIsdFt0LkRVUExJQ0FURV9QUk9EVUNUSU9OUz0zXT1cIkRVUExJQ0FURV9QUk9EVUNUSU9OU1wiLHRbdC5VTlJFU09MVkVEX1NVQlJVTEVfUkVGPTRdPVwiVU5SRVNPTFZFRF9TVUJSVUxFX1JFRlwiLHRbdC5MRUZUX1JFQ1VSU0lPTj01XT1cIkxFRlRfUkVDVVJTSU9OXCIsdFt0Lk5PTkVfTEFTVF9FTVBUWV9BTFQ9Nl09XCJOT05FX0xBU1RfRU1QVFlfQUxUXCIsdFt0LkFNQklHVU9VU19BTFRTPTddPVwiQU1CSUdVT1VTX0FMVFNcIix0W3QuQ09ORkxJQ1RfVE9LRU5TX1JVTEVTX05BTUVTUEFDRT04XT1cIkNPTkZMSUNUX1RPS0VOU19SVUxFU19OQU1FU1BBQ0VcIix0W3QuSU5WQUxJRF9UT0tFTl9OQU1FPTldPVwiSU5WQUxJRF9UT0tFTl9OQU1FXCIsdFt0LklOVkFMSURfTkVTVEVEX1JVTEVfTkFNRT0xMF09XCJJTlZBTElEX05FU1RFRF9SVUxFX05BTUVcIix0W3QuRFVQTElDQVRFX05FU1RFRF9OQU1FPTExXT1cIkRVUExJQ0FURV9ORVNURURfTkFNRVwiLHRbdC5OT19OT05fRU1QVFlfTE9PS0FIRUFEPTEyXT1cIk5PX05PTl9FTVBUWV9MT09LQUhFQURcIix0W3QuQU1CSUdVT1VTX1BSRUZJWF9BTFRTPTEzXT1cIkFNQklHVU9VU19QUkVGSVhfQUxUU1wiLHRbdC5UT09fTUFOWV9BTFRTPTE0XT1cIlRPT19NQU5ZX0FMVFNcIjt9KGUuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZXx8KGUuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZT17fSkpLGUuRU1QVFlfQUxUPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD12b2lkIDApLGZ1bmN0aW9uKCl7cmV0dXJuIHR9fTt2YXIgXz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxuKXt2b2lkIDA9PT1uJiYobj1lLkRFRkFVTFRfUEFSU0VSX0NPTkZJRyksdGhpcy5pZ25vcmVkSXNzdWVzPWUuREVGQVVMVF9QQVJTRVJfQ09ORklHLmlnbm9yZWRJc3N1ZXMsdGhpcy5kZWZpbml0aW9uRXJyb3JzPVtdLHRoaXMuc2VsZkFuYWx5c2lzRG9uZT0hMTt0aGlzLmluaXRFcnJvckhhbmRsZXIobiksdGhpcy5pbml0TGV4ZXJBZGFwdGVyKCksdGhpcy5pbml0TG9va3NBaGVhZChuKSx0aGlzLmluaXRSZWNvZ25pemVyRW5naW5lKHQsbiksdGhpcy5pbml0UmVjb3ZlcmFibGUobiksdGhpcy5pbml0VHJlZUJ1aWxkZXIobiksdGhpcy5pbml0Q29udGVudEFzc2lzdCgpLHRoaXMuaWdub3JlZElzc3Vlcz1hLmhhcyhuLFwiaWdub3JlZElzc3Vlc1wiKT9uLmlnbm9yZWRJc3N1ZXM6ZS5ERUZBVUxUX1BBUlNFUl9DT05GSUcuaWdub3JlZElzc3VlcyxhLnRvRmFzdFByb3BlcnRpZXModGhpcyk7fXJldHVybiB0LnBlcmZvcm1TZWxmQW5hbHlzaXM9ZnVuY3Rpb24odCl7dC5wZXJmb3JtU2VsZkFuYWx5c2lzKCk7fSx0LnByb3RvdHlwZS5wZXJmb3JtU2VsZkFuYWx5c2lzPWZ1bmN0aW9uKCl7dmFyIGUsbj10aGlzO3RoaXMuc2VsZkFuYWx5c2lzRG9uZT0hMDt2YXIgcj1vLmNsYXNzTmFtZUZyb21JbnN0YW5jZSh0aGlzKSxpPXRoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGU7aWYodGhpcy5zZXJpYWxpemVkR3JhbW1hcil7dmFyIHU9Yy5kZXNlcmlhbGl6ZUdyYW1tYXIodGhpcy5zZXJpYWxpemVkR3JhbW1hcix0aGlzLnRva2Vuc01hcCk7YS5mb3JFYWNoKHUsZnVuY3Rpb24odCl7bi5nYXN0UHJvZHVjdGlvbnNDYWNoZS5wdXQodC5uYW1lLHQpO30pO312YXIgZj1oLnJlc29sdmVHcmFtbWFyKHtydWxlczppLnZhbHVlcygpfSk7aWYodGhpcy5kZWZpbml0aW9uRXJyb3JzLnB1c2guYXBwbHkodGhpcy5kZWZpbml0aW9uRXJyb3JzLGYpLGEuaXNFbXB0eShmKSl7dmFyIGQ9aC52YWxpZGF0ZUdyYW1tYXIoe3J1bGVzOmkudmFsdWVzKCksbWF4TG9va2FoZWFkOnRoaXMubWF4TG9va2FoZWFkLHRva2VuVHlwZXM6YS52YWx1ZXModGhpcy50b2tlbnNNYXApLGlnbm9yZWRJc3N1ZXM6dGhpcy5pZ25vcmVkSXNzdWVzLGVyck1zZ1Byb3ZpZGVyOmwuZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyLGdyYW1tYXJOYW1lOnJ9KTt0aGlzLmRlZmluaXRpb25FcnJvcnMucHVzaC5hcHBseSh0aGlzLmRlZmluaXRpb25FcnJvcnMsZCk7fWlmKGEuaXNFbXB0eSh0aGlzLmRlZmluaXRpb25FcnJvcnMpKXt2YXIgRT1zLmNvbXB1dGVBbGxQcm9kc0ZvbGxvd3MoaS52YWx1ZXMoKSk7dGhpcy5yZXN5bmNGb2xsb3dzPUU7fXZhciBtPXAuYW5hbHl6ZUNzdChpLnZhbHVlcygpLHRoaXMuZnVsbFJ1bGVOYW1lVG9TaG9ydCk7aWYodGhpcy5hbGxSdWxlTmFtZXM9bS5hbGxSdWxlTmFtZXMsIXQuREVGRVJfREVGSU5JVElPTl9FUlJPUlNfSEFORExJTkcmJiFhLmlzRW1wdHkodGhpcy5kZWZpbml0aW9uRXJyb3JzKSl0aHJvdyBlPWEubWFwKHRoaXMuZGVmaW5pdGlvbkVycm9ycyxmdW5jdGlvbih0KXtyZXR1cm4gdC5tZXNzYWdlfSksbmV3IEVycm9yKFwiUGFyc2VyIERlZmluaXRpb24gRXJyb3JzIGRldGVjdGVkOlxcbiBcIitlLmpvaW4oXCJcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXCIpKX0sdC5ERUZFUl9ERUZJTklUSU9OX0VSUk9SU19IQU5ETElORz0hMSx0fSgpO2UuUGFyc2VyPV8sYS5hcHBseU1peGlucyhfLFtmLlJlY292ZXJhYmxlLGQuTG9va3NBaGVhZCxFLlRyZWVCdWlsZGVyLG0uTGV4ZXJBZGFwdGVyLFQuUmVjb2duaXplckVuZ2luZSx5LlJlY29nbml6ZXJBcGksdi5FcnJvckhhbmRsZXIsZy5Db250ZW50QXNzaXN0XSk7dmFyIFI9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbihuLHIpe3ZvaWQgMD09PXImJihyPWUuREVGQVVMVF9QQVJTRVJfQ09ORklHKTt2YXIgaT1hLmNsb25lT2JqKHIpO3JldHVybiBpLm91dHB1dENzdD0hMCx0LmNhbGwodGhpcyxuLGkpfHx0aGlzfXJldHVybiBpKG4sdCksbn0oXyk7ZS5Dc3RQYXJzZXI9Ujt2YXIgQT1mdW5jdGlvbih0KXtmdW5jdGlvbiBuKG4scil7dm9pZCAwPT09ciYmKHI9ZS5ERUZBVUxUX1BBUlNFUl9DT05GSUcpO3ZhciBpPWEuY2xvbmVPYmoocik7cmV0dXJuIGkub3V0cHV0Q3N0PSExLHQuY2FsbCh0aGlzLG4saSl8fHRoaXN9cmV0dXJuIGkobix0KSxufShfKTtlLkVtYmVkZGVkQWN0aW9uc1BhcnNlcj1BO30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPW4oMCk7ZS5jbGFzc05hbWVGcm9tSW5zdGFuY2U9ZnVuY3Rpb24odCl7cmV0dXJuIGEodC5jb25zdHJ1Y3Rvcil9O3ZhciBpPS9eXFxzKmZ1bmN0aW9uXFxzKihcXFMqKVxccypcXCgvLG89XCJuYW1lXCI7ZnVuY3Rpb24gYSh0KXt2YXIgZT10Lm5hbWU7cmV0dXJuIGV8fHQudG9TdHJpbmcoKS5tYXRjaChpKVsxXX1lLmZ1bmN0aW9uTmFtZT1hLGUuZGVmaW5lTmFtZVByb3A9ZnVuY3Rpb24odCxlKXt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbyk7cmV0dXJuICEoIXIuaXNVbmRlZmluZWQobikmJiFuLmNvbmZpZ3VyYWJsZXx8KE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG8se2VudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiExLHZhbHVlOmV9KSwwKSl9O3ZhciBzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMuX3N0YXRlPXt9O31yZXR1cm4gdC5wcm90b3R5cGUua2V5cz1mdW5jdGlvbigpe3JldHVybiByLmtleXModGhpcy5fc3RhdGUpfSx0LnByb3RvdHlwZS52YWx1ZXM9ZnVuY3Rpb24oKXtyZXR1cm4gci52YWx1ZXModGhpcy5fc3RhdGUpfSx0LnByb3RvdHlwZS5wdXQ9ZnVuY3Rpb24odCxlKXt0aGlzLl9zdGF0ZVt0XT1lO30sdC5wcm90b3R5cGUucHV0QWxsPWZ1bmN0aW9uKHQpe3RoaXMuX3N0YXRlPXIuYXNzaWduKHRoaXMuX3N0YXRlLHQuX3N0YXRlKTt9LHQucHJvdG90eXBlLmdldD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fc3RhdGVbdF19LHQucHJvdG90eXBlLmNvbnRhaW5zS2V5PWZ1bmN0aW9uKHQpe3JldHVybiByLmhhcyh0aGlzLl9zdGF0ZSx0KX0sdC5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLl9zdGF0ZT17fTt9LHR9KCk7ZS5IYXNoVGFibGU9czt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1uKDEpLGk9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS52aXNpdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2Ygci5Ob25UZXJtaW5hbClyZXR1cm4gdGhpcy52aXNpdE5vblRlcm1pbmFsKHQpO2lmKHQgaW5zdGFuY2VvZiByLkZsYXQpcmV0dXJuIHRoaXMudmlzaXRGbGF0KHQpO2lmKHQgaW5zdGFuY2VvZiByLk9wdGlvbilyZXR1cm4gdGhpcy52aXNpdE9wdGlvbih0KTtpZih0IGluc3RhbmNlb2Ygci5SZXBldGl0aW9uTWFuZGF0b3J5KXJldHVybiB0aGlzLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeSh0KTtpZih0IGluc3RhbmNlb2Ygci5SZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcilyZXR1cm4gdGhpcy52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yKHQpO2lmKHQgaW5zdGFuY2VvZiByLlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKXJldHVybiB0aGlzLnZpc2l0UmVwZXRpdGlvbldpdGhTZXBhcmF0b3IodCk7aWYodCBpbnN0YW5jZW9mIHIuUmVwZXRpdGlvbilyZXR1cm4gdGhpcy52aXNpdFJlcGV0aXRpb24odCk7aWYodCBpbnN0YW5jZW9mIHIuQWx0ZXJuYXRpb24pcmV0dXJuIHRoaXMudmlzaXRBbHRlcm5hdGlvbih0KTtpZih0IGluc3RhbmNlb2Ygci5UZXJtaW5hbClyZXR1cm4gdGhpcy52aXNpdFRlcm1pbmFsKHQpO2lmKHQgaW5zdGFuY2VvZiByLlJ1bGUpcmV0dXJuIHRoaXMudmlzaXRSdWxlKHQpO3Rocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIil9LHQucHJvdG90eXBlLnZpc2l0Tm9uVGVybWluYWw9ZnVuY3Rpb24odCl7fSx0LnByb3RvdHlwZS52aXNpdEZsYXQ9ZnVuY3Rpb24odCl7fSx0LnByb3RvdHlwZS52aXNpdE9wdGlvbj1mdW5jdGlvbih0KXt9LHQucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbj1mdW5jdGlvbih0KXt9LHQucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeT1mdW5jdGlvbih0KXt9LHQucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3I9ZnVuY3Rpb24odCl7fSx0LnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yPWZ1bmN0aW9uKHQpe30sdC5wcm90b3R5cGUudmlzaXRBbHRlcm5hdGlvbj1mdW5jdGlvbih0KXt9LHQucHJvdG90eXBlLnZpc2l0VGVybWluYWw9ZnVuY3Rpb24odCl7fSx0LnByb3RvdHlwZS52aXNpdFJ1bGU9ZnVuY3Rpb24odCl7fSx0fSgpO2UuR0FzdFZpc2l0b3I9aTt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1uKDApLGk9XCJNaXNtYXRjaGVkVG9rZW5FeGNlcHRpb25cIixvPVwiTm9WaWFibGVBbHRFeGNlcHRpb25cIixhPVwiRWFybHlFeGl0RXhjZXB0aW9uXCIscz1cIk5vdEFsbElucHV0UGFyc2VkRXhjZXB0aW9uXCIsdT1baSxvLGEsc107ZnVuY3Rpb24gYyh0LGUsbil7dGhpcy5uYW1lPWksdGhpcy5tZXNzYWdlPXQsdGhpcy50b2tlbj1lLHRoaXMucHJldmlvdXNUb2tlbj1uLHRoaXMucmVzeW5jZWRUb2tlbnM9W107fWZ1bmN0aW9uIHAodCxlLG4pe3RoaXMubmFtZT1vLHRoaXMubWVzc2FnZT10LHRoaXMudG9rZW49ZSx0aGlzLnByZXZpb3VzVG9rZW49bix0aGlzLnJlc3luY2VkVG9rZW5zPVtdO31mdW5jdGlvbiBsKHQsZSl7dGhpcy5uYW1lPXMsdGhpcy5tZXNzYWdlPXQsdGhpcy50b2tlbj1lLHRoaXMucmVzeW5jZWRUb2tlbnM9W107fWZ1bmN0aW9uIGgodCxlLG4pe3RoaXMubmFtZT1hLHRoaXMubWVzc2FnZT10LHRoaXMudG9rZW49ZSx0aGlzLnByZXZpb3VzVG9rZW49bix0aGlzLnJlc3luY2VkVG9rZW5zPVtdO31PYmplY3QuZnJlZXplKHUpLGUuaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbj1mdW5jdGlvbih0KXtyZXR1cm4gci5jb250YWlucyh1LHQubmFtZSl9LGUuTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uPWMsYy5wcm90b3R5cGU9RXJyb3IucHJvdG90eXBlLGUuTm9WaWFibGVBbHRFeGNlcHRpb249cCxwLnByb3RvdHlwZT1FcnJvci5wcm90b3R5cGUsZS5Ob3RBbGxJbnB1dFBhcnNlZEV4Y2VwdGlvbj1sLGwucHJvdG90eXBlPUVycm9yLnByb3RvdHlwZSxlLkVhcmx5RXhpdEV4Y2VwdGlvbj1oLGgucHJvdG90eXBlPUVycm9yLnByb3RvdHlwZTt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1uKDApLGk9big0KSxvPW4oMik7ZnVuY3Rpb24gYSh0KXtmb3IodmFyIGU9ci5jbG9uZUFycih0KSxuPXQsaT0hMDtpOyl7bj1yLmNvbXBhY3Qoci5mbGF0dGVuKHIubWFwKG4sZnVuY3Rpb24odCl7cmV0dXJuIHQuQ0FURUdPUklFU30pKSk7dmFyIG89ci5kaWZmZXJlbmNlKG4sZSk7ZT1lLmNvbmNhdChvKSxyLmlzRW1wdHkobyk/aT0hMTpuPW87fXJldHVybiBlfWZ1bmN0aW9uIHModCl7ci5mb3JFYWNoKHQsZnVuY3Rpb24odCl7bCh0KXx8KGUudG9rZW5JZHhUb0NsYXNzLnB1dChlLnRva2VuU2hvcnROYW1lSWR4LHQpLHQudG9rZW5UeXBlSWR4PWUudG9rZW5TaG9ydE5hbWVJZHgrKyksaCh0KSYmIXIuaXNBcnJheSh0LkNBVEVHT1JJRVMpJiYodC5DQVRFR09SSUVTPVt0LkNBVEVHT1JJRVNdKSxoKHQpfHwodC5DQVRFR09SSUVTPVtdKSxmKHQpfHwodC5jYXRlZ29yeU1hdGNoZXM9W10pLGQodCl8fCh0LmNhdGVnb3J5TWF0Y2hlc01hcD17fSksRSh0KXx8KHQudG9rZW5OYW1lPW8udG9rZW5OYW1lKHQpKTt9KTt9ZnVuY3Rpb24gdSh0KXtyLmZvckVhY2godCxmdW5jdGlvbih0KXt0LmNhdGVnb3J5TWF0Y2hlcz1bXSxyLmZvckVhY2godC5jYXRlZ29yeU1hdGNoZXNNYXAsZnVuY3Rpb24obixyKXt0LmNhdGVnb3J5TWF0Y2hlcy5wdXNoKGUudG9rZW5JZHhUb0NsYXNzLmdldChyKS50b2tlblR5cGVJZHgpO30pO30pO31mdW5jdGlvbiBjKHQpe3IuZm9yRWFjaCh0LGZ1bmN0aW9uKHQpe3AoW10sdCk7fSk7fWZ1bmN0aW9uIHAodCxlKXtyLmZvckVhY2godCxmdW5jdGlvbih0KXtlLmNhdGVnb3J5TWF0Y2hlc01hcFt0LnRva2VuVHlwZUlkeF09ITA7fSksci5mb3JFYWNoKGUuQ0FURUdPUklFUyxmdW5jdGlvbihuKXt2YXIgaT10LmNvbmNhdChlKTtyLmNvbnRhaW5zKGksbil8fHAoaSxuKTt9KTt9ZnVuY3Rpb24gbCh0KXtyZXR1cm4gci5oYXModCxcInRva2VuVHlwZUlkeFwiKX1mdW5jdGlvbiBoKHQpe3JldHVybiByLmhhcyh0LFwiQ0FURUdPUklFU1wiKX1mdW5jdGlvbiBmKHQpe3JldHVybiByLmhhcyh0LFwiY2F0ZWdvcnlNYXRjaGVzXCIpfWZ1bmN0aW9uIGQodCl7cmV0dXJuIHIuaGFzKHQsXCJjYXRlZ29yeU1hdGNoZXNNYXBcIil9ZnVuY3Rpb24gRSh0KXtyZXR1cm4gci5oYXModCxcInRva2VuTmFtZVwiKX1lLnRva2VuU3RydWN0dXJlZE1hdGNoZXI9ZnVuY3Rpb24odCxlKXt2YXIgbj10LnRva2VuVHlwZUlkeDtyZXR1cm4gbj09PWUudG9rZW5UeXBlSWR4fHwhMD09PWUuaXNQYXJlbnQmJiEwPT09ZS5jYXRlZ29yeU1hdGNoZXNNYXBbbl19LGUudG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlck5vQ2F0ZWdvcmllcz1mdW5jdGlvbih0LGUpe3JldHVybiB0LnRva2VuVHlwZUlkeD09PWUudG9rZW5UeXBlSWR4fSxlLnRva2VuU2hvcnROYW1lSWR4PTEsZS50b2tlbklkeFRvQ2xhc3M9bmV3IGkuSGFzaFRhYmxlLGUuYXVnbWVudFRva2VuVHlwZXM9ZnVuY3Rpb24odCl7dmFyIGU9YSh0KTtzKGUpLGMoZSksdShlKSxyLmZvckVhY2goZSxmdW5jdGlvbih0KXt0LmlzUGFyZW50PXQuY2F0ZWdvcnlNYXRjaGVzLmxlbmd0aD4wO30pO30sZS5leHBhbmRDYXRlZ29yaWVzPWEsZS5hc3NpZ25Ub2tlbkRlZmF1bHRQcm9wcz1zLGUuYXNzaWduQ2F0ZWdvcmllc1Rva2Vuc1Byb3A9dSxlLmFzc2lnbkNhdGVnb3JpZXNNYXBQcm9wPWMsZS5zaW5nbGVBc3NpZ25DYXRlZ29yaWVzVG9rc01hcD1wLGUuaGFzU2hvcnRLZXlQcm9wZXJ0eT1sLGUuaGFzQ2F0ZWdvcmllc1Byb3BlcnR5PWgsZS5oYXNFeHRlbmRpbmdUb2tlbnNUeXBlc1Byb3BlcnR5PWYsZS5oYXNFeHRlbmRpbmdUb2tlbnNUeXBlc01hcFByb3BlcnR5PWQsZS5oYXNUb2tlbk5hbWVQcm9wZXJ0eT1FLGUuaXNUb2tlblR5cGU9ZnVuY3Rpb24odCl7cmV0dXJuIHIuaGFzKHQsXCJ0b2tlblR5cGVJZHhcIil9O30sZnVuY3Rpb24odCxlLG4pe3ZhciByLGk9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fChyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIChyPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbih0LGUpe3QuX19wcm90b19fPWU7fXx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIG4gaW4gZSllLmhhc093blByb3BlcnR5KG4pJiYodFtuXT1lW25dKTt9KSh0LGUpfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4oKXt0aGlzLmNvbnN0cnVjdG9yPXQ7fXIodCxlKSx0LnByb3RvdHlwZT1udWxsPT09ZT9PYmplY3QuY3JlYXRlKGUpOihuLnByb3RvdHlwZT1lLnByb3RvdHlwZSxuZXcgbik7fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG89bigwKSxhPW4oMSkscz1uKDUpLHU9bigyKTtlLmlzU2VxdWVuY2VQcm9kPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgYS5GbGF0fHx0IGluc3RhbmNlb2YgYS5PcHRpb258fHQgaW5zdGFuY2VvZiBhLlJlcGV0aXRpb258fHQgaW5zdGFuY2VvZiBhLlJlcGV0aXRpb25NYW5kYXRvcnl8fHQgaW5zdGFuY2VvZiBhLlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yfHx0IGluc3RhbmNlb2YgYS5SZXBldGl0aW9uV2l0aFNlcGFyYXRvcnx8dCBpbnN0YW5jZW9mIGEuVGVybWluYWx8fHQgaW5zdGFuY2VvZiBhLlJ1bGV9LGUuaXNPcHRpb25hbFByb2Q9ZnVuY3Rpb24gdChlLG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj1bXSksISEoZSBpbnN0YW5jZW9mIGEuT3B0aW9ufHxlIGluc3RhbmNlb2YgYS5SZXBldGl0aW9ufHxlIGluc3RhbmNlb2YgYS5SZXBldGl0aW9uV2l0aFNlcGFyYXRvcil8fChlIGluc3RhbmNlb2YgYS5BbHRlcm5hdGlvbj9vLnNvbWUoZS5kZWZpbml0aW9uLGZ1bmN0aW9uKGUpe3JldHVybiB0KGUsbil9KTohKGUgaW5zdGFuY2VvZiBhLk5vblRlcm1pbmFsJiZvLmNvbnRhaW5zKG4sZSkpJiZlIGluc3RhbmNlb2YgYS5BYnN0cmFjdFByb2R1Y3Rpb24mJihlIGluc3RhbmNlb2YgYS5Ob25UZXJtaW5hbCYmbi5wdXNoKGUpLG8uZXZlcnkoZS5kZWZpbml0aW9uLGZ1bmN0aW9uKGUpe3JldHVybiB0KGUsbil9KSkpfSxlLmlzQnJhbmNoaW5nUHJvZD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIGEuQWx0ZXJuYXRpb259LGUuZ2V0UHJvZHVjdGlvbkRzbE5hbWU9ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIGEuTm9uVGVybWluYWwpcmV0dXJuIFwiU1VCUlVMRVwiO2lmKHQgaW5zdGFuY2VvZiBhLk9wdGlvbilyZXR1cm4gXCJPUFRJT05cIjtpZih0IGluc3RhbmNlb2YgYS5BbHRlcm5hdGlvbilyZXR1cm4gXCJPUlwiO2lmKHQgaW5zdGFuY2VvZiBhLlJlcGV0aXRpb25NYW5kYXRvcnkpcmV0dXJuIFwiQVRfTEVBU1RfT05FXCI7aWYodCBpbnN0YW5jZW9mIGEuUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IpcmV0dXJuIFwiQVRfTEVBU1RfT05FX1NFUFwiO2lmKHQgaW5zdGFuY2VvZiBhLlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKXJldHVybiBcIk1BTllfU0VQXCI7aWYodCBpbnN0YW5jZW9mIGEuUmVwZXRpdGlvbilyZXR1cm4gXCJNQU5ZXCI7aWYodCBpbnN0YW5jZW9mIGEuVGVybWluYWwpcmV0dXJuIFwiQ09OU1VNRVwiO3Rocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIil9O3ZhciBjPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgZT1udWxsIT09dCYmdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXM7cmV0dXJuIGUuc2VwYXJhdG9yPVwiLVwiLGUuZHNsTWV0aG9kcz17b3B0aW9uOltdLGFsdGVybmF0aW9uOltdLHJlcGV0aXRpb246W10scmVwZXRpdGlvbldpdGhTZXBhcmF0b3I6W10scmVwZXRpdGlvbk1hbmRhdG9yeTpbXSxyZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcjpbXX0sZX1yZXR1cm4gaShlLHQpLGUucHJvdG90eXBlLnZpc2l0VGVybWluYWw9ZnVuY3Rpb24odCl7dmFyIGU9dS50b2tlbk5hbWUodC50ZXJtaW5hbFR5cGUpK3RoaXMuc2VwYXJhdG9yK1wiVGVybWluYWxcIjtvLmhhcyh0aGlzLmRzbE1ldGhvZHMsZSl8fCh0aGlzLmRzbE1ldGhvZHNbZV09W10pLHRoaXMuZHNsTWV0aG9kc1tlXS5wdXNoKHQpO30sZS5wcm90b3R5cGUudmlzaXROb25UZXJtaW5hbD1mdW5jdGlvbih0KXt2YXIgZT10Lm5vblRlcm1pbmFsTmFtZSt0aGlzLnNlcGFyYXRvcitcIlRlcm1pbmFsXCI7by5oYXModGhpcy5kc2xNZXRob2RzLGUpfHwodGhpcy5kc2xNZXRob2RzW2VdPVtdKSx0aGlzLmRzbE1ldGhvZHNbZV0ucHVzaCh0KTt9LGUucHJvdG90eXBlLnZpc2l0T3B0aW9uPWZ1bmN0aW9uKHQpe3RoaXMuZHNsTWV0aG9kcy5vcHRpb24ucHVzaCh0KTt9LGUucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbldpdGhTZXBhcmF0b3I9ZnVuY3Rpb24odCl7dGhpcy5kc2xNZXRob2RzLnJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLnB1c2godCk7fSxlLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnk9ZnVuY3Rpb24odCl7dGhpcy5kc2xNZXRob2RzLnJlcGV0aXRpb25NYW5kYXRvcnkucHVzaCh0KTt9LGUucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3I9ZnVuY3Rpb24odCl7dGhpcy5kc2xNZXRob2RzLnJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLnB1c2godCk7fSxlLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb249ZnVuY3Rpb24odCl7dGhpcy5kc2xNZXRob2RzLnJlcGV0aXRpb24ucHVzaCh0KTt9LGUucHJvdG90eXBlLnZpc2l0QWx0ZXJuYXRpb249ZnVuY3Rpb24odCl7dGhpcy5kc2xNZXRob2RzLmFsdGVybmF0aW9uLnB1c2godCk7fSxlfShzLkdBc3RWaXNpdG9yKTtlLkRzbE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yPWM7fSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0LGUsbil7cmV0dXJuIG58ZXx0fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuQklUU19GT1JfTUVUSE9EX0lEWD00LGUuQklUU19GT1JfT0NDVVJSRU5DRV9JRFg9NCxlLkJJVFNfRk9SX1JVTEVfSURYPTI0LGUuQklUU19GT1JfQUxUX0lEWD04LGUuT1JfSURYPTE8PGUuQklUU19GT1JfTUVUSE9EX0lEWCxlLk9QVElPTl9JRFg9Mjw8ZS5CSVRTX0ZPUl9NRVRIT0RfSURYLGUuTUFOWV9JRFg9Mzw8ZS5CSVRTX0ZPUl9NRVRIT0RfSURYLGUuQVRfTEVBU1RfT05FX0lEWD00PDxlLkJJVFNfRk9SX01FVEhPRF9JRFgsZS5NQU5ZX1NFUF9JRFg9NTw8ZS5CSVRTX0ZPUl9NRVRIT0RfSURYLGUuQVRfTEVBU1RfT05FX1NFUF9JRFg9Njw8ZS5CSVRTX0ZPUl9NRVRIT0RfSURYLGUuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkPXI7dmFyIGk9MzItZS5CSVRTX0ZPUl9BTFRfSURYO2UuZ2V0S2V5Rm9yQWx0SW5kZXg9ZnVuY3Rpb24odCxlLG4sbyl7dmFyIGE9bysxPDxpO3JldHVybiByKHQsZSxuKXxhfTt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1uKDIpLGk9bigwKSxvPW4oMCksYT1uKDEpLHM9big4KSx1PW4oMTEpLGM9bigxNykscD1uKDMpO2UuZGVmYXVsdFBhcnNlckVycm9yUHJvdmlkZXI9e2J1aWxkTWlzbWF0Y2hUb2tlbk1lc3NhZ2U6ZnVuY3Rpb24odCl7dmFyIGU9dC5leHBlY3RlZCxuPXQuYWN0dWFsO3QucHJldmlvdXMsdC5ydWxlTmFtZTtyZXR1cm4gXCJFeHBlY3RpbmcgXCIrKHIuaGFzVG9rZW5MYWJlbChlKT9cIi0tXFx4M2UgXCIrci50b2tlbkxhYmVsKGUpK1wiIDwtLVwiOlwidG9rZW4gb2YgdHlwZSAtLVxceDNlIFwiK3IudG9rZW5OYW1lKGUpK1wiIDwtLVwiKStcIiBidXQgZm91bmQgLS1cXHgzZSAnXCIrbi5pbWFnZStcIicgPC0tXCJ9LGJ1aWxkTm90QWxsSW5wdXRQYXJzZWRNZXNzYWdlOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZmlyc3RSZWR1bmRhbnQ7dC5ydWxlTmFtZTtyZXR1cm4gXCJSZWR1bmRhbnQgaW5wdXQsIGV4cGVjdGluZyBFT0YgYnV0IGZvdW5kOiBcIitlLmltYWdlfSxidWlsZE5vVmlhYmxlQWx0TWVzc2FnZTpmdW5jdGlvbih0KXt2YXIgZT10LmV4cGVjdGVkUGF0aHNQZXJBbHQsbj10LmFjdHVhbCxpPSh0LnByZXZpb3VzLHQuY3VzdG9tVXNlckRlc2NyaXB0aW9uKSxhPSh0LnJ1bGVOYW1lLFwiXFxuYnV0IGZvdW5kOiAnXCIrby5maXJzdChuKS5pbWFnZStcIidcIik7aWYoaSlyZXR1cm4gXCJFeHBlY3Rpbmc6IFwiK2krYTt2YXIgcz1vLnJlZHVjZShlLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuY29uY2F0KGUpfSxbXSksdT1vLm1hcChzLGZ1bmN0aW9uKHQpe3JldHVybiBcIltcIitvLm1hcCh0LGZ1bmN0aW9uKHQpe3JldHVybiByLnRva2VuTGFiZWwodCl9KS5qb2luKFwiLCBcIikrXCJdXCJ9KTtyZXR1cm4gXCJFeHBlY3Rpbmc6IFwiKyhcIm9uZSBvZiB0aGVzZSBwb3NzaWJsZSBUb2tlbiBzZXF1ZW5jZXM6XFxuXCIrby5tYXAodSxmdW5jdGlvbih0LGUpe3JldHVybiBcIiAgXCIrKGUrMSkrXCIuIFwiK3R9KS5qb2luKFwiXFxuXCIpKSthfSxidWlsZEVhcmx5RXhpdE1lc3NhZ2U6ZnVuY3Rpb24odCl7dmFyIGU9dC5leHBlY3RlZEl0ZXJhdGlvblBhdGhzLG49dC5hY3R1YWwsaT10LmN1c3RvbVVzZXJEZXNjcmlwdGlvbixhPSh0LnJ1bGVOYW1lLFwiXFxuYnV0IGZvdW5kOiAnXCIrby5maXJzdChuKS5pbWFnZStcIidcIik7cmV0dXJuIGk/XCJFeHBlY3Rpbmc6IFwiK2krYTpcIkV4cGVjdGluZzogXCIrKFwiZXhwZWN0aW5nIGF0IGxlYXN0IG9uZSBpdGVyYXRpb24gd2hpY2ggc3RhcnRzIHdpdGggb25lIG9mIHRoZXNlIHBvc3NpYmxlIFRva2VuIHNlcXVlbmNlczo6XFxuICA8XCIrby5tYXAoZSxmdW5jdGlvbih0KXtyZXR1cm4gXCJbXCIrby5tYXAodCxmdW5jdGlvbih0KXtyZXR1cm4gci50b2tlbkxhYmVsKHQpfSkuam9pbihcIixcIikrXCJdXCJ9KS5qb2luKFwiICxcIikrXCI+XCIpK2F9fSxPYmplY3QuZnJlZXplKGUuZGVmYXVsdFBhcnNlckVycm9yUHJvdmlkZXIpLGUuZGVmYXVsdEdyYW1tYXJSZXNvbHZlckVycm9yUHJvdmlkZXI9e2J1aWxkUnVsZU5vdEZvdW5kRXJyb3I6ZnVuY3Rpb24odCxlKXtyZXR1cm4gXCJJbnZhbGlkIGdyYW1tYXIsIHJlZmVyZW5jZSB0byBhIHJ1bGUgd2hpY2ggaXMgbm90IGRlZmluZWQ6IC0+XCIrZS5ub25UZXJtaW5hbE5hbWUrXCI8LVxcbmluc2lkZSB0b3AgbGV2ZWwgcnVsZTogLT5cIit0Lm5hbWUrXCI8LVwifX0sZS5kZWZhdWx0R3JhbW1hclZhbGlkYXRvckVycm9yUHJvdmlkZXI9e2J1aWxkRHVwbGljYXRlRm91bmRFcnJvcjpmdW5jdGlvbih0LGUpe3ZhciBuLGk9dC5uYW1lLHU9by5maXJzdChlKSxjPXUuaWR4LHA9cy5nZXRQcm9kdWN0aW9uRHNsTmFtZSh1KSxsPShuPXUpaW5zdGFuY2VvZiBhLlRlcm1pbmFsP3IudG9rZW5OYW1lKG4udGVybWluYWxUeXBlKTpuIGluc3RhbmNlb2YgYS5Ob25UZXJtaW5hbD9uLm5vblRlcm1pbmFsTmFtZTpcIlwiLGg9XCItPlwiK3ArXCI8LSB3aXRoIG51bWVyaWNhbCBzdWZmaXg6IC0+XCIrYytcIjwtXFxuICAgICAgICAgICAgICAgICAgXCIrKGw/XCJhbmQgYXJndW1lbnQ6IC0+XCIrbCtcIjwtXCI6XCJcIikrXCJcXG4gICAgICAgICAgICAgICAgICBhcHBlYXJzIG1vcmUgdGhhbiBvbmNlIChcIitlLmxlbmd0aCtcIiB0aW1lcykgaW4gdGhlIHRvcCBsZXZlbCBydWxlOiAtPlwiK2krXCI8LS5cXG4gICAgICAgICAgICAgICAgICBcIisoMD09PWM/XCJBbHNvIG5vdGUgdGhhdCBudW1lcmljYWwgc3VmZml4IDAgbWVhbnMgXCIrcCtcIiB3aXRob3V0IGFueSBzdWZmaXguXCI6XCJcIikrXCJcXG4gICAgICAgICAgICAgICAgICBUbyBmaXggdGhpcyBtYWtlIHN1cmUgZWFjaCB1c2FnZSBvZiBcIitwK1wiIFwiKyhsP1wid2l0aCB0aGUgYXJndW1lbnQ6IC0+XCIrbCtcIjwtXCI6XCJcIikrXCJcXG4gICAgICAgICAgICAgICAgICBpbiB0aGUgcnVsZSAtPlwiK2krXCI8LSBoYXMgYSBkaWZmZXJlbnQgb2NjdXJyZW5jZSBpbmRleCAoMC01KSwgYXMgdGhhdCBjb21iaW5hdGlvbiBhY3RzIGFzIGEgdW5pcXVlXFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb24ga2V5IGluIHRoZSBncmFtbWFyLCB3aGljaCBpcyBuZWVkZWQgYnkgdGhlIHBhcnNpbmcgZW5naW5lLlxcbiAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgIEZvciBmdXJ0aGVyIGRldGFpbHMgc2VlOiBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL0ZBUS5odG1sI05VTUVSSUNBTF9TVUZGSVhFUyBcXG4gICAgICAgICAgICAgICAgICBcIjtyZXR1cm4gaD0oaD1oLnJlcGxhY2UoL1sgXFx0XSsvZyxcIiBcIikpLnJlcGxhY2UoL1xcc1xccysvZyxcIlxcblwiKX0sYnVpbGRJbnZhbGlkTmVzdGVkUnVsZU5hbWVFcnJvcjpmdW5jdGlvbih0LGUpe3JldHVybiBcIkludmFsaWQgbmVzdGVkIHJ1bGUgbmFtZTogLT5cIitlLm5hbWUrXCI8LSBpbnNpZGUgcnVsZTogLT5cIit0Lm5hbWUrXCI8LVxcbml0IG11c3QgbWF0Y2ggdGhlIHBhdHRlcm46IC0+XCIrdS52YWxpZE5lc3RlZFJ1bGVOYW1lLnRvU3RyaW5nKCkrXCI8LS5cXG5Ob3RlIHRoYXQgdGhpcyBtZWFucyBhIG5lc3RlZCBydWxlIG5hbWUgbXVzdCBzdGFydCB3aXRoIHRoZSAnJCcoZG9sbGFyKSBzaWduLlwifSxidWlsZER1cGxpY2F0ZU5lc3RlZFJ1bGVOYW1lRXJyb3I6ZnVuY3Rpb24odCxlKXtyZXR1cm4gXCJEdXBsaWNhdGUgbmVzdGVkIHJ1bGUgbmFtZTogLT5cIitvLmZpcnN0KGUpLm5hbWUrXCI8LSBpbnNpZGUgcnVsZTogLT5cIit0Lm5hbWUrXCI8LVxcbkEgbmVzdGVkIG5hbWUgbXVzdCBiZSB1bmlxdWUgaW4gdGhlIHNjb3BlIG9mIGEgdG9wIGxldmVsIGdyYW1tYXIgcnVsZS5cIn0sYnVpbGROYW1lc3BhY2VDb25mbGljdEVycm9yOmZ1bmN0aW9uKHQpe3JldHVybiBcIk5hbWVzcGFjZSBjb25mbGljdCBmb3VuZCBpbiBncmFtbWFyLlxcblRoZSBncmFtbWFyIGhhcyBib3RoIGEgVGVybWluYWwoVG9rZW4pIGFuZCBhIE5vbi1UZXJtaW5hbChSdWxlKSBuYW1lZDogPFwiK3QubmFtZStcIj4uXFxuVG8gcmVzb2x2ZSB0aGlzIG1ha2Ugc3VyZSBlYWNoIFRlcm1pbmFsIGFuZCBOb24tVGVybWluYWwgbmFtZXMgYXJlIHVuaXF1ZVxcblRoaXMgaXMgZWFzeSB0byBhY2NvbXBsaXNoIGJ5IHVzaW5nIHRoZSBjb252ZW50aW9uIHRoYXQgVGVybWluYWwgbmFtZXMgc3RhcnQgd2l0aCBhbiB1cHBlcmNhc2UgbGV0dGVyXFxuYW5kIE5vbi1UZXJtaW5hbCBuYW1lcyBzdGFydCB3aXRoIGEgbG93ZXIgY2FzZSBsZXR0ZXIuXCJ9LGJ1aWxkQWx0ZXJuYXRpb25QcmVmaXhBbWJpZ3VpdHlFcnJvcjpmdW5jdGlvbih0KXt2YXIgZT1vLm1hcCh0LnByZWZpeFBhdGgsZnVuY3Rpb24odCl7cmV0dXJuIHIudG9rZW5MYWJlbCh0KX0pLmpvaW4oXCIsIFwiKSxuPTA9PT10LmFsdGVybmF0aW9uLmlkeD9cIlwiOnQuYWx0ZXJuYXRpb24uaWR4O3JldHVybiBcIkFtYmlndW91cyBhbHRlcm5hdGl2ZXM6IDxcIit0LmFtYmlndWl0eUluZGljZXMuam9pbihcIiAsXCIpK1wiPiBkdWUgdG8gY29tbW9uIGxvb2thaGVhZCBwcmVmaXhcXG5pbiA8T1JcIituK1wiPiBpbnNpZGUgPFwiK3QudG9wTGV2ZWxSdWxlLm5hbWUrXCI+IFJ1bGUsXFxuPFwiK2UrXCI+IG1heSBhcHBlYXJzIGFzIGEgcHJlZml4IHBhdGggaW4gYWxsIHRoZXNlIGFsdGVybmF0aXZlcy5cXG5odHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL3Jlc29sdmluZ19ncmFtbWFyX2Vycm9ycy5odG1sI0NPTU1PTl9QUkVGSVhcXG5Gb3IgRnVydGhlciBkZXRhaWxzLlwifSxidWlsZEFsdGVybmF0aW9uQW1iaWd1aXR5RXJyb3I6ZnVuY3Rpb24odCl7dmFyIGU9by5tYXAodC5wcmVmaXhQYXRoLGZ1bmN0aW9uKHQpe3JldHVybiByLnRva2VuTGFiZWwodCl9KS5qb2luKFwiLCBcIiksbj0wPT09dC5hbHRlcm5hdGlvbi5pZHg/XCJcIjp0LmFsdGVybmF0aW9uLmlkeCxpPVwiQW1iaWd1b3VzIGFsdGVybmF0aXZlczogPFwiK3QuYW1iaWd1aXR5SW5kaWNlcy5qb2luKFwiICxcIikrXCI+IGluIDxPUlwiK24rXCI+IGluc2lkZSA8XCIrdC50b3BMZXZlbFJ1bGUubmFtZStcIj4gUnVsZSxcXG48XCIrZStcIj4gbWF5IGFwcGVhcnMgYXMgYSBwcmVmaXggcGF0aCBpbiBhbGwgdGhlc2UgYWx0ZXJuYXRpdmVzLlxcblwiLGE9Yy5WRVJTSU9OLnJlcGxhY2UoL1xcLi9nLFwiX1wiKTtyZXR1cm4gaT1pK1wiVG8gUmVzb2x2ZSB0aGlzLCB0cnkgb25lIG9mIG9mIHRoZSBmb2xsb3dpbmc6IFxcbjEuIFJlZmFjdG9yIHlvdXIgZ3JhbW1hciB0byBiZSBMTChLKSBmb3IgdGhlIGN1cnJlbnQgdmFsdWUgb2YgayAoYnkgZGVmYXVsdCBrPVwiK3AuREVGQVVMVF9QQVJTRVJfQ09ORklHLm1heExvb2thaGVhZCtcIn0pXFxuMi4gSW5jcmVhc2UgdGhlIHZhbHVlIG9mIEsgZm9yIHlvdXIgZ3JhbW1hciBieSBwcm92aWRpbmcgYSBsYXJnZXIgJ21heExvb2thaGVhZCcgdmFsdWUgaW4gdGhlIHBhcnNlcidzIGNvbmZpZ1xcbjMuIFRoaXMgaXNzdWUgY2FuIGJlIGlnbm9yZWQgKGlmIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy4uLiksIHNlZSBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2N1bWVudGF0aW9uL1wiK2ErXCIvaW50ZXJmYWNlcy9pcGFyc2VyY29uZmlnLmh0bWwjaWdub3JlZGlzc3VlcyBmb3IgbW9yZSBkZXRhaWxzXFxuXCJ9LGJ1aWxkRW1wdHlSZXBldGl0aW9uRXJyb3I6ZnVuY3Rpb24odCl7dmFyIGU9cy5nZXRQcm9kdWN0aW9uRHNsTmFtZSh0LnJlcGV0aXRpb24pO3JldHVybiAwIT09dC5yZXBldGl0aW9uLmlkeCYmKGUrPXQucmVwZXRpdGlvbi5pZHgpLFwiVGhlIHJlcGV0aXRpb24gPFwiK2UrXCI+IHdpdGhpbiBSdWxlIDxcIit0LnRvcExldmVsUnVsZS5uYW1lK1wiPiBjYW4gbmV2ZXIgY29uc3VtZSBhbnkgdG9rZW5zLlxcblRoaXMgY291bGQgbGVhZCB0byBhbiBpbmZpbml0ZSBsb29wLlwifSxidWlsZFRva2VuTmFtZUVycm9yOmZ1bmN0aW9uKHQpe3JldHVybiBcIkludmFsaWQgR3JhbW1hciBUb2tlbiBuYW1lOiAtPlwiK3IudG9rZW5OYW1lKHQudG9rZW5UeXBlKStcIjwtIGl0IG11c3QgbWF0Y2ggdGhlIHBhdHRlcm46IC0+XCIrdC5leHBlY3RlZFBhdHRlcm4udG9TdHJpbmcoKStcIjwtXCJ9LGJ1aWxkRW1wdHlBbHRlcm5hdGlvbkVycm9yOmZ1bmN0aW9uKHQpe3JldHVybiBcIkFtYmlndW91cyBlbXB0eSBhbHRlcm5hdGl2ZTogPFwiKyh0LmVtcHR5Q2hvaWNlSWR4KzEpK1wiPiBpbiA8T1JcIit0LmFsdGVybmF0aW9uLmlkeCtcIj4gaW5zaWRlIDxcIit0LnRvcExldmVsUnVsZS5uYW1lK1wiPiBSdWxlLlxcbk9ubHkgdGhlIGxhc3QgYWx0ZXJuYXRpdmUgbWF5IGJlIGFuIGVtcHR5IGFsdGVybmF0aXZlLlwifSxidWlsZFRvb01hbnlBbHRlcm5hdGl2ZXNFcnJvcjpmdW5jdGlvbih0KXtyZXR1cm4gXCJBbiBBbHRlcm5hdGlvbiBjYW5ub3QgaGF2ZSBtb3JlIHRoYW4gMjU2IGFsdGVybmF0aXZlczpcXG48T1JcIit0LmFsdGVybmF0aW9uLmlkeCtcIj4gaW5zaWRlIDxcIit0LnRvcExldmVsUnVsZS5uYW1lK1wiPiBSdWxlLlxcbiBoYXMgXCIrKHQuYWx0ZXJuYXRpb24uZGVmaW5pdGlvbi5sZW5ndGgrMSkrXCIgYWx0ZXJuYXRpdmVzLlwifSxidWlsZExlZnRSZWN1cnNpb25FcnJvcjpmdW5jdGlvbih0KXt2YXIgZT10LnRvcExldmVsUnVsZS5uYW1lO3JldHVybiBcIkxlZnQgUmVjdXJzaW9uIGZvdW5kIGluIGdyYW1tYXIuXFxucnVsZTogPFwiK2UrXCI+IGNhbiBiZSBpbnZva2VkIGZyb20gaXRzZWxmIChkaXJlY3RseSBvciBpbmRpcmVjdGx5KVxcbndpdGhvdXQgY29uc3VtaW5nIGFueSBUb2tlbnMuIFRoZSBncmFtbWFyIHBhdGggdGhhdCBjYXVzZXMgdGhpcyBpczogXFxuIFwiKyhlK1wiIC0tXFx4M2UgXCIraS5tYXAodC5sZWZ0UmVjdXJzaW9uUGF0aCxmdW5jdGlvbih0KXtyZXR1cm4gdC5uYW1lfSkuY29uY2F0KFtlXSkuam9pbihcIiAtLVxceDNlIFwiKSkrXCJcXG4gVG8gZml4IHRoaXMgcmVmYWN0b3IgeW91ciBncmFtbWFyIHRvIHJlbW92ZSB0aGUgbGVmdCByZWN1cnNpb24uXFxuc2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MTF9wYXJzZXIjTGVmdF9GYWN0b3JpbmcuXCJ9LGJ1aWxkSW52YWxpZFJ1bGVOYW1lRXJyb3I6ZnVuY3Rpb24odCl7cmV0dXJuIFwiSW52YWxpZCBncmFtbWFyIHJ1bGUgbmFtZTogLT5cIit0LnRvcExldmVsUnVsZS5uYW1lK1wiPC0gaXQgbXVzdCBtYXRjaCB0aGUgcGF0dGVybjogLT5cIit0LmV4cGVjdGVkUGF0dGVybi50b1N0cmluZygpK1wiPC1cIn0sYnVpbGREdXBsaWNhdGVSdWxlTmFtZUVycm9yOmZ1bmN0aW9uKHQpe3JldHVybiBcIkR1cGxpY2F0ZSBkZWZpbml0aW9uLCBydWxlOiAtPlwiKyh0LnRvcExldmVsUnVsZSBpbnN0YW5jZW9mIGEuUnVsZT90LnRvcExldmVsUnVsZS5uYW1lOnQudG9wTGV2ZWxSdWxlKStcIjwtIGlzIGFscmVhZHkgZGVmaW5lZCBpbiB0aGUgZ3JhbW1hcjogLT5cIit0LmdyYW1tYXJOYW1lK1wiPC1cIn19O30sZnVuY3Rpb24odCxlLG4pe3ZhciByLGk9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fChyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIChyPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbih0LGUpe3QuX19wcm90b19fPWU7fXx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIG4gaW4gZSllLmhhc093blByb3BlcnR5KG4pJiYodFtuXT1lW25dKTt9KSh0LGUpfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4oKXt0aGlzLmNvbnN0cnVjdG9yPXQ7fXIodCxlKSx0LnByb3RvdHlwZT1udWxsPT09ZT9PYmplY3QuY3JlYXRlKGUpOihuLnByb3RvdHlwZT1lLnByb3RvdHlwZSxuZXcgbik7fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG89bigwKSxhPW4oMCkscz1uKDMpLHU9big4KSxjPW4oMikscD1uKDEyKSxsPW4oMTYpLGg9bigxMyksZj1uKDEpLGQ9big1KTtmdW5jdGlvbiBFKHQpe3JldHVybiB1LmdldFByb2R1Y3Rpb25Ec2xOYW1lKHQpK1wiXyNfXCIrdC5pZHgrXCJfI19cIittKHQpfWZ1bmN0aW9uIG0odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBmLlRlcm1pbmFsP2MudG9rZW5OYW1lKHQudGVybWluYWxUeXBlKTp0IGluc3RhbmNlb2YgZi5Ob25UZXJtaW5hbD90Lm5vblRlcm1pbmFsTmFtZTpcIlwifWUudmFsaWRhdGVHcmFtbWFyPWZ1bmN0aW9uKHQsZSxuLHIsaSxwKXt2YXIgaD1vLm1hcCh0LGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbih0LGUpe3ZhciBuPW5ldyB5O3QuYWNjZXB0KG4pO3ZhciByPW4uYWxsUHJvZHVjdGlvbnMsaT1vLmdyb3VwQnkocixFKSxhPW8ucGljayhpLGZ1bmN0aW9uKHQpe3JldHVybiB0Lmxlbmd0aD4xfSk7cmV0dXJuIG8ubWFwKG8udmFsdWVzKGEpLGZ1bmN0aW9uKG4pe3ZhciByPW8uZmlyc3QobiksaT1lLmJ1aWxkRHVwbGljYXRlRm91bmRFcnJvcih0LG4pLGE9dS5nZXRQcm9kdWN0aW9uRHNsTmFtZShyKSxjPXttZXNzYWdlOmksdHlwZTpzLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuRFVQTElDQVRFX1BST0RVQ1RJT05TLHJ1bGVOYW1lOnQubmFtZSxkc2xOYW1lOmEsb2NjdXJyZW5jZTpyLmlkeH0scD1tKHIpO3JldHVybiBwJiYoYy5wYXJhbWV0ZXI9cCksY30pfSh0LGkpfSksZj1vLm1hcCh0LGZ1bmN0aW9uKHQpe3JldHVybiBSKHQsdCxpKX0pLGQ9W10sQT1bXSxOPVtdO2EuZXZlcnkoZixhLmlzRW1wdHkpJiYoZD1hLm1hcCh0LGZ1bmN0aW9uKHQpe3JldHVybiBPKHQsaSl9KSxBPWEubWFwKHQsZnVuY3Rpb24odCl7cmV0dXJuIFModCxlLHIsaSl9KSxOPWsodCxlLGkpKTt2YXIgST1mdW5jdGlvbih0LGUsbil7dmFyIHI9W10saT1hLm1hcChlLGZ1bmN0aW9uKHQpe3JldHVybiBjLnRva2VuTmFtZSh0KX0pO3JldHVybiBhLmZvckVhY2godCxmdW5jdGlvbih0KXt2YXIgZT10Lm5hbWU7aWYoYS5jb250YWlucyhpLGUpKXt2YXIgbz1uLmJ1aWxkTmFtZXNwYWNlQ29uZmxpY3RFcnJvcih0KTtyLnB1c2goe21lc3NhZ2U6byx0eXBlOnMuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5DT05GTElDVF9UT0tFTlNfUlVMRVNfTkFNRVNQQUNFLHJ1bGVOYW1lOmV9KTt9fSkscn0odCxuLGkpLFA9by5tYXAobixmdW5jdGlvbih0KXtyZXR1cm4gZyh0LGkpfSkseD1mdW5jdGlvbih0LGUpe3ZhciBuPVtdO3JldHVybiBhLmZvckVhY2godCxmdW5jdGlvbih0KXt2YXIgcj1uZXcgbC5OYW1lZERTTE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yKFwiXCIpO3QuYWNjZXB0KHIpO3ZhciBpPWEubWFwKHIucmVzdWx0LGZ1bmN0aW9uKHQpe3JldHVybiB0Lm9yZ1Byb2R9KTtuLnB1c2goYS5tYXAoaSxmdW5jdGlvbihuKXtyZXR1cm4gdih0LG4sZSl9KSk7fSksYS5mbGF0dGVuKG4pfSh0LGkpLEM9ZnVuY3Rpb24odCxlKXt2YXIgbj1bXTtyZXR1cm4gYS5mb3JFYWNoKHQsZnVuY3Rpb24odCl7dmFyIHI9bmV3IGwuTmFtZWREU0xNZXRob2RzQ29sbGVjdG9yVmlzaXRvcihcIlwiKTt0LmFjY2VwdChyKTt2YXIgaT1hLmdyb3VwQnkoci5yZXN1bHQsZnVuY3Rpb24odCl7cmV0dXJuIHQubmFtZX0pLG89YS5waWNrKGksZnVuY3Rpb24odCl7cmV0dXJuIHQubGVuZ3RoPjF9KTthLmZvckVhY2goYS52YWx1ZXMobyksZnVuY3Rpb24ocil7dmFyIGk9YS5tYXAocixmdW5jdGlvbih0KXtyZXR1cm4gdC5vcmdQcm9kfSksbz1lLmJ1aWxkRHVwbGljYXRlTmVzdGVkUnVsZU5hbWVFcnJvcih0LGkpO24ucHVzaCh7bWVzc2FnZTpvLHR5cGU6cy5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLkRVUExJQ0FURV9ORVNURURfTkFNRSxydWxlTmFtZTp0Lm5hbWV9KTt9KTt9KSxufSh0LGkpLE09YS5tYXAodCxmdW5jdGlvbih0KXtyZXR1cm4gTCh0LGkpfSksRj1hLm1hcCh0LGZ1bmN0aW9uKHQpe3JldHVybiBUKHQsaSl9KSxiPWEubWFwKHQsZnVuY3Rpb24oZSl7cmV0dXJuIF8oZSx0LHAsaSl9KTtyZXR1cm4gby5mbGF0dGVuKGguY29uY2F0KFAseCxDLE4sZixkLEEsSSxNLEYsYikpfSxlLmlkZW50aWZ5UHJvZHVjdGlvbkZvckR1cGxpY2F0ZXM9RTt2YXIgeT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIGU9bnVsbCE9PXQmJnQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzO3JldHVybiBlLmFsbFByb2R1Y3Rpb25zPVtdLGV9cmV0dXJuIGkoZSx0KSxlLnByb3RvdHlwZS52aXNpdE5vblRlcm1pbmFsPWZ1bmN0aW9uKHQpe3RoaXMuYWxsUHJvZHVjdGlvbnMucHVzaCh0KTt9LGUucHJvdG90eXBlLnZpc2l0T3B0aW9uPWZ1bmN0aW9uKHQpe3RoaXMuYWxsUHJvZHVjdGlvbnMucHVzaCh0KTt9LGUucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbldpdGhTZXBhcmF0b3I9ZnVuY3Rpb24odCl7dGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKHQpO30sZS5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5PWZ1bmN0aW9uKHQpe3RoaXMuYWxsUHJvZHVjdGlvbnMucHVzaCh0KTt9LGUucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3I9ZnVuY3Rpb24odCl7dGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKHQpO30sZS5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uPWZ1bmN0aW9uKHQpe3RoaXMuYWxsUHJvZHVjdGlvbnMucHVzaCh0KTt9LGUucHJvdG90eXBlLnZpc2l0QWx0ZXJuYXRpb249ZnVuY3Rpb24odCl7dGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKHQpO30sZS5wcm90b3R5cGUudmlzaXRUZXJtaW5hbD1mdW5jdGlvbih0KXt0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2godCk7fSxlfShkLkdBc3RWaXNpdG9yKTtmdW5jdGlvbiBUKHQsbil7dmFyIHI9W10saT10Lm5hbWU7cmV0dXJuIGkubWF0Y2goZS52YWxpZFRlcm1zUGF0dGVybil8fHIucHVzaCh7bWVzc2FnZTpuLmJ1aWxkSW52YWxpZFJ1bGVOYW1lRXJyb3Ioe3RvcExldmVsUnVsZTp0LGV4cGVjdGVkUGF0dGVybjplLnZhbGlkVGVybXNQYXR0ZXJufSksdHlwZTpzLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuSU5WQUxJRF9SVUxFX05BTUUscnVsZU5hbWU6aX0pLHJ9ZnVuY3Rpb24gdih0LG4scil7dmFyIGksbz1bXTtyZXR1cm4gbi5uYW1lLm1hdGNoKGUudmFsaWROZXN0ZWRSdWxlTmFtZSl8fChpPXIuYnVpbGRJbnZhbGlkTmVzdGVkUnVsZU5hbWVFcnJvcih0LG4pLG8ucHVzaCh7bWVzc2FnZTppLHR5cGU6cy5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLklOVkFMSURfTkVTVEVEX1JVTEVfTkFNRSxydWxlTmFtZTp0Lm5hbWV9KSksb31mdW5jdGlvbiBnKHQsbil7dmFyIHI9W107cmV0dXJuIGMudG9rZW5OYW1lKHQpLm1hdGNoKGUudmFsaWRUZXJtc1BhdHRlcm4pfHxyLnB1c2goe21lc3NhZ2U6bi5idWlsZFRva2VuTmFtZUVycm9yKHt0b2tlblR5cGU6dCxleHBlY3RlZFBhdHRlcm46ZS52YWxpZFRlcm1zUGF0dGVybn0pLHR5cGU6cy5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLklOVkFMSURfVE9LRU5fTkFNRX0pLHJ9ZnVuY3Rpb24gXyh0LGUsbixyKXt2YXIgaT1bXTtpZihhLnJlZHVjZShlLGZ1bmN0aW9uKGUsbil7cmV0dXJuIG4ubmFtZT09PXQubmFtZT9lKzE6ZX0sMCk+MSl7dmFyIG89ci5idWlsZER1cGxpY2F0ZVJ1bGVOYW1lRXJyb3Ioe3RvcExldmVsUnVsZTp0LGdyYW1tYXJOYW1lOm59KTtpLnB1c2goe21lc3NhZ2U6byx0eXBlOnMuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5EVVBMSUNBVEVfUlVMRV9OQU1FLHJ1bGVOYW1lOnQubmFtZX0pO31yZXR1cm4gaX1mdW5jdGlvbiBSKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPVtdKTt2YXIgaT1bXSxhPUEoZS5kZWZpbml0aW9uKTtpZihvLmlzRW1wdHkoYSkpcmV0dXJuIFtdO3ZhciB1PXQubmFtZTtvLmNvbnRhaW5zKGEsdCkmJmkucHVzaCh7bWVzc2FnZTpuLmJ1aWxkTGVmdFJlY3Vyc2lvbkVycm9yKHt0b3BMZXZlbFJ1bGU6dCxsZWZ0UmVjdXJzaW9uUGF0aDpyfSksdHlwZTpzLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuTEVGVF9SRUNVUlNJT04scnVsZU5hbWU6dX0pO3ZhciBjPW8uZGlmZmVyZW5jZShhLHIuY29uY2F0KFt0XSkpLHA9by5tYXAoYyxmdW5jdGlvbihlKXt2YXIgaT1vLmNsb25lQXJyKHIpO3JldHVybiBpLnB1c2goZSksUih0LGUsbixpKX0pO3JldHVybiBpLmNvbmNhdChvLmZsYXR0ZW4ocCkpfWZ1bmN0aW9uIEEodCl7dmFyIGU9W107aWYoby5pc0VtcHR5KHQpKXJldHVybiBlO3ZhciBuPW8uZmlyc3QodCk7aWYobiBpbnN0YW5jZW9mIGYuTm9uVGVybWluYWwpZS5wdXNoKG4ucmVmZXJlbmNlZFJ1bGUpO2Vsc2UgaWYobiBpbnN0YW5jZW9mIGYuRmxhdHx8biBpbnN0YW5jZW9mIGYuT3B0aW9ufHxuIGluc3RhbmNlb2YgZi5SZXBldGl0aW9uTWFuZGF0b3J5fHxuIGluc3RhbmNlb2YgZi5SZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcnx8biBpbnN0YW5jZW9mIGYuUmVwZXRpdGlvbldpdGhTZXBhcmF0b3J8fG4gaW5zdGFuY2VvZiBmLlJlcGV0aXRpb24pZT1lLmNvbmNhdChBKG4uZGVmaW5pdGlvbikpO2Vsc2UgaWYobiBpbnN0YW5jZW9mIGYuQWx0ZXJuYXRpb24pZT1vLmZsYXR0ZW4oby5tYXAobi5kZWZpbml0aW9uLGZ1bmN0aW9uKHQpe3JldHVybiBBKHQuZGVmaW5pdGlvbil9KSk7ZWxzZSBpZighKG4gaW5zdGFuY2VvZiBmLlRlcm1pbmFsKSl0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO3ZhciByPXUuaXNPcHRpb25hbFByb2QobiksaT10Lmxlbmd0aD4xO2lmKHImJmkpe3ZhciBhPW8uZHJvcCh0KTtyZXR1cm4gZS5jb25jYXQoQShhKSl9cmV0dXJuIGV9ZS5PY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3Rvcj15LGUudmFsaWRUZXJtc1BhdHRlcm49L15bYS16QS1aX11cXHcqJC8sZS52YWxpZE5lc3RlZFJ1bGVOYW1lPW5ldyBSZWdFeHAoZS52YWxpZFRlcm1zUGF0dGVybi5zb3VyY2UucmVwbGFjZShcIl5cIixcIl5cXFxcJFwiKSksZS52YWxpZGF0ZVJ1bGVOYW1lPVQsZS52YWxpZGF0ZU5lc3RlZFJ1bGVOYW1lPXYsZS52YWxpZGF0ZVRva2VuTmFtZT1nLGUudmFsaWRhdGVSdWxlRG9lc05vdEFscmVhZHlFeGlzdD1fLGUudmFsaWRhdGVSdWxlSXNPdmVycmlkZGVuPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcixpPVtdO3JldHVybiBvLmNvbnRhaW5zKGUsdCl8fChyPVwiSW52YWxpZCBydWxlIG92ZXJyaWRlLCBydWxlOiAtPlwiK3QrXCI8LSBjYW5ub3QgYmUgb3ZlcnJpZGRlbiBpbiB0aGUgZ3JhbW1hcjogLT5cIituK1wiPC1hcyBpdCBpcyBub3QgZGVmaW5lZCBpbiBhbnkgb2YgdGhlIHN1cGVyIGdyYW1tYXJzIFwiLGkucHVzaCh7bWVzc2FnZTpyLHR5cGU6cy5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLklOVkFMSURfUlVMRV9PVkVSUklERSxydWxlTmFtZTp0fSkpLGl9LGUudmFsaWRhdGVOb0xlZnRSZWN1cnNpb249UixlLmdldEZpcnN0Tm9uZVRlcm1pbmFsPUE7dmFyIE49ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciBlPW51bGwhPT10JiZ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpcztyZXR1cm4gZS5hbHRlcm5hdGlvbnM9W10sZX1yZXR1cm4gaShlLHQpLGUucHJvdG90eXBlLnZpc2l0QWx0ZXJuYXRpb249ZnVuY3Rpb24odCl7dGhpcy5hbHRlcm5hdGlvbnMucHVzaCh0KTt9LGV9KGQuR0FzdFZpc2l0b3IpO2Z1bmN0aW9uIE8odCxlKXt2YXIgbj1uZXcgTjt0LmFjY2VwdChuKTt2YXIgcj1uLmFsdGVybmF0aW9ucztyZXR1cm4gby5yZWR1Y2UocixmdW5jdGlvbihuLHIpe3ZhciBpPW8uZHJvcFJpZ2h0KHIuZGVmaW5pdGlvbiksYT1vLm1hcChpLGZ1bmN0aW9uKG4saSl7dmFyIGE9aC5uZXh0UG9zc2libGVUb2tlbnNBZnRlcihbbl0sW10sbnVsbCwxKTtyZXR1cm4gby5pc0VtcHR5KGEpP3ttZXNzYWdlOmUuYnVpbGRFbXB0eUFsdGVybmF0aW9uRXJyb3Ioe3RvcExldmVsUnVsZTp0LGFsdGVybmF0aW9uOnIsZW1wdHlDaG9pY2VJZHg6aX0pLHR5cGU6cy5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLk5PTkVfTEFTVF9FTVBUWV9BTFQscnVsZU5hbWU6dC5uYW1lLG9jY3VycmVuY2U6ci5pZHgsYWx0ZXJuYXRpdmU6aSsxfTpudWxsfSk7cmV0dXJuIG4uY29uY2F0KG8uY29tcGFjdChhKSl9LFtdKX1mdW5jdGlvbiBTKHQsZSxuLHIpe3ZhciBpPW5ldyBOO3QuYWNjZXB0KGkpO3ZhciBjPWkuYWx0ZXJuYXRpb25zLGw9blt0Lm5hbWVdO3JldHVybiBsJiYoYz1hLnJlamVjdChjLGZ1bmN0aW9uKHQpe3JldHVybiBsW3UuZ2V0UHJvZHVjdGlvbkRzbE5hbWUodCkrKDA9PT10LmlkeD9cIlwiOnQuaWR4KV19KSksby5yZWR1Y2UoYyxmdW5jdGlvbihuLGkpe3ZhciB1PWkuaWR4LGM9cC5nZXRMb29rYWhlYWRQYXRoc0Zvck9yKHUsdCxlKSxsPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBpPVtdLHU9YS5yZWR1Y2UodCxmdW5jdGlvbihlLG4scil7cmV0dXJuIGEuZm9yRWFjaChuLGZ1bmN0aW9uKG4pe3ZhciBvPVtyXTthLmZvckVhY2godCxmdW5jdGlvbih0LGUpe3IhPT1lJiZwLmNvbnRhaW5zUGF0aCh0LG4pJiZvLnB1c2goZSk7fSksby5sZW5ndGg+MSYmIXAuY29udGFpbnNQYXRoKGksbikmJihpLnB1c2gobiksZS5wdXNoKHthbHRzOm8scGF0aDpufSkpO30pLGV9LFtdKTtyZXR1cm4gby5tYXAodSxmdW5jdGlvbih0KXt2YXIgaT1hLm1hcCh0LmFsdHMsZnVuY3Rpb24odCl7cmV0dXJuIHQrMX0pLG89ci5idWlsZEFsdGVybmF0aW9uQW1iaWd1aXR5RXJyb3Ioe3RvcExldmVsUnVsZTpuLGFsdGVybmF0aW9uOmUsYW1iaWd1aXR5SW5kaWNlczppLHByZWZpeFBhdGg6dC5wYXRofSk7cmV0dXJuIHttZXNzYWdlOm8sdHlwZTpzLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuQU1CSUdVT1VTX0FMVFMscnVsZU5hbWU6bi5uYW1lLG9jY3VycmVuY2U6ZS5pZHgsYWx0ZXJuYXRpdmVzOlt0LmFsdHNdfX0pfShjLGksdCxyKSxoPVAoYyxpLHQscik7cmV0dXJuIG4uY29uY2F0KGwsaCl9LFtdKX1lLnZhbGlkYXRlRW1wdHlPckFsdGVybmF0aXZlPU8sZS52YWxpZGF0ZUFtYmlndW91c0FsdGVybmF0aW9uQWx0ZXJuYXRpdmVzPVM7dmFyIEk9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciBlPW51bGwhPT10JiZ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpcztyZXR1cm4gZS5hbGxQcm9kdWN0aW9ucz1bXSxlfXJldHVybiBpKGUsdCksZS5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uV2l0aFNlcGFyYXRvcj1mdW5jdGlvbih0KXt0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2godCk7fSxlLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnk9ZnVuY3Rpb24odCl7dGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKHQpO30sZS5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcj1mdW5jdGlvbih0KXt0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2godCk7fSxlLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb249ZnVuY3Rpb24odCl7dGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKHQpO30sZX0oZC5HQXN0VmlzaXRvcik7ZnVuY3Rpb24gTCh0LGUpe3ZhciBuPW5ldyBOO3QuYWNjZXB0KG4pO3ZhciByPW4uYWx0ZXJuYXRpb25zO3JldHVybiBvLnJlZHVjZShyLGZ1bmN0aW9uKG4scil7cmV0dXJuIHIuZGVmaW5pdGlvbi5sZW5ndGg+MjU1JiZuLnB1c2goe21lc3NhZ2U6ZS5idWlsZFRvb01hbnlBbHRlcm5hdGl2ZXNFcnJvcih7dG9wTGV2ZWxSdWxlOnQsYWx0ZXJuYXRpb246cn0pLHR5cGU6cy5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLlRPT19NQU5ZX0FMVFMscnVsZU5hbWU6dC5uYW1lLG9jY3VycmVuY2U6ci5pZHh9KSxufSxbXSl9ZnVuY3Rpb24gayh0LGUsbil7dmFyIHI9W107cmV0dXJuIGEuZm9yRWFjaCh0LGZ1bmN0aW9uKHQpe3ZhciBpPW5ldyBJO3QuYWNjZXB0KGkpO3ZhciBvPWkuYWxsUHJvZHVjdGlvbnM7YS5mb3JFYWNoKG8sZnVuY3Rpb24oaSl7dmFyIG89cC5nZXRQcm9kVHlwZShpKSx1PWkuaWR4LGM9cC5nZXRMb29rYWhlYWRQYXRoc0Zvck9wdGlvbmFsUHJvZCh1LHQsbyxlKVswXTtpZihhLmlzRW1wdHkoYS5mbGF0dGVuKGMpKSl7dmFyIGw9bi5idWlsZEVtcHR5UmVwZXRpdGlvbkVycm9yKHt0b3BMZXZlbFJ1bGU6dCxyZXBldGl0aW9uOml9KTtyLnB1c2goe21lc3NhZ2U6bCx0eXBlOnMuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5OT19OT05fRU1QVFlfTE9PS0FIRUFELHJ1bGVOYW1lOnQubmFtZX0pO319KTt9KSxyfWZ1bmN0aW9uIFAodCxlLG4scil7dmFyIGk9W10sbz1hLnJlZHVjZSh0LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1hLm1hcChlLGZ1bmN0aW9uKHQpe3JldHVybiB7aWR4Om4scGF0aDp0fX0pO3JldHVybiB0LmNvbmNhdChyKX0sW10pO3JldHVybiBhLmZvckVhY2gobyxmdW5jdGlvbih0KXt2YXIgdT10LmlkeCxjPXQucGF0aCxsPWEuZmluZEFsbChvLGZ1bmN0aW9uKHQpe3JldHVybiB0LmlkeDx1JiZwLmlzU3RyaWN0UHJlZml4T2ZQYXRoKHQucGF0aCxjKX0pLGg9YS5tYXAobCxmdW5jdGlvbih0KXt2YXIgaT1bdC5pZHgrMSx1KzFdLG89MD09PWUuaWR4P1wiXCI6ZS5pZHg7cmV0dXJuIHttZXNzYWdlOnIuYnVpbGRBbHRlcm5hdGlvblByZWZpeEFtYmlndWl0eUVycm9yKHt0b3BMZXZlbFJ1bGU6bixhbHRlcm5hdGlvbjplLGFtYmlndWl0eUluZGljZXM6aSxwcmVmaXhQYXRoOnQucGF0aH0pLHR5cGU6cy5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLkFNQklHVU9VU19QUkVGSVhfQUxUUyxydWxlTmFtZTpuLm5hbWUsb2NjdXJyZW5jZTpvLGFsdGVybmF0aXZlczppfX0pO2k9aS5jb25jYXQoaCk7fSksaX1lLlJlcGV0aW9uQ29sbGVjdG9yPUksZS52YWxpZGF0ZVRvb01hbnlBbHRzPUwsZS52YWxpZGF0ZVNvbWVOb25FbXB0eUxvb2thaGVhZFBhdGg9ayxlLmNoZWNrUHJlZml4QWx0ZXJuYXRpdmVzQW1iaWd1aXRpZXM9UDt9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcixpPXRoaXMmJnRoaXMuX19leHRlbmRzfHwocj1mdW5jdGlvbih0LGUpe3JldHVybiAocj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24odCxlKXt0Ll9fcHJvdG9fXz1lO318fGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuIGluIGUpZS5oYXNPd25Qcm9wZXJ0eShuKSYmKHRbbl09ZVtuXSk7fSkodCxlKX0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKCl7dGhpcy5jb25zdHJ1Y3Rvcj10O31yKHQsZSksdC5wcm90b3R5cGU9bnVsbD09PWU/T2JqZWN0LmNyZWF0ZShlKToobi5wcm90b3R5cGU9ZS5wcm90b3R5cGUsbmV3IG4pO30pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBvLGE9bigwKSxzPW4oMTMpLHU9bigxNCksYz1uKDcpLHA9bigxKSxsPW4oNSk7IWZ1bmN0aW9uKHQpe3RbdC5PUFRJT049MF09XCJPUFRJT05cIix0W3QuUkVQRVRJVElPTj0xXT1cIlJFUEVUSVRJT05cIix0W3QuUkVQRVRJVElPTl9NQU5EQVRPUlk9Ml09XCJSRVBFVElUSU9OX01BTkRBVE9SWVwiLHRbdC5SRVBFVElUSU9OX01BTkRBVE9SWV9XSVRIX1NFUEFSQVRPUj0zXT1cIlJFUEVUSVRJT05fTUFOREFUT1JZX1dJVEhfU0VQQVJBVE9SXCIsdFt0LlJFUEVUSVRJT05fV0lUSF9TRVBBUkFUT1I9NF09XCJSRVBFVElUSU9OX1dJVEhfU0VQQVJBVE9SXCIsdFt0LkFMVEVSTkFUSU9OPTVdPVwiQUxURVJOQVRJT05cIjt9KG89ZS5QUk9EX1RZUEV8fChlLlBST0RfVFlQRT17fSkpLGUuZ2V0UHJvZFR5cGU9ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIHAuT3B0aW9uKXJldHVybiBvLk9QVElPTjtpZih0IGluc3RhbmNlb2YgcC5SZXBldGl0aW9uKXJldHVybiBvLlJFUEVUSVRJT047aWYodCBpbnN0YW5jZW9mIHAuUmVwZXRpdGlvbk1hbmRhdG9yeSlyZXR1cm4gby5SRVBFVElUSU9OX01BTkRBVE9SWTtpZih0IGluc3RhbmNlb2YgcC5SZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcilyZXR1cm4gby5SRVBFVElUSU9OX01BTkRBVE9SWV9XSVRIX1NFUEFSQVRPUjtpZih0IGluc3RhbmNlb2YgcC5SZXBldGl0aW9uV2l0aFNlcGFyYXRvcilyZXR1cm4gby5SRVBFVElUSU9OX1dJVEhfU0VQQVJBVE9SO2lmKHQgaW5zdGFuY2VvZiBwLkFsdGVybmF0aW9uKXJldHVybiBvLkFMVEVSTkFUSU9OO3Rocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIil9LGUuYnVpbGRMb29rYWhlYWRGdW5jRm9yT3I9ZnVuY3Rpb24odCxlLG4scixpLG8pe3ZhciBhPUUodCxlLG4pO3JldHVybiBvKGEscixUKGEpP2MudG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlck5vQ2F0ZWdvcmllczpjLnRva2VuU3RydWN0dXJlZE1hdGNoZXIsaSl9LGUuYnVpbGRMb29rYWhlYWRGdW5jRm9yT3B0aW9uYWxQcm9kPWZ1bmN0aW9uKHQsZSxuLHIsaSxvKXt2YXIgYT1tKHQsZSxpLG4pLHM9VChhKT9jLnRva2VuU3RydWN0dXJlZE1hdGNoZXJOb0NhdGVnb3JpZXM6Yy50b2tlblN0cnVjdHVyZWRNYXRjaGVyO3JldHVybiBvKGFbMF0scyxyKX0sZS5idWlsZEFsdGVybmF0aXZlc0xvb2tBaGVhZEZ1bmM9ZnVuY3Rpb24odCxlLG4scil7dmFyIGk9dC5sZW5ndGgsbz1hLmV2ZXJ5KHQsZnVuY3Rpb24odCl7cmV0dXJuIGEuZXZlcnkodCxmdW5jdGlvbih0KXtyZXR1cm4gMT09PXQubGVuZ3RofSl9KTtpZihlKXJldHVybiBmdW5jdGlvbihlKXtmb3IodmFyIHI9YS5tYXAoZSxmdW5jdGlvbih0KXtyZXR1cm4gdC5HQVRFfSksbz0wO288aTtvKyspe3ZhciBzPXRbb10sdT1zLmxlbmd0aCxjPXJbb107aWYodm9pZCAwPT09Y3x8ITEhPT1jLmNhbGwodGhpcykpdDpmb3IodmFyIHA9MDtwPHU7cCsrKXtmb3IodmFyIGw9c1twXSxoPWwubGVuZ3RoLGY9MDtmPGg7ZisrKXt2YXIgZD10aGlzLkxBKGYrMSk7aWYoITE9PT1uKGQsbFtmXSkpY29udGludWUgdH1yZXR1cm4gb319fTtpZihvJiYhcil7dmFyIHM9YS5tYXAodCxmdW5jdGlvbih0KXtyZXR1cm4gYS5mbGF0dGVuKHQpfSksdT1hLnJlZHVjZShzLGZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gYS5mb3JFYWNoKGUsZnVuY3Rpb24oZSl7YS5oYXModCxlLnRva2VuVHlwZUlkeCl8fCh0W2UudG9rZW5UeXBlSWR4XT1uKSxhLmZvckVhY2goZS5jYXRlZ29yeU1hdGNoZXMsZnVuY3Rpb24oZSl7YS5oYXModCxlKXx8KHRbZV09bik7fSk7fSksdH0sW10pO3JldHVybiBmdW5jdGlvbigpe3ZhciB0PXRoaXMuTEEoMSk7cmV0dXJuIHVbdC50b2tlblR5cGVJZHhdfX1yZXR1cm4gZnVuY3Rpb24oKXtmb3IodmFyIGU9MDtlPGk7ZSsrKXt2YXIgcj10W2VdLG89ci5sZW5ndGg7dDpmb3IodmFyIGE9MDthPG87YSsrKXtmb3IodmFyIHM9clthXSx1PXMubGVuZ3RoLGM9MDtjPHU7YysrKXt2YXIgcD10aGlzLkxBKGMrMSk7aWYoITE9PT1uKHAsc1tjXSkpY29udGludWUgdH1yZXR1cm4gZX19fX0sZS5idWlsZFNpbmdsZUFsdGVybmF0aXZlTG9va2FoZWFkRnVuY3Rpb249ZnVuY3Rpb24odCxlLG4pe3ZhciByPWEuZXZlcnkodCxmdW5jdGlvbih0KXtyZXR1cm4gMT09PXQubGVuZ3RofSksaT10Lmxlbmd0aDtpZihyJiYhbil7dmFyIG89YS5mbGF0dGVuKHQpO2lmKDE9PT1vLmxlbmd0aCYmYS5pc0VtcHR5KG9bMF0uY2F0ZWdvcnlNYXRjaGVzKSl7dmFyIHM9b1swXS50b2tlblR5cGVJZHg7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuTEEoMSkudG9rZW5UeXBlSWR4PT09c319dmFyIHU9YS5yZWR1Y2UobyxmdW5jdGlvbih0LGUsbil7cmV0dXJuIHRbZS50b2tlblR5cGVJZHhdPSEwLGEuZm9yRWFjaChlLmNhdGVnb3J5TWF0Y2hlcyxmdW5jdGlvbihlKXt0W2VdPSEwO30pLHR9LFtdKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgdD10aGlzLkxBKDEpO3JldHVybiAhMD09PXVbdC50b2tlblR5cGVJZHhdfX1yZXR1cm4gZnVuY3Rpb24oKXt0OmZvcih2YXIgbj0wO248aTtuKyspe2Zvcih2YXIgcj10W25dLG89ci5sZW5ndGgsYT0wO2E8bzthKyspe3ZhciBzPXRoaXMuTEEoYSsxKTtpZighMT09PWUocyxyW2FdKSljb250aW51ZSB0fXJldHVybiAhMH1yZXR1cm4gITF9fTt2YXIgaD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUsbixyKXt2YXIgaT10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIGkudG9wUHJvZD1lLGkudGFyZ2V0T2NjdXJyZW5jZT1uLGkudGFyZ2V0UHJvZFR5cGU9cixpfXJldHVybiBpKGUsdCksZS5wcm90b3R5cGUuc3RhcnRXYWxraW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMud2Fsayh0aGlzLnRvcFByb2QpLHRoaXMucmVzdERlZn0sZS5wcm90b3R5cGUuY2hlY2tJc1RhcmdldD1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gdC5pZHg9PT10aGlzLnRhcmdldE9jY3VycmVuY2UmJnRoaXMudGFyZ2V0UHJvZFR5cGU9PT1lJiYodGhpcy5yZXN0RGVmPW4uY29uY2F0KHIpLCEwKX0sZS5wcm90b3R5cGUud2Fsa09wdGlvbj1mdW5jdGlvbihlLG4scil7dGhpcy5jaGVja0lzVGFyZ2V0KGUsby5PUFRJT04sbixyKXx8dC5wcm90b3R5cGUud2Fsa09wdGlvbi5jYWxsKHRoaXMsZSxuLHIpO30sZS5wcm90b3R5cGUud2Fsa0F0TGVhc3RPbmU9ZnVuY3Rpb24oZSxuLHIpe3RoaXMuY2hlY2tJc1RhcmdldChlLG8uUkVQRVRJVElPTl9NQU5EQVRPUlksbixyKXx8dC5wcm90b3R5cGUud2Fsa09wdGlvbi5jYWxsKHRoaXMsZSxuLHIpO30sZS5wcm90b3R5cGUud2Fsa0F0TGVhc3RPbmVTZXA9ZnVuY3Rpb24oZSxuLHIpe3RoaXMuY2hlY2tJc1RhcmdldChlLG8uUkVQRVRJVElPTl9NQU5EQVRPUllfV0lUSF9TRVBBUkFUT1IsbixyKXx8dC5wcm90b3R5cGUud2Fsa09wdGlvbi5jYWxsKHRoaXMsZSxuLHIpO30sZS5wcm90b3R5cGUud2Fsa01hbnk9ZnVuY3Rpb24oZSxuLHIpe3RoaXMuY2hlY2tJc1RhcmdldChlLG8uUkVQRVRJVElPTixuLHIpfHx0LnByb3RvdHlwZS53YWxrT3B0aW9uLmNhbGwodGhpcyxlLG4scik7fSxlLnByb3RvdHlwZS53YWxrTWFueVNlcD1mdW5jdGlvbihlLG4scil7dGhpcy5jaGVja0lzVGFyZ2V0KGUsby5SRVBFVElUSU9OX1dJVEhfU0VQQVJBVE9SLG4scil8fHQucHJvdG90eXBlLndhbGtPcHRpb24uY2FsbCh0aGlzLGUsbixyKTt9LGV9KHUuUmVzdFdhbGtlciksZj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUsbil7dmFyIHI9dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiByLnRhcmdldE9jY3VycmVuY2U9ZSxyLnRhcmdldFByb2RUeXBlPW4sci5yZXN1bHQ9W10scn1yZXR1cm4gaShlLHQpLGUucHJvdG90eXBlLmNoZWNrSXNUYXJnZXQ9ZnVuY3Rpb24odCxlKXt0LmlkeD09PXRoaXMudGFyZ2V0T2NjdXJyZW5jZSYmdGhpcy50YXJnZXRQcm9kVHlwZT09PWUmJih0aGlzLnJlc3VsdD10LmRlZmluaXRpb24pO30sZS5wcm90b3R5cGUudmlzaXRPcHRpb249ZnVuY3Rpb24odCl7dGhpcy5jaGVja0lzVGFyZ2V0KHQsby5PUFRJT04pO30sZS5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uPWZ1bmN0aW9uKHQpe3RoaXMuY2hlY2tJc1RhcmdldCh0LG8uUkVQRVRJVElPTik7fSxlLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnk9ZnVuY3Rpb24odCl7dGhpcy5jaGVja0lzVGFyZ2V0KHQsby5SRVBFVElUSU9OX01BTkRBVE9SWSk7fSxlLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yPWZ1bmN0aW9uKHQpe3RoaXMuY2hlY2tJc1RhcmdldCh0LG8uUkVQRVRJVElPTl9NQU5EQVRPUllfV0lUSF9TRVBBUkFUT1IpO30sZS5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uV2l0aFNlcGFyYXRvcj1mdW5jdGlvbih0KXt0aGlzLmNoZWNrSXNUYXJnZXQodCxvLlJFUEVUSVRJT05fV0lUSF9TRVBBUkFUT1IpO30sZS5wcm90b3R5cGUudmlzaXRBbHRlcm5hdGlvbj1mdW5jdGlvbih0KXt0aGlzLmNoZWNrSXNUYXJnZXQodCxvLkFMVEVSTkFUSU9OKTt9LGV9KGwuR0FzdFZpc2l0b3IpO2Z1bmN0aW9uIGQodCxlKXtmdW5jdGlvbiBuKHQsZSl7cmV0dXJuIGEucmVkdWNlKHQsZnVuY3Rpb24odCxuLHIpe2lmKHIhPT1lKXt2YXIgaT1hLm1hcChuLGZ1bmN0aW9uKHQpe3JldHVybiB0LnBhcnRpYWxQYXRofSk7cmV0dXJuIHQuY29uY2F0KGkpfXJldHVybiB0fSxbXSl9ZnVuY3Rpb24gcih0LGUpe3JldHVybiB2b2lkIDA9PT1hLmZpbmQodCxmdW5jdGlvbih0KXtyZXR1cm4gYS5ldmVyeShlLGZ1bmN0aW9uKGUsbil7cmV0dXJuIHI9ZSxpPXRbbl0scj09PWl8fHImJmkmJihyLmNhdGVnb3J5TWF0Y2hlc01hcFtpLnRva2VuVHlwZUlkeF18fGkuY2F0ZWdvcnlNYXRjaGVzTWFwW3IudG9rZW5UeXBlSWR4XSk7dmFyIHIsaTt9KX0pfWZ1bmN0aW9uIGkodCl7Zm9yKHZhciBlPVtdLG49MDtuPHQ7bisrKWUucHVzaChbXSk7cmV0dXJuIGV9Zm9yKHZhciBvPWEubWFwKHQsZnVuY3Rpb24odCl7cmV0dXJuIHMucG9zc2libGVQYXRoc0Zyb20oW3RdLDEpfSksdT1pKG8ubGVuZ3RoKSxjPW8scD0xO3A8PWU7cCsrKXt2YXIgbD1jO2M9aShsLmxlbmd0aCk7Zm9yKHZhciBoPTA7aDxsLmxlbmd0aDtoKyspZm9yKHZhciBmPWxbaF0sZD1uKGwsaCksRT0wO0U8Zi5sZW5ndGg7RSsrKXt2YXIgbT1mW0VdLnBhcnRpYWxQYXRoLFQ9ZltFXS5zdWZmaXhEZWY7aWYocihkLG0pfHxhLmlzRW1wdHkoVCl8fG0ubGVuZ3RoPT09ZSl7dmFyIHY9dVtoXTt5KHYsbSl8fHYucHVzaChtKTt9ZWxzZSB7dmFyIGc9cy5wb3NzaWJsZVBhdGhzRnJvbShULHArMSxtKTtjW2hdPWNbaF0uY29uY2F0KGcpO319fXJldHVybiB1fWZ1bmN0aW9uIEUodCxlLG4pe3ZhciByPW5ldyBmKHQsby5BTFRFUk5BVElPTik7cmV0dXJuIGUuYWNjZXB0KHIpLGQoci5yZXN1bHQsbil9ZnVuY3Rpb24gbSh0LGUsbixyKXt2YXIgaT1uZXcgZih0LG4pO2UuYWNjZXB0KGkpO3ZhciBvPWkucmVzdWx0LGE9bmV3IGgoZSx0LG4pLnN0YXJ0V2Fsa2luZygpO3JldHVybiBkKFtuZXcgcC5GbGF0KHtkZWZpbml0aW9uOm99KSxuZXcgcC5GbGF0KHtkZWZpbml0aW9uOmF9KV0scil9ZnVuY3Rpb24geSh0LGUpe3JldHVybiB2b2lkIDAhPT1hLmZpbmQodCxmdW5jdGlvbih0KXtyZXR1cm4gZS5sZW5ndGg9PT10Lmxlbmd0aCYmYS5ldmVyeShlLGZ1bmN0aW9uKGUsbil7cmV0dXJuIGU9PT10W25dfHx0W25dLmNhdGVnb3J5TWF0Y2hlc01hcFtlLnRva2VuVHlwZUlkeF19KX0pfWZ1bmN0aW9uIFQodCl7cmV0dXJuIGEuZXZlcnkodCxmdW5jdGlvbih0KXtyZXR1cm4gYS5ldmVyeSh0LGZ1bmN0aW9uKHQpe3JldHVybiBhLmV2ZXJ5KHQsZnVuY3Rpb24odCl7cmV0dXJuIGEuaXNFbXB0eSh0LmNhdGVnb3J5TWF0Y2hlcyl9KX0pfSl9ZS5sb29rQWhlYWRTZXF1ZW5jZUZyb21BbHRlcm5hdGl2ZXM9ZCxlLmdldExvb2thaGVhZFBhdGhzRm9yT3I9RSxlLmdldExvb2thaGVhZFBhdGhzRm9yT3B0aW9uYWxQcm9kPW0sZS5jb250YWluc1BhdGg9eSxlLmlzU3RyaWN0UHJlZml4T2ZQYXRoPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQubGVuZ3RoPGUubGVuZ3RoJiZhLmV2ZXJ5KHQsZnVuY3Rpb24odCxuKXt2YXIgcj1lW25dO3JldHVybiB0PT09cnx8ci5jYXRlZ29yeU1hdGNoZXNNYXBbdC50b2tlblR5cGVJZHhdfSl9LGUuYXJlVG9rZW5DYXRlZ29yaWVzTm90VXNlZD1UO30sZnVuY3Rpb24odCxlLG4pe3ZhciByLGk9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fChyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIChyPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbih0LGUpe3QuX19wcm90b19fPWU7fXx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIG4gaW4gZSllLmhhc093blByb3BlcnR5KG4pJiYodFtuXT1lW25dKTt9KSh0LGUpfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4oKXt0aGlzLmNvbnN0cnVjdG9yPXQ7fXIodCxlKSx0LnByb3RvdHlwZT1udWxsPT09ZT9PYmplY3QuY3JlYXRlKGUpOihuLnByb3RvdHlwZT1lLnByb3RvdHlwZSxuZXcgbik7fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG89bigxNCksYT1uKDApLHM9bigyKSx1PW4oMjEpLGM9bigxKSxwPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxuKXt2YXIgcj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIHIudG9wUHJvZD1lLHIucGF0aD1uLHIucG9zc2libGVUb2tUeXBlcz1bXSxyLm5leHRQcm9kdWN0aW9uTmFtZT1cIlwiLHIubmV4dFByb2R1Y3Rpb25PY2N1cnJlbmNlPTAsci5mb3VuZD0hMSxyLmlzQXRFbmRPZlBhdGg9ITEscn1yZXR1cm4gaShlLHQpLGUucHJvdG90eXBlLnN0YXJ0V2Fsa2luZz1mdW5jdGlvbigpe2lmKHRoaXMuZm91bmQ9ITEsdGhpcy5wYXRoLnJ1bGVTdGFja1swXSE9PXRoaXMudG9wUHJvZC5uYW1lKXRocm93IEVycm9yKFwiVGhlIHBhdGggZG9lcyBub3Qgc3RhcnQgd2l0aCB0aGUgd2Fsa2VyJ3MgdG9wIFJ1bGUhXCIpO3JldHVybiB0aGlzLnJ1bGVTdGFjaz1hLmNsb25lQXJyKHRoaXMucGF0aC5ydWxlU3RhY2spLnJldmVyc2UoKSx0aGlzLm9jY3VycmVuY2VTdGFjaz1hLmNsb25lQXJyKHRoaXMucGF0aC5vY2N1cnJlbmNlU3RhY2spLnJldmVyc2UoKSx0aGlzLnJ1bGVTdGFjay5wb3AoKSx0aGlzLm9jY3VycmVuY2VTdGFjay5wb3AoKSx0aGlzLnVwZGF0ZUV4cGVjdGVkTmV4dCgpLHRoaXMud2Fsayh0aGlzLnRvcFByb2QpLHRoaXMucG9zc2libGVUb2tUeXBlc30sZS5wcm90b3R5cGUud2Fsaz1mdW5jdGlvbihlLG4pe3ZvaWQgMD09PW4mJihuPVtdKSx0aGlzLmZvdW5kfHx0LnByb3RvdHlwZS53YWxrLmNhbGwodGhpcyxlLG4pO30sZS5wcm90b3R5cGUud2Fsa1Byb2RSZWY9ZnVuY3Rpb24odCxlLG4pe2lmKHQucmVmZXJlbmNlZFJ1bGUubmFtZT09PXRoaXMubmV4dFByb2R1Y3Rpb25OYW1lJiZ0LmlkeD09PXRoaXMubmV4dFByb2R1Y3Rpb25PY2N1cnJlbmNlKXt2YXIgcj1lLmNvbmNhdChuKTt0aGlzLnVwZGF0ZUV4cGVjdGVkTmV4dCgpLHRoaXMud2Fsayh0LnJlZmVyZW5jZWRSdWxlLHIpO319LGUucHJvdG90eXBlLnVwZGF0ZUV4cGVjdGVkTmV4dD1mdW5jdGlvbigpe2EuaXNFbXB0eSh0aGlzLnJ1bGVTdGFjayk/KHRoaXMubmV4dFByb2R1Y3Rpb25OYW1lPVwiXCIsdGhpcy5uZXh0UHJvZHVjdGlvbk9jY3VycmVuY2U9MCx0aGlzLmlzQXRFbmRPZlBhdGg9ITApOih0aGlzLm5leHRQcm9kdWN0aW9uTmFtZT10aGlzLnJ1bGVTdGFjay5wb3AoKSx0aGlzLm5leHRQcm9kdWN0aW9uT2NjdXJyZW5jZT10aGlzLm9jY3VycmVuY2VTdGFjay5wb3AoKSk7fSxlfShvLlJlc3RXYWxrZXIpO2UuQWJzdHJhY3ROZXh0UG9zc2libGVUb2tlbnNXYWxrZXI9cDt2YXIgbD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUsbil7dmFyIHI9dC5jYWxsKHRoaXMsZSxuKXx8dGhpcztyZXR1cm4gci5wYXRoPW4sci5uZXh0VGVybWluYWxOYW1lPVwiXCIsci5uZXh0VGVybWluYWxPY2N1cnJlbmNlPTAsci5uZXh0VGVybWluYWxOYW1lPXMudG9rZW5OYW1lKHIucGF0aC5sYXN0VG9rKSxyLm5leHRUZXJtaW5hbE9jY3VycmVuY2U9ci5wYXRoLmxhc3RUb2tPY2N1cnJlbmNlLHJ9cmV0dXJuIGkoZSx0KSxlLnByb3RvdHlwZS53YWxrVGVybWluYWw9ZnVuY3Rpb24odCxlLG4pe2lmKHRoaXMuaXNBdEVuZE9mUGF0aCYmcy50b2tlbk5hbWUodC50ZXJtaW5hbFR5cGUpPT09dGhpcy5uZXh0VGVybWluYWxOYW1lJiZ0LmlkeD09PXRoaXMubmV4dFRlcm1pbmFsT2NjdXJyZW5jZSYmIXRoaXMuZm91bmQpe3ZhciByPWUuY29uY2F0KG4pLGk9bmV3IGMuRmxhdCh7ZGVmaW5pdGlvbjpyfSk7dGhpcy5wb3NzaWJsZVRva1R5cGVzPXUuZmlyc3QoaSksdGhpcy5mb3VuZD0hMDt9fSxlfShwKTtlLk5leHRBZnRlclRva2VuV2Fsa2VyPWw7dmFyIGg9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLG4pe3ZhciByPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gci50b3BSdWxlPWUsci5vY2N1cnJlbmNlPW4sci5yZXN1bHQ9e3Rva2VuOnZvaWQgMCxvY2N1cnJlbmNlOnZvaWQgMCxpc0VuZE9mUnVsZTp2b2lkIDB9LHJ9cmV0dXJuIGkoZSx0KSxlLnByb3RvdHlwZS5zdGFydFdhbGtpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy53YWxrKHRoaXMudG9wUnVsZSksdGhpcy5yZXN1bHR9LGV9KG8uUmVzdFdhbGtlcik7ZS5BYnN0cmFjdE5leHRUZXJtaW5hbEFmdGVyUHJvZHVjdGlvbldhbGtlcj1oO3ZhciBmPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gbnVsbCE9PXQmJnQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBpKGUsdCksZS5wcm90b3R5cGUud2Fsa01hbnk9ZnVuY3Rpb24oZSxuLHIpe2lmKGUuaWR4PT09dGhpcy5vY2N1cnJlbmNlKXt2YXIgaT1hLmZpcnN0KG4uY29uY2F0KHIpKTt0aGlzLnJlc3VsdC5pc0VuZE9mUnVsZT12b2lkIDA9PT1pLGkgaW5zdGFuY2VvZiBjLlRlcm1pbmFsJiYodGhpcy5yZXN1bHQudG9rZW49aS50ZXJtaW5hbFR5cGUsdGhpcy5yZXN1bHQub2NjdXJyZW5jZT1pLmlkeCk7fWVsc2UgdC5wcm90b3R5cGUud2Fsa01hbnkuY2FsbCh0aGlzLGUsbixyKTt9LGV9KGgpO2UuTmV4dFRlcm1pbmFsQWZ0ZXJNYW55V2Fsa2VyPWY7dmFyIGQ9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3JldHVybiBudWxsIT09dCYmdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIGkoZSx0KSxlLnByb3RvdHlwZS53YWxrTWFueVNlcD1mdW5jdGlvbihlLG4scil7aWYoZS5pZHg9PT10aGlzLm9jY3VycmVuY2Upe3ZhciBpPWEuZmlyc3Qobi5jb25jYXQocikpO3RoaXMucmVzdWx0LmlzRW5kT2ZSdWxlPXZvaWQgMD09PWksaSBpbnN0YW5jZW9mIGMuVGVybWluYWwmJih0aGlzLnJlc3VsdC50b2tlbj1pLnRlcm1pbmFsVHlwZSx0aGlzLnJlc3VsdC5vY2N1cnJlbmNlPWkuaWR4KTt9ZWxzZSB0LnByb3RvdHlwZS53YWxrTWFueVNlcC5jYWxsKHRoaXMsZSxuLHIpO30sZX0oaCk7ZS5OZXh0VGVybWluYWxBZnRlck1hbnlTZXBXYWxrZXI9ZDt2YXIgRT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cmV0dXJuIG51bGwhPT10JiZ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gaShlLHQpLGUucHJvdG90eXBlLndhbGtBdExlYXN0T25lPWZ1bmN0aW9uKGUsbixyKXtpZihlLmlkeD09PXRoaXMub2NjdXJyZW5jZSl7dmFyIGk9YS5maXJzdChuLmNvbmNhdChyKSk7dGhpcy5yZXN1bHQuaXNFbmRPZlJ1bGU9dm9pZCAwPT09aSxpIGluc3RhbmNlb2YgYy5UZXJtaW5hbCYmKHRoaXMucmVzdWx0LnRva2VuPWkudGVybWluYWxUeXBlLHRoaXMucmVzdWx0Lm9jY3VycmVuY2U9aS5pZHgpO31lbHNlIHQucHJvdG90eXBlLndhbGtBdExlYXN0T25lLmNhbGwodGhpcyxlLG4scik7fSxlfShoKTtlLk5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVdhbGtlcj1FO3ZhciBtPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gbnVsbCE9PXQmJnQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBpKGUsdCksZS5wcm90b3R5cGUud2Fsa0F0TGVhc3RPbmVTZXA9ZnVuY3Rpb24oZSxuLHIpe2lmKGUuaWR4PT09dGhpcy5vY2N1cnJlbmNlKXt2YXIgaT1hLmZpcnN0KG4uY29uY2F0KHIpKTt0aGlzLnJlc3VsdC5pc0VuZE9mUnVsZT12b2lkIDA9PT1pLGkgaW5zdGFuY2VvZiBjLlRlcm1pbmFsJiYodGhpcy5yZXN1bHQudG9rZW49aS50ZXJtaW5hbFR5cGUsdGhpcy5yZXN1bHQub2NjdXJyZW5jZT1pLmlkeCk7fWVsc2UgdC5wcm90b3R5cGUud2Fsa0F0TGVhc3RPbmVTZXAuY2FsbCh0aGlzLGUsbixyKTt9LGV9KGgpO2Z1bmN0aW9uIHkodCxlLG4scil7dmFyIGk9YS5jbG9uZUFycihuKTtpLnB1c2godC5uYW1lKTt2YXIgbz1hLmNsb25lQXJyKHIpO3JldHVybiBvLnB1c2goMSkse2lkeDplLGRlZjp0LmRlZmluaXRpb24scnVsZVN0YWNrOmksb2NjdXJyZW5jZVN0YWNrOm99fWUuTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lU2VwV2Fsa2VyPW0sZS5wb3NzaWJsZVBhdGhzRnJvbT1mdW5jdGlvbiB0KGUsbixyKXt2b2lkIDA9PT1yJiYocj1bXSkscj1hLmNsb25lQXJyKHIpO3ZhciBpPVtdLG89MDtmdW5jdGlvbiBzKHMpe3ZhciB1PXQocy5jb25jYXQoYS5kcm9wKGUsbysxKSksbixyKTtyZXR1cm4gaS5jb25jYXQodSl9Zm9yKDtyLmxlbmd0aDxuJiZvPGUubGVuZ3RoOyl7dmFyIHU9ZVtvXTtpZih1IGluc3RhbmNlb2YgYy5GbGF0KXJldHVybiBzKHUuZGVmaW5pdGlvbik7aWYodSBpbnN0YW5jZW9mIGMuTm9uVGVybWluYWwpcmV0dXJuIHModS5kZWZpbml0aW9uKTtpZih1IGluc3RhbmNlb2YgYy5PcHRpb24paT1zKHUuZGVmaW5pdGlvbik7ZWxzZSB7aWYodSBpbnN0YW5jZW9mIGMuUmVwZXRpdGlvbk1hbmRhdG9yeSlyZXR1cm4gcyhwPXUuZGVmaW5pdGlvbi5jb25jYXQoW25ldyBjLlJlcGV0aXRpb24oe2RlZmluaXRpb246dS5kZWZpbml0aW9ufSldKSk7aWYodSBpbnN0YW5jZW9mIGMuUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IpcmV0dXJuIHMocD1bbmV3IGMuRmxhdCh7ZGVmaW5pdGlvbjp1LmRlZmluaXRpb259KSxuZXcgYy5SZXBldGl0aW9uKHtkZWZpbml0aW9uOltuZXcgYy5UZXJtaW5hbCh7dGVybWluYWxUeXBlOnUuc2VwYXJhdG9yfSldLmNvbmNhdCh1LmRlZmluaXRpb24pfSldKTtpZih1IGluc3RhbmNlb2YgYy5SZXBldGl0aW9uV2l0aFNlcGFyYXRvcil7dmFyIHA9dS5kZWZpbml0aW9uLmNvbmNhdChbbmV3IGMuUmVwZXRpdGlvbih7ZGVmaW5pdGlvbjpbbmV3IGMuVGVybWluYWwoe3Rlcm1pbmFsVHlwZTp1LnNlcGFyYXRvcn0pXS5jb25jYXQodS5kZWZpbml0aW9uKX0pXSk7aT1zKHApO31lbHNlIGlmKHUgaW5zdGFuY2VvZiBjLlJlcGV0aXRpb24pcD11LmRlZmluaXRpb24uY29uY2F0KFtuZXcgYy5SZXBldGl0aW9uKHtkZWZpbml0aW9uOnUuZGVmaW5pdGlvbn0pXSksaT1zKHApO2Vsc2Uge2lmKHUgaW5zdGFuY2VvZiBjLkFsdGVybmF0aW9uKXJldHVybiBhLmZvckVhY2godS5kZWZpbml0aW9uLGZ1bmN0aW9uKHQpe2k9cyh0LmRlZmluaXRpb24pO30pLGk7aWYoISh1IGluc3RhbmNlb2YgYy5UZXJtaW5hbCkpdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtyLnB1c2godS50ZXJtaW5hbFR5cGUpO319bysrO31yZXR1cm4gaS5wdXNoKHtwYXJ0aWFsUGF0aDpyLHN1ZmZpeERlZjphLmRyb3AoZSxvKX0pLGl9LGUubmV4dFBvc3NpYmxlVG9rZW5zQWZ0ZXI9ZnVuY3Rpb24odCxlLG4scil7dmFyIGk9W1wiRVhJVF9OT05FX1RFUk1JTkFMXCJdLG89ITEscz1lLmxlbmd0aCx1PXMtci0xLHA9W10sbD1bXTtmb3IobC5wdXNoKHtpZHg6LTEsZGVmOnQscnVsZVN0YWNrOltdLG9jY3VycmVuY2VTdGFjazpbXX0pOyFhLmlzRW1wdHkobCk7KXt2YXIgaD1sLnBvcCgpO2lmKFwiRVhJVF9BTFRFUk5BVElWRVwiIT09aCl7dmFyIGY9aC5kZWYsZD1oLmlkeCxFPWgucnVsZVN0YWNrLG09aC5vY2N1cnJlbmNlU3RhY2s7aWYoIWEuaXNFbXB0eShmKSl7dmFyIFQ9ZlswXTtpZihcIkVYSVRfTk9ORV9URVJNSU5BTFwiPT09VCl7dmFyIHY9e2lkeDpkLGRlZjphLmRyb3AoZikscnVsZVN0YWNrOmEuZHJvcFJpZ2h0KEUpLG9jY3VycmVuY2VTdGFjazphLmRyb3BSaWdodChtKX07bC5wdXNoKHYpO31lbHNlIGlmKFQgaW5zdGFuY2VvZiBjLlRlcm1pbmFsKWlmKGQ8cy0xKXt2YXIgZz1kKzE7bihlW2ddLFQudGVybWluYWxUeXBlKSYmKHY9e2lkeDpnLGRlZjphLmRyb3AoZikscnVsZVN0YWNrOkUsb2NjdXJyZW5jZVN0YWNrOm19LGwucHVzaCh2KSk7fWVsc2Uge2lmKGQhPT1zLTEpdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtwLnB1c2goe25leHRUb2tlblR5cGU6VC50ZXJtaW5hbFR5cGUsbmV4dFRva2VuT2NjdXJyZW5jZTpULmlkeCxydWxlU3RhY2s6RSxvY2N1cnJlbmNlU3RhY2s6bX0pLG89ITA7fWVsc2UgaWYoVCBpbnN0YW5jZW9mIGMuTm9uVGVybWluYWwpe3ZhciBfPWEuY2xvbmVBcnIoRSk7Xy5wdXNoKFQubm9uVGVybWluYWxOYW1lKTt2YXIgUj1hLmNsb25lQXJyKG0pO1IucHVzaChULmlkeCksdj17aWR4OmQsZGVmOlQuZGVmaW5pdGlvbi5jb25jYXQoaSxhLmRyb3AoZikpLHJ1bGVTdGFjazpfLG9jY3VycmVuY2VTdGFjazpSfSxsLnB1c2godik7fWVsc2UgaWYoVCBpbnN0YW5jZW9mIGMuT3B0aW9uKXt2YXIgQT17aWR4OmQsZGVmOmEuZHJvcChmKSxydWxlU3RhY2s6RSxvY2N1cnJlbmNlU3RhY2s6bX07bC5wdXNoKEEpLGwucHVzaChcIkVYSVRfQUxURVJOQVRJVkVcIik7dmFyIE49e2lkeDpkLGRlZjpULmRlZmluaXRpb24uY29uY2F0KGEuZHJvcChmKSkscnVsZVN0YWNrOkUsb2NjdXJyZW5jZVN0YWNrOm19O2wucHVzaChOKTt9ZWxzZSBpZihUIGluc3RhbmNlb2YgYy5SZXBldGl0aW9uTWFuZGF0b3J5KXt2YXIgTz1uZXcgYy5SZXBldGl0aW9uKHtkZWZpbml0aW9uOlQuZGVmaW5pdGlvbixpZHg6VC5pZHh9KTt2PXtpZHg6ZCxkZWY6VC5kZWZpbml0aW9uLmNvbmNhdChbT10sYS5kcm9wKGYpKSxydWxlU3RhY2s6RSxvY2N1cnJlbmNlU3RhY2s6bX0sbC5wdXNoKHYpO31lbHNlIGlmKFQgaW5zdGFuY2VvZiBjLlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yKXt2YXIgUz1uZXcgYy5UZXJtaW5hbCh7dGVybWluYWxUeXBlOlQuc2VwYXJhdG9yfSk7Tz1uZXcgYy5SZXBldGl0aW9uKHtkZWZpbml0aW9uOltTXS5jb25jYXQoVC5kZWZpbml0aW9uKSxpZHg6VC5pZHh9KSx2PXtpZHg6ZCxkZWY6VC5kZWZpbml0aW9uLmNvbmNhdChbT10sYS5kcm9wKGYpKSxydWxlU3RhY2s6RSxvY2N1cnJlbmNlU3RhY2s6bX0sbC5wdXNoKHYpO31lbHNlIGlmKFQgaW5zdGFuY2VvZiBjLlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKXtBPXtpZHg6ZCxkZWY6YS5kcm9wKGYpLHJ1bGVTdGFjazpFLG9jY3VycmVuY2VTdGFjazptfSxsLnB1c2goQSksbC5wdXNoKFwiRVhJVF9BTFRFUk5BVElWRVwiKSxTPW5ldyBjLlRlcm1pbmFsKHt0ZXJtaW5hbFR5cGU6VC5zZXBhcmF0b3J9KTt2YXIgST1uZXcgYy5SZXBldGl0aW9uKHtkZWZpbml0aW9uOltTXS5jb25jYXQoVC5kZWZpbml0aW9uKSxpZHg6VC5pZHh9KTtOPXtpZHg6ZCxkZWY6VC5kZWZpbml0aW9uLmNvbmNhdChbSV0sYS5kcm9wKGYpKSxydWxlU3RhY2s6RSxvY2N1cnJlbmNlU3RhY2s6bX0sbC5wdXNoKE4pO31lbHNlIGlmKFQgaW5zdGFuY2VvZiBjLlJlcGV0aXRpb24pQT17aWR4OmQsZGVmOmEuZHJvcChmKSxydWxlU3RhY2s6RSxvY2N1cnJlbmNlU3RhY2s6bX0sbC5wdXNoKEEpLGwucHVzaChcIkVYSVRfQUxURVJOQVRJVkVcIiksST1uZXcgYy5SZXBldGl0aW9uKHtkZWZpbml0aW9uOlQuZGVmaW5pdGlvbixpZHg6VC5pZHh9KSxOPXtpZHg6ZCxkZWY6VC5kZWZpbml0aW9uLmNvbmNhdChbSV0sYS5kcm9wKGYpKSxydWxlU3RhY2s6RSxvY2N1cnJlbmNlU3RhY2s6bX0sbC5wdXNoKE4pO2Vsc2UgaWYoVCBpbnN0YW5jZW9mIGMuQWx0ZXJuYXRpb24pZm9yKHZhciBMPVQuZGVmaW5pdGlvbi5sZW5ndGgtMTtMPj0wO0wtLSl7dmFyIGs9e2lkeDpkLGRlZjpULmRlZmluaXRpb25bTF0uZGVmaW5pdGlvbi5jb25jYXQoYS5kcm9wKGYpKSxydWxlU3RhY2s6RSxvY2N1cnJlbmNlU3RhY2s6bX07bC5wdXNoKGspLGwucHVzaChcIkVYSVRfQUxURVJOQVRJVkVcIik7fWVsc2UgaWYoVCBpbnN0YW5jZW9mIGMuRmxhdClsLnB1c2goe2lkeDpkLGRlZjpULmRlZmluaXRpb24uY29uY2F0KGEuZHJvcChmKSkscnVsZVN0YWNrOkUsb2NjdXJyZW5jZVN0YWNrOm19KTtlbHNlIHtpZighKFQgaW5zdGFuY2VvZiBjLlJ1bGUpKXRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7bC5wdXNoKHkoVCxkLEUsbSkpO319fWVsc2UgbyYmYS5sYXN0KGwpLmlkeDw9dSYmbC5wb3AoKTt9cmV0dXJuIHB9O30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPW4oMCksaT1uKDEpLG89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS53YWxrPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpczt2b2lkIDA9PT1lJiYoZT1bXSksci5mb3JFYWNoKHQuZGVmaW5pdGlvbixmdW5jdGlvbihvLGEpe3ZhciBzPXIuZHJvcCh0LmRlZmluaXRpb24sYSsxKTtpZihvIGluc3RhbmNlb2YgaS5Ob25UZXJtaW5hbCluLndhbGtQcm9kUmVmKG8scyxlKTtlbHNlIGlmKG8gaW5zdGFuY2VvZiBpLlRlcm1pbmFsKW4ud2Fsa1Rlcm1pbmFsKG8scyxlKTtlbHNlIGlmKG8gaW5zdGFuY2VvZiBpLkZsYXQpbi53YWxrRmxhdChvLHMsZSk7ZWxzZSBpZihvIGluc3RhbmNlb2YgaS5PcHRpb24pbi53YWxrT3B0aW9uKG8scyxlKTtlbHNlIGlmKG8gaW5zdGFuY2VvZiBpLlJlcGV0aXRpb25NYW5kYXRvcnkpbi53YWxrQXRMZWFzdE9uZShvLHMsZSk7ZWxzZSBpZihvIGluc3RhbmNlb2YgaS5SZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciluLndhbGtBdExlYXN0T25lU2VwKG8scyxlKTtlbHNlIGlmKG8gaW5zdGFuY2VvZiBpLlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKW4ud2Fsa01hbnlTZXAobyxzLGUpO2Vsc2UgaWYobyBpbnN0YW5jZW9mIGkuUmVwZXRpdGlvbiluLndhbGtNYW55KG8scyxlKTtlbHNlIHtpZighKG8gaW5zdGFuY2VvZiBpLkFsdGVybmF0aW9uKSl0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO24ud2Fsa09yKG8scyxlKTt9fSk7fSx0LnByb3RvdHlwZS53YWxrVGVybWluYWw9ZnVuY3Rpb24odCxlLG4pe30sdC5wcm90b3R5cGUud2Fsa1Byb2RSZWY9ZnVuY3Rpb24odCxlLG4pe30sdC5wcm90b3R5cGUud2Fsa0ZsYXQ9ZnVuY3Rpb24odCxlLG4pe3ZhciByPWUuY29uY2F0KG4pO3RoaXMud2Fsayh0LHIpO30sdC5wcm90b3R5cGUud2Fsa09wdGlvbj1mdW5jdGlvbih0LGUsbil7dmFyIHI9ZS5jb25jYXQobik7dGhpcy53YWxrKHQscik7fSx0LnByb3RvdHlwZS53YWxrQXRMZWFzdE9uZT1mdW5jdGlvbih0LGUsbil7dmFyIHI9W25ldyBpLk9wdGlvbih7ZGVmaW5pdGlvbjp0LmRlZmluaXRpb259KV0uY29uY2F0KGUsbik7dGhpcy53YWxrKHQscik7fSx0LnByb3RvdHlwZS53YWxrQXRMZWFzdE9uZVNlcD1mdW5jdGlvbih0LGUsbil7dmFyIHI9YSh0LGUsbik7dGhpcy53YWxrKHQscik7fSx0LnByb3RvdHlwZS53YWxrTWFueT1mdW5jdGlvbih0LGUsbil7dmFyIHI9W25ldyBpLk9wdGlvbih7ZGVmaW5pdGlvbjp0LmRlZmluaXRpb259KV0uY29uY2F0KGUsbik7dGhpcy53YWxrKHQscik7fSx0LnByb3RvdHlwZS53YWxrTWFueVNlcD1mdW5jdGlvbih0LGUsbil7dmFyIHI9YSh0LGUsbik7dGhpcy53YWxrKHQscik7fSx0LnByb3RvdHlwZS53YWxrT3I9ZnVuY3Rpb24odCxlLG4pe3ZhciBvPXRoaXMsYT1lLmNvbmNhdChuKTtyLmZvckVhY2godC5kZWZpbml0aW9uLGZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBpLkZsYXQoe2RlZmluaXRpb246W3RdfSk7by53YWxrKGUsYSk7fSk7fSx0fSgpO2Z1bmN0aW9uIGEodCxlLG4pe3JldHVybiBbbmV3IGkuT3B0aW9uKHtkZWZpbml0aW9uOltuZXcgaS5UZXJtaW5hbCh7dGVybWluYWxUeXBlOnQuc2VwYXJhdG9yfSldLmNvbmNhdCh0LmRlZmluaXRpb24pfSldLmNvbmNhdChlLG4pfWUuUmVzdFdhbGtlcj1vO30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPW4oMjcpLGk9bigwKSxvPW4oNyksYT1uKDIwKTshZnVuY3Rpb24odCl7dFt0Lk1JU1NJTkdfUEFUVEVSTj0wXT1cIk1JU1NJTkdfUEFUVEVSTlwiLHRbdC5JTlZBTElEX1BBVFRFUk49MV09XCJJTlZBTElEX1BBVFRFUk5cIix0W3QuRU9JX0FOQ0hPUl9GT1VORD0yXT1cIkVPSV9BTkNIT1JfRk9VTkRcIix0W3QuVU5TVVBQT1JURURfRkxBR1NfRk9VTkQ9M109XCJVTlNVUFBPUlRFRF9GTEFHU19GT1VORFwiLHRbdC5EVVBMSUNBVEVfUEFUVEVSTlNfRk9VTkQ9NF09XCJEVVBMSUNBVEVfUEFUVEVSTlNfRk9VTkRcIix0W3QuSU5WQUxJRF9HUk9VUF9UWVBFX0ZPVU5EPTVdPVwiSU5WQUxJRF9HUk9VUF9UWVBFX0ZPVU5EXCIsdFt0LlBVU0hfTU9ERV9ET0VTX05PVF9FWElTVD02XT1cIlBVU0hfTU9ERV9ET0VTX05PVF9FWElTVFwiLHRbdC5NVUxUSV9NT0RFX0xFWEVSX1dJVEhPVVRfREVGQVVMVF9NT0RFPTddPVwiTVVMVElfTU9ERV9MRVhFUl9XSVRIT1VUX0RFRkFVTFRfTU9ERVwiLHRbdC5NVUxUSV9NT0RFX0xFWEVSX1dJVEhPVVRfTU9ERVNfUFJPUEVSVFk9OF09XCJNVUxUSV9NT0RFX0xFWEVSX1dJVEhPVVRfTU9ERVNfUFJPUEVSVFlcIix0W3QuTVVMVElfTU9ERV9MRVhFUl9ERUZBVUxUX01PREVfVkFMVUVfRE9FU19OT1RfRVhJU1Q9OV09XCJNVUxUSV9NT0RFX0xFWEVSX0RFRkFVTFRfTU9ERV9WQUxVRV9ET0VTX05PVF9FWElTVFwiLHRbdC5MRVhFUl9ERUZJTklUSU9OX0NBTk5PVF9DT05UQUlOX1VOREVGSU5FRD0xMF09XCJMRVhFUl9ERUZJTklUSU9OX0NBTk5PVF9DT05UQUlOX1VOREVGSU5FRFwiLHRbdC5TT0lfQU5DSE9SX0ZPVU5EPTExXT1cIlNPSV9BTkNIT1JfRk9VTkRcIix0W3QuRU1QVFlfTUFUQ0hfUEFUVEVSTj0xMl09XCJFTVBUWV9NQVRDSF9QQVRURVJOXCIsdFt0Lk5PX0xJTkVfQlJFQUtTX0ZMQUdTPTEzXT1cIk5PX0xJTkVfQlJFQUtTX0ZMQUdTXCIsdFt0LlVOUkVBQ0hBQkxFX1BBVFRFUk49MTRdPVwiVU5SRUFDSEFCTEVfUEFUVEVSTlwiLHRbdC5JREVOVElGWV9URVJNSU5BVE9SPTE1XT1cIklERU5USUZZX1RFUk1JTkFUT1JcIix0W3QuQ1VTVE9NX0xJTkVfQlJFQUs9MTZdPVwiQ1VTVE9NX0xJTkVfQlJFQUtcIjt9KGUuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlfHwoZS5MZXhlckRlZmluaXRpb25FcnJvclR5cGU9e30pKTt2YXIgcz17ZGVmZXJEZWZpbml0aW9uRXJyb3JzSGFuZGxpbmc6ITEscG9zaXRpb25UcmFja2luZzpcImZ1bGxcIixsaW5lVGVybWluYXRvcnNQYXR0ZXJuOi9cXG58XFxyXFxuPy9nLGxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVyczpbXCJcXG5cIixcIlxcclwiXSxlbnN1cmVPcHRpbWl6YXRpb25zOiExLHNhZmVNb2RlOiExLGVycm9yTWVzc2FnZVByb3ZpZGVyOmEuZGVmYXVsdExleGVyRXJyb3JQcm92aWRlcn07T2JqZWN0LmZyZWV6ZShzKTt2YXIgdT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXt2YXIgbj10aGlzO2lmKHZvaWQgMD09PWUmJihlPXMpLHRoaXMubGV4ZXJEZWZpbml0aW9uPXQsdGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnM9W10sdGhpcy5sZXhlckRlZmluaXRpb25XYXJuaW5nPVtdLHRoaXMucGF0dGVybklkeFRvQ29uZmlnPXt9LHRoaXMuY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZz17fSx0aGlzLm1vZGVzPVtdLHRoaXMuZW1wdHlHcm91cHM9e30sdGhpcy5jb25maWc9dm9pZCAwLHRoaXMudHJhY2tTdGFydExpbmVzPSEwLHRoaXMudHJhY2tFbmRMaW5lcz0hMCx0aGlzLmhhc0N1c3RvbT0hMSx0aGlzLmNhbk1vZGVCZU9wdGltaXplZD17fSxcImJvb2xlYW5cIj09dHlwZW9mIGUpdGhyb3cgRXJyb3IoXCJUaGUgc2Vjb25kIGFyZ3VtZW50IHRvIHRoZSBMZXhlciBjb25zdHJ1Y3RvciBpcyBub3cgYW4gSUxleGVyQ29uZmlnIE9iamVjdC5cXG5hIGJvb2xlYW4gMm5kIGFyZ3VtZW50IGlzIG5vIGxvbmdlciBzdXBwb3J0ZWRcIik7aWYodGhpcy5jb25maWc9aS5tZXJnZShzLGUpLHRoaXMuY29uZmlnLmxpbmVUZXJtaW5hdG9yc1BhdHRlcm49PT1zLmxpbmVUZXJtaW5hdG9yc1BhdHRlcm4pdGhpcy5jb25maWcubGluZVRlcm1pbmF0b3JzUGF0dGVybj1yLkxpbmVUZXJtaW5hdG9yT3B0aW1pemVkVGVzdGVyO2Vsc2UgaWYodGhpcy5jb25maWcubGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzPT09cy5saW5lVGVybWluYXRvckNoYXJhY3RlcnMpdGhyb3cgRXJyb3IoXCJFcnJvcjogTWlzc2luZyA8bGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzPiBwcm9wZXJ0eSBvbiB0aGUgTGV4ZXIgY29uZmlnLlxcblxcdEZvciBkZXRhaWxzIFNlZTogaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjTUlTU0lOR19MSU5FX1RFUk1fQ0hBUlNcIik7aWYoZS5zYWZlTW9kZSYmZS5lbnN1cmVPcHRpbWl6YXRpb25zKXRocm93IEVycm9yKCdcInNhZmVNb2RlXCIgYW5kIFwiZW5zdXJlT3B0aW1pemF0aW9uc1wiIGZsYWdzIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuJyk7dGhpcy50cmFja1N0YXJ0TGluZXM9L2Z1bGx8b25seVN0YXJ0L2kudGVzdCh0aGlzLmNvbmZpZy5wb3NpdGlvblRyYWNraW5nKSx0aGlzLnRyYWNrRW5kTGluZXM9L2Z1bGwvaS50ZXN0KHRoaXMuY29uZmlnLnBvc2l0aW9uVHJhY2tpbmcpO3ZhciBhLHU9ITA7aS5pc0FycmF5KHQpPygoYT17bW9kZXM6e319KS5tb2Rlc1tyLkRFRkFVTFRfTU9ERV09aS5jbG9uZUFycih0KSxhW3IuREVGQVVMVF9NT0RFXT1yLkRFRkFVTFRfTU9ERSk6KHU9ITEsYT1pLmNsb25lT2JqKHQpKSx0aGlzLmxleGVyRGVmaW5pdGlvbkVycm9ycz10aGlzLmxleGVyRGVmaW5pdGlvbkVycm9ycy5jb25jYXQoci5wZXJmb3JtUnVudGltZUNoZWNrcyhhLHRoaXMudHJhY2tTdGFydExpbmVzLHRoaXMuY29uZmlnLmxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycykpLHRoaXMubGV4ZXJEZWZpbml0aW9uV2FybmluZz10aGlzLmxleGVyRGVmaW5pdGlvbldhcm5pbmcuY29uY2F0KHIucGVyZm9ybVdhcm5pbmdSdW50aW1lQ2hlY2tzKGEsdGhpcy50cmFja1N0YXJ0TGluZXMsdGhpcy5jb25maWcubGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzKSksYS5tb2Rlcz1hLm1vZGVzP2EubW9kZXM6e30saS5mb3JFYWNoKGEubW9kZXMsZnVuY3Rpb24odCxlKXthLm1vZGVzW2VdPWkucmVqZWN0KHQsZnVuY3Rpb24odCl7cmV0dXJuIGkuaXNVbmRlZmluZWQodCl9KTt9KTt2YXIgYz1pLmtleXMoYS5tb2Rlcyk7aWYoaS5mb3JFYWNoKGEubW9kZXMsZnVuY3Rpb24odCxhKXtpZihuLm1vZGVzLnB1c2goYSksbi5sZXhlckRlZmluaXRpb25FcnJvcnM9bi5sZXhlckRlZmluaXRpb25FcnJvcnMuY29uY2F0KHIudmFsaWRhdGVQYXR0ZXJucyh0LGMpKSxpLmlzRW1wdHkobi5sZXhlckRlZmluaXRpb25FcnJvcnMpKXtvLmF1Z21lbnRUb2tlblR5cGVzKHQpO3ZhciBzPXIuYW5hbHl6ZVRva2VuVHlwZXModCx7bGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzOm4uY29uZmlnLmxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycyxwb3NpdGlvblRyYWNraW5nOmUucG9zaXRpb25UcmFja2luZyxlbnN1cmVPcHRpbWl6YXRpb25zOmUuZW5zdXJlT3B0aW1pemF0aW9ucyxzYWZlTW9kZTplLnNhZmVNb2RlfSk7bi5wYXR0ZXJuSWR4VG9Db25maWdbYV09cy5wYXR0ZXJuSWR4VG9Db25maWcsbi5jaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnW2FdPXMuY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZyxuLmVtcHR5R3JvdXBzPWkubWVyZ2Uobi5lbXB0eUdyb3VwcyxzLmVtcHR5R3JvdXBzKSxuLmhhc0N1c3RvbT1zLmhhc0N1c3RvbXx8bi5oYXNDdXN0b20sbi5jYW5Nb2RlQmVPcHRpbWl6ZWRbYV09cy5jYW5CZU9wdGltaXplZDt9fSksdGhpcy5kZWZhdWx0TW9kZT1hLmRlZmF1bHRNb2RlLCFpLmlzRW1wdHkodGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMpJiYhdGhpcy5jb25maWcuZGVmZXJEZWZpbml0aW9uRXJyb3JzSGFuZGxpbmcpe3ZhciBwPWkubWFwKHRoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzLGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1lc3NhZ2V9KS5qb2luKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cIik7dGhyb3cgbmV3IEVycm9yKFwiRXJyb3JzIGRldGVjdGVkIGluIGRlZmluaXRpb24gb2YgTGV4ZXI6XFxuXCIrcCl9aWYoaS5mb3JFYWNoKHRoaXMubGV4ZXJEZWZpbml0aW9uV2FybmluZyxmdW5jdGlvbih0KXtpLlBSSU5UX1dBUk5JTkcodC5tZXNzYWdlKTt9KSxyLlNVUFBPUlRfU1RJQ0tZPyh0aGlzLmNob3BJbnB1dD1pLklERU5USVRZLHRoaXMubWF0Y2g9dGhpcy5tYXRjaFdpdGhUZXN0KToodGhpcy51cGRhdGVMYXN0SW5kZXg9aS5OT09QLHRoaXMubWF0Y2g9dGhpcy5tYXRjaFdpdGhFeGVjKSx1JiYodGhpcy5oYW5kbGVNb2Rlcz1pLk5PT1ApLCExPT09dGhpcy50cmFja1N0YXJ0TGluZXMmJih0aGlzLmNvbXB1dGVOZXdDb2x1bW49aS5JREVOVElUWSksITE9PT10aGlzLnRyYWNrRW5kTGluZXMmJih0aGlzLnVwZGF0ZVRva2VuRW5kTGluZUNvbHVtbkxvY2F0aW9uPWkuTk9PUCksL2Z1bGwvaS50ZXN0KHRoaXMuY29uZmlnLnBvc2l0aW9uVHJhY2tpbmcpKXRoaXMuY3JlYXRlVG9rZW5JbnN0YW5jZT10aGlzLmNyZWF0ZUZ1bGxUb2tlbjtlbHNlIGlmKC9vbmx5U3RhcnQvaS50ZXN0KHRoaXMuY29uZmlnLnBvc2l0aW9uVHJhY2tpbmcpKXRoaXMuY3JlYXRlVG9rZW5JbnN0YW5jZT10aGlzLmNyZWF0ZVN0YXJ0T25seVRva2VuO2Vsc2Uge2lmKCEvb25seU9mZnNldC9pLnRlc3QodGhpcy5jb25maWcucG9zaXRpb25UcmFja2luZykpdGhyb3cgRXJyb3IoJ0ludmFsaWQgPHBvc2l0aW9uVHJhY2tpbmc+IGNvbmZpZyBvcHRpb246IFwiJyt0aGlzLmNvbmZpZy5wb3NpdGlvblRyYWNraW5nKydcIicpO3RoaXMuY3JlYXRlVG9rZW5JbnN0YW5jZT10aGlzLmNyZWF0ZU9mZnNldE9ubHlUb2tlbjt9dGhpcy5oYXNDdXN0b20/dGhpcy5hZGRUb2tlbj10aGlzLmFkZFRva2VuVXNpbmdQdXNoOnRoaXMuYWRkVG9rZW49dGhpcy5hZGRUb2tlblVzaW5nTWVtYmVyQWNjZXNzO3ZhciBsPWkucmVkdWNlKHRoaXMuY2FuTW9kZUJlT3B0aW1pemVkLGZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gITE9PT1lJiZ0LnB1c2gobiksdH0sW10pO2lmKGUuZW5zdXJlT3B0aW1pemF0aW9ucyYmIWkuaXNFbXB0eShsKSl0aHJvdyBFcnJvcihcIkxleGVyIE1vZGVzOiA8IFwiK2wuam9pbihcIiwgXCIpKycgPiBjYW5ub3QgYmUgb3B0aW1pemVkLlxcblxcdCBEaXNhYmxlIHRoZSBcImVuc3VyZU9wdGltaXphdGlvbnNcIiBsZXhlciBjb25maWcgZmxhZyB0byBzaWxlbnRseSBpZ25vcmUgdGhpcyBhbmQgcnVuIHRoZSBsZXhlciBpbiBhbiB1bi1vcHRpbWl6ZWQgbW9kZS5cXG5cXHQgT3IgaW5zcGVjdCB0aGUgY29uc29sZSBsb2cgZm9yIGRldGFpbHMgb24gaG93IHRvIHJlc29sdmUgdGhlc2UgaXNzdWVzLicpfXJldHVybiB0LnByb3RvdHlwZS50b2tlbml6ZT1mdW5jdGlvbih0LGUpe2lmKHZvaWQgMD09PWUmJihlPXRoaXMuZGVmYXVsdE1vZGUpLCFpLmlzRW1wdHkodGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMpKXt2YXIgbj1pLm1hcCh0aGlzLmxleGVyRGVmaW5pdGlvbkVycm9ycyxmdW5jdGlvbih0KXtyZXR1cm4gdC5tZXNzYWdlfSkuam9pbihcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXCIpO3Rocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBUb2tlbml6ZSBiZWNhdXNlIEVycm9ycyBkZXRlY3RlZCBpbiBkZWZpbml0aW9uIG9mIExleGVyOlxcblwiK24pfXJldHVybiB0aGlzLnRva2VuaXplSW50ZXJuYWwodCxlKX0sdC5wcm90b3R5cGUudG9rZW5pemVJbnRlcm5hbD1mdW5jdGlvbih0LGUpe3ZhciBuLG8sYSxzLHUsYyxwLGwsaCxmLGQsRSxtPXRoaXMseT10LFQ9eS5sZW5ndGgsdj0wLGc9MCxfPXRoaXMuaGFzQ3VzdG9tPzA6TWF0aC5mbG9vcih0Lmxlbmd0aC8xMCksUj1uZXcgQXJyYXkoXyksQT1bXSxOPXRoaXMudHJhY2tTdGFydExpbmVzPzE6dm9pZCAwLE89dGhpcy50cmFja1N0YXJ0TGluZXM/MTp2b2lkIDAsUz1yLmNsb25lRW1wdHlHcm91cHModGhpcy5lbXB0eUdyb3VwcyksST10aGlzLnRyYWNrU3RhcnRMaW5lcyxMPXRoaXMuY29uZmlnLmxpbmVUZXJtaW5hdG9yc1BhdHRlcm4saz0wLFA9W10seD1bXSxDPVtdLE09W107T2JqZWN0LmZyZWV6ZShNKTt2YXIgRixiPXZvaWQgMCxEPWZ1bmN0aW9uKHQpe2lmKDE9PT1DLmxlbmd0aCYmdm9pZCAwPT09dC50b2tlblR5cGUuUFVTSF9NT0RFKXt2YXIgZT1tLmNvbmZpZy5lcnJvck1lc3NhZ2VQcm92aWRlci5idWlsZFVuYWJsZVRvUG9wTGV4ZXJNb2RlTWVzc2FnZSh0KTtBLnB1c2goe29mZnNldDp0LnN0YXJ0T2Zmc2V0LGxpbmU6dm9pZCAwIT09dC5zdGFydExpbmU/dC5zdGFydExpbmU6dm9pZCAwLGNvbHVtbjp2b2lkIDAhPT10LnN0YXJ0Q29sdW1uP3Quc3RhcnRDb2x1bW46dm9pZCAwLGxlbmd0aDp0LmltYWdlLmxlbmd0aCxtZXNzYWdlOmV9KTt9ZWxzZSB7Qy5wb3AoKTt2YXIgbj1pLmxhc3QoQyk7UD1tLnBhdHRlcm5JZHhUb0NvbmZpZ1tuXSx4PW0uY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZ1tuXSxrPVAubGVuZ3RoO3ZhciByPW0uY2FuTW9kZUJlT3B0aW1pemVkW25dJiYhMT09PW0uY29uZmlnLnNhZmVNb2RlO2I9eCYmcj9mdW5jdGlvbih0KXt2YXIgZT14W3RdO3JldHVybiB2b2lkIDA9PT1lP006ZX06ZnVuY3Rpb24oKXtyZXR1cm4gUH07fX07ZnVuY3Rpb24gdyh0KXtDLnB1c2godCkseD10aGlzLmNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWdbdF0sUD10aGlzLnBhdHRlcm5JZHhUb0NvbmZpZ1t0XSxrPVAubGVuZ3RoLGs9UC5sZW5ndGg7dmFyIGU9dGhpcy5jYW5Nb2RlQmVPcHRpbWl6ZWRbdF0mJiExPT09dGhpcy5jb25maWcuc2FmZU1vZGU7Yj14JiZlP2Z1bmN0aW9uKHQpe3ZhciBlPXhbdF07cmV0dXJuIHZvaWQgMD09PWU/TTplfTpmdW5jdGlvbigpe3JldHVybiBQfTt9Zm9yKHcuY2FsbCh0aGlzLGUpO3Y8VDspe3U9bnVsbDt2YXIgVT15LmNoYXJDb2RlQXQodiksRz1iKFUpLEI9Ry5sZW5ndGg7Zm9yKG49MDtuPEI7bisrKXt2YXIgSz0oRj1HW25dKS5wYXR0ZXJuO2lmKCExIT09KFo9Ri5zaG9ydCk/VT09PVomJih1PUspOiEwPT09Ri5pc0N1c3RvbT91PW51bGwhPT0oRT1LLmV4ZWMoeSx2LFIsUykpP0VbMF06RToodGhpcy51cGRhdGVMYXN0SW5kZXgoSyx2KSx1PXRoaXMubWF0Y2goSyx0LHYpKSxudWxsIT09dSl7aWYodm9pZCAwIT09KHM9Ri5sb25nZXJBbHQpKXt2YXIgVz1QW3NdLGo9Vy5wYXR0ZXJuOyEwPT09Vy5pc0N1c3RvbT9hPW51bGwhPT0oRT1qLmV4ZWMoeSx2LFIsUykpP0VbMF06RToodGhpcy51cGRhdGVMYXN0SW5kZXgoaix2KSxhPXRoaXMubWF0Y2goaix0LHYpKSxhJiZhLmxlbmd0aD51Lmxlbmd0aCYmKHU9YSxGPVcpO31icmVha319aWYobnVsbCE9PXUpe2lmKGM9dS5sZW5ndGgsdm9pZCAwIT09KHA9Ri5ncm91cCkmJihsPUYudG9rZW5UeXBlSWR4LGg9dGhpcy5jcmVhdGVUb2tlbkluc3RhbmNlKHUsdixsLEYudG9rZW5UeXBlLE4sTyxjKSwhMT09PXA/Zz10aGlzLmFkZFRva2VuKFIsZyxoKTpTW3BdLnB1c2goaCkpLHQ9dGhpcy5jaG9wSW5wdXQodCxjKSx2Kz1jLE89dGhpcy5jb21wdXRlTmV3Q29sdW1uKE8sYyksITA9PT1JJiYhMD09PUYuY2FuTGluZVRlcm1pbmF0b3Ipe3ZhciBWPTAsWT12b2lkIDAsSD12b2lkIDA7TC5sYXN0SW5kZXg9MDtkb3shMD09PShZPUwudGVzdCh1KSkmJihIPUwubGFzdEluZGV4LTEsVisrKTt9d2hpbGUoWSk7MCE9PVYmJihOKz1WLE89Yy1ILHRoaXMudXBkYXRlVG9rZW5FbmRMaW5lQ29sdW1uTG9jYXRpb24oaCxwLEgsVixOLE8sYykpO310aGlzLmhhbmRsZU1vZGVzKEYsRCx3LGgpO31lbHNlIHtmb3IodmFyIFg9dix6PU4scT1PLCQ9ITE7ISQmJnY8VDspZm9yKHkuY2hhckNvZGVBdCh2KSx0PXRoaXMuY2hvcElucHV0KHQsMSksdisrLG89MDtvPGs7bysrKXt2YXIgWixRPVBbb107Sz1RLnBhdHRlcm47aWYoITEhPT0oWj1RLnNob3J0KT95LmNoYXJDb2RlQXQodik9PT1aJiYoJD0hMCk6ITA9PT1RLmlzQ3VzdG9tPyQ9bnVsbCE9PUsuZXhlYyh5LHYsUixTKToodGhpcy51cGRhdGVMYXN0SW5kZXgoSyx2KSwkPW51bGwhPT1LLmV4ZWModCkpLCEwPT09JClicmVha31mPXYtWCxkPXRoaXMuY29uZmlnLmVycm9yTWVzc2FnZVByb3ZpZGVyLmJ1aWxkVW5leHBlY3RlZENoYXJhY3RlcnNNZXNzYWdlKHksWCxmLHoscSksQS5wdXNoKHtvZmZzZXQ6WCxsaW5lOnosY29sdW1uOnEsbGVuZ3RoOmYsbWVzc2FnZTpkfSk7fX1yZXR1cm4gdGhpcy5oYXNDdXN0b218fChSLmxlbmd0aD1nKSx7dG9rZW5zOlIsZ3JvdXBzOlMsZXJyb3JzOkF9fSx0LnByb3RvdHlwZS5oYW5kbGVNb2Rlcz1mdW5jdGlvbih0LGUsbixyKXtpZighMD09PXQucG9wKXt2YXIgaT10LnB1c2g7ZShyKSx2b2lkIDAhPT1pJiZuLmNhbGwodGhpcyxpKTt9ZWxzZSB2b2lkIDAhPT10LnB1c2gmJm4uY2FsbCh0aGlzLHQucHVzaCk7fSx0LnByb3RvdHlwZS5jaG9wSW5wdXQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5zdWJzdHJpbmcoZSl9LHQucHJvdG90eXBlLnVwZGF0ZUxhc3RJbmRleD1mdW5jdGlvbih0LGUpe3QubGFzdEluZGV4PWU7fSx0LnByb3RvdHlwZS51cGRhdGVUb2tlbkVuZExpbmVDb2x1bW5Mb2NhdGlvbj1mdW5jdGlvbih0LGUsbixyLGksbyxhKXt2YXIgcyx1O3ZvaWQgMCE9PWUmJih1PShzPW49PT1hLTEpPy0xOjAsMT09PXImJiEwPT09c3x8KHQuZW5kTGluZT1pK3UsdC5lbmRDb2x1bW49by0xLXUpKTt9LHQucHJvdG90eXBlLmNvbXB1dGVOZXdDb2x1bW49ZnVuY3Rpb24odCxlKXtyZXR1cm4gdCtlfSx0LnByb3RvdHlwZS5jcmVhdGVUb2tlbkluc3RhbmNlPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLGU9MDtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXRbZV09YXJndW1lbnRzW2VdO3JldHVybiBudWxsfSx0LnByb3RvdHlwZS5jcmVhdGVPZmZzZXRPbmx5VG9rZW49ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHtpbWFnZTp0LHN0YXJ0T2Zmc2V0OmUsdG9rZW5UeXBlSWR4Om4sdG9rZW5UeXBlOnJ9fSx0LnByb3RvdHlwZS5jcmVhdGVTdGFydE9ubHlUb2tlbj1mdW5jdGlvbih0LGUsbixyLGksbyl7cmV0dXJuIHtpbWFnZTp0LHN0YXJ0T2Zmc2V0OmUsc3RhcnRMaW5lOmksc3RhcnRDb2x1bW46byx0b2tlblR5cGVJZHg6bix0b2tlblR5cGU6cn19LHQucHJvdG90eXBlLmNyZWF0ZUZ1bGxUb2tlbj1mdW5jdGlvbih0LGUsbixyLGksbyxhKXtyZXR1cm4ge2ltYWdlOnQsc3RhcnRPZmZzZXQ6ZSxlbmRPZmZzZXQ6ZSthLTEsc3RhcnRMaW5lOmksZW5kTGluZTppLHN0YXJ0Q29sdW1uOm8sZW5kQ29sdW1uOm8rYS0xLHRva2VuVHlwZUlkeDpuLHRva2VuVHlwZTpyfX0sdC5wcm90b3R5cGUuYWRkVG9rZW49ZnVuY3Rpb24odCxlLG4pe3JldHVybiA2NjZ9LHQucHJvdG90eXBlLmFkZFRva2VuVXNpbmdQdXNoPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdC5wdXNoKG4pLGV9LHQucHJvdG90eXBlLmFkZFRva2VuVXNpbmdNZW1iZXJBY2Nlc3M9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0W2VdPW4sKytlfSx0LnByb3RvdHlwZS5tYXRjaD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIG51bGx9LHQucHJvdG90eXBlLm1hdGNoV2l0aFRlc3Q9ZnVuY3Rpb24odCxlLG4pe3JldHVybiAhMD09PXQudGVzdChlKT9lLnN1YnN0cmluZyhuLHQubGFzdEluZGV4KTpudWxsfSx0LnByb3RvdHlwZS5tYXRjaFdpdGhFeGVjPWZ1bmN0aW9uKHQsZSl7dmFyIG49dC5leGVjKGUpO3JldHVybiBudWxsIT09bj9uWzBdOm59LHQuU0tJUFBFRD1cIlRoaXMgbWFya3MgYSBza2lwcGVkIFRva2VuIHBhdHRlcm4sIHRoaXMgbWVhbnMgZWFjaCB0b2tlbiBpZGVudGlmaWVkIGJ5IGl0IHdpbGxiZSBjb25zdW1lZCBhbmQgdGhlbiB0aHJvd24gaW50byBvYmxpdmlvbiwgdGhpcyBjYW4gYmUgdXNlZCB0byBmb3IgZXhhbXBsZSB0byBjb21wbGV0ZWx5IGlnbm9yZSB3aGl0ZXNwYWNlLlwiLHQuTkE9L05PVF9BUFBMSUNBQkxFLyx0fSgpO2UuTGV4ZXI9dTt9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcixpPXRoaXMmJnRoaXMuX19leHRlbmRzfHwocj1mdW5jdGlvbih0LGUpe3JldHVybiAocj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24odCxlKXt0Ll9fcHJvdG9fXz1lO318fGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuIGluIGUpZS5oYXNPd25Qcm9wZXJ0eShuKSYmKHRbbl09ZVtuXSk7fSkodCxlKX0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKCl7dGhpcy5jb25zdHJ1Y3Rvcj10O31yKHQsZSksdC5wcm90b3R5cGU9bnVsbD09PWU/T2JqZWN0LmNyZWF0ZShlKToobi5wcm90b3R5cGU9ZS5wcm90b3R5cGUsbmV3IG4pO30pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBvPW4oMCksYT1uKDQpLHM9big5KSx1PW4oMSksYz1uKDUpO2UuYWRkVGVybWluYWxUb0NzdD1mdW5jdGlvbih0LGUsbil7dm9pZCAwPT09dC5jaGlsZHJlbltuXT90LmNoaWxkcmVuW25dPVtlXTp0LmNoaWxkcmVuW25dLnB1c2goZSk7fSxlLmFkZE5vbmVUZXJtaW5hbFRvQ3N0PWZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT10LmNoaWxkcmVuW2VdP3QuY2hpbGRyZW5bZV09W25dOnQuY2hpbGRyZW5bZV0ucHVzaChuKTt9O3ZhciBwPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7dmFyIG49dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLnJlc3VsdD1bXSxuLnJ1bGVJZHg9ZSxufXJldHVybiBpKGUsdCksZS5wcm90b3R5cGUuY29sbGVjdE5hbWVkRFNMTWV0aG9kPWZ1bmN0aW9uKHQsZSxuKXtpZighby5pc1VuZGVmaW5lZCh0Lm5hbWUpKXt2YXIgcj12b2lkIDA7aWYodCBpbnN0YW5jZW9mIHUuT3B0aW9ufHx0IGluc3RhbmNlb2YgdS5SZXBldGl0aW9ufHx0IGluc3RhbmNlb2YgdS5SZXBldGl0aW9uTWFuZGF0b3J5fHx0IGluc3RhbmNlb2YgdS5BbHRlcm5hdGlvbilyPW5ldyBlKHtkZWZpbml0aW9uOnQuZGVmaW5pdGlvbixpZHg6dC5pZHh9KTtlbHNlIHtpZighKHQgaW5zdGFuY2VvZiB1LlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yfHx0IGluc3RhbmNlb2YgdS5SZXBldGl0aW9uV2l0aFNlcGFyYXRvcikpdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtyPW5ldyBlKHtkZWZpbml0aW9uOnQuZGVmaW5pdGlvbixpZHg6dC5pZHgsc2VwYXJhdG9yOnQuc2VwYXJhdG9yfSk7fXZhciBpPVtyXSxhPXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKHRoaXMucnVsZUlkeCxuLHQuaWR4KTt0aGlzLnJlc3VsdC5wdXNoKHtkZWY6aSxrZXk6YSxuYW1lOnQubmFtZSxvcmdQcm9kOnR9KTt9fSxlLnByb3RvdHlwZS52aXNpdE9wdGlvbj1mdW5jdGlvbih0KXt0aGlzLmNvbGxlY3ROYW1lZERTTE1ldGhvZCh0LHUuT3B0aW9uLHMuT1BUSU9OX0lEWCk7fSxlLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb249ZnVuY3Rpb24odCl7dGhpcy5jb2xsZWN0TmFtZWREU0xNZXRob2QodCx1LlJlcGV0aXRpb24scy5NQU5ZX0lEWCk7fSxlLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnk9ZnVuY3Rpb24odCl7dGhpcy5jb2xsZWN0TmFtZWREU0xNZXRob2QodCx1LlJlcGV0aXRpb25NYW5kYXRvcnkscy5BVF9MRUFTVF9PTkVfSURYKTt9LGUucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3I9ZnVuY3Rpb24odCl7dGhpcy5jb2xsZWN0TmFtZWREU0xNZXRob2QodCx1LlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLHMuQVRfTEVBU1RfT05FX1NFUF9JRFgpO30sZS5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uV2l0aFNlcGFyYXRvcj1mdW5jdGlvbih0KXt0aGlzLmNvbGxlY3ROYW1lZERTTE1ldGhvZCh0LHUuUmVwZXRpdGlvbldpdGhTZXBhcmF0b3Iscy5NQU5ZX1NFUF9JRFgpO30sZS5wcm90b3R5cGUudmlzaXRBbHRlcm5hdGlvbj1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3RoaXMuY29sbGVjdE5hbWVkRFNMTWV0aG9kKHQsdS5BbHRlcm5hdGlvbixzLk9SX0lEWCk7dmFyIG49dC5kZWZpbml0aW9uLmxlbmd0aD4xO28uZm9yRWFjaCh0LmRlZmluaXRpb24sZnVuY3Rpb24ocixpKXtpZighby5pc1VuZGVmaW5lZChyLm5hbWUpKXt2YXIgYT1yLmRlZmluaXRpb247YT1uP1tuZXcgdS5PcHRpb24oe2RlZmluaXRpb246ci5kZWZpbml0aW9ufSldOnIuZGVmaW5pdGlvbjt2YXIgYz1zLmdldEtleUZvckFsdEluZGV4KGUucnVsZUlkeCxzLk9SX0lEWCx0LmlkeCxpKTtlLnJlc3VsdC5wdXNoKHtkZWY6YSxrZXk6YyxuYW1lOnIubmFtZSxvcmdQcm9kOnJ9KTt9fSk7fSxlfShjLkdBc3RWaXNpdG9yKTtlLk5hbWVkRFNMTWV0aG9kc0NvbGxlY3RvclZpc2l0b3I9cCxlLmFuYWx5emVDc3Q9ZnVuY3Rpb24odCxlKXt2YXIgbj17ZGljdERlZjpuZXcgYS5IYXNoVGFibGUsYWxsUnVsZU5hbWVzOltdfTtyZXR1cm4gby5mb3JFYWNoKHQsZnVuY3Rpb24odCl7dmFyIHI9ZS5nZXQodC5uYW1lKTtuLmFsbFJ1bGVOYW1lcy5wdXNoKHQubmFtZSk7dmFyIGk9bmV3IHAocik7dC5hY2NlcHQoaSksby5mb3JFYWNoKGkucmVzdWx0LGZ1bmN0aW9uKGUpe2UuZGVmLGUua2V5O3ZhciByPWUubmFtZTtuLmFsbFJ1bGVOYW1lcy5wdXNoKHQubmFtZStyKTt9KTt9KSxufTt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLlZFUlNJT049XCI0LjYuMFwiO30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPW4oMyksaT1uKDE1KSxvPW4oMiksYT1uKDYpLHM9bigxNyksdT1uKDEwKSxjPW4oMzkpLHA9big1KSxsPW4oMSksaD1uKDI0KSxmPW4oNDApLGQ9bigyMCksRT17fTtFLlZFUlNJT049cy5WRVJTSU9OLEUuUGFyc2VyPXIuUGFyc2VyLEUuQ3N0UGFyc2VyPXIuQ3N0UGFyc2VyLEUuRW1iZWRkZWRBY3Rpb25zUGFyc2VyPXIuRW1iZWRkZWRBY3Rpb25zUGFyc2VyO0UuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZT1yLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGUsRS5MZXhlcj1pLkxleGVyLEUuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlPWkuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLEUuRU9GPW8uRU9GLEUudG9rZW5OYW1lPW8udG9rZW5OYW1lLEUudG9rZW5MYWJlbD1vLnRva2VuTGFiZWwsRS50b2tlbk1hdGNoZXI9by50b2tlbk1hdGNoZXIsRS5jcmVhdGVUb2tlbj1vLmNyZWF0ZVRva2VuLEUuY3JlYXRlVG9rZW5JbnN0YW5jZT1vLmNyZWF0ZVRva2VuSW5zdGFuY2UsRS5FTVBUWV9BTFQ9ci5FTVBUWV9BTFQsRS5kZWZhdWx0UGFyc2VyRXJyb3JQcm92aWRlcj11LmRlZmF1bHRQYXJzZXJFcnJvclByb3ZpZGVyLEUuaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbj1hLmlzUmVjb2duaXRpb25FeGNlcHRpb24sRS5FYXJseUV4aXRFeGNlcHRpb249YS5FYXJseUV4aXRFeGNlcHRpb24sRS5NaXNtYXRjaGVkVG9rZW5FeGNlcHRpb249YS5NaXNtYXRjaGVkVG9rZW5FeGNlcHRpb24sRS5Ob3RBbGxJbnB1dFBhcnNlZEV4Y2VwdGlvbj1hLk5vdEFsbElucHV0UGFyc2VkRXhjZXB0aW9uLEUuTm9WaWFibGVBbHRFeGNlcHRpb249YS5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbixFLmRlZmF1bHRMZXhlckVycm9yUHJvdmlkZXI9ZC5kZWZhdWx0TGV4ZXJFcnJvclByb3ZpZGVyLEUuRmxhdD1sLkZsYXQsRS5SZXBldGl0aW9uPWwuUmVwZXRpdGlvbixFLlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yPWwuUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IsRS5SZXBldGl0aW9uTWFuZGF0b3J5PWwuUmVwZXRpdGlvbk1hbmRhdG9yeSxFLlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yPWwuUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IsRS5PcHRpb249bC5PcHRpb24sRS5BbHRlcm5hdGlvbj1sLkFsdGVybmF0aW9uLEUuTm9uVGVybWluYWw9bC5Ob25UZXJtaW5hbCxFLlRlcm1pbmFsPWwuVGVybWluYWwsRS5SdWxlPWwuUnVsZSxFLkdBc3RWaXNpdG9yPXAuR0FzdFZpc2l0b3IsRS5zZXJpYWxpemVHcmFtbWFyPWwuc2VyaWFsaXplR3JhbW1hcixFLnNlcmlhbGl6ZVByb2R1Y3Rpb249bC5zZXJpYWxpemVQcm9kdWN0aW9uLEUucmVzb2x2ZUdyYW1tYXI9aC5yZXNvbHZlR3JhbW1hcixFLmRlZmF1bHRHcmFtbWFyUmVzb2x2ZXJFcnJvclByb3ZpZGVyPXUuZGVmYXVsdEdyYW1tYXJSZXNvbHZlckVycm9yUHJvdmlkZXIsRS52YWxpZGF0ZUdyYW1tYXI9aC52YWxpZGF0ZUdyYW1tYXIsRS5kZWZhdWx0R3JhbW1hclZhbGlkYXRvckVycm9yUHJvdmlkZXI9dS5kZWZhdWx0R3JhbW1hclZhbGlkYXRvckVycm9yUHJvdmlkZXIsRS5hc3NpZ25PY2N1cnJlbmNlSW5kaWNlcz1oLmFzc2lnbk9jY3VycmVuY2VJbmRpY2VzLEUuY2xlYXJDYWNoZT1mdW5jdGlvbigpe2NvbnNvbGUud2FybihcIlRoZSBjbGVhckNhY2hlIGZ1bmN0aW9uIHdhcyAnc29mdCcgcmVtb3ZlZCBmcm9tIHRoZSBDaGV2cm90YWluIEFQSS5cXG5cXHQgSXQgcGVyZm9ybXMgbm8gYWN0aW9uIG90aGVyIHRoYW4gcHJpbnRpbmcgdGhpcyBtZXNzYWdlLlxcblxcdCBQbGVhc2UgYXZvaWQgdXNpbmcgaXQgYXMgaXQgd2lsbCBiZSBjb21wbGV0ZWx5IHJlbW92ZWQgaW4gdGhlIGZ1dHVyZVwiKTt9LEUuY3JlYXRlU3ludGF4RGlhZ3JhbXNDb2RlPWMuY3JlYXRlU3ludGF4RGlhZ3JhbXNDb2RlLEUuZ2VuZXJhdGVQYXJzZXJGYWN0b3J5PWYuZ2VuZXJhdGVQYXJzZXJGYWN0b3J5LEUuZ2VuZXJhdGVQYXJzZXJNb2R1bGU9Zi5nZW5lcmF0ZVBhcnNlck1vZHVsZSx0LmV4cG9ydHM9RTt9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcixpLG87aT1bXSx2b2lkIDA9PT0obz1cImZ1bmN0aW9uXCI9PXR5cGVvZihyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe310LnByb3RvdHlwZS5zYXZlU3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4ge2lkeDp0aGlzLmlkeCxpbnB1dDp0aGlzLmlucHV0LGdyb3VwSWR4OnRoaXMuZ3JvdXBJZHh9fSx0LnByb3RvdHlwZS5yZXN0b3JlU3RhdGU9ZnVuY3Rpb24odCl7dGhpcy5pZHg9dC5pZHgsdGhpcy5pbnB1dD10LmlucHV0LHRoaXMuZ3JvdXBJZHg9dC5ncm91cElkeDt9LHQucHJvdG90eXBlLnBhdHRlcm49ZnVuY3Rpb24odCl7dGhpcy5pZHg9MCx0aGlzLmlucHV0PXQsdGhpcy5ncm91cElkeD0wLHRoaXMuY29uc3VtZUNoYXIoXCIvXCIpO3ZhciBlPXRoaXMuZGlzanVuY3Rpb24oKTt0aGlzLmNvbnN1bWVDaGFyKFwiL1wiKTtmb3IodmFyIG49e3R5cGU6XCJGbGFnc1wiLGdsb2JhbDohMSxpZ25vcmVDYXNlOiExLG11bHRpTGluZTohMSx1bmljb2RlOiExLHN0aWNreTohMX07dGhpcy5pc1JlZ0V4cEZsYWcoKTspc3dpdGNoKHRoaXMucG9wQ2hhcigpKXtjYXNlXCJnXCI6cyhuLFwiZ2xvYmFsXCIpO2JyZWFrO2Nhc2VcImlcIjpzKG4sXCJpZ25vcmVDYXNlXCIpO2JyZWFrO2Nhc2VcIm1cIjpzKG4sXCJtdWx0aUxpbmVcIik7YnJlYWs7Y2FzZVwidVwiOnMobixcInVuaWNvZGVcIik7YnJlYWs7Y2FzZVwieVwiOnMobixcInN0aWNreVwiKTt9aWYodGhpcy5pZHghPT10aGlzLmlucHV0Lmxlbmd0aCl0aHJvdyBFcnJvcihcIlJlZHVuZGFudCBpbnB1dDogXCIrdGhpcy5pbnB1dC5zdWJzdHJpbmcodGhpcy5pZHgpKTtyZXR1cm4ge3R5cGU6XCJQYXR0ZXJuXCIsZmxhZ3M6bix2YWx1ZTplfX0sdC5wcm90b3R5cGUuZGlzanVuY3Rpb249ZnVuY3Rpb24oKXt2YXIgdD1bXTtmb3IodC5wdXNoKHRoaXMuYWx0ZXJuYXRpdmUoKSk7XCJ8XCI9PT10aGlzLnBlZWtDaGFyKCk7KXRoaXMuY29uc3VtZUNoYXIoXCJ8XCIpLHQucHVzaCh0aGlzLmFsdGVybmF0aXZlKCkpO3JldHVybiB7dHlwZTpcIkRpc2p1bmN0aW9uXCIsdmFsdWU6dH19LHQucHJvdG90eXBlLmFsdGVybmF0aXZlPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdO3RoaXMuaXNUZXJtKCk7KXQucHVzaCh0aGlzLnRlcm0oKSk7cmV0dXJuIHt0eXBlOlwiQWx0ZXJuYXRpdmVcIix2YWx1ZTp0fX0sdC5wcm90b3R5cGUudGVybT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlzQXNzZXJ0aW9uKCk/dGhpcy5hc3NlcnRpb24oKTp0aGlzLmF0b20oKX0sdC5wcm90b3R5cGUuYXNzZXJ0aW9uPWZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMucG9wQ2hhcigpKXtjYXNlXCJeXCI6cmV0dXJuIHt0eXBlOlwiU3RhcnRBbmNob3JcIn07Y2FzZVwiJFwiOnJldHVybiB7dHlwZTpcIkVuZEFuY2hvclwifTtjYXNlXCJcXFxcXCI6c3dpdGNoKHRoaXMucG9wQ2hhcigpKXtjYXNlXCJiXCI6cmV0dXJuIHt0eXBlOlwiV29yZEJvdW5kYXJ5XCJ9O2Nhc2VcIkJcIjpyZXR1cm4ge3R5cGU6XCJOb25Xb3JkQm91bmRhcnlcIn19dGhyb3cgRXJyb3IoXCJJbnZhbGlkIEFzc2VydGlvbiBFc2NhcGVcIik7Y2FzZVwiKFwiOnZhciB0O3N3aXRjaCh0aGlzLmNvbnN1bWVDaGFyKFwiP1wiKSx0aGlzLnBvcENoYXIoKSl7Y2FzZVwiPVwiOnQ9XCJMb29rYWhlYWRcIjticmVhaztjYXNlXCIhXCI6dD1cIk5lZ2F0aXZlTG9va2FoZWFkXCI7fXUodCk7dmFyIGU9dGhpcy5kaXNqdW5jdGlvbigpO3JldHVybiB0aGlzLmNvbnN1bWVDaGFyKFwiKVwiKSx7dHlwZTp0LHZhbHVlOmV9fSFmdW5jdGlvbigpe3Rocm93IEVycm9yKFwiSW50ZXJuYWwgRXJyb3IgLSBTaG91bGQgbmV2ZXIgZ2V0IGhlcmUhXCIpfSgpO30sdC5wcm90b3R5cGUucXVhbnRpZmllcj1mdW5jdGlvbih0KXt2YXIgZTtzd2l0Y2godGhpcy5wb3BDaGFyKCkpe2Nhc2VcIipcIjplPXthdExlYXN0OjAsYXRNb3N0OjEvMH07YnJlYWs7Y2FzZVwiK1wiOmU9e2F0TGVhc3Q6MSxhdE1vc3Q6MS8wfTticmVhaztjYXNlXCI/XCI6ZT17YXRMZWFzdDowLGF0TW9zdDoxfTticmVhaztjYXNlXCJ7XCI6dmFyIG49dGhpcy5pbnRlZ2VySW5jbHVkaW5nWmVybygpO3N3aXRjaCh0aGlzLnBvcENoYXIoKSl7Y2FzZVwifVwiOmU9e2F0TGVhc3Q6bixhdE1vc3Q6bn07YnJlYWs7Y2FzZVwiLFwiOnZhciByO3RoaXMuaXNEaWdpdCgpPyhyPXRoaXMuaW50ZWdlckluY2x1ZGluZ1plcm8oKSxlPXthdExlYXN0Om4sYXRNb3N0OnJ9KTplPXthdExlYXN0Om4sYXRNb3N0OjEvMH0sdGhpcy5jb25zdW1lQ2hhcihcIn1cIik7fWlmKCEwPT09dCYmdm9pZCAwPT09ZSlyZXR1cm47dShlKTt9aWYoITAhPT10fHx2b2lkIDAhPT1lKXJldHVybiB1KGUpLFwiP1wiPT09dGhpcy5wZWVrQ2hhcigwKT8odGhpcy5jb25zdW1lQ2hhcihcIj9cIiksZS5ncmVlZHk9ITEpOmUuZ3JlZWR5PSEwLGUudHlwZT1cIlF1YW50aWZpZXJcIixlfSx0LnByb3RvdHlwZS5hdG9tPWZ1bmN0aW9uKCl7dmFyIHQ7c3dpdGNoKHRoaXMucGVla0NoYXIoKSl7Y2FzZVwiLlwiOnQ9dGhpcy5kb3RBbGwoKTticmVhaztjYXNlXCJcXFxcXCI6dD10aGlzLmF0b21Fc2NhcGUoKTticmVhaztjYXNlXCJbXCI6dD10aGlzLmNoYXJhY3RlckNsYXNzKCk7YnJlYWs7Y2FzZVwiKFwiOnQ9dGhpcy5ncm91cCgpO31yZXR1cm4gdm9pZCAwPT09dCYmdGhpcy5pc1BhdHRlcm5DaGFyYWN0ZXIoKSYmKHQ9dGhpcy5wYXR0ZXJuQ2hhcmFjdGVyKCkpLHUodCksdGhpcy5pc1F1YW50aWZpZXIoKSYmKHQucXVhbnRpZmllcj10aGlzLnF1YW50aWZpZXIoKSksdH0sdC5wcm90b3R5cGUuZG90QWxsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3VtZUNoYXIoXCIuXCIpLHt0eXBlOlwiU2V0XCIsY29tcGxlbWVudDohMCx2YWx1ZTpbbyhcIlxcblwiKSxvKFwiXFxyXCIpLG8oXCJcXHUyMDI4XCIpLG8oXCJcXHUyMDI5XCIpXX19LHQucHJvdG90eXBlLmF0b21Fc2NhcGU9ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5jb25zdW1lQ2hhcihcIlxcXFxcIiksdGhpcy5wZWVrQ2hhcigpKXtjYXNlXCIxXCI6Y2FzZVwiMlwiOmNhc2VcIjNcIjpjYXNlXCI0XCI6Y2FzZVwiNVwiOmNhc2VcIjZcIjpjYXNlXCI3XCI6Y2FzZVwiOFwiOmNhc2VcIjlcIjpyZXR1cm4gdGhpcy5kZWNpbWFsRXNjYXBlQXRvbSgpO2Nhc2VcImRcIjpjYXNlXCJEXCI6Y2FzZVwic1wiOmNhc2VcIlNcIjpjYXNlXCJ3XCI6Y2FzZVwiV1wiOnJldHVybiB0aGlzLmNoYXJhY3RlckNsYXNzRXNjYXBlKCk7Y2FzZVwiZlwiOmNhc2VcIm5cIjpjYXNlXCJyXCI6Y2FzZVwidFwiOmNhc2VcInZcIjpyZXR1cm4gdGhpcy5jb250cm9sRXNjYXBlQXRvbSgpO2Nhc2VcImNcIjpyZXR1cm4gdGhpcy5jb250cm9sTGV0dGVyRXNjYXBlQXRvbSgpO2Nhc2VcIjBcIjpyZXR1cm4gdGhpcy5udWxDaGFyYWN0ZXJBdG9tKCk7Y2FzZVwieFwiOnJldHVybiB0aGlzLmhleEVzY2FwZVNlcXVlbmNlQXRvbSgpO2Nhc2VcInVcIjpyZXR1cm4gdGhpcy5yZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2VBdG9tKCk7ZGVmYXVsdDpyZXR1cm4gdGhpcy5pZGVudGl0eUVzY2FwZUF0b20oKX19LHQucHJvdG90eXBlLmRlY2ltYWxFc2NhcGVBdG9tPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wb3NpdGl2ZUludGVnZXIoKTtyZXR1cm4ge3R5cGU6XCJHcm91cEJhY2tSZWZlcmVuY2VcIix2YWx1ZTp0fX0sdC5wcm90b3R5cGUuY2hhcmFjdGVyQ2xhc3NFc2NhcGU9ZnVuY3Rpb24oKXt2YXIgdCxlPSExO3N3aXRjaCh0aGlzLnBvcENoYXIoKSl7Y2FzZVwiZFwiOnQ9YzticmVhaztjYXNlXCJEXCI6dD1jLGU9ITA7YnJlYWs7Y2FzZVwic1wiOnQ9bDticmVhaztjYXNlXCJTXCI6dD1sLGU9ITA7YnJlYWs7Y2FzZVwid1wiOnQ9cDticmVhaztjYXNlXCJXXCI6dD1wLGU9ITA7fXJldHVybiB1KHQpLHt0eXBlOlwiU2V0XCIsdmFsdWU6dCxjb21wbGVtZW50OmV9fSx0LnByb3RvdHlwZS5jb250cm9sRXNjYXBlQXRvbT1mdW5jdGlvbigpe3ZhciB0O3N3aXRjaCh0aGlzLnBvcENoYXIoKSl7Y2FzZVwiZlwiOnQ9byhcIlxcZlwiKTticmVhaztjYXNlXCJuXCI6dD1vKFwiXFxuXCIpO2JyZWFrO2Nhc2VcInJcIjp0PW8oXCJcXHJcIik7YnJlYWs7Y2FzZVwidFwiOnQ9byhcIlxcdFwiKTticmVhaztjYXNlXCJ2XCI6dD1vKFwiXFx2XCIpO31yZXR1cm4gdSh0KSx7dHlwZTpcIkNoYXJhY3RlclwiLHZhbHVlOnR9fSx0LnByb3RvdHlwZS5jb250cm9sTGV0dGVyRXNjYXBlQXRvbT1mdW5jdGlvbigpe3RoaXMuY29uc3VtZUNoYXIoXCJjXCIpO3ZhciB0PXRoaXMucG9wQ2hhcigpO2lmKCExPT09L1thLXpBLVpdLy50ZXN0KHQpKXRocm93IEVycm9yKFwiSW52YWxpZCBcIik7dmFyIGU9dC50b1VwcGVyQ2FzZSgpLmNoYXJDb2RlQXQoMCktNjQ7cmV0dXJuIHt0eXBlOlwiQ2hhcmFjdGVyXCIsdmFsdWU6ZX19LHQucHJvdG90eXBlLm51bENoYXJhY3RlckF0b209ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdW1lQ2hhcihcIjBcIikse3R5cGU6XCJDaGFyYWN0ZXJcIix2YWx1ZTpvKFwiXFwwXCIpfX0sdC5wcm90b3R5cGUuaGV4RXNjYXBlU2VxdWVuY2VBdG9tPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3VtZUNoYXIoXCJ4XCIpLHRoaXMucGFyc2VIZXhEaWdpdHMoMil9LHQucHJvdG90eXBlLnJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZUF0b209ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdW1lQ2hhcihcInVcIiksdGhpcy5wYXJzZUhleERpZ2l0cyg0KX0sdC5wcm90b3R5cGUuaWRlbnRpdHlFc2NhcGVBdG9tPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wb3BDaGFyKCk7cmV0dXJuIHt0eXBlOlwiQ2hhcmFjdGVyXCIsdmFsdWU6byh0KX19LHQucHJvdG90eXBlLmNsYXNzUGF0dGVybkNoYXJhY3RlckF0b209ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5wZWVrQ2hhcigpKXtjYXNlXCJcXG5cIjpjYXNlXCJcXHJcIjpjYXNlXCJcXHUyMDI4XCI6Y2FzZVwiXFx1MjAyOVwiOmNhc2VcIlxcXFxcIjpjYXNlXCJdXCI6dGhyb3cgRXJyb3IoXCJUQkRcIik7ZGVmYXVsdDp2YXIgdD10aGlzLnBvcENoYXIoKTtyZXR1cm4ge3R5cGU6XCJDaGFyYWN0ZXJcIix2YWx1ZTpvKHQpfX19LHQucHJvdG90eXBlLmNoYXJhY3RlckNsYXNzPWZ1bmN0aW9uKCl7dmFyIHQ9W10sZT0hMTtmb3IodGhpcy5jb25zdW1lQ2hhcihcIltcIiksXCJeXCI9PT10aGlzLnBlZWtDaGFyKDApJiYodGhpcy5jb25zdW1lQ2hhcihcIl5cIiksZT0hMCk7dGhpcy5pc0NsYXNzQXRvbSgpOyl7dmFyIG49dGhpcy5jbGFzc0F0b20oKSxyPVwiQ2hhcmFjdGVyXCI9PT1uLnR5cGU7aWYociYmdGhpcy5pc1JhbmdlRGFzaCgpKXt0aGlzLmNvbnN1bWVDaGFyKFwiLVwiKTt2YXIgaT10aGlzLmNsYXNzQXRvbSgpLHM9XCJDaGFyYWN0ZXJcIj09PWkudHlwZTtpZihzKXtpZihpLnZhbHVlPG4udmFsdWUpdGhyb3cgRXJyb3IoXCJSYW5nZSBvdXQgb2Ygb3JkZXIgaW4gY2hhcmFjdGVyIGNsYXNzXCIpO3QucHVzaCh7ZnJvbTpuLnZhbHVlLHRvOmkudmFsdWV9KTt9ZWxzZSBhKG4udmFsdWUsdCksdC5wdXNoKG8oXCItXCIpKSxhKGkudmFsdWUsdCk7fWVsc2UgYShuLnZhbHVlLHQpO31yZXR1cm4gdGhpcy5jb25zdW1lQ2hhcihcIl1cIikse3R5cGU6XCJTZXRcIixjb21wbGVtZW50OmUsdmFsdWU6dH19LHQucHJvdG90eXBlLmNsYXNzQXRvbT1mdW5jdGlvbigpe3N3aXRjaCh0aGlzLnBlZWtDaGFyKCkpe2Nhc2VcIl1cIjpjYXNlXCJcXG5cIjpjYXNlXCJcXHJcIjpjYXNlXCJcXHUyMDI4XCI6Y2FzZVwiXFx1MjAyOVwiOnRocm93IEVycm9yKFwiVEJEXCIpO2Nhc2VcIlxcXFxcIjpyZXR1cm4gdGhpcy5jbGFzc0VzY2FwZSgpO2RlZmF1bHQ6cmV0dXJuIHRoaXMuY2xhc3NQYXR0ZXJuQ2hhcmFjdGVyQXRvbSgpfX0sdC5wcm90b3R5cGUuY2xhc3NFc2NhcGU9ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5jb25zdW1lQ2hhcihcIlxcXFxcIiksdGhpcy5wZWVrQ2hhcigpKXtjYXNlXCJiXCI6cmV0dXJuIHRoaXMuY29uc3VtZUNoYXIoXCJiXCIpLHt0eXBlOlwiQ2hhcmFjdGVyXCIsdmFsdWU6byhcIlxcYlwiKX07Y2FzZVwiZFwiOmNhc2VcIkRcIjpjYXNlXCJzXCI6Y2FzZVwiU1wiOmNhc2VcIndcIjpjYXNlXCJXXCI6cmV0dXJuIHRoaXMuY2hhcmFjdGVyQ2xhc3NFc2NhcGUoKTtjYXNlXCJmXCI6Y2FzZVwiblwiOmNhc2VcInJcIjpjYXNlXCJ0XCI6Y2FzZVwidlwiOnJldHVybiB0aGlzLmNvbnRyb2xFc2NhcGVBdG9tKCk7Y2FzZVwiY1wiOnJldHVybiB0aGlzLmNvbnRyb2xMZXR0ZXJFc2NhcGVBdG9tKCk7Y2FzZVwiMFwiOnJldHVybiB0aGlzLm51bENoYXJhY3RlckF0b20oKTtjYXNlXCJ4XCI6cmV0dXJuIHRoaXMuaGV4RXNjYXBlU2VxdWVuY2VBdG9tKCk7Y2FzZVwidVwiOnJldHVybiB0aGlzLnJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZUF0b20oKTtkZWZhdWx0OnJldHVybiB0aGlzLmlkZW50aXR5RXNjYXBlQXRvbSgpfX0sdC5wcm90b3R5cGUuZ3JvdXA9ZnVuY3Rpb24oKXt2YXIgdD0hMDtzd2l0Y2godGhpcy5jb25zdW1lQ2hhcihcIihcIiksdGhpcy5wZWVrQ2hhcigwKSl7Y2FzZVwiP1wiOnRoaXMuY29uc3VtZUNoYXIoXCI/XCIpLHRoaXMuY29uc3VtZUNoYXIoXCI6XCIpLHQ9ITE7YnJlYWs7ZGVmYXVsdDp0aGlzLmdyb3VwSWR4Kys7fXZhciBlPXRoaXMuZGlzanVuY3Rpb24oKTt0aGlzLmNvbnN1bWVDaGFyKFwiKVwiKTt2YXIgbj17dHlwZTpcIkdyb3VwXCIsY2FwdHVyaW5nOnQsdmFsdWU6ZX07cmV0dXJuIHQmJihuLmlkeD10aGlzLmdyb3VwSWR4KSxufSx0LnByb3RvdHlwZS5wb3NpdGl2ZUludGVnZXI9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnBvcENoYXIoKTtpZighMT09PWkudGVzdCh0KSl0aHJvdyBFcnJvcihcIkV4cGVjdGluZyBhIHBvc2l0aXZlIGludGVnZXJcIik7Zm9yKDtyLnRlc3QodGhpcy5wZWVrQ2hhcigwKSk7KXQrPXRoaXMucG9wQ2hhcigpO3JldHVybiBwYXJzZUludCh0LDEwKX0sdC5wcm90b3R5cGUuaW50ZWdlckluY2x1ZGluZ1plcm89ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnBvcENoYXIoKTtpZighMT09PXIudGVzdCh0KSl0aHJvdyBFcnJvcihcIkV4cGVjdGluZyBhbiBpbnRlZ2VyXCIpO2Zvcig7ci50ZXN0KHRoaXMucGVla0NoYXIoMCkpOyl0Kz10aGlzLnBvcENoYXIoKTtyZXR1cm4gcGFyc2VJbnQodCwxMCl9LHQucHJvdG90eXBlLnBhdHRlcm5DaGFyYWN0ZXI9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnBvcENoYXIoKTtzd2l0Y2godCl7Y2FzZVwiXFxuXCI6Y2FzZVwiXFxyXCI6Y2FzZVwiXFx1MjAyOFwiOmNhc2VcIlxcdTIwMjlcIjpjYXNlXCJeXCI6Y2FzZVwiJFwiOmNhc2VcIlxcXFxcIjpjYXNlXCIuXCI6Y2FzZVwiKlwiOmNhc2VcIitcIjpjYXNlXCI/XCI6Y2FzZVwiKFwiOmNhc2VcIilcIjpjYXNlXCJbXCI6Y2FzZVwifFwiOnRocm93IEVycm9yKFwiVEJEXCIpO2RlZmF1bHQ6cmV0dXJuIHt0eXBlOlwiQ2hhcmFjdGVyXCIsdmFsdWU6byh0KX19fSx0LnByb3RvdHlwZS5pc1JlZ0V4cEZsYWc9ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5wZWVrQ2hhcigwKSl7Y2FzZVwiZ1wiOmNhc2VcImlcIjpjYXNlXCJtXCI6Y2FzZVwidVwiOmNhc2VcInlcIjpyZXR1cm4gITA7ZGVmYXVsdDpyZXR1cm4gITF9fSx0LnByb3RvdHlwZS5pc1JhbmdlRGFzaD1mdW5jdGlvbigpe3JldHVybiBcIi1cIj09PXRoaXMucGVla0NoYXIoKSYmdGhpcy5pc0NsYXNzQXRvbSgxKX0sdC5wcm90b3R5cGUuaXNEaWdpdD1mdW5jdGlvbigpe3JldHVybiByLnRlc3QodGhpcy5wZWVrQ2hhcigwKSl9LHQucHJvdG90eXBlLmlzQ2xhc3NBdG9tPWZ1bmN0aW9uKHQpe3N3aXRjaCh2b2lkIDA9PT10JiYodD0wKSx0aGlzLnBlZWtDaGFyKHQpKXtjYXNlXCJdXCI6Y2FzZVwiXFxuXCI6Y2FzZVwiXFxyXCI6Y2FzZVwiXFx1MjAyOFwiOmNhc2VcIlxcdTIwMjlcIjpyZXR1cm4gITE7ZGVmYXVsdDpyZXR1cm4gITB9fSx0LnByb3RvdHlwZS5pc1Rlcm09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0F0b20oKXx8dGhpcy5pc0Fzc2VydGlvbigpfSx0LnByb3RvdHlwZS5pc0F0b209ZnVuY3Rpb24oKXtpZih0aGlzLmlzUGF0dGVybkNoYXJhY3RlcigpKXJldHVybiAhMDtzd2l0Y2godGhpcy5wZWVrQ2hhcigwKSl7Y2FzZVwiLlwiOmNhc2VcIlxcXFxcIjpjYXNlXCJbXCI6Y2FzZVwiKFwiOnJldHVybiAhMDtkZWZhdWx0OnJldHVybiAhMX19LHQucHJvdG90eXBlLmlzQXNzZXJ0aW9uPWZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMucGVla0NoYXIoMCkpe2Nhc2VcIl5cIjpjYXNlXCIkXCI6cmV0dXJuICEwO2Nhc2VcIlxcXFxcIjpzd2l0Y2godGhpcy5wZWVrQ2hhcigxKSl7Y2FzZVwiYlwiOmNhc2VcIkJcIjpyZXR1cm4gITA7ZGVmYXVsdDpyZXR1cm4gITF9Y2FzZVwiKFwiOnJldHVybiBcIj9cIj09PXRoaXMucGVla0NoYXIoMSkmJihcIj1cIj09PXRoaXMucGVla0NoYXIoMil8fFwiIVwiPT09dGhpcy5wZWVrQ2hhcigyKSk7ZGVmYXVsdDpyZXR1cm4gITF9fSx0LnByb3RvdHlwZS5pc1F1YW50aWZpZXI9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnNhdmVTdGF0ZSgpO3RyeXtyZXR1cm4gdm9pZCAwIT09dGhpcy5xdWFudGlmaWVyKCEwKX1jYXRjaCh0KXtyZXR1cm4gITF9ZmluYWxseXt0aGlzLnJlc3RvcmVTdGF0ZSh0KTt9fSx0LnByb3RvdHlwZS5pc1BhdHRlcm5DaGFyYWN0ZXI9ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5wZWVrQ2hhcigpKXtjYXNlXCJeXCI6Y2FzZVwiJFwiOmNhc2VcIlxcXFxcIjpjYXNlXCIuXCI6Y2FzZVwiKlwiOmNhc2VcIitcIjpjYXNlXCI/XCI6Y2FzZVwiKFwiOmNhc2VcIilcIjpjYXNlXCJbXCI6Y2FzZVwifFwiOmNhc2VcIi9cIjpjYXNlXCJcXG5cIjpjYXNlXCJcXHJcIjpjYXNlXCJcXHUyMDI4XCI6Y2FzZVwiXFx1MjAyOVwiOnJldHVybiAhMTtkZWZhdWx0OnJldHVybiAhMH19LHQucHJvdG90eXBlLnBhcnNlSGV4RGlnaXRzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1cIlwiLHI9MDtyPHQ7cisrKXt2YXIgaT10aGlzLnBvcENoYXIoKTtpZighMT09PW4udGVzdChpKSl0aHJvdyBFcnJvcihcIkV4cGVjdGluZyBhIEhleERlY2ltYWwgZGlnaXRzXCIpO2UrPWk7fXZhciBvPXBhcnNlSW50KGUsMTYpO3JldHVybiB7dHlwZTpcIkNoYXJhY3RlclwiLHZhbHVlOm99fSx0LnByb3RvdHlwZS5wZWVrQ2hhcj1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCksdGhpcy5pbnB1dFt0aGlzLmlkeCt0XX0sdC5wcm90b3R5cGUucG9wQ2hhcj1mdW5jdGlvbigpe3ZhciB0PXRoaXMucGVla0NoYXIoMCk7cmV0dXJuIHRoaXMuY29uc3VtZUNoYXIoKSx0fSx0LnByb3RvdHlwZS5jb25zdW1lQ2hhcj1mdW5jdGlvbih0KXtpZih2b2lkIDAhPT10JiZ0aGlzLmlucHV0W3RoaXMuaWR4XSE9PXQpdGhyb3cgRXJyb3IoXCJFeHBlY3RlZDogJ1wiK3QrXCInIGJ1dCBmb3VuZDogJ1wiK3RoaXMuaW5wdXRbdGhpcy5pZHhdK1wiJyBhdCBvZmZzZXQ6IFwiK3RoaXMuaWR4KTtpZih0aGlzLmlkeD49dGhpcy5pbnB1dC5sZW5ndGgpdGhyb3cgRXJyb3IoXCJVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dFwiKTt0aGlzLmlkeCsrO307dmFyIGUsbj0vWzAtOWEtZkEtRl0vLHI9L1swLTldLyxpPS9bMS05XS87ZnVuY3Rpb24gbyh0KXtyZXR1cm4gdC5jaGFyQ29kZUF0KDApfWZ1bmN0aW9uIGEodCxlKXt2b2lkIDAhPT10Lmxlbmd0aD90LmZvckVhY2goZnVuY3Rpb24odCl7ZS5wdXNoKHQpO30pOmUucHVzaCh0KTt9ZnVuY3Rpb24gcyh0LGUpe2lmKCEwPT09dFtlXSl0aHJvdyBcImR1cGxpY2F0ZSBmbGFnIFwiK2U7dFtlXT0hMDt9ZnVuY3Rpb24gdSh0KXtpZih2b2lkIDA9PT10KXRocm93IEVycm9yKFwiSW50ZXJuYWwgRXJyb3IgLSBTaG91bGQgbmV2ZXIgZ2V0IGhlcmUhXCIpfXZhciBjPVtdO2ZvcihlPW8oXCIwXCIpO2U8PW8oXCI5XCIpO2UrKyljLnB1c2goZSk7dmFyIHA9W28oXCJfXCIpXS5jb25jYXQoYyk7Zm9yKGU9byhcImFcIik7ZTw9byhcInpcIik7ZSsrKXAucHVzaChlKTtmb3IoZT1vKFwiQVwiKTtlPD1vKFwiWlwiKTtlKyspcC5wdXNoKGUpO3ZhciBsPVtvKFwiIFwiKSxvKFwiXFxmXCIpLG8oXCJcXG5cIiksbyhcIlxcclwiKSxvKFwiXFx0XCIpLG8oXCJcXHZcIiksbyhcIlxcdFwiKSxvKFwiwqBcIiksbyhcIuGagFwiKSxvKFwi4oCAXCIpLG8oXCLigIFcIiksbyhcIuKAglwiKSxvKFwi4oCDXCIpLG8oXCLigIRcIiksbyhcIuKAhVwiKSxvKFwi4oCGXCIpLG8oXCLigIdcIiksbyhcIuKAiFwiKSxvKFwi4oCJXCIpLG8oXCLigIpcIiksbyhcIlxcdTIwMjhcIiksbyhcIlxcdTIwMjlcIiksbyhcIuKAr1wiKSxvKFwi4oGfXCIpLG8oXCLjgIBcIiksbyhcIlxcdWZlZmZcIildO2Z1bmN0aW9uIGgoKXt9cmV0dXJuIGgucHJvdG90eXBlLnZpc2l0Q2hpbGRyZW49ZnVuY3Rpb24odCl7Zm9yKHZhciBlIGluIHQpe3ZhciBuPXRbZV07dC5oYXNPd25Qcm9wZXJ0eShlKSYmKHZvaWQgMCE9PW4udHlwZT90aGlzLnZpc2l0KG4pOkFycmF5LmlzQXJyYXkobikmJm4uZm9yRWFjaChmdW5jdGlvbih0KXt0aGlzLnZpc2l0KHQpO30sdGhpcykpO319LGgucHJvdG90eXBlLnZpc2l0PWZ1bmN0aW9uKHQpe3N3aXRjaCh0LnR5cGUpe2Nhc2VcIlBhdHRlcm5cIjp0aGlzLnZpc2l0UGF0dGVybih0KTticmVhaztjYXNlXCJGbGFnc1wiOnRoaXMudmlzaXRGbGFncyh0KTticmVhaztjYXNlXCJEaXNqdW5jdGlvblwiOnRoaXMudmlzaXREaXNqdW5jdGlvbih0KTticmVhaztjYXNlXCJBbHRlcm5hdGl2ZVwiOnRoaXMudmlzaXRBbHRlcm5hdGl2ZSh0KTticmVhaztjYXNlXCJTdGFydEFuY2hvclwiOnRoaXMudmlzaXRTdGFydEFuY2hvcih0KTticmVhaztjYXNlXCJFbmRBbmNob3JcIjp0aGlzLnZpc2l0RW5kQW5jaG9yKHQpO2JyZWFrO2Nhc2VcIldvcmRCb3VuZGFyeVwiOnRoaXMudmlzaXRXb3JkQm91bmRhcnkodCk7YnJlYWs7Y2FzZVwiTm9uV29yZEJvdW5kYXJ5XCI6dGhpcy52aXNpdE5vbldvcmRCb3VuZGFyeSh0KTticmVhaztjYXNlXCJMb29rYWhlYWRcIjp0aGlzLnZpc2l0TG9va2FoZWFkKHQpO2JyZWFrO2Nhc2VcIk5lZ2F0aXZlTG9va2FoZWFkXCI6dGhpcy52aXNpdE5lZ2F0aXZlTG9va2FoZWFkKHQpO2JyZWFrO2Nhc2VcIkNoYXJhY3RlclwiOnRoaXMudmlzaXRDaGFyYWN0ZXIodCk7YnJlYWs7Y2FzZVwiU2V0XCI6dGhpcy52aXNpdFNldCh0KTticmVhaztjYXNlXCJHcm91cFwiOnRoaXMudmlzaXRHcm91cCh0KTticmVhaztjYXNlXCJHcm91cEJhY2tSZWZlcmVuY2VcIjp0aGlzLnZpc2l0R3JvdXBCYWNrUmVmZXJlbmNlKHQpO2JyZWFrO2Nhc2VcIlF1YW50aWZpZXJcIjp0aGlzLnZpc2l0UXVhbnRpZmllcih0KTt9dGhpcy52aXNpdENoaWxkcmVuKHQpO30saC5wcm90b3R5cGUudmlzaXRQYXR0ZXJuPWZ1bmN0aW9uKHQpe30saC5wcm90b3R5cGUudmlzaXRGbGFncz1mdW5jdGlvbih0KXt9LGgucHJvdG90eXBlLnZpc2l0RGlzanVuY3Rpb249ZnVuY3Rpb24odCl7fSxoLnByb3RvdHlwZS52aXNpdEFsdGVybmF0aXZlPWZ1bmN0aW9uKHQpe30saC5wcm90b3R5cGUudmlzaXRTdGFydEFuY2hvcj1mdW5jdGlvbih0KXt9LGgucHJvdG90eXBlLnZpc2l0RW5kQW5jaG9yPWZ1bmN0aW9uKHQpe30saC5wcm90b3R5cGUudmlzaXRXb3JkQm91bmRhcnk9ZnVuY3Rpb24odCl7fSxoLnByb3RvdHlwZS52aXNpdE5vbldvcmRCb3VuZGFyeT1mdW5jdGlvbih0KXt9LGgucHJvdG90eXBlLnZpc2l0TG9va2FoZWFkPWZ1bmN0aW9uKHQpe30saC5wcm90b3R5cGUudmlzaXROZWdhdGl2ZUxvb2thaGVhZD1mdW5jdGlvbih0KXt9LGgucHJvdG90eXBlLnZpc2l0Q2hhcmFjdGVyPWZ1bmN0aW9uKHQpe30saC5wcm90b3R5cGUudmlzaXRTZXQ9ZnVuY3Rpb24odCl7fSxoLnByb3RvdHlwZS52aXNpdEdyb3VwPWZ1bmN0aW9uKHQpe30saC5wcm90b3R5cGUudmlzaXRHcm91cEJhY2tSZWZlcmVuY2U9ZnVuY3Rpb24odCl7fSxoLnByb3RvdHlwZS52aXNpdFF1YW50aWZpZXI9ZnVuY3Rpb24odCl7fSx7UmVnRXhwUGFyc2VyOnQsQmFzZVJlZ0V4cFZpc2l0b3I6aCxWRVJTSU9OOlwiMC40LjBcIn19KT9yLmFwcGx5KGUsaSk6cil8fCh0LmV4cG9ydHM9byk7fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5kZWZhdWx0TGV4ZXJFcnJvclByb3ZpZGVyPXtidWlsZFVuYWJsZVRvUG9wTGV4ZXJNb2RlTWVzc2FnZTpmdW5jdGlvbih0KXtyZXR1cm4gXCJVbmFibGUgdG8gcG9wIExleGVyIE1vZGUgYWZ0ZXIgZW5jb3VudGVyaW5nIFRva2VuIC0+XCIrdC5pbWFnZStcIjwtIFRoZSBNb2RlIFN0YWNrIGlzIGVtcHR5XCJ9LGJ1aWxkVW5leHBlY3RlZENoYXJhY3RlcnNNZXNzYWdlOmZ1bmN0aW9uKHQsZSxuLHIsaSl7cmV0dXJuIFwidW5leHBlY3RlZCBjaGFyYWN0ZXI6IC0+XCIrdC5jaGFyQXQoZSkrXCI8LSBhdCBvZmZzZXQ6IFwiK2UrXCIsIHNraXBwZWQgXCIrbitcIiBjaGFyYWN0ZXJzLlwifX07fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9bigwKSxpPW4oMSksbz1uKDgpO2Z1bmN0aW9uIGEodCl7aWYodCBpbnN0YW5jZW9mIGkuTm9uVGVybWluYWwpcmV0dXJuIGEodC5yZWZlcmVuY2VkUnVsZSk7aWYodCBpbnN0YW5jZW9mIGkuVGVybWluYWwpcmV0dXJuIGModCk7aWYoby5pc1NlcXVlbmNlUHJvZCh0KSlyZXR1cm4gcyh0KTtpZihvLmlzQnJhbmNoaW5nUHJvZCh0KSlyZXR1cm4gdSh0KTt0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpfWZ1bmN0aW9uIHModCl7Zm9yKHZhciBlLG49W10saT10LmRlZmluaXRpb24scz0wLHU9aS5sZW5ndGg+cyxjPSEwO3UmJmM7KWU9aVtzXSxjPW8uaXNPcHRpb25hbFByb2QoZSksbj1uLmNvbmNhdChhKGUpKSxzKz0xLHU9aS5sZW5ndGg+cztyZXR1cm4gci51bmlxKG4pfWZ1bmN0aW9uIHUodCl7dmFyIGU9ci5tYXAodC5kZWZpbml0aW9uLGZ1bmN0aW9uKHQpe3JldHVybiBhKHQpfSk7cmV0dXJuIHIudW5pcShyLmZsYXR0ZW4oZSkpfWZ1bmN0aW9uIGModCl7cmV0dXJuIFt0LnRlcm1pbmFsVHlwZV19ZS5maXJzdD1hLGUuZmlyc3RGb3JTZXF1ZW5jZT1zLGUuZmlyc3RGb3JCcmFuY2hpbmc9dSxlLmZpcnN0Rm9yVGVybWluYWw9Yzt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLklOPVwiX35JTn5fXCI7fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHIsaT1uKDI5KSxvPW4oMCksYT1uKDEpOyFmdW5jdGlvbih0KXt0W3QuT1BUSU9OPTBdPVwiT1BUSU9OXCIsdFt0Lk9SPTFdPVwiT1JcIix0W3QuTUFOWT0yXT1cIk1BTllcIix0W3QuTUFOWV9TRVA9M109XCJNQU5ZX1NFUFwiLHRbdC5BVF9MRUFTVF9PTkU9NF09XCJBVF9MRUFTVF9PTkVcIix0W3QuQVRfTEVBU1RfT05FX1NFUD01XT1cIkFUX0xFQVNUX09ORV9TRVBcIix0W3QuUkVGPTZdPVwiUkVGXCIsdFt0LlRFUk1JTkFMPTddPVwiVEVSTUlOQUxcIix0W3QuRkxBVD04XT1cIkZMQVRcIjt9KHI9ZS5Qcm9kVHlwZXx8KGUuUHJvZFR5cGU9e30pKTt2YXIgcz0vKD86XFxzKntcXHMqTkFNRVxccyo6XFxzKltcIidgXShbXFx3JF0qKVtcIidgXSk/Lyx1PW5ldyBSZWdFeHAocy5zb3VyY2UucmVwbGFjZShcIntcIixcIlwiKS5yZXBsYWNlKFwiKT9cIixcIlxcXFxzKiwpP1wiKSksYz0vXFwuXFxzKkNPTlNVTUUoXFxkKyk/XFxzKlxcKFxccyooPzpbYS16QS1aXyRdXFx3KlxccypcXC5cXHMqKSooW2EtekEtWl8kXVxcdyopLyxwPW5ldyBSZWdFeHAoYy5zb3VyY2UsXCJnXCIpLGw9L1xcLlxccypTVUJSVUxFKFxcZCspP1xccypcXChcXHMqKD86W2EtekEtWl8kXVxcdypcXHMqXFwuXFxzKikqKFthLXpBLVpfJF1cXHcqKS8saD1uZXcgUmVnRXhwKGwuc291cmNlLFwiZ1wiKSxmPS9cXC5cXHMqT1BUSU9OKFxcZCspP1xccypcXCgvLGQ9bmV3IFJlZ0V4cChmLnNvdXJjZStzLnNvdXJjZSksRT1uZXcgUmVnRXhwKGYuc291cmNlLFwiZ1wiKSxtPS9cXC5cXHMqTUFOWShcXGQrKT9cXHMqXFwoLyx5PW5ldyBSZWdFeHAobS5zb3VyY2Urcy5zb3VyY2UpLFQ9bmV3IFJlZ0V4cChtLnNvdXJjZSxcImdcIiksdj0vXFxzKlNFUFxccyo6XFxzKig/OlthLXpBLVpfJF1cXHcqXFxzKlxcLlxccyopKihbYS16QS1aXyRdXFx3KikvLGc9bmV3IFJlZ0V4cCgvXFwuXFxzKk1BTllfU0VQKFxcZCspP1xccypcXChcXHMqey8uc291cmNlK3Uuc291cmNlK3Yuc291cmNlKSxfPW5ldyBSZWdFeHAoZy5zb3VyY2UsXCJnXCIpLFI9bmV3IFJlZ0V4cCgvXFwuXFxzKkFUX0xFQVNUX09ORV9TRVAoXFxkKyk/XFxzKlxcKFxccyp7Ly5zb3VyY2UrdS5zb3VyY2Urdi5zb3VyY2UpLEE9bmV3IFJlZ0V4cChSLnNvdXJjZSxcImdcIiksTj0vXFwuXFxzKkFUX0xFQVNUX09ORShcXGQrKT9cXHMqXFwoLyxPPW5ldyBSZWdFeHAoTi5zb3VyY2Urcy5zb3VyY2UpLFM9bmV3IFJlZ0V4cChOLnNvdXJjZSxcImdcIiksST0vXFwuXFxzKk9SKFxcZCspP1xccypcXCgvLEw9bmV3IFJlZ0V4cChJLnNvdXJjZStzLnNvdXJjZSksaz1uZXcgUmVnRXhwKEkuc291cmNlLFwiZ1wiKSxQPW5ldyBSZWdFeHAodS5zb3VyY2UrL1xccyooQUxUKVxccyo6Ly5zb3VyY2UpLHg9bmV3IFJlZ0V4cChQLnNvdXJjZSxcImdcIik7ZnVuY3Rpb24gQyh0LG4saSl7c3dpdGNoKHQudHlwZSl7Y2FzZSByLkFUX0xFQVNUX09ORTpyZXR1cm4gZnVuY3Rpb24odCxlLG4pe3JldHVybiBNKE8sbmV3IGEuUmVwZXRpdGlvbk1hbmRhdG9yeSh7ZGVmaW5pdGlvbjpbXX0pLHQsZSxuKX0odCxuLGkpO2Nhc2Ugci5BVF9MRUFTVF9PTkVfU0VQOnJldHVybiBmdW5jdGlvbih0LGUsbil7cmV0dXJuIEYodCxlLGEuUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IsUixuKX0odCxuLGkpO2Nhc2Ugci5NQU5ZX1NFUDpyZXR1cm4gZnVuY3Rpb24odCxlLG4pe3JldHVybiBGKHQsZSxhLlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLGcsbil9KHQsbixpKTtjYXNlIHIuTUFOWTpyZXR1cm4gZnVuY3Rpb24odCxlLG4pe3JldHVybiBNKHksbmV3IGEuUmVwZXRpdGlvbih7ZGVmaW5pdGlvbjpbXX0pLHQsZSxuKX0odCxuLGkpO2Nhc2Ugci5PUFRJT046cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gTShkLG5ldyBhLk9wdGlvbih7ZGVmaW5pdGlvbjpbXX0pLHQsZSxuKX0odCxuLGkpO2Nhc2Ugci5PUjpyZXR1cm4gZnVuY3Rpb24odCxlLG4pe3JldHVybiBNKEwsbmV3IGEuQWx0ZXJuYXRpb24oe2RlZmluaXRpb246W119KSx0LGUsbil9KHQsbixpKTtjYXNlIHIuRkxBVDpyZXR1cm4gZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBhLkZsYXQoe2RlZmluaXRpb246W119KSxpPVAuZXhlYyh0LnRleHQpWzFdO28uaXNVbmRlZmluZWQoaSl8fChyLm5hbWU9aSk7cmV0dXJuIGIocix0LnJhbmdlLGUsbil9KHQsbixpKTtjYXNlIHIuUkVGOnJldHVybiBmdW5jdGlvbih0KXt2YXIgZT1sLmV4ZWModC50ZXh0KSxuPXZvaWQgMD09PWVbMV0/MDpwYXJzZUludChlWzFdLDEwKSxyPWVbMl07cmV0dXJuIG5ldyBhLk5vblRlcm1pbmFsKHtub25UZXJtaW5hbE5hbWU6cixpZHg6bn0pfSh0KTtjYXNlIHIuVEVSTUlOQUw6cmV0dXJuIGZ1bmN0aW9uKHQsbil7dmFyIHI9Yy5leGVjKHQudGV4dCksaT12b2lkIDA9PT1yWzFdPzA6cGFyc2VJbnQoclsxXSwxMCksbz1yWzJdLHM9ZS50ZXJtaW5hbE5hbWVUb0NvbnN0cnVjdG9yW29dO2lmKCFzKXRocm93IEVycm9yKFwiVGVybWluYWwgVG9rZW4gbmFtZTogPFwiK28rXCI+IG5vdCBmb3VuZCBpbiBydWxlOiA8XCIrbitcIj4gIFxcblxcdFNlZTogaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9yZXNvbHZpbmdfZ3JhbW1hcl9lcnJvcnMuaHRtbCNURVJNSU5BTF9OQU1FX05PVF9GT1VORFxcblxcdEZvciBGdXJ0aGVyIGRldGFpbHMuXCIpO3JldHVybiBuZXcgYS5UZXJtaW5hbCh7dGVybWluYWxUeXBlOnMsaWR4Oml9KX0odCxpKTtkZWZhdWx0OnRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIil9fWZ1bmN0aW9uIE0odCxlLG4scixpKXt2YXIgYT10LmV4ZWMobi50ZXh0KSxzPXZvaWQgMD09PWFbMV07ZS5pZHg9cz8wOnBhcnNlSW50KGFbMV0sMTApO3ZhciB1PWFbMl07cmV0dXJuIG8uaXNVbmRlZmluZWQodSl8fChlLm5hbWU9dSksYihlLG4ucmFuZ2UscixpKX1mdW5jdGlvbiBGKHQsbixyLGksYSl7dmFyIHM9aS5leGVjKHQudGV4dCksdT12b2lkIDA9PT1zWzFdPzA6cGFyc2VJbnQoc1sxXSwxMCksYz1zWzNdLHA9ZS50ZXJtaW5hbE5hbWVUb0NvbnN0cnVjdG9yW2NdO2lmKCFwKXRocm93IEVycm9yKFwiU2VwYXJhdG9yIFRlcm1pbmFsIFRva2VuIG5hbWU6IFwiK2MrXCIgbm90IGZvdW5kXCIpO3ZhciBsPW5ldyByKHtkZWZpbml0aW9uOltdLHNlcGFyYXRvcjpwLGlkeDp1fSksaD1zWzJdO3JldHVybiBvLmlzVW5kZWZpbmVkKGgpfHwobC5uYW1lPWgpLGIobCx0LnJhbmdlLG4sYSl9ZnVuY3Rpb24gYih0LGUsbixyKXt2YXIgaT1EKGUsbiksYT1vLnNvcnRCeShpLGZ1bmN0aW9uKHQpe3JldHVybiB0LnJhbmdlLnN0YXJ0fSkscz1bXTtyZXR1cm4gby5mb3JFYWNoKGEsZnVuY3Rpb24odCl7cy5wdXNoKEModCxuLHIpKTt9KSx0LmRlZmluaXRpb249cyx0fWZ1bmN0aW9uIEQodCxlKXtyZXR1cm4gby5maWx0ZXIoZSxmdW5jdGlvbihuKXt2YXIgcj10LnN0cmljdGx5Q29udGFpbnNSYW5nZShuLnJhbmdlKSxpPW8uZXZlcnkoZSxmdW5jdGlvbihlKXt2YXIgcj1lLnJhbmdlLnN0cmljdGx5Q29udGFpbnNSYW5nZShuLnJhbmdlKSxpPWUucmFuZ2UuaXNTdHJpY3RseUNvbnRhaW5lZEluUmFuZ2UodCk7cmV0dXJuICEociYmaSl9KTtyZXR1cm4gciYmaX0pfWUudGVybWluYWxOYW1lVG9Db25zdHJ1Y3Rvcj17fSxlLmJ1aWxkVG9wUHJvZHVjdGlvbj1mdW5jdGlvbih0LG4scil7ZS50ZXJtaW5hbE5hbWVUb0NvbnN0cnVjdG9yPXI7dmFyIG89VihqKEsoXCIgIFwiK3QpKSk7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiBiKG5ldyBhLlJ1bGUoe25hbWU6dCxkZWZpbml0aW9uOltdLG9yZ1RleHQ6cn0pLGUsbix0KX0obixuZXcgaS5SYW5nZSgwLHQubGVuZ3RoKzIpLG8sdCl9LGUuYnVpbGRQcm9kR2FzdD1DLGUuZ2V0RGlyZWN0bHlDb250YWluZWRSYW5nZXM9RDt2YXIgdz0vXFwvXFwvLiovZyxVPS9cXC9cXCooW14qXXxbXFxyXFxuXXwoXFwqKyhbXipcXC9dfFtcXHJcXG5dKSkpKlxcKitcXC8vZyxHPS8oTkFNRVxccyo6XFxzKik/XCIoW15cXFxcXCJdfFxcXFwoW2JmbnJ0dlwiXFxcXFxcL118dVswLTlhLWZBLUZdezR9KSkqXCIvZyxCPS8oTkFNRVxccyo6XFxzKik/JyhbXlxcXFwnXXxcXFxcKFtiZm5ydHYnXFxcXFxcL118dVswLTlhLWZBLUZdezR9KSkqJy9nO2Z1bmN0aW9uIEsodCl7cmV0dXJuIHQucmVwbGFjZSh3LFwiXCIpLnJlcGxhY2UoVSxcIlwiKX1mdW5jdGlvbiBXKHQsZSl7cmV0dXJuIHZvaWQgMCE9PWU/dDpcIlwifWZ1bmN0aW9uIGoodCl7cmV0dXJuIHQucmVwbGFjZShHLFcpLnJlcGxhY2UoQixXKX1mdW5jdGlvbiBWKHQpe3ZhciBlPVkodCksbj1IKHQpLHI9WCh0KSxpPXoodCksbz1xKHQpLGE9JCh0KSxzPVoodCksdT1RKHQpO3JldHVybiBbXS5jb25jYXQoZSxuLHIsaSxvLGEscyx1KX1mdW5jdGlvbiBZKHQpe3JldHVybiBudCh0LHIuVEVSTUlOQUwscCl9ZnVuY3Rpb24gSCh0KXtyZXR1cm4gbnQodCxyLlJFRixoKX1mdW5jdGlvbiBYKHQpe3JldHVybiBydCh0LHIuQVRfTEVBU1RfT05FLFMpfWZ1bmN0aW9uIHoodCl7cmV0dXJuIHJ0KHQsci5BVF9MRUFTVF9PTkVfU0VQLEEpfWZ1bmN0aW9uIHEodCl7cmV0dXJuIHJ0KHQsci5NQU5ZLFQpfWZ1bmN0aW9uICQodCl7cmV0dXJuIHJ0KHQsci5NQU5ZX1NFUCxfKX1mdW5jdGlvbiBaKHQpe3JldHVybiBydCh0LHIuT1BUSU9OLEUpfWZ1bmN0aW9uIFEodCl7dmFyIGU9cnQodCxyLk9SLGspLG49ZXQoZSk7cmV0dXJuIGUuY29uY2F0KG4pfWUucmVtb3ZlQ29tbWVudHM9SyxlLnJlbW92ZVN0cmluZ0xpdGVyYWxzPWosZS5jcmVhdGVSYW5nZXM9VixlLmNyZWF0ZVRlcm1pbmFsUmFuZ2VzPVksZS5jcmVhdGVSZWZzUmFuZ2VzPUgsZS5jcmVhdGVBdExlYXN0T25lUmFuZ2VzPVgsZS5jcmVhdGVBdExlYXN0T25lU2VwUmFuZ2VzPXosZS5jcmVhdGVNYW55UmFuZ2VzPXEsZS5jcmVhdGVNYW55U2VwUmFuZ2VzPSQsZS5jcmVhdGVPcHRpb25SYW5nZXM9WixlLmNyZWF0ZU9yUmFuZ2VzPVE7dmFyIEo9by5wYXJ0aWFsKG90LFwie1wiLFwifVwiKSx0dD1vLnBhcnRpYWwob3QsXCIoXCIsXCIpXCIpO2Z1bmN0aW9uIGV0KHQpe3ZhciBlPVtdO3JldHVybiBvLmZvckVhY2godCxmdW5jdGlvbih0KXt2YXIgbj1pdCh0LnRleHQsci5GTEFULHgsSiksaT10LnJhbmdlLnN0YXJ0O28uZm9yRWFjaChuLGZ1bmN0aW9uKHQpe3QucmFuZ2Uuc3RhcnQrPWksdC5yYW5nZS5lbmQrPWk7fSksZT1lLmNvbmNhdChuKTt9KSxvLnVuaXEoZSxmdW5jdGlvbih0KXtyZXR1cm4gdC50eXBlK1wiflwiK3QucmFuZ2Uuc3RhcnQrXCJ+XCIrdC5yYW5nZS5lbmQrXCJ+XCIrdC50ZXh0fSl9ZnVuY3Rpb24gbnQodCxlLG4pe2Zvcih2YXIgcixvPVtdO3I9bi5leGVjKHQpOyl7dmFyIGE9ci5pbmRleCxzPW4ubGFzdEluZGV4LHU9bmV3IGkuUmFuZ2UoYSxzKSxjPXJbMF07by5wdXNoKHtyYW5nZTp1LHRleHQ6Yyx0eXBlOmV9KTt9cmV0dXJuIG99ZnVuY3Rpb24gcnQodCxlLG4pe3JldHVybiBpdCh0LGUsbix0dCl9ZnVuY3Rpb24gaXQodCxlLG4scil7Zm9yKHZhciBvLGE9W107bz1uLmV4ZWModCk7KXt2YXIgcz1vLmluZGV4LHU9cihzK29bMF0ubGVuZ3RoLHQpLGM9bmV3IGkuUmFuZ2Uocyx1KSxwPXQuc3Vic3RyKHMsdS1zKzEpO2EucHVzaCh7cmFuZ2U6Yyx0ZXh0OnAsdHlwZTplfSk7fXJldHVybiBhfWZ1bmN0aW9uIG90KHQsZSxuLHIpe2Zvcih2YXIgaT1bMV0sYT0tMTshby5pc0VtcHR5KGkpJiZhK248ci5sZW5ndGg7KXthKys7dmFyIHM9ci5jaGFyQXQobithKTtzPT09dD9pLnB1c2goMSk6cz09PWUmJmkucG9wKCk7fWlmKG8uaXNFbXB0eShpKSlyZXR1cm4gYStuO3Rocm93IG5ldyBFcnJvcihcIklOVkFMSUQgSU5QVVQgVEVYVCwgVU5URVJNSU5BVEVEIFBBUkVOVEhFU0lTXCIpfWZ1bmN0aW9uIGF0KHQsZSl7cmV0dXJuIG8ubWFwKHQsZnVuY3Rpb24odCl7cmV0dXJuIHN0KHQsZSl9KX1mdW5jdGlvbiBzdCh0LGUpe3N3aXRjaCh0LnR5cGUpe2Nhc2VcIk5vblRlcm1pbmFsXCI6cmV0dXJuIG5ldyBhLk5vblRlcm1pbmFsKHtub25UZXJtaW5hbE5hbWU6dC5uYW1lLGlkeDp0LmlkeH0pO2Nhc2VcIkZsYXRcIjpyZXR1cm4gbmV3IGEuRmxhdCh7bmFtZTp0Lm5hbWUsZGVmaW5pdGlvbjphdCh0LmRlZmluaXRpb24sZSl9KTtjYXNlXCJPcHRpb25cIjpyZXR1cm4gbmV3IGEuT3B0aW9uKHtuYW1lOnQubmFtZSxpZHg6dC5pZHgsZGVmaW5pdGlvbjphdCh0LmRlZmluaXRpb24sZSl9KTtjYXNlXCJSZXBldGl0aW9uTWFuZGF0b3J5XCI6cmV0dXJuIG5ldyBhLlJlcGV0aXRpb25NYW5kYXRvcnkoe25hbWU6dC5uYW1lLGlkeDp0LmlkeCxkZWZpbml0aW9uOmF0KHQuZGVmaW5pdGlvbixlKX0pO2Nhc2VcIlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yXCI6cmV0dXJuIG5ldyBhLlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yKHtuYW1lOnQubmFtZSxpZHg6dC5pZHgsc2VwYXJhdG9yOmVbdC5zZXBhcmF0b3IubmFtZV0sZGVmaW5pdGlvbjphdCh0LmRlZmluaXRpb24sZSl9KTtjYXNlXCJSZXBldGl0aW9uV2l0aFNlcGFyYXRvclwiOnJldHVybiBuZXcgYS5SZXBldGl0aW9uV2l0aFNlcGFyYXRvcih7bmFtZTp0Lm5hbWUsaWR4OnQuaWR4LHNlcGFyYXRvcjplW3Quc2VwYXJhdG9yLm5hbWVdLGRlZmluaXRpb246YXQodC5kZWZpbml0aW9uLGUpfSk7Y2FzZVwiUmVwZXRpdGlvblwiOnJldHVybiBuZXcgYS5SZXBldGl0aW9uKHtuYW1lOnQubmFtZSxpZHg6dC5pZHgsZGVmaW5pdGlvbjphdCh0LmRlZmluaXRpb24sZSl9KTtjYXNlXCJBbHRlcm5hdGlvblwiOnJldHVybiBuZXcgYS5BbHRlcm5hdGlvbih7bmFtZTp0Lm5hbWUsaWR4OnQuaWR4LGRlZmluaXRpb246YXQodC5kZWZpbml0aW9uLGUpfSk7Y2FzZVwiVGVybWluYWxcIjpyZXR1cm4gbmV3IGEuVGVybWluYWwoe3Rlcm1pbmFsVHlwZTplW3QubmFtZV0saWR4OnQuaWR4fSk7Y2FzZVwiUnVsZVwiOnJldHVybiBuZXcgYS5SdWxlKHtuYW1lOnQubmFtZSxvcmdUZXh0OnQub3JnVGV4dCxkZWZpbml0aW9uOmF0KHQuZGVmaW5pdGlvbixlKX0pO319ZS5jcmVhdGVPclBhcnRSYW5nZXM9ZXQsZS5maW5kQ2xvc2luZ09mZnNldD1vdCxlLmRlc2VyaWFsaXplR3JhbW1hcj1hdCxlLmRlc2VyaWFsaXplUHJvZHVjdGlvbj1zdDt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1uKDApLGk9big0KSxvPW4oMzApLGE9bigxMSkscz1uKDEwKSx1PW4oOCk7ZS5yZXNvbHZlR3JhbW1hcj1mdW5jdGlvbih0KXt0PXIuZGVmYXVsdHModCx7ZXJyTXNnUHJvdmlkZXI6cy5kZWZhdWx0R3JhbW1hclJlc29sdmVyRXJyb3JQcm92aWRlcn0pO3ZhciBlPW5ldyBpLkhhc2hUYWJsZTtyZXR1cm4gci5mb3JFYWNoKHQucnVsZXMsZnVuY3Rpb24odCl7ZS5wdXQodC5uYW1lLHQpO30pLG8ucmVzb2x2ZUdyYW1tYXIoZSx0LmVyck1zZ1Byb3ZpZGVyKX0sZS52YWxpZGF0ZUdyYW1tYXI9ZnVuY3Rpb24odCl7cmV0dXJuIHQ9ci5kZWZhdWx0cyh0LHtlcnJNc2dQcm92aWRlcjpzLmRlZmF1bHRHcmFtbWFyVmFsaWRhdG9yRXJyb3JQcm92aWRlcixpZ25vcmVkSXNzdWVzOnt9fSksYS52YWxpZGF0ZUdyYW1tYXIodC5ydWxlcyx0Lm1heExvb2thaGVhZCx0LnRva2VuVHlwZXMsdC5pZ25vcmVkSXNzdWVzLHQuZXJyTXNnUHJvdmlkZXIsdC5ncmFtbWFyTmFtZSl9LGUuYXNzaWduT2NjdXJyZW5jZUluZGljZXM9ZnVuY3Rpb24odCl7ci5mb3JFYWNoKHQucnVsZXMsZnVuY3Rpb24odCl7dmFyIGU9bmV3IHUuRHNsTWV0aG9kc0NvbGxlY3RvclZpc2l0b3I7dC5hY2NlcHQoZSksci5mb3JFYWNoKGUuZHNsTWV0aG9kcyxmdW5jdGlvbih0KXtyLmZvckVhY2godCxmdW5jdGlvbih0LGUpe3QuaWR4PWUrMTt9KTt9KTt9KTt9O30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPW4oMiksaT1uKDApLG89big2KSxhPW4oMjIpLHM9big0KSx1PW4oMyk7ZnVuY3Rpb24gYyh0KXt0aGlzLm5hbWU9ZS5JTl9SVUxFX1JFQ09WRVJZX0VYQ0VQVElPTix0aGlzLm1lc3NhZ2U9dDt9ZS5FT0ZfRk9MTE9XX0tFWT17fSxlLklOX1JVTEVfUkVDT1ZFUllfRVhDRVBUSU9OPVwiSW5SdWxlUmVjb3ZlcnlFeGNlcHRpb25cIixlLkluUnVsZVJlY292ZXJ5RXhjZXB0aW9uPWMsYy5wcm90b3R5cGU9RXJyb3IucHJvdG90eXBlO3ZhciBwPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUuaW5pdFJlY292ZXJhYmxlPWZ1bmN0aW9uKHQpe3RoaXMuZmlyc3RBZnRlclJlcE1hcD1uZXcgcy5IYXNoVGFibGUsdGhpcy5yZXN5bmNGb2xsb3dzPW5ldyBzLkhhc2hUYWJsZSx0aGlzLnJlY292ZXJ5RW5hYmxlZD1pLmhhcyh0LFwicmVjb3ZlcnlFbmFibGVkXCIpP3QucmVjb3ZlcnlFbmFibGVkOnUuREVGQVVMVF9QQVJTRVJfQ09ORklHLnJlY292ZXJ5RW5hYmxlZCx0aGlzLnJlY292ZXJ5RW5hYmxlZCYmKHRoaXMuYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5PWwpO30sdC5wcm90b3R5cGUuZ2V0VG9rZW5Ub0luc2VydD1mdW5jdGlvbih0KXt2YXIgZT1yLmNyZWF0ZVRva2VuSW5zdGFuY2UodCxcIlwiLE5hTixOYU4sTmFOLE5hTixOYU4sTmFOKTtyZXR1cm4gZS5pc0luc2VydGVkSW5SZWNvdmVyeT0hMCxlfSx0LnByb3RvdHlwZS5jYW5Ub2tlblR5cGVCZUluc2VydGVkSW5SZWNvdmVyeT1mdW5jdGlvbih0KXtyZXR1cm4gITB9LHQucHJvdG90eXBlLnRyeUluUmVwZXRpdGlvblJlY292ZXJ5PWZ1bmN0aW9uKHQsZSxuLHIpe2Zvcih2YXIgYT10aGlzLHM9dGhpcy5maW5kUmVTeW5jVG9rZW5UeXBlKCksdT10aGlzLmV4cG9ydExleGVyU3RhdGUoKSxjPVtdLHA9ITEsbD10aGlzLkxBKDEpLGg9dGhpcy5MQSgxKSxmPWZ1bmN0aW9uKCl7dmFyIHQ9YS5MQSgwKSxlPWEuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGRNaXNtYXRjaFRva2VuTWVzc2FnZSh7ZXhwZWN0ZWQ6cixhY3R1YWw6bCxwcmV2aW91czp0LHJ1bGVOYW1lOmEuZ2V0Q3VyclJ1bGVGdWxsTmFtZSgpfSksbj1uZXcgby5NaXNtYXRjaGVkVG9rZW5FeGNlcHRpb24oZSxsLGEuTEEoMCkpO24ucmVzeW5jZWRUb2tlbnM9aS5kcm9wUmlnaHQoYyksYS5TQVZFX0VSUk9SKG4pO307IXA7KXtpZih0aGlzLnRva2VuTWF0Y2hlcihoLHIpKXJldHVybiB2b2lkIGYoKTtpZihuLmNhbGwodGhpcykpcmV0dXJuIGYoKSx2b2lkIHQuYXBwbHkodGhpcyxlKTt0aGlzLnRva2VuTWF0Y2hlcihoLHMpP3A9ITA6KGg9dGhpcy5TS0lQX1RPS0VOKCksdGhpcy5hZGRUb1Jlc3luY1Rva2VucyhoLGMpKTt9dGhpcy5pbXBvcnRMZXhlclN0YXRlKHUpO30sdC5wcm90b3R5cGUuc2hvdWxkSW5SZXBldGl0aW9uUmVjb3ZlcnlCZVRyaWVkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMCE9PXQmJnZvaWQgMCE9PWUmJighdGhpcy50b2tlbk1hdGNoZXIodGhpcy5MQSgxKSx0KSYmKCF0aGlzLmlzQmFja1RyYWNraW5nKCkmJiF0aGlzLmNhblBlcmZvcm1JblJ1bGVSZWNvdmVyeSh0LHRoaXMuZ2V0Rm9sbG93c0ZvckluUnVsZVJlY292ZXJ5KHQsZSkpKSl9LHQucHJvdG90eXBlLmdldEZvbGxvd3NGb3JJblJ1bGVSZWNvdmVyeT1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2V0Q3VycmVudEdyYW1tYXJQYXRoKHQsZSk7cmV0dXJuIHRoaXMuZ2V0TmV4dFBvc3NpYmxlVG9rZW5UeXBlcyhuKX0sdC5wcm90b3R5cGUudHJ5SW5SdWxlUmVjb3Zlcnk9ZnVuY3Rpb24odCxlKXtpZih0aGlzLmNhblJlY292ZXJXaXRoU2luZ2xlVG9rZW5JbnNlcnRpb24odCxlKSlyZXR1cm4gdGhpcy5nZXRUb2tlblRvSW5zZXJ0KHQpO2lmKHRoaXMuY2FuUmVjb3ZlcldpdGhTaW5nbGVUb2tlbkRlbGV0aW9uKHQpKXt2YXIgbj10aGlzLlNLSVBfVE9LRU4oKTtyZXR1cm4gdGhpcy5jb25zdW1lVG9rZW4oKSxufXRocm93IG5ldyBjKFwic2FkIHNhZCBwYW5kYVwiKX0sdC5wcm90b3R5cGUuY2FuUGVyZm9ybUluUnVsZVJlY292ZXJ5PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuY2FuUmVjb3ZlcldpdGhTaW5nbGVUb2tlbkluc2VydGlvbih0LGUpfHx0aGlzLmNhblJlY292ZXJXaXRoU2luZ2xlVG9rZW5EZWxldGlvbih0KX0sdC5wcm90b3R5cGUuY2FuUmVjb3ZlcldpdGhTaW5nbGVUb2tlbkluc2VydGlvbj1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7aWYoIXRoaXMuY2FuVG9rZW5UeXBlQmVJbnNlcnRlZEluUmVjb3ZlcnkodCkpcmV0dXJuICExO2lmKGkuaXNFbXB0eShlKSlyZXR1cm4gITE7dmFyIHI9dGhpcy5MQSgxKTtyZXR1cm4gdm9pZCAwIT09aS5maW5kKGUsZnVuY3Rpb24odCl7cmV0dXJuIG4udG9rZW5NYXRjaGVyKHIsdCl9KX0sdC5wcm90b3R5cGUuY2FuUmVjb3ZlcldpdGhTaW5nbGVUb2tlbkRlbGV0aW9uPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRva2VuTWF0Y2hlcih0aGlzLkxBKDIpLHQpfSx0LnByb3RvdHlwZS5pc0luQ3VycmVudFJ1bGVSZVN5bmNTZXQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRDdXJyRm9sbG93S2V5KCksbj10aGlzLmdldEZvbGxvd1NldEZyb21Gb2xsb3dLZXkoZSk7cmV0dXJuIGkuY29udGFpbnMobix0KX0sdC5wcm90b3R5cGUuZmluZFJlU3luY1Rva2VuVHlwZT1mdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmZsYXR0ZW5Gb2xsb3dTZXQoKSxlPXRoaXMuTEEoMSksbj0yOzspe3ZhciByPWUudG9rZW5UeXBlO2lmKGkuY29udGFpbnModCxyKSlyZXR1cm4gcjtlPXRoaXMuTEEobiksbisrO319LHQucHJvdG90eXBlLmdldEN1cnJGb2xsb3dLZXk9ZnVuY3Rpb24oKXtpZigxPT09dGhpcy5SVUxFX1NUQUNLLmxlbmd0aClyZXR1cm4gZS5FT0ZfRk9MTE9XX0tFWTt2YXIgdD10aGlzLmdldExhc3RFeHBsaWNpdFJ1bGVTaG9ydE5hbWUoKSxuPXRoaXMuZ2V0TGFzdEV4cGxpY2l0UnVsZU9jY3VycmVuY2VJbmRleCgpLHI9dGhpcy5nZXRQcmV2aW91c0V4cGxpY2l0UnVsZVNob3J0TmFtZSgpO3JldHVybiB7cnVsZU5hbWU6dGhpcy5zaG9ydFJ1bGVOYW1lVG9GdWxsTmFtZSh0KSxpZHhJbkNhbGxpbmdSdWxlOm4saW5SdWxlOnRoaXMuc2hvcnRSdWxlTmFtZVRvRnVsbE5hbWUocil9fSx0LnByb3RvdHlwZS5idWlsZEZ1bGxGb2xsb3dLZXlTdGFjaz1mdW5jdGlvbigpe3ZhciB0PXRoaXMsbj10aGlzLlJVTEVfU1RBQ0sscj10aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSztyZXR1cm4gaS5pc0VtcHR5KHRoaXMuTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLKXx8KG49aS5tYXAodGhpcy5MQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0ssZnVuY3Rpb24oZSl7cmV0dXJuIHQuUlVMRV9TVEFDS1tlXX0pLHI9aS5tYXAodGhpcy5MQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0ssZnVuY3Rpb24oZSl7cmV0dXJuIHQuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLW2VdfSkpLGkubWFwKG4sZnVuY3Rpb24oaSxvKXtyZXR1cm4gMD09PW8/ZS5FT0ZfRk9MTE9XX0tFWTp7cnVsZU5hbWU6dC5zaG9ydFJ1bGVOYW1lVG9GdWxsTmFtZShpKSxpZHhJbkNhbGxpbmdSdWxlOnJbb10saW5SdWxlOnQuc2hvcnRSdWxlTmFtZVRvRnVsbE5hbWUobltvLTFdKX19KX0sdC5wcm90b3R5cGUuZmxhdHRlbkZvbGxvd1NldD1mdW5jdGlvbigpe3ZhciB0PXRoaXMsZT1pLm1hcCh0aGlzLmJ1aWxkRnVsbEZvbGxvd0tleVN0YWNrKCksZnVuY3Rpb24oZSl7cmV0dXJuIHQuZ2V0Rm9sbG93U2V0RnJvbUZvbGxvd0tleShlKX0pO3JldHVybiBpLmZsYXR0ZW4oZSl9LHQucHJvdG90eXBlLmdldEZvbGxvd1NldEZyb21Gb2xsb3dLZXk9ZnVuY3Rpb24odCl7aWYodD09PWUuRU9GX0ZPTExPV19LRVkpcmV0dXJuIFtyLkVPRl07dmFyIG49dC5ydWxlTmFtZSt0LmlkeEluQ2FsbGluZ1J1bGUrYS5JTit0LmluUnVsZTtyZXR1cm4gdGhpcy5yZXN5bmNGb2xsb3dzLmdldChuKX0sdC5wcm90b3R5cGUuYWRkVG9SZXN5bmNUb2tlbnM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50b2tlbk1hdGNoZXIodCxyLkVPRil8fGUucHVzaCh0KSxlfSx0LnByb3RvdHlwZS5yZVN5bmNUbz1mdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj10aGlzLkxBKDEpOyExPT09dGhpcy50b2tlbk1hdGNoZXIobix0KTspbj10aGlzLlNLSVBfVE9LRU4oKSx0aGlzLmFkZFRvUmVzeW5jVG9rZW5zKG4sZSk7cmV0dXJuIGkuZHJvcFJpZ2h0KGUpfSx0LnByb3RvdHlwZS5hdHRlbXB0SW5SZXBldGl0aW9uUmVjb3Zlcnk9ZnVuY3Rpb24odCxlLG4scixpLG8pe30sdC5wcm90b3R5cGUuZ2V0Q3VycmVudEdyYW1tYXJQYXRoPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHtydWxlU3RhY2s6dGhpcy5nZXRIdW1hblJlYWRhYmxlUnVsZVN0YWNrKCksb2NjdXJyZW5jZVN0YWNrOmkuY2xvbmVBcnIodGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0spLGxhc3RUb2s6dCxsYXN0VG9rT2NjdXJyZW5jZTplfX0sdC5wcm90b3R5cGUuZ2V0SHVtYW5SZWFkYWJsZVJ1bGVTdGFjaz1mdW5jdGlvbigpe3ZhciB0PXRoaXM7cmV0dXJuIGkuaXNFbXB0eSh0aGlzLkxBU1RfRVhQTElDSVRfUlVMRV9TVEFDSyk/aS5tYXAodGhpcy5SVUxFX1NUQUNLLGZ1bmN0aW9uKGUpe3JldHVybiB0LnNob3J0UnVsZU5hbWVUb0Z1bGxOYW1lKGUpfSk6aS5tYXAodGhpcy5MQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0ssZnVuY3Rpb24oZSl7cmV0dXJuIHQuc2hvcnRSdWxlTmFtZVRvRnVsbE5hbWUodC5SVUxFX1NUQUNLW2VdKX0pfSx0fSgpO2Z1bmN0aW9uIGwodCxlLG4saSxvLGEpe3ZhciBzPXRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKGksbyksdT10aGlzLmZpcnN0QWZ0ZXJSZXBNYXAuZ2V0KHMpO2lmKHZvaWQgMD09PXUpe3ZhciBjPXRoaXMuZ2V0Q3VyclJ1bGVGdWxsTmFtZSgpO3U9bmV3IGEodGhpcy5nZXRHQXN0UHJvZHVjdGlvbnMoKS5nZXQoYyksbykuc3RhcnRXYWxraW5nKCksdGhpcy5maXJzdEFmdGVyUmVwTWFwLnB1dChzLHUpO312YXIgcD11LnRva2VuLGw9dS5vY2N1cnJlbmNlLGg9dS5pc0VuZE9mUnVsZTsxPT09dGhpcy5SVUxFX1NUQUNLLmxlbmd0aCYmaCYmdm9pZCAwPT09cCYmKHA9ci5FT0YsbD0xKSx0aGlzLnNob3VsZEluUmVwZXRpdGlvblJlY292ZXJ5QmVUcmllZChwLGwpJiZ0aGlzLnRyeUluUmVwZXRpdGlvblJlY292ZXJ5KHQsZSxuLHApO31lLlJlY292ZXJhYmxlPXAsZS5hdHRlbXB0SW5SZXBldGl0aW9uUmVjb3Zlcnk9bDt9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcixpPXRoaXMmJnRoaXMuX19leHRlbmRzfHwocj1mdW5jdGlvbih0LGUpe3JldHVybiAocj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24odCxlKXt0Ll9fcHJvdG9fXz1lO318fGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuIGluIGUpZS5oYXNPd25Qcm9wZXJ0eShuKSYmKHRbbl09ZVtuXSk7fSkodCxlKX0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKCl7dGhpcy5jb25zdHJ1Y3Rvcj10O31yKHQsZSksdC5wcm90b3R5cGU9bnVsbD09PWU/T2JqZWN0LmNyZWF0ZShlKToobi5wcm90b3R5cGU9ZS5wcm90b3R5cGUsbmV3IG4pO30pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBvPW4oMTQpLGE9big0KSxzPW4oMjEpLHU9bigwKSxjPW4oMjIpLHA9bigyKSxsPW4oMSksaD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3ZhciBuPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi50b3BQcm9kPWUsbi5mb2xsb3dzPW5ldyBhLkhhc2hUYWJsZSxufXJldHVybiBpKGUsdCksZS5wcm90b3R5cGUuc3RhcnRXYWxraW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMud2Fsayh0aGlzLnRvcFByb2QpLHRoaXMuZm9sbG93c30sZS5wcm90b3R5cGUud2Fsa1Rlcm1pbmFsPWZ1bmN0aW9uKHQsZSxuKXt9LGUucHJvdG90eXBlLndhbGtQcm9kUmVmPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1mKHQucmVmZXJlbmNlZFJ1bGUsdC5pZHgpK3RoaXMudG9wUHJvZC5uYW1lLGk9ZS5jb25jYXQobiksbz1uZXcgbC5GbGF0KHtkZWZpbml0aW9uOml9KSxhPXMuZmlyc3Qobyk7dGhpcy5mb2xsb3dzLnB1dChyLGEpO30sZX0oby5SZXN0V2Fsa2VyKTtmdW5jdGlvbiBmKHQsZSl7cmV0dXJuIHQubmFtZStlK2MuSU59ZS5SZXN5bmNGb2xsb3dzV2Fsa2VyPWgsZS5jb21wdXRlQWxsUHJvZHNGb2xsb3dzPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBhLkhhc2hUYWJsZTtyZXR1cm4gdS5mb3JFYWNoKHQsZnVuY3Rpb24odCl7dmFyIG49bmV3IGgodCkuc3RhcnRXYWxraW5nKCk7ZS5wdXRBbGwobik7fSksZX0sZS5idWlsZEJldHdlZW5Qcm9kc0ZvbGxvd1ByZWZpeD1mLGUuYnVpbGRJblByb2RGb2xsb3dQcmVmaXg9ZnVuY3Rpb24odCl7cmV0dXJuIHAudG9rZW5OYW1lKHQudGVybWluYWxUeXBlKSt0LmlkeCtjLklOfTt9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcixpPXRoaXMmJnRoaXMuX19leHRlbmRzfHwocj1mdW5jdGlvbih0LGUpe3JldHVybiAocj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24odCxlKXt0Ll9fcHJvdG9fXz1lO318fGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuIGluIGUpZS5oYXNPd25Qcm9wZXJ0eShuKSYmKHRbbl09ZVtuXSk7fSkodCxlKX0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKCl7dGhpcy5jb25zdHJ1Y3Rvcj10O31yKHQsZSksdC5wcm90b3R5cGU9bnVsbD09PWU/T2JqZWN0LmNyZWF0ZShlKToobi5wcm90b3R5cGU9ZS5wcm90b3R5cGUsbmV3IG4pO30pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBvPW4oMTkpLGE9bigyKSxzPW4oMTUpLHU9bigwKSxjPW4oMjgpLHA9bmV3IG8uUmVnRXhwUGFyc2VyLGw9XCJQQVRURVJOXCI7ZnVuY3Rpb24gaCh0KXt2YXIgZT11LmZpbHRlcih0LGZ1bmN0aW9uKHQpe3JldHVybiAhdS5oYXModCxsKX0pO3JldHVybiB7ZXJyb3JzOnUubWFwKGUsZnVuY3Rpb24odCl7cmV0dXJuIHttZXNzYWdlOlwiVG9rZW4gVHlwZTogLT5cIithLnRva2VuTmFtZSh0KStcIjwtIG1pc3Npbmcgc3RhdGljICdQQVRURVJOJyBwcm9wZXJ0eVwiLHR5cGU6cy5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuTUlTU0lOR19QQVRURVJOLHRva2VuVHlwZXM6W3RdfX0pLHZhbGlkOnUuZGlmZmVyZW5jZSh0LGUpfX1mdW5jdGlvbiBmKHQpe3ZhciBlPXUuZmlsdGVyKHQsZnVuY3Rpb24odCl7dmFyIGU9dFtsXTtyZXR1cm4gISh1LmlzUmVnRXhwKGUpfHx1LmlzRnVuY3Rpb24oZSl8fHUuaGFzKGUsXCJleGVjXCIpfHx1LmlzU3RyaW5nKGUpKX0pO3JldHVybiB7ZXJyb3JzOnUubWFwKGUsZnVuY3Rpb24odCl7cmV0dXJuIHttZXNzYWdlOlwiVG9rZW4gVHlwZTogLT5cIithLnRva2VuTmFtZSh0KStcIjwtIHN0YXRpYyAnUEFUVEVSTicgY2FuIG9ubHkgYmUgYSBSZWdFeHAsIGEgRnVuY3Rpb24gbWF0Y2hpbmcgdGhlIHtDdXN0b21QYXR0ZXJuTWF0Y2hlckZ1bmN9IHR5cGUgb3IgYW4gT2JqZWN0IG1hdGNoaW5nIHRoZSB7SUN1c3RvbVBhdHRlcm59IGludGVyZmFjZS5cIix0eXBlOnMuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLklOVkFMSURfUEFUVEVSTix0b2tlblR5cGVzOlt0XX19KSx2YWxpZDp1LmRpZmZlcmVuY2UodCxlKX19ZS5ERUZBVUxUX01PREU9XCJkZWZhdWx0TW9kZVwiLGUuTU9ERVM9XCJtb2Rlc1wiLGUuU1VQUE9SVF9TVElDS1k9XCJib29sZWFuXCI9PXR5cGVvZiBuZXcgUmVnRXhwKFwiKD86KVwiKS5zdGlja3ksZS5kaXNhYmxlU3RpY2t5PWZ1bmN0aW9uKCl7ZS5TVVBQT1JUX1NUSUNLWT0hMTt9LGUuZW5hYmxlU3RpY2t5PWZ1bmN0aW9uKCl7ZS5TVVBQT1JUX1NUSUNLWT0hMDt9LGUuYW5hbHl6ZVRva2VuVHlwZXM9ZnVuY3Rpb24odCxuKXtuPXUuZGVmYXVsdHMobix7dXNlU3RpY2t5OmUuU1VQUE9SVF9TVElDS1ksZGVidWc6ITEsc2FmZU1vZGU6ITEscG9zaXRpb25UcmFja2luZzpcImZ1bGxcIixsaW5lVGVybWluYXRvckNoYXJhY3RlcnM6W1wiXFxyXCIsXCJcXG5cIl19KTt2YXIgcj11LnJlamVjdCh0LGZ1bmN0aW9uKHQpe3JldHVybiB0W2xdPT09cy5MZXhlci5OQX0pLGk9ITEsbz11Lm1hcChyLGZ1bmN0aW9uKHQpe3ZhciBlPXRbbF07aWYodS5pc1JlZ0V4cChlKSl7dmFyIHI9ZS5zb3VyY2U7cmV0dXJuIDE9PT1yLmxlbmd0aCYmXCJeXCIhPT1yJiZcIiRcIiE9PXImJlwiLlwiIT09cj9yOjIhPT1yLmxlbmd0aHx8XCJcXFxcXCIhPT1yWzBdfHx1LmNvbnRhaW5zKFtcImRcIixcIkRcIixcInNcIixcIlNcIixcInRcIixcInJcIixcIm5cIixcInRcIixcIjBcIixcImNcIixcImJcIixcIkJcIixcImZcIixcInZcIixcIndcIixcIldcIl0sclsxXSk/bi51c2VTdGlja3k/TyhlKTpOKGUpOnJbMV19aWYodS5pc0Z1bmN0aW9uKGUpKXJldHVybiBpPSEwLHtleGVjOmV9O2lmKHUuaGFzKGUsXCJleGVjXCIpKXJldHVybiBpPSEwLGU7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe2lmKDE9PT1lLmxlbmd0aClyZXR1cm4gZTt2YXIgbz1lLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLFwiXFxcXCQmXCIpLGE9bmV3IFJlZ0V4cChvKTtyZXR1cm4gbi51c2VTdGlja3k/TyhhKTpOKGEpfXRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIil9KSxwPXUubWFwKHIsZnVuY3Rpb24odCl7cmV0dXJuIHQudG9rZW5UeXBlSWR4fSksaD11Lm1hcChyLGZ1bmN0aW9uKHQpe3ZhciBlPXQuR1JPVVA7aWYoZSE9PXMuTGV4ZXIuU0tJUFBFRCl7aWYodS5pc1N0cmluZyhlKSlyZXR1cm4gZTtpZih1LmlzVW5kZWZpbmVkKGUpKXJldHVybiAhMTt0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpfX0pLGY9dS5tYXAocixmdW5jdGlvbih0KXt2YXIgZT10LkxPTkdFUl9BTFQ7aWYoZSlyZXR1cm4gdS5pbmRleE9mKHIsZSl9KSxkPXUubWFwKHIsZnVuY3Rpb24odCl7cmV0dXJuIHQuUFVTSF9NT0RFfSksRT11Lm1hcChyLGZ1bmN0aW9uKHQpe3JldHVybiB1Lmhhcyh0LFwiUE9QX01PREVcIil9KSxtPVAobi5saW5lVGVybWluYXRvckNoYXJhY3RlcnMpLHk9dS5tYXAocixmdW5jdGlvbih0KXtyZXR1cm4gITF9KTtcIm9ubHlPZmZzZXRcIiE9PW4ucG9zaXRpb25UcmFja2luZyYmKHk9dS5tYXAocixmdW5jdGlvbih0KXtyZXR1cm4gdS5oYXModCxcIkxJTkVfQlJFQUtTXCIpP3QuTElORV9CUkVBS1M6ITE9PT1MKHQsbSk/Yy5jYW5NYXRjaENoYXJDb2RlKG0sdC5QQVRURVJOKTp2b2lkIDB9KSk7dmFyIFQ9dS5tYXAocixTKSx2PXUubWFwKG8sSSksZz11LnJlZHVjZShyLGZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5HUk9VUDtyZXR1cm4gdS5pc1N0cmluZyhuKSYmbiE9PXMuTGV4ZXIuU0tJUFBFRCYmKHRbbl09W10pLHR9LHt9KSxfPXUubWFwKG8sZnVuY3Rpb24odCxlKXtyZXR1cm4ge3BhdHRlcm46b1tlXSxsb25nZXJBbHQ6ZltlXSxjYW5MaW5lVGVybWluYXRvcjp5W2VdLGlzQ3VzdG9tOlRbZV0sc2hvcnQ6dltlXSxncm91cDpoW2VdLHB1c2g6ZFtlXSxwb3A6RVtlXSx0b2tlblR5cGVJZHg6cFtlXSx0b2tlblR5cGU6cltlXX19KTtmdW5jdGlvbiBSKHQsZSxuKXt2b2lkIDA9PT10W2VdJiYodFtlXT1bXSksdFtlXS5wdXNoKG4pO312YXIgQT0hMCxrPVtdO3JldHVybiBuLnNhZmVNb2RlfHwoaz11LnJlZHVjZShyLGZ1bmN0aW9uKHQsZSxyKXtpZihcInN0cmluZ1wiPT10eXBlb2YgZS5QQVRURVJOKXt2YXIgaT1lLlBBVFRFUk4uY2hhckNvZGVBdCgwKTtSKHQsaSxfW3JdKTt9ZWxzZSBpZih1LmlzQXJyYXkoZS5TVEFSVF9DSEFSU19ISU5UKSl1LmZvckVhY2goZS5TVEFSVF9DSEFSU19ISU5ULGZ1bmN0aW9uKGUpe3ZhciBuPVwic3RyaW5nXCI9PXR5cGVvZiBlP2UuY2hhckNvZGVBdCgwKTplO1IodCxuLF9bcl0pO30pO2Vsc2UgaWYodS5pc1JlZ0V4cChlLlBBVFRFUk4pKWlmKGUuUEFUVEVSTi51bmljb2RlKUE9ITEsbi5lbnN1cmVPcHRpbWl6YXRpb25zJiZ1LlBSSU5UX0VSUk9SKGMuZmFpbGVkT3B0aW1pemF0aW9uUHJlZml4TXNnK1wiXFx0VW5hYmxlIHRvIGFuYWx5emUgPCBcIitlLlBBVFRFUk4udG9TdHJpbmcoKStcIiA+IHBhdHRlcm4uXFxuXFx0VGhlIHJlZ2V4cCB1bmljb2RlIGZsYWcgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgdGhlIHJlZ2V4cC10by1hc3QgbGlicmFyeS5cXG5cXHRUaGlzIHdpbGwgZGlzYWJsZSB0aGUgbGV4ZXIncyBmaXJzdCBjaGFyIG9wdGltaXphdGlvbnMuXFxuXFx0Rm9yIGRldGFpbHMgU2VlOiBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNVTklDT0RFX09QVElNSVpFXCIpO2Vsc2Uge3ZhciBvPWMuZ2V0U3RhcnRDb2RlcyhlLlBBVFRFUk4sbi5lbnN1cmVPcHRpbWl6YXRpb25zKTt1LmlzRW1wdHkobykmJihBPSExKSx1LmZvckVhY2gobyxmdW5jdGlvbihlKXtSKHQsZSxfW3JdKTt9KTt9ZWxzZSBuLmVuc3VyZU9wdGltaXphdGlvbnMmJnUuUFJJTlRfRVJST1IoYy5mYWlsZWRPcHRpbWl6YXRpb25QcmVmaXhNc2crXCJcXHRUb2tlblR5cGU6IDxcIithLnRva2VuTmFtZShlKStcIj4gaXMgdXNpbmcgYSBjdXN0b20gdG9rZW4gcGF0dGVybiB3aXRob3V0IHByb3ZpZGluZyA8c3RhcnRfY2hhcnNfaGludD4gcGFyYW1ldGVyLlxcblxcdFRoaXMgd2lsbCBkaXNhYmxlIHRoZSBsZXhlcidzIGZpcnN0IGNoYXIgb3B0aW1pemF0aW9ucy5cXG5cXHRGb3IgZGV0YWlscyBTZWU6IGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI0NVU1RPTV9PUFRJTUlaRVwiKSxBPSExO3JldHVybiB0fSxbXSkpLEEmJmsubGVuZ3RoPDY1NTM2JiYoaz11LnBhY2tBcnJheShrKSkse2VtcHR5R3JvdXBzOmcscGF0dGVybklkeFRvQ29uZmlnOl8sY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZzprLGhhc0N1c3RvbTppLGNhbkJlT3B0aW1pemVkOkF9fSxlLnZhbGlkYXRlUGF0dGVybnM9ZnVuY3Rpb24odCxlKXt2YXIgbj1bXSxyPWgodCk7bj1uLmNvbmNhdChyLmVycm9ycyk7dmFyIGk9ZihyLnZhbGlkKSxvPWkudmFsaWQ7cmV0dXJuIG49KG49KG49KG49KG49bi5jb25jYXQoaS5lcnJvcnMpKS5jb25jYXQoZnVuY3Rpb24odCl7dmFyIGU9W10sbj11LmZpbHRlcih0LGZ1bmN0aW9uKHQpe3JldHVybiB1LmlzUmVnRXhwKHRbbF0pfSk7cmV0dXJuIGU9KGU9KGU9KGU9KGU9ZS5jb25jYXQoRShuKSkpLmNvbmNhdChUKG4pKSkuY29uY2F0KHYobikpKS5jb25jYXQoZyhuKSkpLmNvbmNhdChtKG4pKX0obykpKS5jb25jYXQoXyhvKSkpLmNvbmNhdChSKG8sZSkpKS5jb25jYXQoQShvKSl9LGUuZmluZE1pc3NpbmdQYXR0ZXJucz1oLGUuZmluZEludmFsaWRQYXR0ZXJucz1mO3ZhciBkPS9bXlxcXFxdW1xcJF0vO2Z1bmN0aW9uIEUodCl7dmFyIGU9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciBlPW51bGwhPT10JiZ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpcztyZXR1cm4gZS5mb3VuZD0hMSxlfXJldHVybiBpKGUsdCksZS5wcm90b3R5cGUudmlzaXRFbmRBbmNob3I9ZnVuY3Rpb24odCl7dGhpcy5mb3VuZD0hMDt9LGV9KG8uQmFzZVJlZ0V4cFZpc2l0b3IpLG49dS5maWx0ZXIodCxmdW5jdGlvbih0KXt2YXIgbj10W2xdO3RyeXt2YXIgcj1wLnBhdHRlcm4obi50b1N0cmluZygpKSxpPW5ldyBlO3JldHVybiBpLnZpc2l0KHIpLGkuZm91bmR9Y2F0Y2godCl7cmV0dXJuIGQudGVzdChuLnNvdXJjZSl9fSk7cmV0dXJuIHUubWFwKG4sZnVuY3Rpb24odCl7cmV0dXJuIHttZXNzYWdlOlwiVW5leHBlY3RlZCBSZWdFeHAgQW5jaG9yIEVycm9yOlxcblxcdFRva2VuIFR5cGU6IC0+XCIrYS50b2tlbk5hbWUodCkrXCI8LSBzdGF0aWMgJ1BBVFRFUk4nIGNhbm5vdCBjb250YWluIGVuZCBvZiBpbnB1dCBhbmNob3IgJyQnXFxuXFx0U2VlIHNhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNBTkNIT1JTXFx0Zm9yIGRldGFpbHMuXCIsdHlwZTpzLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5FT0lfQU5DSE9SX0ZPVU5ELHRva2VuVHlwZXM6W3RdfX0pfWZ1bmN0aW9uIG0odCl7dmFyIGU9dS5maWx0ZXIodCxmdW5jdGlvbih0KXtyZXR1cm4gdFtsXS50ZXN0KFwiXCIpfSk7cmV0dXJuIHUubWFwKGUsZnVuY3Rpb24odCl7cmV0dXJuIHttZXNzYWdlOlwiVG9rZW4gVHlwZTogLT5cIithLnRva2VuTmFtZSh0KStcIjwtIHN0YXRpYyAnUEFUVEVSTicgbXVzdCBub3QgbWF0Y2ggYW4gZW1wdHkgc3RyaW5nXCIsdHlwZTpzLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5FTVBUWV9NQVRDSF9QQVRURVJOLHRva2VuVHlwZXM6W3RdfX0pfWUuZmluZEVuZE9mSW5wdXRBbmNob3I9RSxlLmZpbmRFbXB0eU1hdGNoUmVnRXhwcz1tO3ZhciB5PS9bXlxcXFxbXVtcXF5dfF5cXF4vO2Z1bmN0aW9uIFQodCl7dmFyIGU9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciBlPW51bGwhPT10JiZ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpcztyZXR1cm4gZS5mb3VuZD0hMSxlfXJldHVybiBpKGUsdCksZS5wcm90b3R5cGUudmlzaXRTdGFydEFuY2hvcj1mdW5jdGlvbih0KXt0aGlzLmZvdW5kPSEwO30sZX0oby5CYXNlUmVnRXhwVmlzaXRvciksbj11LmZpbHRlcih0LGZ1bmN0aW9uKHQpe3ZhciBuPXRbbF07dHJ5e3ZhciByPXAucGF0dGVybihuLnRvU3RyaW5nKCkpLGk9bmV3IGU7cmV0dXJuIGkudmlzaXQociksaS5mb3VuZH1jYXRjaCh0KXtyZXR1cm4geS50ZXN0KG4uc291cmNlKX19KTtyZXR1cm4gdS5tYXAobixmdW5jdGlvbih0KXtyZXR1cm4ge21lc3NhZ2U6XCJVbmV4cGVjdGVkIFJlZ0V4cCBBbmNob3IgRXJyb3I6XFxuXFx0VG9rZW4gVHlwZTogLT5cIithLnRva2VuTmFtZSh0KStcIjwtIHN0YXRpYyAnUEFUVEVSTicgY2Fubm90IGNvbnRhaW4gc3RhcnQgb2YgaW5wdXQgYW5jaG9yICdeJ1xcblxcdFNlZSBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNBTkNIT1JTXFx0Zm9yIGRldGFpbHMuXCIsdHlwZTpzLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5TT0lfQU5DSE9SX0ZPVU5ELHRva2VuVHlwZXM6W3RdfX0pfWZ1bmN0aW9uIHYodCl7dmFyIGU9dS5maWx0ZXIodCxmdW5jdGlvbih0KXt2YXIgZT10W2xdO3JldHVybiBlIGluc3RhbmNlb2YgUmVnRXhwJiYoZS5tdWx0aWxpbmV8fGUuZ2xvYmFsKX0pO3JldHVybiB1Lm1hcChlLGZ1bmN0aW9uKHQpe3JldHVybiB7bWVzc2FnZTpcIlRva2VuIFR5cGU6IC0+XCIrYS50b2tlbk5hbWUodCkrXCI8LSBzdGF0aWMgJ1BBVFRFUk4nIG1heSBOT1QgY29udGFpbiBnbG9iYWwoJ2cnKSBvciBtdWx0aWxpbmUoJ20nKVwiLHR5cGU6cy5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuVU5TVVBQT1JURURfRkxBR1NfRk9VTkQsdG9rZW5UeXBlczpbdF19fSl9ZnVuY3Rpb24gZyh0KXt2YXIgZT1bXSxuPXUubWFwKHQsZnVuY3Rpb24obil7cmV0dXJuIHUucmVkdWNlKHQsZnVuY3Rpb24odCxyKXtyZXR1cm4gbi5QQVRURVJOLnNvdXJjZSE9PXIuUEFUVEVSTi5zb3VyY2V8fHUuY29udGFpbnMoZSxyKXx8ci5QQVRURVJOPT09cy5MZXhlci5OQT90OihlLnB1c2gociksdC5wdXNoKHIpLHQpfSxbXSl9KTtuPXUuY29tcGFjdChuKTt2YXIgcj11LmZpbHRlcihuLGZ1bmN0aW9uKHQpe3JldHVybiB0Lmxlbmd0aD4xfSk7cmV0dXJuIHUubWFwKHIsZnVuY3Rpb24odCl7dmFyIGU9dS5tYXAodCxmdW5jdGlvbih0KXtyZXR1cm4gYS50b2tlbk5hbWUodCl9KTtyZXR1cm4ge21lc3NhZ2U6XCJUaGUgc2FtZSBSZWdFeHAgcGF0dGVybiAtPlwiK3UuZmlyc3QodCkuUEFUVEVSTitcIjwtaGFzIGJlZW4gdXNlZCBpbiBhbGwgb2YgdGhlIGZvbGxvd2luZyBUb2tlbiBUeXBlczogXCIrZS5qb2luKFwiLCBcIikrXCIgPC1cIix0eXBlOnMuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLkRVUExJQ0FURV9QQVRURVJOU19GT1VORCx0b2tlblR5cGVzOnR9fSl9ZnVuY3Rpb24gXyh0KXt2YXIgZT11LmZpbHRlcih0LGZ1bmN0aW9uKHQpe2lmKCF1Lmhhcyh0LFwiR1JPVVBcIikpcmV0dXJuICExO3ZhciBlPXQuR1JPVVA7cmV0dXJuIGUhPT1zLkxleGVyLlNLSVBQRUQmJmUhPT1zLkxleGVyLk5BJiYhdS5pc1N0cmluZyhlKX0pO3JldHVybiB1Lm1hcChlLGZ1bmN0aW9uKHQpe3JldHVybiB7bWVzc2FnZTpcIlRva2VuIFR5cGU6IC0+XCIrYS50b2tlbk5hbWUodCkrXCI8LSBzdGF0aWMgJ0dST1VQJyBjYW4gb25seSBiZSBMZXhlci5TS0lQUEVEL0xleGVyLk5BL0EgU3RyaW5nXCIsdHlwZTpzLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5JTlZBTElEX0dST1VQX1RZUEVfRk9VTkQsdG9rZW5UeXBlczpbdF19fSl9ZnVuY3Rpb24gUih0LGUpe3ZhciBuPXUuZmlsdGVyKHQsZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXQuUFVTSF9NT0RFJiYhdS5jb250YWlucyhlLHQuUFVTSF9NT0RFKX0pO3JldHVybiB1Lm1hcChuLGZ1bmN0aW9uKHQpe3JldHVybiB7bWVzc2FnZTpcIlRva2VuIFR5cGU6IC0+XCIrYS50b2tlbk5hbWUodCkrXCI8LSBzdGF0aWMgJ1BVU0hfTU9ERScgdmFsdWUgY2Fubm90IHJlZmVyIHRvIGEgTGV4ZXIgTW9kZSAtPlwiK3QuUFVTSF9NT0RFK1wiPC13aGljaCBkb2VzIG5vdCBleGlzdFwiLHR5cGU6cy5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuUFVTSF9NT0RFX0RPRVNfTk9UX0VYSVNULHRva2VuVHlwZXM6W3RdfX0pfWZ1bmN0aW9uIEEodCl7dmFyIGU9W10sbj11LnJlZHVjZSh0LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcixpPWUuUEFUVEVSTjtyZXR1cm4gaT09PXMuTGV4ZXIuTkE/dDoodS5pc1N0cmluZyhpKT90LnB1c2goe3N0cjppLGlkeDpuLHRva2VuVHlwZTplfSk6dS5pc1JlZ0V4cChpKSYmKHI9aSx2b2lkIDA9PT11LmZpbmQoW1wiLlwiLFwiXFxcXFwiLFwiW1wiLFwiXVwiLFwifFwiLFwiXlwiLFwiJFwiLFwiKFwiLFwiKVwiLFwiP1wiLFwiKlwiLFwiK1wiLFwie1wiXSxmdW5jdGlvbih0KXtyZXR1cm4gLTEhPT1yLnNvdXJjZS5pbmRleE9mKHQpfSkpJiZ0LnB1c2goe3N0cjppLnNvdXJjZSxpZHg6bix0b2tlblR5cGU6ZX0pLHQpfSxbXSk7cmV0dXJuIHUuZm9yRWFjaCh0LGZ1bmN0aW9uKHQscil7dS5mb3JFYWNoKG4sZnVuY3Rpb24obil7dmFyIGk9bi5zdHIsbz1uLmlkeCxjPW4udG9rZW5UeXBlO2lmKHI8byYmZnVuY3Rpb24odCxlKXtpZih1LmlzUmVnRXhwKGUpKXt2YXIgbj1lLmV4ZWModCk7cmV0dXJuIG51bGwhPT1uJiYwPT09bi5pbmRleH1pZih1LmlzRnVuY3Rpb24oZSkpcmV0dXJuIGUodCwwLFtdLHt9KTtpZih1LmhhcyhlLFwiZXhlY1wiKSlyZXR1cm4gZS5leGVjKHQsMCxbXSx7fSk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpcmV0dXJuIGU9PT10O3Rocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIil9KGksdC5QQVRURVJOKSl7dmFyIHA9XCJUb2tlbjogLT5cIithLnRva2VuTmFtZShjKStcIjwtIGNhbiBuZXZlciBiZSBtYXRjaGVkLlxcbkJlY2F1c2UgaXQgYXBwZWFycyBBRlRFUiB0aGUgVG9rZW4gVHlwZSAtPlwiK2EudG9rZW5OYW1lKHQpK1wiPC1pbiB0aGUgbGV4ZXIncyBkZWZpbml0aW9uLlxcblNlZSBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNVTlJFQUNIQUJMRVwiO2UucHVzaCh7bWVzc2FnZTpwLHR5cGU6cy5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuVU5SRUFDSEFCTEVfUEFUVEVSTix0b2tlblR5cGVzOlt0LGNdfSk7fX0pO30pLGV9ZnVuY3Rpb24gTih0KXt2YXIgZT10Lmlnbm9yZUNhc2U/XCJpXCI6XCJcIjtyZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIit0LnNvdXJjZStcIilcIixlKX1mdW5jdGlvbiBPKHQpe3ZhciBlPXQuaWdub3JlQ2FzZT9cIml5XCI6XCJ5XCI7cmV0dXJuIG5ldyBSZWdFeHAoXCJcIit0LnNvdXJjZSxlKX1mdW5jdGlvbiBTKHQpe3ZhciBlPXQuUEFUVEVSTjtpZih1LmlzUmVnRXhwKGUpKXJldHVybiAhMTtpZih1LmlzRnVuY3Rpb24oZSkpcmV0dXJuICEwO2lmKHUuaGFzKGUsXCJleGVjXCIpKXJldHVybiAhMDtpZih1LmlzU3RyaW5nKGUpKXJldHVybiAhMTt0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpfWZ1bmN0aW9uIEkodCl7cmV0dXJuICEoIXUuaXNTdHJpbmcodCl8fDEhPT10Lmxlbmd0aCkmJnQuY2hhckNvZGVBdCgwKX1mdW5jdGlvbiBMKHQsZSl7aWYodS5oYXModCxcIkxJTkVfQlJFQUtTXCIpKXJldHVybiAhMTtpZih1LmlzUmVnRXhwKHQuUEFUVEVSTikpe3RyeXtjLmNhbk1hdGNoQ2hhckNvZGUoZSx0LlBBVFRFUk4pO31jYXRjaCh0KXtyZXR1cm4ge2lzc3VlOnMuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLklERU5USUZZX1RFUk1JTkFUT1IsZXJyTXNnOnQubWVzc2FnZX19cmV0dXJuICExfWlmKHUuaXNTdHJpbmcodC5QQVRURVJOKSlyZXR1cm4gITE7aWYoUyh0KSlyZXR1cm4ge2lzc3VlOnMuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLkNVU1RPTV9MSU5FX0JSRUFLfTt0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpfWZ1bmN0aW9uIGsodCxlKXtpZihlLmlzc3VlPT09cy5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuSURFTlRJRllfVEVSTUlOQVRPUilyZXR1cm4gXCJXYXJuaW5nOiB1bmFibGUgdG8gaWRlbnRpZnkgbGluZSB0ZXJtaW5hdG9yIHVzYWdlIGluIHBhdHRlcm4uXFxuXFx0VGhlIHByb2JsZW0gaXMgaW4gdGhlIDxcIit0Lm5hbWUrXCI+IFRva2VuIFR5cGVcXG5cXHQgUm9vdCBjYXVzZTogXCIrZS5lcnJNc2crXCIuXFxuXFx0Rm9yIGRldGFpbHMgU2VlOiBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNJREVOVElGWV9URVJNSU5BVE9SXCI7aWYoZS5pc3N1ZT09PXMuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLkNVU1RPTV9MSU5FX0JSRUFLKXJldHVybiBcIldhcm5pbmc6IEEgQ3VzdG9tIFRva2VuIFBhdHRlcm4gc2hvdWxkIHNwZWNpZnkgdGhlIDxsaW5lX2JyZWFrcz4gb3B0aW9uLlxcblxcdFRoZSBwcm9ibGVtIGlzIGluIHRoZSA8XCIrdC5uYW1lK1wiPiBUb2tlbiBUeXBlXFxuXFx0Rm9yIGRldGFpbHMgU2VlOiBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNDVVNUT01fTElORV9CUkVBS1wiO3Rocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIil9ZnVuY3Rpb24gUCh0KXtyZXR1cm4gdS5tYXAodCxmdW5jdGlvbih0KXtyZXR1cm4gdS5pc1N0cmluZyh0KSYmdC5sZW5ndGg+MD90LmNoYXJDb2RlQXQoMCk6dH0pfWUuZmluZFN0YXJ0T2ZJbnB1dEFuY2hvcj1ULGUuZmluZFVuc3VwcG9ydGVkRmxhZ3M9dixlLmZpbmREdXBsaWNhdGVQYXR0ZXJucz1nLGUuZmluZEludmFsaWRHcm91cFR5cGU9XyxlLmZpbmRNb2Rlc1RoYXREb05vdEV4aXN0PVIsZS5maW5kVW5yZWFjaGFibGVQYXR0ZXJucz1BLGUuYWRkU3RhcnRPZklucHV0PU4sZS5hZGRTdGlja3lGbGFnPU8sZS5wZXJmb3JtUnVudGltZUNoZWNrcz1mdW5jdGlvbih0LG4scil7dmFyIGk9W107cmV0dXJuIHUuaGFzKHQsZS5ERUZBVUxUX01PREUpfHxpLnB1c2goe21lc3NhZ2U6XCJBIE11bHRpTW9kZSBMZXhlciBjYW5ub3QgYmUgaW5pdGlhbGl6ZWQgd2l0aG91dCBhIDxcIitlLkRFRkFVTFRfTU9ERStcIj4gcHJvcGVydHkgaW4gaXRzIGRlZmluaXRpb25cXG5cIix0eXBlOnMuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLk1VTFRJX01PREVfTEVYRVJfV0lUSE9VVF9ERUZBVUxUX01PREV9KSx1Lmhhcyh0LGUuTU9ERVMpfHxpLnB1c2goe21lc3NhZ2U6XCJBIE11bHRpTW9kZSBMZXhlciBjYW5ub3QgYmUgaW5pdGlhbGl6ZWQgd2l0aG91dCBhIDxcIitlLk1PREVTK1wiPiBwcm9wZXJ0eSBpbiBpdHMgZGVmaW5pdGlvblxcblwiLHR5cGU6cy5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuTVVMVElfTU9ERV9MRVhFUl9XSVRIT1VUX01PREVTX1BST1BFUlRZfSksdS5oYXModCxlLk1PREVTKSYmdS5oYXModCxlLkRFRkFVTFRfTU9ERSkmJiF1Lmhhcyh0Lm1vZGVzLHQuZGVmYXVsdE1vZGUpJiZpLnB1c2goe21lc3NhZ2U6XCJBIE11bHRpTW9kZSBMZXhlciBjYW5ub3QgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhIFwiK2UuREVGQVVMVF9NT0RFK1wiOiA8XCIrdC5kZWZhdWx0TW9kZStcIj53aGljaCBkb2VzIG5vdCBleGlzdFxcblwiLHR5cGU6cy5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuTVVMVElfTU9ERV9MRVhFUl9ERUZBVUxUX01PREVfVkFMVUVfRE9FU19OT1RfRVhJU1R9KSx1Lmhhcyh0LGUuTU9ERVMpJiZ1LmZvckVhY2godC5tb2RlcyxmdW5jdGlvbih0LGUpe3UuZm9yRWFjaCh0LGZ1bmN0aW9uKHQsbil7dS5pc1VuZGVmaW5lZCh0KSYmaS5wdXNoKHttZXNzYWdlOlwiQSBMZXhlciBjYW5ub3QgYmUgaW5pdGlhbGl6ZWQgdXNpbmcgYW4gdW5kZWZpbmVkIFRva2VuIFR5cGUuIE1vZGU6PFwiK2UrXCI+IGF0IGluZGV4OiA8XCIrbitcIj5cXG5cIix0eXBlOnMuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLkxFWEVSX0RFRklOSVRJT05fQ0FOTk9UX0NPTlRBSU5fVU5ERUZJTkVEfSk7fSk7fSksaX0sZS5wZXJmb3JtV2FybmluZ1J1bnRpbWVDaGVja3M9ZnVuY3Rpb24odCxlLG4pe3ZhciByPVtdLGk9ITEsbz11LmNvbXBhY3QodS5mbGF0dGVuKHUubWFwVmFsdWVzKHQubW9kZXMsZnVuY3Rpb24odCl7cmV0dXJuIHR9KSkpLGE9dS5yZWplY3QobyxmdW5jdGlvbih0KXtyZXR1cm4gdFtsXT09PXMuTGV4ZXIuTkF9KSxwPVAobik7cmV0dXJuIGUmJnUuZm9yRWFjaChhLGZ1bmN0aW9uKHQpe3ZhciBlPUwodCxwKTtpZighMSE9PWUpe3ZhciBuPXttZXNzYWdlOmsodCxlKSx0eXBlOmUuaXNzdWUsdG9rZW5UeXBlOnR9O3IucHVzaChuKTt9ZWxzZSB1Lmhhcyh0LFwiTElORV9CUkVBS1NcIik/ITA9PT10LkxJTkVfQlJFQUtTJiYoaT0hMCk6Yy5jYW5NYXRjaENoYXJDb2RlKHAsdC5QQVRURVJOKSYmKGk9ITApO30pLGUmJiFpJiZyLnB1c2goe21lc3NhZ2U6XCJXYXJuaW5nOiBObyBMSU5FX0JSRUFLUyBGb3VuZC5cXG5cXHRUaGlzIExleGVyIGhhcyBiZWVuIGRlZmluZWQgdG8gdHJhY2sgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uLFxcblxcdEJ1dCBub25lIG9mIHRoZSBUb2tlbiBUeXBlcyBjYW4gYmUgaWRlbnRpZmllZCBhcyBtYXRjaGluZyBhIGxpbmUgdGVybWluYXRvci5cXG5cXHRTZWUgaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjTElORV9CUkVBS1MgXFxuXFx0Zm9yIGRldGFpbHMuXCIsdHlwZTpzLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5OT19MSU5FX0JSRUFLU19GTEFHU30pLHJ9LGUuY2xvbmVFbXB0eUdyb3Vwcz1mdW5jdGlvbih0KXt2YXIgZT17fSxuPXUua2V5cyh0KTtyZXR1cm4gdS5mb3JFYWNoKG4sZnVuY3Rpb24obil7dmFyIHI9dFtuXTtpZighdS5pc0FycmF5KHIpKXRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7ZVtuXT1bXTt9KSxlfSxlLmlzQ3VzdG9tUGF0dGVybj1TLGUuaXNTaG9ydFBhdHRlcm49SSxlLkxpbmVUZXJtaW5hdG9yT3B0aW1pemVkVGVzdGVyPXt0ZXN0OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lmxlbmd0aCxuPXRoaXMubGFzdEluZGV4O248ZTtuKyspe3ZhciByPXQuY2hhckNvZGVBdChuKTtpZigxMD09PXIpcmV0dXJuIHRoaXMubGFzdEluZGV4PW4rMSwhMDtpZigxMz09PXIpcmV0dXJuIDEwPT09dC5jaGFyQ29kZUF0KG4rMSk/dGhpcy5sYXN0SW5kZXg9bisyOnRoaXMubGFzdEluZGV4PW4rMSwhMH1yZXR1cm4gITF9LGxhc3RJbmRleDowfSxlLmJ1aWxkTGluZUJyZWFrSXNzdWVNZXNzYWdlPWs7fSxmdW5jdGlvbih0LGUsbil7dmFyIHIsaT10aGlzJiZ0aGlzLl9fZXh0ZW5kc3x8KHI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gKHI9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKHQsZSl7dC5fX3Byb3RvX189ZTt9fHxmdW5jdGlvbih0LGUpe2Zvcih2YXIgbiBpbiBlKWUuaGFzT3duUHJvcGVydHkobikmJih0W25dPWVbbl0pO30pKHQsZSl9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbigpe3RoaXMuY29uc3RydWN0b3I9dDt9cih0LGUpLHQucHJvdG90eXBlPW51bGw9PT1lP09iamVjdC5jcmVhdGUoZSk6KG4ucHJvdG90eXBlPWUucHJvdG90eXBlLG5ldyBuKTt9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbz1uKDE5KSxhPW4oMCkscz1uZXcgby5SZWdFeHBQYXJzZXIsdT1cIkNvbXBsZW1lbnQgU2V0cyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgZmlyc3QgY2hhciBvcHRpbWl6YXRpb25cIjtmdW5jdGlvbiBjKHQpe3N3aXRjaCh0LnR5cGUpe2Nhc2VcIkRpc2p1bmN0aW9uXCI6cmV0dXJuIGEuZmxhdHRlbihhLm1hcCh0LnZhbHVlLGMpKTtjYXNlXCJBbHRlcm5hdGl2ZVwiOmZvcih2YXIgZT1bXSxuPXQudmFsdWUscj0wO3I8bi5sZW5ndGg7cisrKXt2YXIgaT1uW3JdO2lmKCFhLmNvbnRhaW5zKFtcIkdyb3VwQmFja1JlZmVyZW5jZVwiLFwiTG9va2FoZWFkXCIsXCJOZWdhdGl2ZUxvb2thaGVhZFwiLFwiU3RhcnRBbmNob3JcIixcIkVuZEFuY2hvclwiLFwiV29yZEJvdW5kYXJ5XCIsXCJOb25Xb3JkQm91bmRhcnlcIl0saS50eXBlKSl7dmFyIG89aTtzd2l0Y2goby50eXBlKXtjYXNlXCJDaGFyYWN0ZXJcIjplLnB1c2goby52YWx1ZSk7YnJlYWs7Y2FzZVwiU2V0XCI6aWYoITA9PT1vLmNvbXBsZW1lbnQpdGhyb3cgRXJyb3IodSk7YS5mb3JFYWNoKG8udmFsdWUsZnVuY3Rpb24odCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQpZS5wdXNoKHQpO2Vsc2UgZm9yKHZhciBuPXQscj1uLmZyb207cjw9bi50bztyKyspZS5wdXNoKHIpO30pO2JyZWFrO2Nhc2VcIkdyb3VwXCI6dmFyIHM9YyhvLnZhbHVlKTthLmZvckVhY2gocyxmdW5jdGlvbih0KXtyZXR1cm4gZS5wdXNoKHQpfSk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihcIk5vbiBFeGhhdXN0aXZlIE1hdGNoXCIpfXZhciBwPXZvaWQgMCE9PW8ucXVhbnRpZmllciYmMD09PW8ucXVhbnRpZmllci5hdExlYXN0O2lmKFwiR3JvdXBcIj09PW8udHlwZSYmITE9PT1oKG8pfHxcIkdyb3VwXCIhPT1vLnR5cGUmJiExPT09cClicmVha319cmV0dXJuIGU7ZGVmYXVsdDp0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoIVwiKX19ZnVuY3Rpb24gcCh0KXt2YXIgZT1bXTtyZXR1cm4gYS5mb3JFYWNoKHQsZnVuY3Rpb24odCl7ZS5wdXNoKHQpO3ZhciBuPVN0cmluZy5mcm9tQ2hhckNvZGUodCk7bi50b1VwcGVyQ2FzZSgpIT09bj9lLnB1c2gobi50b1VwcGVyQ2FzZSgpLmNoYXJDb2RlQXQoMCkpOm4udG9Mb3dlckNhc2UoKSE9PW4mJmUucHVzaChuLnRvTG93ZXJDYXNlKCkuY2hhckNvZGVBdCgwKSk7fSksZX1mdW5jdGlvbiBsKHQsZSl7cmV0dXJuIGEuZmluZCh0LnZhbHVlLGZ1bmN0aW9uKHQpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0KXJldHVybiBhLmNvbnRhaW5zKGUsdCk7dmFyIG49dDtyZXR1cm4gdm9pZCAwIT09YS5maW5kKGUsZnVuY3Rpb24odCl7cmV0dXJuIG4uZnJvbTw9dCYmdDw9bi50b30pfSl9ZnVuY3Rpb24gaCh0KXtyZXR1cm4gISghdC5xdWFudGlmaWVyfHwwIT09dC5xdWFudGlmaWVyLmF0TGVhc3QpfHwhIXQudmFsdWUmJihhLmlzQXJyYXkodC52YWx1ZSk/YS5ldmVyeSh0LnZhbHVlLGgpOmgodC52YWx1ZSkpfWUuZmFpbGVkT3B0aW1pemF0aW9uUHJlZml4TXNnPSdVbmFibGUgdG8gdXNlIFwiZmlyc3QgY2hhclwiIGxleGVyIG9wdGltaXphdGlvbnM6XFxuJyxlLmdldFN0YXJ0Q29kZXM9ZnVuY3Rpb24odCxuKXt2b2lkIDA9PT1uJiYobj0hMSk7dHJ5e3ZhciByPXMucGF0dGVybih0LnRvU3RyaW5nKCkpLGk9YyhyLnZhbHVlKTtyZXR1cm4gci5mbGFncy5pZ25vcmVDYXNlJiYoaT1wKGkpKSxpfWNhdGNoKHIpe2lmKHIubWVzc2FnZT09PXUpbiYmYS5QUklOVF9XQVJOSU5HKGUuZmFpbGVkT3B0aW1pemF0aW9uUHJlZml4TXNnK1wiXFx0VW5hYmxlIHRvIG9wdGltaXplOiA8IFwiK3QudG9TdHJpbmcoKStcIiA+XFxuXFx0Q29tcGxlbWVudCBTZXRzIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IG9wdGltaXplZC5cXG5cXHRUaGlzIHdpbGwgZGlzYWJsZSB0aGUgbGV4ZXIncyBmaXJzdCBjaGFyIG9wdGltaXphdGlvbnMuXFxuXFx0U2VlOiBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNDT01QTEVNRU5UIGZvciBkZXRhaWxzLlwiKTtlbHNlIHt2YXIgbD1cIlwiO24mJihsPVwiXFxuXFx0VGhpcyB3aWxsIGRpc2FibGUgdGhlIGxleGVyJ3MgZmlyc3QgY2hhciBvcHRpbWl6YXRpb25zLlxcblxcdFNlZTogaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjUkVHRVhQX1BBUlNJTkcgZm9yIGRldGFpbHMuXCIpLGEuUFJJTlRfRVJST1IoZS5mYWlsZWRPcHRpbWl6YXRpb25QcmVmaXhNc2crXCJcXG5cXHRGYWlsZWQgcGFyc2luZzogPCBcIit0LnRvU3RyaW5nKCkrXCIgPlxcblxcdFVzaW5nIHRoZSByZWdleHAtdG8tYXN0IGxpYnJhcnkgdmVyc2lvbjogXCIrby5WRVJTSU9OK1wiXFxuXFx0UGxlYXNlIG9wZW4gYW4gaXNzdWUgYXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZDgyL3JlZ2V4cC10by1hc3QvaXNzdWVzXCIrbCk7fX1yZXR1cm4gW119LGUuZmlyc3RDaGFyPWMsZS5hcHBseUlnbm9yZUNhc2U9cDt2YXIgZj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3ZhciBuPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi50YXJnZXRDaGFyQ29kZXM9ZSxuLmZvdW5kPSExLG59cmV0dXJuIGkoZSx0KSxlLnByb3RvdHlwZS52aXNpdENoaWxkcmVuPWZ1bmN0aW9uKGUpe3N3aXRjaChlLnR5cGUpe2Nhc2VcIkxvb2thaGVhZFwiOnJldHVybiB2b2lkIHRoaXMudmlzaXRMb29rYWhlYWQoZSk7Y2FzZVwiTmVnYXRpdmVMb29rYWhlYWRcIjpyZXR1cm4gdm9pZCB0aGlzLnZpc2l0TmVnYXRpdmVMb29rYWhlYWQoZSl9dC5wcm90b3R5cGUudmlzaXRDaGlsZHJlbi5jYWxsKHRoaXMsZSk7fSxlLnByb3RvdHlwZS52aXNpdENoYXJhY3Rlcj1mdW5jdGlvbih0KXthLmNvbnRhaW5zKHRoaXMudGFyZ2V0Q2hhckNvZGVzLHQudmFsdWUpJiYodGhpcy5mb3VuZD0hMCk7fSxlLnByb3RvdHlwZS52aXNpdFNldD1mdW5jdGlvbih0KXt0LmNvbXBsZW1lbnQ/dm9pZCAwPT09bCh0LHRoaXMudGFyZ2V0Q2hhckNvZGVzKSYmKHRoaXMuZm91bmQ9ITApOnZvaWQgMCE9PWwodCx0aGlzLnRhcmdldENoYXJDb2RlcykmJih0aGlzLmZvdW5kPSEwKTt9LGV9KG8uQmFzZVJlZ0V4cFZpc2l0b3IpO2UuY2FuTWF0Y2hDaGFyQ29kZT1mdW5jdGlvbih0LGUpe2lmKGUgaW5zdGFuY2VvZiBSZWdFeHApe3ZhciBuPXMucGF0dGVybihlLnRvU3RyaW5nKCkpLHI9bmV3IGYodCk7cmV0dXJuIHIudmlzaXQobiksci5mb3VuZH1yZXR1cm4gdm9pZCAwIT09YS5maW5kKGUsZnVuY3Rpb24oZSl7cmV0dXJuIGEuY29udGFpbnModCxlLmNoYXJDb2RlQXQoMCkpfSl9O30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2lmKHRoaXMuc3RhcnQ9dCx0aGlzLmVuZD1lLCFpKHQsZSkpdGhyb3cgbmV3IEVycm9yKFwiSU5WQUxJRCBSQU5HRVwiKX1yZXR1cm4gdC5wcm90b3R5cGUuY29udGFpbnM9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc3RhcnQ8PXQmJnRoaXMuZW5kPj10fSx0LnByb3RvdHlwZS5jb250YWluc1JhbmdlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnN0YXJ0PD10LnN0YXJ0JiZ0aGlzLmVuZD49dC5lbmR9LHQucHJvdG90eXBlLmlzQ29udGFpbmVkSW5SYW5nZT1mdW5jdGlvbih0KXtyZXR1cm4gdC5jb250YWluc1JhbmdlKHRoaXMpfSx0LnByb3RvdHlwZS5zdHJpY3RseUNvbnRhaW5zUmFuZ2U9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc3RhcnQ8dC5zdGFydCYmdGhpcy5lbmQ+dC5lbmR9LHQucHJvdG90eXBlLmlzU3RyaWN0bHlDb250YWluZWRJblJhbmdlPWZ1bmN0aW9uKHQpe3JldHVybiB0LnN0cmljdGx5Q29udGFpbnNSYW5nZSh0aGlzKX0sdH0oKTtmdW5jdGlvbiBpKHQsZSl7cmV0dXJuICEodDwwfHxlPHQpfWUuUmFuZ2U9cixlLmlzVmFsaWRSYW5nZT1pO30sZnVuY3Rpb24odCxlLG4pe3ZhciByLGk9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fChyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIChyPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbih0LGUpe3QuX19wcm90b19fPWU7fXx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIG4gaW4gZSllLmhhc093blByb3BlcnR5KG4pJiYodFtuXT1lW25dKTt9KSh0LGUpfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4oKXt0aGlzLmNvbnN0cnVjdG9yPXQ7fXIodCxlKSx0LnByb3RvdHlwZT1udWxsPT09ZT9PYmplY3QuY3JlYXRlKGUpOihuLnByb3RvdHlwZT1lLnByb3RvdHlwZSxuZXcgbik7fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG89bigzKSxhPW4oMCkscz1uKDUpO2UucmVzb2x2ZUdyYW1tYXI9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgdSh0LGUpO3JldHVybiBuLnJlc29sdmVSZWZzKCksbi5lcnJvcnN9O3ZhciB1PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxuKXt2YXIgcj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIHIubmFtZVRvVG9wUnVsZT1lLHIuZXJyTXNnUHJvdmlkZXI9bixyLmVycm9ycz1bXSxyfXJldHVybiBpKGUsdCksZS5wcm90b3R5cGUucmVzb2x2ZVJlZnM9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO2EuZm9yRWFjaCh0aGlzLm5hbWVUb1RvcFJ1bGUudmFsdWVzKCksZnVuY3Rpb24oZSl7dC5jdXJyVG9wTGV2ZWw9ZSxlLmFjY2VwdCh0KTt9KTt9LGUucHJvdG90eXBlLnZpc2l0Tm9uVGVybWluYWw9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5uYW1lVG9Ub3BSdWxlLmdldCh0Lm5vblRlcm1pbmFsTmFtZSk7aWYoZSl0LnJlZmVyZW5jZWRSdWxlPWU7ZWxzZSB7dmFyIG49dGhpcy5lcnJNc2dQcm92aWRlci5idWlsZFJ1bGVOb3RGb3VuZEVycm9yKHRoaXMuY3VyclRvcExldmVsLHQpO3RoaXMuZXJyb3JzLnB1c2goe21lc3NhZ2U6bix0eXBlOm8uUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5VTlJFU09MVkVEX1NVQlJVTEVfUkVGLHJ1bGVOYW1lOnRoaXMuY3VyclRvcExldmVsLm5hbWUsdW5yZXNvbHZlZFJlZk5hbWU6dC5ub25UZXJtaW5hbE5hbWV9KTt9fSxlfShzLkdBc3RWaXNpdG9yKTtlLkdhc3RSZWZSZXNvbHZlclZpc2l0b3I9dTt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1uKDEyKSxpPW4oMCksbz1uKDMpLGE9big5KSxzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUuaW5pdExvb2tzQWhlYWQ9ZnVuY3Rpb24odCl7dGhpcy5keW5hbWljVG9rZW5zRW5hYmxlZD1pLmhhcyh0LFwiZHluYW1pY1Rva2Vuc0VuYWJsZWRcIik/dC5keW5hbWljVG9rZW5zRW5hYmxlZDpvLkRFRkFVTFRfUEFSU0VSX0NPTkZJRy5keW5hbWljVG9rZW5zRW5hYmxlZCx0aGlzLm1heExvb2thaGVhZD1pLmhhcyh0LFwibWF4TG9va2FoZWFkXCIpP3QubWF4TG9va2FoZWFkOm8uREVGQVVMVF9QQVJTRVJfQ09ORklHLm1heExvb2thaGVhZCx0aGlzLmxvb2tBaGVhZEZ1bmNzQ2FjaGU9aS5pc0VTMjAxNU1hcFN1cHBvcnRlZCgpP25ldyBNYXA6W10saS5pc0VTMjAxNU1hcFN1cHBvcnRlZCgpPyh0aGlzLmdldExhRnVuY0Zyb21DYWNoZT10aGlzLmdldExhRnVuY0Zyb21NYXAsdGhpcy5zZXRMYUZ1bmNDYWNoZT10aGlzLnNldExhRnVuY0NhY2hlVXNpbmdNYXApOih0aGlzLmdldExhRnVuY0Zyb21DYWNoZT10aGlzLmdldExhRnVuY0Zyb21PYmosdGhpcy5zZXRMYUZ1bmNDYWNoZT10aGlzLnNldExhRnVuY1VzaW5nT2JqKTt9LHQucHJvdG90eXBlLmxvb2tBaGVhZEJ1aWxkZXJGb3JPcHRpb25hbD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHIuYnVpbGRTaW5nbGVBbHRlcm5hdGl2ZUxvb2thaGVhZEZ1bmN0aW9uKHQsZSxuKX0sdC5wcm90b3R5cGUubG9va0FoZWFkQnVpbGRlckZvckFsdGVybmF0aXZlcz1mdW5jdGlvbih0LGUsbixpKXtyZXR1cm4gci5idWlsZEFsdGVybmF0aXZlc0xvb2tBaGVhZEZ1bmModCxlLG4saSl9LHQucHJvdG90eXBlLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2V0TGFzdEV4cGxpY2l0UnVsZVNob3J0TmFtZSgpO3JldHVybiBhLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChuLHQsZSl9LHQucHJvdG90eXBlLmdldExvb2thaGVhZEZ1bmNGb3JPcj1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKGEuT1JfSURYLHQpLG89dGhpcy5nZXRMYUZ1bmNGcm9tQ2FjaGUobik7aWYodm9pZCAwPT09byl7dmFyIHM9dGhpcy5nZXRDdXJyUnVsZUZ1bGxOYW1lKCksdT10aGlzLmdldEdBc3RQcm9kdWN0aW9ucygpLmdldChzKSxjPWkuc29tZShlLGZ1bmN0aW9uKHQpe3JldHVybiBpLmlzRnVuY3Rpb24odC5HQVRFKX0pO3JldHVybiBvPXIuYnVpbGRMb29rYWhlYWRGdW5jRm9yT3IodCx1LHRoaXMubWF4TG9va2FoZWFkLGMsdGhpcy5keW5hbWljVG9rZW5zRW5hYmxlZCx0aGlzLmxvb2tBaGVhZEJ1aWxkZXJGb3JBbHRlcm5hdGl2ZXMpLHRoaXMuc2V0TGFGdW5jQ2FjaGUobixvKSxvfXJldHVybiBvfSx0LnByb3RvdHlwZS5nZXRMb29rYWhlYWRGdW5jRm9yT3B0aW9uPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZ2V0TG9va2FoZWFkRnVuY0Zvcih0LGUsdGhpcy5tYXhMb29rYWhlYWQsci5QUk9EX1RZUEUuT1BUSU9OKX0sdC5wcm90b3R5cGUuZ2V0TG9va2FoZWFkRnVuY0Zvck1hbnk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5nZXRMb29rYWhlYWRGdW5jRm9yKHQsZSx0aGlzLm1heExvb2thaGVhZCxyLlBST0RfVFlQRS5SRVBFVElUSU9OKX0sdC5wcm90b3R5cGUuZ2V0TG9va2FoZWFkRnVuY0Zvck1hbnlTZXA9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5nZXRMb29rYWhlYWRGdW5jRm9yKHQsZSx0aGlzLm1heExvb2thaGVhZCxyLlBST0RfVFlQRS5SRVBFVElUSU9OX1dJVEhfU0VQQVJBVE9SKX0sdC5wcm90b3R5cGUuZ2V0TG9va2FoZWFkRnVuY0ZvckF0TGVhc3RPbmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5nZXRMb29rYWhlYWRGdW5jRm9yKHQsZSx0aGlzLm1heExvb2thaGVhZCxyLlBST0RfVFlQRS5SRVBFVElUSU9OX01BTkRBVE9SWSl9LHQucHJvdG90eXBlLmdldExvb2thaGVhZEZ1bmNGb3JBdExlYXN0T25lU2VwPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZ2V0TG9va2FoZWFkRnVuY0Zvcih0LGUsdGhpcy5tYXhMb29rYWhlYWQsci5QUk9EX1RZUEUuUkVQRVRJVElPTl9NQU5EQVRPUllfV0lUSF9TRVBBUkFUT1IpfSx0LnByb3RvdHlwZS5nZXRMb29rYWhlYWRGdW5jRm9yPWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciBvPXRoaXMuZ2V0TGFGdW5jRnJvbUNhY2hlKHQpO2lmKHZvaWQgMD09PW8pe3ZhciBhPXRoaXMuZ2V0Q3VyclJ1bGVGdWxsTmFtZSgpLHM9dGhpcy5nZXRHQXN0UHJvZHVjdGlvbnMoKS5nZXQoYSk7cmV0dXJuIG89ci5idWlsZExvb2thaGVhZEZ1bmNGb3JPcHRpb25hbFByb2QoZSxzLG4sdGhpcy5keW5hbWljVG9rZW5zRW5hYmxlZCxpLHRoaXMubG9va0FoZWFkQnVpbGRlckZvck9wdGlvbmFsKSx0aGlzLnNldExhRnVuY0NhY2hlKHQsbyksb31yZXR1cm4gb30sdC5wcm90b3R5cGUuZ2V0TGFGdW5jRnJvbUNhY2hlPWZ1bmN0aW9uKHQpe30sdC5wcm90b3R5cGUuZ2V0TGFGdW5jRnJvbU1hcD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5sb29rQWhlYWRGdW5jc0NhY2hlLmdldCh0KX0sdC5wcm90b3R5cGUuZ2V0TGFGdW5jRnJvbU9iaj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5sb29rQWhlYWRGdW5jc0NhY2hlW3RdfSx0LnByb3RvdHlwZS5zZXRMYUZ1bmNDYWNoZT1mdW5jdGlvbih0LGUpe30sdC5wcm90b3R5cGUuc2V0TGFGdW5jQ2FjaGVVc2luZ01hcD1mdW5jdGlvbih0LGUpe3RoaXMubG9va0FoZWFkRnVuY3NDYWNoZS5zZXQodCxlKTt9LHQucHJvdG90eXBlLnNldExhRnVuY1VzaW5nT2JqPWZ1bmN0aW9uKHQsZSl7dGhpcy5sb29rQWhlYWRGdW5jc0NhY2hlW3RdPWU7fSx0fSgpO2UuTG9va3NBaGVhZD1zO30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPW4oMTYpLGk9bigwKSxvPW4oMzMpLGE9big5KSxzPW4oMyksdT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQucHJvdG90eXBlLmluaXRUcmVlQnVpbGRlcj1mdW5jdGlvbih0KXt0aGlzLkxBU1RfRVhQTElDSVRfUlVMRV9TVEFDSz1bXSx0aGlzLkNTVF9TVEFDSz1bXSx0aGlzLm91dHB1dENzdD1pLmhhcyh0LFwib3V0cHV0Q3N0XCIpP3Qub3V0cHV0Q3N0OnMuREVGQVVMVF9QQVJTRVJfQ09ORklHLm91dHB1dENzdCx0aGlzLm91dHB1dENzdHx8KHRoaXMuY3N0SW52b2NhdGlvblN0YXRlVXBkYXRlPWkuTk9PUCx0aGlzLmNzdEZpbmFsbHlTdGF0ZVVwZGF0ZT1pLk5PT1AsdGhpcy5jc3RQb3N0VGVybWluYWw9aS5OT09QLHRoaXMuY3N0UG9zdE5vblRlcm1pbmFsPWkuTk9PUCx0aGlzLmdldExhc3RFeHBsaWNpdFJ1bGVTaG9ydE5hbWU9dGhpcy5nZXRMYXN0RXhwbGljaXRSdWxlU2hvcnROYW1lTm9Dc3QsdGhpcy5nZXRQcmV2aW91c0V4cGxpY2l0UnVsZVNob3J0TmFtZT10aGlzLmdldFByZXZpb3VzRXhwbGljaXRSdWxlU2hvcnROYW1lTm9Dc3QsdGhpcy5nZXRMYXN0RXhwbGljaXRSdWxlT2NjdXJyZW5jZUluZGV4PXRoaXMuZ2V0TGFzdEV4cGxpY2l0UnVsZU9jY3VycmVuY2VJbmRleE5vQ3N0LHRoaXMubWFueUludGVybmFsPXRoaXMubWFueUludGVybmFsTm9Dc3QsdGhpcy5vckludGVybmFsPXRoaXMub3JJbnRlcm5hbE5vQ3N0LHRoaXMub3B0aW9uSW50ZXJuYWw9dGhpcy5vcHRpb25JbnRlcm5hbE5vQ3N0LHRoaXMuYXRMZWFzdE9uZUludGVybmFsPXRoaXMuYXRMZWFzdE9uZUludGVybmFsTm9Dc3QsdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbD10aGlzLm1hbnlTZXBGaXJzdEludGVybmFsTm9Dc3QsdGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbD10aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsTm9Dc3QpO30sdC5wcm90b3R5cGUuY3N0TmVzdGVkSW52b2NhdGlvblN0YXRlVXBkYXRlPWZ1bmN0aW9uKHQsZSl7dGhpcy5DU1RfU1RBQ0sucHVzaCh7bmFtZTp0LGZ1bGxOYW1lOnRoaXMuc2hvcnRSdWxlTmFtZVRvRnVsbC5nZXQodGhpcy5nZXRMYXN0RXhwbGljaXRSdWxlU2hvcnROYW1lKCkpK3QsY2hpbGRyZW46e319KTt9LHQucHJvdG90eXBlLmNzdEludm9jYXRpb25TdGF0ZVVwZGF0ZT1mdW5jdGlvbih0LGUpe3RoaXMuTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLLnB1c2godGhpcy5SVUxFX1NUQUNLLmxlbmd0aC0xKSx0aGlzLkNTVF9TVEFDSy5wdXNoKHtuYW1lOnQsY2hpbGRyZW46e319KTt9LHQucHJvdG90eXBlLmNzdEZpbmFsbHlTdGF0ZVVwZGF0ZT1mdW5jdGlvbigpe3RoaXMuTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLLnBvcCgpLHRoaXMuQ1NUX1NUQUNLLnBvcCgpO30sdC5wcm90b3R5cGUuY3N0TmVzdGVkRmluYWxseVN0YXRlVXBkYXRlPWZ1bmN0aW9uKCl7dGhpcy5DU1RfU1RBQ0sucG9wKCk7fSx0LnByb3RvdHlwZS5jc3RQb3N0VGVybWluYWw9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLkNTVF9TVEFDS1t0aGlzLkNTVF9TVEFDSy5sZW5ndGgtMV07ci5hZGRUZXJtaW5hbFRvQ3N0KG4sZSx0KTt9LHQucHJvdG90eXBlLmNzdFBvc3ROb25UZXJtaW5hbD1mdW5jdGlvbih0LGUpe3IuYWRkTm9uZVRlcm1pbmFsVG9Dc3QodGhpcy5DU1RfU1RBQ0tbdGhpcy5DU1RfU1RBQ0subGVuZ3RoLTFdLGUsdCk7fSx0LnByb3RvdHlwZS5nZXRCYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yPWZ1bmN0aW9uKCl7aWYoaS5pc1VuZGVmaW5lZCh0aGlzLmJhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3IpKXt2YXIgdD1vLmNyZWF0ZUJhc2VTZW1hbnRpY1Zpc2l0b3JDb25zdHJ1Y3Rvcih0aGlzLmNsYXNzTmFtZSx0aGlzLmFsbFJ1bGVOYW1lcyk7cmV0dXJuIHRoaXMuYmFzZUNzdFZpc2l0b3JDb25zdHJ1Y3Rvcj10LHR9cmV0dXJuIHRoaXMuYmFzZUNzdFZpc2l0b3JDb25zdHJ1Y3Rvcn0sdC5wcm90b3R5cGUuZ2V0QmFzZUNzdFZpc2l0b3JDb25zdHJ1Y3RvcldpdGhEZWZhdWx0cz1mdW5jdGlvbigpe2lmKGkuaXNVbmRlZmluZWQodGhpcy5iYXNlQ3N0VmlzaXRvcldpdGhEZWZhdWx0c0NvbnN0cnVjdG9yKSl7dmFyIHQ9by5jcmVhdGVCYXNlVmlzaXRvckNvbnN0cnVjdG9yV2l0aERlZmF1bHRzKHRoaXMuY2xhc3NOYW1lLHRoaXMuYWxsUnVsZU5hbWVzLHRoaXMuZ2V0QmFzZUNzdFZpc2l0b3JDb25zdHJ1Y3RvcigpKTtyZXR1cm4gdGhpcy5iYXNlQ3N0VmlzaXRvcldpdGhEZWZhdWx0c0NvbnN0cnVjdG9yPXQsdH1yZXR1cm4gdGhpcy5iYXNlQ3N0VmlzaXRvcldpdGhEZWZhdWx0c0NvbnN0cnVjdG9yfSx0LnByb3RvdHlwZS5uZXN0ZWRSdWxlQmVmb3JlQ2xhdXNlPWZ1bmN0aW9uKHQsZSl7dmFyIG47cmV0dXJuIHZvaWQgMCE9PXQuTkFNRT8obj10Lk5BTUUsdGhpcy5uZXN0ZWRSdWxlSW52b2NhdGlvblN0YXRlVXBkYXRlKG4sZSksbik6dm9pZCAwfSx0LnByb3RvdHlwZS5uZXN0ZWRBbHRCZWZvcmVDbGF1c2U9ZnVuY3Rpb24odCxlLG4scil7dmFyIGksbz10aGlzLmdldExhc3RFeHBsaWNpdFJ1bGVTaG9ydE5hbWUoKSxzPWEuZ2V0S2V5Rm9yQWx0SW5kZXgobyxuLGUscik7cmV0dXJuIHZvaWQgMCE9PXQuTkFNRT8oaT10Lk5BTUUsdGhpcy5uZXN0ZWRSdWxlSW52b2NhdGlvblN0YXRlVXBkYXRlKGkscykse3Nob3J0TmFtZTpzLG5lc3RlZE5hbWU6aX0pOnZvaWQgMH0sdC5wcm90b3R5cGUubmVzdGVkUnVsZUZpbmFsbHlDbGF1c2U9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLkNTVF9TVEFDSyxpPW5bbi5sZW5ndGgtMV07dGhpcy5uZXN0ZWRSdWxlRmluYWxseVN0YXRlVXBkYXRlKCk7dmFyIG89bltuLmxlbmd0aC0xXTtyLmFkZE5vbmVUZXJtaW5hbFRvQ3N0KG8sZSxpKTt9LHQucHJvdG90eXBlLmdldExhc3RFeHBsaWNpdFJ1bGVTaG9ydE5hbWU9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLkxBU1RfRVhQTElDSVRfUlVMRV9TVEFDS1t0aGlzLkxBU1RfRVhQTElDSVRfUlVMRV9TVEFDSy5sZW5ndGgtMV07cmV0dXJuIHRoaXMuUlVMRV9TVEFDS1t0XX0sdC5wcm90b3R5cGUuZ2V0TGFzdEV4cGxpY2l0UnVsZVNob3J0TmFtZU5vQ3N0PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5SVUxFX1NUQUNLO3JldHVybiB0W3QubGVuZ3RoLTFdfSx0LnByb3RvdHlwZS5nZXRQcmV2aW91c0V4cGxpY2l0UnVsZVNob3J0TmFtZT1mdW5jdGlvbigpe3ZhciB0PXRoaXMuTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLW3RoaXMuTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLLmxlbmd0aC0yXTtyZXR1cm4gdGhpcy5SVUxFX1NUQUNLW3RdfSx0LnByb3RvdHlwZS5nZXRQcmV2aW91c0V4cGxpY2l0UnVsZVNob3J0TmFtZU5vQ3N0PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5SVUxFX1NUQUNLO3JldHVybiB0W3QubGVuZ3RoLTJdfSx0LnByb3RvdHlwZS5nZXRMYXN0RXhwbGljaXRSdWxlT2NjdXJyZW5jZUluZGV4PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5MQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0tbdGhpcy5MQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0subGVuZ3RoLTFdO3JldHVybiB0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDS1t0XX0sdC5wcm90b3R5cGUuZ2V0TGFzdEV4cGxpY2l0UnVsZU9jY3VycmVuY2VJbmRleE5vQ3N0PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0s7cmV0dXJuIHRbdC5sZW5ndGgtMV19LHQucHJvdG90eXBlLm5lc3RlZFJ1bGVJbnZvY2F0aW9uU3RhdGVVcGRhdGU9ZnVuY3Rpb24odCxlKXt0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSy5wdXNoKDEpLHRoaXMuUlVMRV9TVEFDSy5wdXNoKGUpLHRoaXMuY3N0TmVzdGVkSW52b2NhdGlvblN0YXRlVXBkYXRlKHQsZSk7fSx0LnByb3RvdHlwZS5uZXN0ZWRSdWxlRmluYWxseVN0YXRlVXBkYXRlPWZ1bmN0aW9uKCl7dGhpcy5SVUxFX1NUQUNLLnBvcCgpLHRoaXMuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLLnBvcCgpLHRoaXMuY3N0TmVzdGVkRmluYWxseVN0YXRlVXBkYXRlKCk7fSx0fSgpO2UuVHJlZUJ1aWxkZXI9dTt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcixpPW4oMCksbz1uKDQpLGE9bigxMSk7ZnVuY3Rpb24gcyh0LGUpe2Zvcih2YXIgbj1pLmtleXModCkscj1uLmxlbmd0aCxvPTA7bzxyO28rKylmb3IodmFyIGE9dFtuW29dXSxzPWEubGVuZ3RoLHU9MDt1PHM7dSsrKXt2YXIgYz1hW3VdO3ZvaWQgMD09PWMudG9rZW5UeXBlSWR4JiYodm9pZCAwIT09Yy5mdWxsTmFtZT90aGlzW2MuZnVsbE5hbWVdKGMuY2hpbGRyZW4sZSk6dGhpc1tjLm5hbWVdKGMuY2hpbGRyZW4sZSkpO319ZnVuY3Rpb24gdSh0LGUpe3ZhciBuPWModCxlKSxyPWwodCxlKTtyZXR1cm4gbi5jb25jYXQocil9ZnVuY3Rpb24gYyh0LGUpe3ZhciBuPWkubWFwKGUsZnVuY3Rpb24oZSl7aWYoIWkuaXNGdW5jdGlvbih0W2VdKSlyZXR1cm4ge21zZzpcIk1pc3NpbmcgdmlzaXRvciBtZXRob2Q6IDxcIitlK1wiPiBvbiBcIitvLmZ1bmN0aW9uTmFtZSh0LmNvbnN0cnVjdG9yKStcIiBDU1QgVmlzaXRvci5cIix0eXBlOnIuTUlTU0lOR19NRVRIT0QsbWV0aG9kTmFtZTplfX0pO3JldHVybiBpLmNvbXBhY3Qobil9ZS5kZWZhdWx0VmlzaXQ9cyxlLmNyZWF0ZUJhc2VTZW1hbnRpY1Zpc2l0b3JDb25zdHJ1Y3Rvcj1mdW5jdGlvbih0LGUpe3ZhciBuPWZ1bmN0aW9uKCl7fTtyZXR1cm4gby5kZWZpbmVOYW1lUHJvcChuLHQrXCJCYXNlU2VtYW50aWNzXCIpLChuLnByb3RvdHlwZT17dmlzaXQ6ZnVuY3Rpb24odCxlKXtpZihpLmlzQXJyYXkodCkmJih0PXRbMF0pLCFpLmlzVW5kZWZpbmVkKHQpKXJldHVybiB2b2lkIDAhPT10LmZ1bGxOYW1lP3RoaXNbdC5mdWxsTmFtZV0odC5jaGlsZHJlbixlKTp0aGlzW3QubmFtZV0odC5jaGlsZHJlbixlKX0sdmFsaWRhdGVWaXNpdG9yOmZ1bmN0aW9uKCl7dmFyIHQ9dSh0aGlzLGUpO2lmKCFpLmlzRW1wdHkodCkpe3ZhciBuPWkubWFwKHQsZnVuY3Rpb24odCl7cmV0dXJuIHQubXNnfSk7dGhyb3cgRXJyb3IoXCJFcnJvcnMgRGV0ZWN0ZWQgaW4gQ1NUIFZpc2l0b3IgPFwiK28uZnVuY3Rpb25OYW1lKHRoaXMuY29uc3RydWN0b3IpK1wiPjpcXG5cXHRcIituLmpvaW4oXCJcXG5cXG5cIikucmVwbGFjZSgvXFxuL2csXCJcXG5cXHRcIikpfX19KS5jb25zdHJ1Y3Rvcj1uLG4uX1JVTEVfTkFNRVM9ZSxufSxlLmNyZWF0ZUJhc2VWaXNpdG9yQ29uc3RydWN0b3JXaXRoRGVmYXVsdHM9ZnVuY3Rpb24odCxlLG4pe3ZhciByPWZ1bmN0aW9uKCl7fTtvLmRlZmluZU5hbWVQcm9wKHIsdCtcIkJhc2VTZW1hbnRpY3NXaXRoRGVmYXVsdHNcIik7dmFyIGE9T2JqZWN0LmNyZWF0ZShuLnByb3RvdHlwZSk7cmV0dXJuIGkuZm9yRWFjaChlLGZ1bmN0aW9uKHQpe2FbdF09czt9KSwoci5wcm90b3R5cGU9YSkuY29uc3RydWN0b3I9cixyfSxmdW5jdGlvbih0KXt0W3QuUkVEVU5EQU5UX01FVEhPRD0wXT1cIlJFRFVOREFOVF9NRVRIT0RcIix0W3QuTUlTU0lOR19NRVRIT0Q9MV09XCJNSVNTSU5HX01FVEhPRFwiO30ocj1lLkNzdFZpc2l0b3JEZWZpbml0aW9uRXJyb3J8fChlLkNzdFZpc2l0b3JEZWZpbml0aW9uRXJyb3I9e30pKSxlLnZhbGlkYXRlVmlzaXRvcj11LGUudmFsaWRhdGVNaXNzaW5nQ3N0TWV0aG9kcz1jO3ZhciBwPVtcImNvbnN0cnVjdG9yXCIsXCJ2aXNpdFwiLFwidmFsaWRhdGVWaXNpdG9yXCJdO2Z1bmN0aW9uIGwodCxlKXt2YXIgbj1bXTtmb3IodmFyIHMgaW4gdClhLnZhbGlkVGVybXNQYXR0ZXJuLnRlc3QocykmJmkuaXNGdW5jdGlvbih0W3NdKSYmIWkuY29udGFpbnMocCxzKSYmIWkuY29udGFpbnMoZSxzKSYmbi5wdXNoKHttc2c6XCJSZWR1bmRhbnQgdmlzaXRvciBtZXRob2Q6IDxcIitzK1wiPiBvbiBcIitvLmZ1bmN0aW9uTmFtZSh0LmNvbnN0cnVjdG9yKStcIiBDU1QgVmlzaXRvclxcblRoZXJlIGlzIG5vIEdyYW1tYXIgUnVsZSBjb3JyZXNwb25kaW5nIHRvIHRoaXMgbWV0aG9kJ3MgbmFtZS5cXG5Gb3IgdXRpbGl0eSBtZXRob2RzIG9uIHZpc2l0b3IgY2xhc3NlcyB1c2UgbWV0aG9kcyBuYW1lcyB0aGF0IGRvIG5vdCBtYXRjaCAvXCIrYS52YWxpZFRlcm1zUGF0dGVybi5zb3VyY2UrXCIvLlwiLHR5cGU6ci5SRURVTkRBTlRfTUVUSE9ELG1ldGhvZE5hbWU6c30pO3JldHVybiBufWUudmFsaWRhdGVSZWR1bmRhbnRNZXRob2RzPWw7fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9bigzKSxpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUuaW5pdExleGVyQWRhcHRlcj1mdW5jdGlvbigpe3RoaXMudG9rVmVjdG9yPVtdLHRoaXMudG9rVmVjdG9yTGVuZ3RoPTAsdGhpcy5jdXJySWR4PS0xO30sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiaW5wdXRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG9rVmVjdG9yfSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5yZXNldCgpLHRoaXMudG9rVmVjdG9yPXQsdGhpcy50b2tWZWN0b3JMZW5ndGg9dC5sZW5ndGg7fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLlNLSVBfVE9LRU49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdXJySWR4PD10aGlzLnRva1ZlY3Rvci5sZW5ndGgtMj8odGhpcy5jb25zdW1lVG9rZW4oKSx0aGlzLkxBKDEpKTpyLkVORF9PRl9GSUxFfSx0LnByb3RvdHlwZS5MQT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jdXJySWR4K3Q8MHx8dGhpcy50b2tWZWN0b3JMZW5ndGg8PXRoaXMuY3VycklkeCt0P3IuRU5EX09GX0ZJTEU6dGhpcy50b2tWZWN0b3JbdGhpcy5jdXJySWR4K3RdfSx0LnByb3RvdHlwZS5jb25zdW1lVG9rZW49ZnVuY3Rpb24oKXt0aGlzLmN1cnJJZHgrKzt9LHQucHJvdG90eXBlLmV4cG9ydExleGVyU3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdXJySWR4fSx0LnByb3RvdHlwZS5pbXBvcnRMZXhlclN0YXRlPWZ1bmN0aW9uKHQpe3RoaXMuY3VycklkeD10O30sdC5wcm90b3R5cGUucmVzZXRMZXhlclN0YXRlPWZ1bmN0aW9uKCl7dGhpcy5jdXJySWR4PS0xO30sdC5wcm90b3R5cGUubW92ZVRvVGVybWluYXRlZFN0YXRlPWZ1bmN0aW9uKCl7dGhpcy5jdXJySWR4PXRoaXMudG9rVmVjdG9yLmxlbmd0aC0xO30sdC5wcm90b3R5cGUuZ2V0TGV4ZXJQb3NpdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmV4cG9ydExleGVyU3RhdGUoKX0sdH0oKTtlLkxleGVyQWRhcHRlcj1pO30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPW4oMCksaT1uKDYpLG89bigzKSxhPW4oMTApLHM9bigyMyksdT1uKDExKSxjPW4oMSkscD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQucHJvdG90eXBlLkNPTlNVTUU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodCwwLGUpfSx0LnByb3RvdHlwZS5DT05TVU1FMT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0LDEsZSl9LHQucHJvdG90eXBlLkNPTlNVTUUyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHQsMixlKX0sdC5wcm90b3R5cGUuQ09OU1VNRTM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodCwzLGUpfSx0LnByb3RvdHlwZS5DT05TVU1FND1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0LDQsZSl9LHQucHJvdG90eXBlLkNPTlNVTUU1PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHQsNSxlKX0sdC5wcm90b3R5cGUuQ09OU1VNRTY9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodCw2LGUpfSx0LnByb3RvdHlwZS5DT05TVU1FNz1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0LDcsZSl9LHQucHJvdG90eXBlLkNPTlNVTUU4PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHQsOCxlKX0sdC5wcm90b3R5cGUuQ09OU1VNRTk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodCw5LGUpfSx0LnByb3RvdHlwZS5TVUJSVUxFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHQsMCxlKX0sdC5wcm90b3R5cGUuU1VCUlVMRTE9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwodCwxLGUpfSx0LnByb3RvdHlwZS5TVUJSVUxFMj1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbCh0LDIsZSl9LHQucHJvdG90eXBlLlNVQlJVTEUzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHQsMyxlKX0sdC5wcm90b3R5cGUuU1VCUlVMRTQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwodCw0LGUpfSx0LnByb3RvdHlwZS5TVUJSVUxFNT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbCh0LDUsZSl9LHQucHJvdG90eXBlLlNVQlJVTEU2PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHQsNixlKX0sdC5wcm90b3R5cGUuU1VCUlVMRTc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwodCw3LGUpfSx0LnByb3RvdHlwZS5TVUJSVUxFOD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbCh0LDgsZSl9LHQucHJvdG90eXBlLlNVQlJVTEU5PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHQsOSxlKX0sdC5wcm90b3R5cGUuT1BUSU9OPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9wdGlvbkludGVybmFsKHQsMCl9LHQucHJvdG90eXBlLk9QVElPTjE9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwodCwxKX0sdC5wcm90b3R5cGUuT1BUSU9OMj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbCh0LDIpfSx0LnByb3RvdHlwZS5PUFRJT04zPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9wdGlvbkludGVybmFsKHQsMyl9LHQucHJvdG90eXBlLk9QVElPTjQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwodCw0KX0sdC5wcm90b3R5cGUuT1BUSU9ONT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbCh0LDUpfSx0LnByb3RvdHlwZS5PUFRJT042PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9wdGlvbkludGVybmFsKHQsNil9LHQucHJvdG90eXBlLk9QVElPTjc9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwodCw3KX0sdC5wcm90b3R5cGUuT1BUSU9OOD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbCh0LDgpfSx0LnByb3RvdHlwZS5PUFRJT045PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9wdGlvbkludGVybmFsKHQsOSl9LHQucHJvdG90eXBlLk9SPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9ySW50ZXJuYWwodCwwKX0sdC5wcm90b3R5cGUuT1IxPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9ySW50ZXJuYWwodCwxKX0sdC5wcm90b3R5cGUuT1IyPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9ySW50ZXJuYWwodCwyKX0sdC5wcm90b3R5cGUuT1IzPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9ySW50ZXJuYWwodCwzKX0sdC5wcm90b3R5cGUuT1I0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9ySW50ZXJuYWwodCw0KX0sdC5wcm90b3R5cGUuT1I1PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9ySW50ZXJuYWwodCw1KX0sdC5wcm90b3R5cGUuT1I2PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9ySW50ZXJuYWwodCw2KX0sdC5wcm90b3R5cGUuT1I3PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9ySW50ZXJuYWwodCw3KX0sdC5wcm90b3R5cGUuT1I4PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9ySW50ZXJuYWwodCw4KX0sdC5wcm90b3R5cGUuT1I5PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9ySW50ZXJuYWwodCw5KX0sdC5wcm90b3R5cGUuTUFOWT1mdW5jdGlvbih0KXt0aGlzLm1hbnlJbnRlcm5hbCgwLHQpO30sdC5wcm90b3R5cGUuTUFOWTE9ZnVuY3Rpb24odCl7dGhpcy5tYW55SW50ZXJuYWwoMSx0KTt9LHQucHJvdG90eXBlLk1BTlkyPWZ1bmN0aW9uKHQpe3RoaXMubWFueUludGVybmFsKDIsdCk7fSx0LnByb3RvdHlwZS5NQU5ZMz1mdW5jdGlvbih0KXt0aGlzLm1hbnlJbnRlcm5hbCgzLHQpO30sdC5wcm90b3R5cGUuTUFOWTQ9ZnVuY3Rpb24odCl7dGhpcy5tYW55SW50ZXJuYWwoNCx0KTt9LHQucHJvdG90eXBlLk1BTlk1PWZ1bmN0aW9uKHQpe3RoaXMubWFueUludGVybmFsKDUsdCk7fSx0LnByb3RvdHlwZS5NQU5ZNj1mdW5jdGlvbih0KXt0aGlzLm1hbnlJbnRlcm5hbCg2LHQpO30sdC5wcm90b3R5cGUuTUFOWTc9ZnVuY3Rpb24odCl7dGhpcy5tYW55SW50ZXJuYWwoNyx0KTt9LHQucHJvdG90eXBlLk1BTlk4PWZ1bmN0aW9uKHQpe3RoaXMubWFueUludGVybmFsKDgsdCk7fSx0LnByb3RvdHlwZS5NQU5ZOT1mdW5jdGlvbih0KXt0aGlzLm1hbnlJbnRlcm5hbCg5LHQpO30sdC5wcm90b3R5cGUuTUFOWV9TRVA9ZnVuY3Rpb24odCl7dGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCgwLHQpO30sdC5wcm90b3R5cGUuTUFOWV9TRVAxPWZ1bmN0aW9uKHQpe3RoaXMubWFueVNlcEZpcnN0SW50ZXJuYWwoMSx0KTt9LHQucHJvdG90eXBlLk1BTllfU0VQMj1mdW5jdGlvbih0KXt0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDIsdCk7fSx0LnByb3RvdHlwZS5NQU5ZX1NFUDM9ZnVuY3Rpb24odCl7dGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCgzLHQpO30sdC5wcm90b3R5cGUuTUFOWV9TRVA0PWZ1bmN0aW9uKHQpe3RoaXMubWFueVNlcEZpcnN0SW50ZXJuYWwoNCx0KTt9LHQucHJvdG90eXBlLk1BTllfU0VQNT1mdW5jdGlvbih0KXt0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDUsdCk7fSx0LnByb3RvdHlwZS5NQU5ZX1NFUDY9ZnVuY3Rpb24odCl7dGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCg2LHQpO30sdC5wcm90b3R5cGUuTUFOWV9TRVA3PWZ1bmN0aW9uKHQpe3RoaXMubWFueVNlcEZpcnN0SW50ZXJuYWwoNyx0KTt9LHQucHJvdG90eXBlLk1BTllfU0VQOD1mdW5jdGlvbih0KXt0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDgsdCk7fSx0LnByb3RvdHlwZS5NQU5ZX1NFUDk9ZnVuY3Rpb24odCl7dGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCg5LHQpO30sdC5wcm90b3R5cGUuQVRfTEVBU1RfT05FPWZ1bmN0aW9uKHQpe3RoaXMuYXRMZWFzdE9uZUludGVybmFsKDAsdCk7fSx0LnByb3RvdHlwZS5BVF9MRUFTVF9PTkUxPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCgxLHQpfSx0LnByb3RvdHlwZS5BVF9MRUFTVF9PTkUyPWZ1bmN0aW9uKHQpe3RoaXMuYXRMZWFzdE9uZUludGVybmFsKDIsdCk7fSx0LnByb3RvdHlwZS5BVF9MRUFTVF9PTkUzPWZ1bmN0aW9uKHQpe3RoaXMuYXRMZWFzdE9uZUludGVybmFsKDMsdCk7fSx0LnByb3RvdHlwZS5BVF9MRUFTVF9PTkU0PWZ1bmN0aW9uKHQpe3RoaXMuYXRMZWFzdE9uZUludGVybmFsKDQsdCk7fSx0LnByb3RvdHlwZS5BVF9MRUFTVF9PTkU1PWZ1bmN0aW9uKHQpe3RoaXMuYXRMZWFzdE9uZUludGVybmFsKDUsdCk7fSx0LnByb3RvdHlwZS5BVF9MRUFTVF9PTkU2PWZ1bmN0aW9uKHQpe3RoaXMuYXRMZWFzdE9uZUludGVybmFsKDYsdCk7fSx0LnByb3RvdHlwZS5BVF9MRUFTVF9PTkU3PWZ1bmN0aW9uKHQpe3RoaXMuYXRMZWFzdE9uZUludGVybmFsKDcsdCk7fSx0LnByb3RvdHlwZS5BVF9MRUFTVF9PTkU4PWZ1bmN0aW9uKHQpe3RoaXMuYXRMZWFzdE9uZUludGVybmFsKDgsdCk7fSx0LnByb3RvdHlwZS5BVF9MRUFTVF9PTkU5PWZ1bmN0aW9uKHQpe3RoaXMuYXRMZWFzdE9uZUludGVybmFsKDksdCk7fSx0LnByb3RvdHlwZS5BVF9MRUFTVF9PTkVfU0VQPWZ1bmN0aW9uKHQpe3RoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoMCx0KTt9LHQucHJvdG90eXBlLkFUX0xFQVNUX09ORV9TRVAxPWZ1bmN0aW9uKHQpe3RoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoMSx0KTt9LHQucHJvdG90eXBlLkFUX0xFQVNUX09ORV9TRVAyPWZ1bmN0aW9uKHQpe3RoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoMix0KTt9LHQucHJvdG90eXBlLkFUX0xFQVNUX09ORV9TRVAzPWZ1bmN0aW9uKHQpe3RoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoMyx0KTt9LHQucHJvdG90eXBlLkFUX0xFQVNUX09ORV9TRVA0PWZ1bmN0aW9uKHQpe3RoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoNCx0KTt9LHQucHJvdG90eXBlLkFUX0xFQVNUX09ORV9TRVA1PWZ1bmN0aW9uKHQpe3RoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoNSx0KTt9LHQucHJvdG90eXBlLkFUX0xFQVNUX09ORV9TRVA2PWZ1bmN0aW9uKHQpe3RoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoNix0KTt9LHQucHJvdG90eXBlLkFUX0xFQVNUX09ORV9TRVA3PWZ1bmN0aW9uKHQpe3RoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoNyx0KTt9LHQucHJvdG90eXBlLkFUX0xFQVNUX09ORV9TRVA4PWZ1bmN0aW9uKHQpe3RoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoOCx0KTt9LHQucHJvdG90eXBlLkFUX0xFQVNUX09ORV9TRVA5PWZ1bmN0aW9uKHQpe3RoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoOSx0KTt9LHQucHJvdG90eXBlLlJVTEU9ZnVuY3Rpb24odCxlLG4pe2lmKHZvaWQgMD09PW4mJihuPW8uREVGQVVMVF9SVUxFX0NPTkZJRyksci5jb250YWlucyh0aGlzLmRlZmluZWRSdWxlc05hbWVzLHQpKXt2YXIgaT17bWVzc2FnZTphLmRlZmF1bHRHcmFtbWFyVmFsaWRhdG9yRXJyb3JQcm92aWRlci5idWlsZER1cGxpY2F0ZVJ1bGVOYW1lRXJyb3Ioe3RvcExldmVsUnVsZTp0LGdyYW1tYXJOYW1lOnRoaXMuY2xhc3NOYW1lfSksdHlwZTpvLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuRFVQTElDQVRFX1JVTEVfTkFNRSxydWxlTmFtZTp0fTt0aGlzLmRlZmluaXRpb25FcnJvcnMucHVzaChpKTt9aWYodGhpcy5kZWZpbmVkUnVsZXNOYW1lcy5wdXNoKHQpLCF0aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlLmNvbnRhaW5zS2V5KHQpJiYhdGhpcy5zZXJpYWxpemVkR3JhbW1hcil7dmFyIHU9cy5idWlsZFRvcFByb2R1Y3Rpb24oZS50b1N0cmluZygpLHQsdGhpcy50b2tlbnNNYXApO3RoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGUucHV0KHQsdSk7fXZhciBjPXRoaXMuZGVmaW5lUnVsZSh0LGUsbik7cmV0dXJuIHRoaXNbdF09YyxjfSx0LnByb3RvdHlwZS5PVkVSUklERV9SVUxFPWZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj1vLkRFRkFVTFRfUlVMRV9DT05GSUcpO3ZhciByPVtdO2lmKHI9ci5jb25jYXQodS52YWxpZGF0ZVJ1bGVJc092ZXJyaWRkZW4odCx0aGlzLmRlZmluZWRSdWxlc05hbWVzLHRoaXMuY2xhc3NOYW1lKSksdGhpcy5kZWZpbml0aW9uRXJyb3JzLnB1c2guYXBwbHkodGhpcy5kZWZpbml0aW9uRXJyb3JzLHIpLCF0aGlzLnNlcmlhbGl6ZWRHcmFtbWFyKXt2YXIgaT1zLmJ1aWxkVG9wUHJvZHVjdGlvbihlLnRvU3RyaW5nKCksdCx0aGlzLnRva2Vuc01hcCk7dGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZS5wdXQodCxpKTt9dmFyIGE9dGhpcy5kZWZpbmVSdWxlKHQsZSxuKTtyZXR1cm4gdGhpc1t0XT1hLGF9LHQucHJvdG90eXBlLkJBQ0tUUkFDSz1mdW5jdGlvbih0LGUpe3JldHVybiBmdW5jdGlvbigpe3RoaXMuaXNCYWNrVHJhY2tpbmdTdGFjay5wdXNoKDEpO3ZhciBuPXRoaXMuc2F2ZVJlY29nU3RhdGUoKTt0cnl7cmV0dXJuIHQuYXBwbHkodGhpcyxlKSwhMH1jYXRjaCh0KXtpZihpLmlzUmVjb2duaXRpb25FeGNlcHRpb24odCkpcmV0dXJuICExO3Rocm93IHR9ZmluYWxseXt0aGlzLnJlbG9hZFJlY29nU3RhdGUobiksdGhpcy5pc0JhY2tUcmFja2luZ1N0YWNrLnBvcCgpO319fSx0LnByb3RvdHlwZS5nZXRHQXN0UHJvZHVjdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZX0sdC5wcm90b3R5cGUuZ2V0U2VyaWFsaXplZEdhc3RQcm9kdWN0aW9ucz1mdW5jdGlvbigpe3JldHVybiBjLnNlcmlhbGl6ZUdyYW1tYXIodGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZS52YWx1ZXMoKSl9LHR9KCk7ZS5SZWNvZ25pemVyQXBpPXA7fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9bigwKSxpPW4oOSksbz1uKDYpLGE9bigxMikscz1uKDEzKSx1PW4oMyksYz1uKDI1KSxwPW4oMiksbD1uKDcpLGg9big0KSxmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUuaW5pdFJlY29nbml6ZXJFbmdpbmU9ZnVuY3Rpb24odCxlKXtpZih0aGlzLmNsYXNzTmFtZT1oLmNsYXNzTmFtZUZyb21JbnN0YW5jZSh0aGlzKSx0aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGw9bmV3IGguSGFzaFRhYmxlLHRoaXMuZnVsbFJ1bGVOYW1lVG9TaG9ydD1uZXcgaC5IYXNoVGFibGUsdGhpcy5ydWxlU2hvcnROYW1lSWR4PTI1Nix0aGlzLnRva2VuTWF0Y2hlcj1sLnRva2VuU3RydWN0dXJlZE1hdGNoZXJOb0NhdGVnb3JpZXMsdGhpcy5kZWZpbmVkUnVsZXNOYW1lcz1bXSx0aGlzLnRva2Vuc01hcD17fSx0aGlzLmFsbFJ1bGVOYW1lcz1bXSx0aGlzLmlzQmFja1RyYWNraW5nU3RhY2s9W10sdGhpcy5SVUxFX1NUQUNLPVtdLHRoaXMuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLPVtdLHRoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGU9bmV3IGguSGFzaFRhYmxlLHRoaXMuc2VyaWFsaXplZEdyYW1tYXI9ci5oYXMoZSxcInNlcmlhbGl6ZWRHcmFtbWFyXCIpP2Uuc2VyaWFsaXplZEdyYW1tYXI6dS5ERUZBVUxUX1BBUlNFUl9DT05GSUcuc2VyaWFsaXplZEdyYW1tYXIsci5pc0FycmF5KHQpKXtpZihyLmlzRW1wdHkodCkpdGhyb3cgRXJyb3IoXCJBIFRva2VuIFZvY2FidWxhcnkgY2Fubm90IGJlIGVtcHR5LlxcblxcdE5vdGUgdGhhdCB0aGUgZmlyc3QgYXJndW1lbnQgZm9yIHRoZSBwYXJzZXIgY29uc3RydWN0b3JcXG5cXHRpcyBubyBsb25nZXIgYSBUb2tlbiB2ZWN0b3IgKHNpbmNlIHY0LjApLlwiKTtpZihcIm51bWJlclwiPT10eXBlb2YgdFswXS5zdGFydE9mZnNldCl0aHJvdyBFcnJvcihcIlRoZSBQYXJzZXIgY29uc3RydWN0b3Igbm8gbG9uZ2VyIGFjY2VwdHMgYSB0b2tlbiB2ZWN0b3IgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxcblxcdFNlZTogaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9jaGFuZ2VzL0JSRUFLSU5HX0NIQU5HRVMuaHRtbCNfNC0wLTBcXG5cXHRGb3IgRnVydGhlciBkZXRhaWxzLlwiKX1pZihyLmlzQXJyYXkodCkpdGhpcy50b2tlbnNNYXA9ci5yZWR1Y2UodCxmdW5jdGlvbih0LGUpe3JldHVybiB0W3AudG9rZW5OYW1lKGUpXT1lLHR9LHt9KTtlbHNlIGlmKHIuaGFzKHQsXCJtb2Rlc1wiKSYmci5ldmVyeShyLmZsYXR0ZW4oci52YWx1ZXModC5tb2RlcykpLGwuaXNUb2tlblR5cGUpKXt2YXIgbj1yLmZsYXR0ZW4oci52YWx1ZXModC5tb2RlcykpLGk9ci51bmlxKG4pO3RoaXMudG9rZW5zTWFwPXIucmVkdWNlKGksZnVuY3Rpb24odCxlKXtyZXR1cm4gdFtwLnRva2VuTmFtZShlKV09ZSx0fSx7fSk7fWVsc2Uge2lmKCFyLmlzT2JqZWN0KHQpKXRocm93IG5ldyBFcnJvcihcIjx0b2tlbnNEaWN0aW9uYXJ5PiBhcmd1bWVudCBtdXN0IGJlIEFuIEFycmF5IG9mIFRva2VuIGNvbnN0cnVjdG9ycywgQSBkaWN0aW9uYXJ5IG9mIFRva2VuIGNvbnN0cnVjdG9ycyBvciBhbiBJTXVsdGlNb2RlTGV4ZXJEZWZpbml0aW9uXCIpO3RoaXMudG9rZW5zTWFwPXIuY2xvbmVPYmoodCk7fXRoaXMudG9rZW5zTWFwLkVPRj1wLkVPRjt2YXIgbz1yLmV2ZXJ5KHIudmFsdWVzKHQpLGZ1bmN0aW9uKHQpe3JldHVybiByLmlzRW1wdHkodC5jYXRlZ29yeU1hdGNoZXMpfSk7dGhpcy50b2tlbk1hdGNoZXI9bz9sLnRva2VuU3RydWN0dXJlZE1hdGNoZXJOb0NhdGVnb3JpZXM6bC50b2tlblN0cnVjdHVyZWRNYXRjaGVyLGwuYXVnbWVudFRva2VuVHlwZXMoci52YWx1ZXModGhpcy50b2tlbnNNYXApKTt9LHQucHJvdG90eXBlLmRlZmluZVJ1bGU9ZnVuY3Rpb24odCxlLG4pe2lmKHRoaXMuc2VsZkFuYWx5c2lzRG9uZSl0aHJvdyBFcnJvcihcIkdyYW1tYXIgcnVsZSA8XCIrdCtcIj4gbWF5IG5vdCBiZSBkZWZpbmVkIGFmdGVyIHRoZSAncGVyZm9ybVNlbGZBbmFseXNpcycgbWV0aG9kIGhhcyBiZWVuIGNhbGxlZCdcXG5NYWtlIHN1cmUgdGhhdCBhbGwgZ3JhbW1hciBydWxlIGRlZmluaXRpb25zIGFyZSBkb25lIGJlZm9yZSAncGVyZm9ybVNlbGZBbmFseXNpcycgaXMgY2FsbGVkLlwiKTt2YXIgYSxzPXIuaGFzKG4sXCJyZXN5bmNFbmFibGVkXCIpP24ucmVzeW5jRW5hYmxlZDp1LkRFRkFVTFRfUlVMRV9DT05GSUcucmVzeW5jRW5hYmxlZCxjPXIuaGFzKG4sXCJyZWNvdmVyeVZhbHVlRnVuY1wiKT9uLnJlY292ZXJ5VmFsdWVGdW5jOnUuREVGQVVMVF9SVUxFX0NPTkZJRy5yZWNvdmVyeVZhbHVlRnVuYyxwPXRoaXMucnVsZVNob3J0TmFtZUlkeDw8aS5CSVRTX0ZPUl9NRVRIT0RfSURYK2kuQklUU19GT1JfT0NDVVJSRU5DRV9JRFg7dGhpcy5ydWxlU2hvcnROYW1lSWR4KyssdGhpcy5zaG9ydFJ1bGVOYW1lVG9GdWxsLnB1dChwLHQpLHRoaXMuZnVsbFJ1bGVOYW1lVG9TaG9ydC5wdXQodCxwKTtyZXR1cm4gKGE9ZnVuY3Rpb24obixyKXtyZXR1cm4gdm9pZCAwPT09biYmKG49MCksdGhpcy5ydWxlSW52b2NhdGlvblN0YXRlVXBkYXRlKHAsdCxuKSxmdW5jdGlvbih0KXt0cnl7cmV0dXJuICEwPT09dGhpcy5vdXRwdXRDc3Q/KGUuYXBwbHkodGhpcyx0KSx0aGlzLkNTVF9TVEFDS1t0aGlzLkNTVF9TVEFDSy5sZW5ndGgtMV0pOmUuYXBwbHkodGhpcyx0KX1jYXRjaCh0KXt2YXIgbj0xPT09dGhpcy5SVUxFX1NUQUNLLmxlbmd0aCxyPXMmJiF0aGlzLmlzQmFja1RyYWNraW5nKCkmJnRoaXMucmVjb3ZlcnlFbmFibGVkO2lmKG8uaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbih0KSl7aWYocil7dmFyIGksYT10aGlzLmZpbmRSZVN5bmNUb2tlblR5cGUoKTtpZih0aGlzLmlzSW5DdXJyZW50UnVsZVJlU3luY1NldChhKSlyZXR1cm4gdC5yZXN5bmNlZFRva2Vucz10aGlzLnJlU3luY1RvKGEpLHRoaXMub3V0cHV0Q3N0PygoaT10aGlzLkNTVF9TVEFDS1t0aGlzLkNTVF9TVEFDSy5sZW5ndGgtMV0pLnJlY292ZXJlZE5vZGU9ITAsaSk6YygpO3Rocm93IHRoaXMub3V0cHV0Q3N0JiYoKGk9dGhpcy5DU1RfU1RBQ0tbdGhpcy5DU1RfU1RBQ0subGVuZ3RoLTFdKS5yZWNvdmVyZWROb2RlPSEwLHQucGFydGlhbENzdFJlc3VsdD1pKSx0fWlmKG4pcmV0dXJuIHRoaXMubW92ZVRvVGVybWluYXRlZFN0YXRlKCksYygpO3Rocm93IHR9dGhyb3cgdH1maW5hbGx5e3RoaXMucnVsZUZpbmFsbHlTdGF0ZVVwZGF0ZSgpO319LmNhbGwodGhpcyxyKX0pLnJ1bGVOYW1lPXQsYX0sdC5wcm90b3R5cGUub3B0aW9uSW50ZXJuYWw9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChpLk9QVElPTl9JRFgsZSkscj10aGlzLm5lc3RlZFJ1bGVCZWZvcmVDbGF1c2UodCxuKTt0cnl7cmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWxMb2dpYyh0LGUsbil9ZmluYWxseXt2b2lkIDAhPT1yJiZ0aGlzLm5lc3RlZFJ1bGVGaW5hbGx5Q2xhdXNlKG4scik7fX0sdC5wcm90b3R5cGUub3B0aW9uSW50ZXJuYWxOb0NzdD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKGkuT1BUSU9OX0lEWCxlKTtyZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbExvZ2ljKHQsZSxuKX0sdC5wcm90b3R5cGUub3B0aW9uSW50ZXJuYWxMb2dpYz1mdW5jdGlvbih0LGUsbil7dmFyIHIsaSxvPXRoaXMsYT10aGlzLmdldExvb2thaGVhZEZ1bmNGb3JPcHRpb24obixlKTtpZih2b2lkIDAhPT10LkRFRil7aWYocj10LkRFRix2b2lkIDAhPT0oaT10LkdBVEUpKXt2YXIgcz1hO2E9ZnVuY3Rpb24oKXtyZXR1cm4gaS5jYWxsKG8pJiZzLmNhbGwobyl9O319ZWxzZSByPXQ7aWYoITA9PT1hLmNhbGwodGhpcykpcmV0dXJuIHIuY2FsbCh0aGlzKX0sdC5wcm90b3R5cGUuYXRMZWFzdE9uZUludGVybmFsPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoaS5BVF9MRUFTVF9PTkVfSURYLHQpLHI9dGhpcy5uZXN0ZWRSdWxlQmVmb3JlQ2xhdXNlKGUsbik7dHJ5e3JldHVybiB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbExvZ2ljKHQsZSxuKX1maW5hbGx5e3ZvaWQgMCE9PXImJnRoaXMubmVzdGVkUnVsZUZpbmFsbHlDbGF1c2UobixyKTt9fSx0LnByb3RvdHlwZS5hdExlYXN0T25lSW50ZXJuYWxOb0NzdD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKGkuQVRfTEVBU1RfT05FX0lEWCx0KTt0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbExvZ2ljKHQsZSxuKTt9LHQucHJvdG90eXBlLmF0TGVhc3RPbmVJbnRlcm5hbExvZ2ljPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcixvLHU9dGhpcyxjPXRoaXMuZ2V0TG9va2FoZWFkRnVuY0ZvckF0TGVhc3RPbmUobix0KTtpZih2b2lkIDAhPT1lLkRFRil7aWYocj1lLkRFRix2b2lkIDAhPT0obz1lLkdBVEUpKXt2YXIgcD1jO2M9ZnVuY3Rpb24oKXtyZXR1cm4gby5jYWxsKHUpJiZwLmNhbGwodSl9O319ZWxzZSByPWU7aWYoITAhPT1jLmNhbGwodGhpcykpdGhyb3cgdGhpcy5yYWlzZUVhcmx5RXhpdEV4Y2VwdGlvbih0LGEuUFJPRF9UWVBFLlJFUEVUSVRJT05fTUFOREFUT1JZLGUuRVJSX01TRyk7Zm9yKHZhciBsPXRoaXMuZG9TaW5nbGVSZXBldGl0aW9uKHIpOyEwPT09Yy5jYWxsKHRoaXMpJiYhMD09PWw7KWw9dGhpcy5kb1NpbmdsZVJlcGV0aXRpb24ocik7dGhpcy5hdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnkodGhpcy5hdExlYXN0T25lSW50ZXJuYWwsW3QsZV0sYyxpLkFUX0xFQVNUX09ORV9JRFgsdCxzLk5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVdhbGtlcik7fSx0LnByb3RvdHlwZS5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKGkuQVRfTEVBU1RfT05FX1NFUF9JRFgsdCkscj10aGlzLm5lc3RlZFJ1bGVCZWZvcmVDbGF1c2UoZSxuKTt0cnl7dGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbExvZ2ljKHQsZSxuKTt9ZmluYWxseXt2b2lkIDAhPT1yJiZ0aGlzLm5lc3RlZFJ1bGVGaW5hbGx5Q2xhdXNlKG4scik7fX0sdC5wcm90b3R5cGUuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWxOb0NzdD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKGkuQVRfTEVBU1RfT05FX1NFUF9JRFgsdCk7dGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbExvZ2ljKHQsZSxuKTt9LHQucHJvdG90eXBlLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsTG9naWM9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXRoaXMsbz1lLkRFRix1PWUuU0VQO2lmKCEwIT09dGhpcy5nZXRMb29rYWhlYWRGdW5jRm9yQXRMZWFzdE9uZVNlcChuLHQpLmNhbGwodGhpcykpdGhyb3cgdGhpcy5yYWlzZUVhcmx5RXhpdEV4Y2VwdGlvbih0LGEuUFJPRF9UWVBFLlJFUEVUSVRJT05fTUFOREFUT1JZX1dJVEhfU0VQQVJBVE9SLGUuRVJSX01TRyk7by5jYWxsKHRoaXMpO2Zvcih2YXIgYz1mdW5jdGlvbigpe3JldHVybiByLnRva2VuTWF0Y2hlcihyLkxBKDEpLHUpfTshMD09PXRoaXMudG9rZW5NYXRjaGVyKHRoaXMuTEEoMSksdSk7KXRoaXMuQ09OU1VNRSh1KSxvLmNhbGwodGhpcyk7dGhpcy5hdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnkodGhpcy5yZXBldGl0aW9uU2VwU2Vjb25kSW50ZXJuYWwsW3QsdSxjLG8scy5OZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVTZXBXYWxrZXJdLGMsaS5BVF9MRUFTVF9PTkVfU0VQX0lEWCx0LHMuTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lU2VwV2Fsa2VyKTt9LHQucHJvdG90eXBlLm1hbnlJbnRlcm5hbD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKGkuTUFOWV9JRFgsdCkscj10aGlzLm5lc3RlZFJ1bGVCZWZvcmVDbGF1c2UoZSxuKTt0cnl7cmV0dXJuIHRoaXMubWFueUludGVybmFsTG9naWModCxlLG4pfWZpbmFsbHl7dm9pZCAwIT09ciYmdGhpcy5uZXN0ZWRSdWxlRmluYWxseUNsYXVzZShuLHIpO319LHQucHJvdG90eXBlLm1hbnlJbnRlcm5hbE5vQ3N0PWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoaS5NQU5ZX0lEWCx0KTtyZXR1cm4gdGhpcy5tYW55SW50ZXJuYWxMb2dpYyh0LGUsbil9LHQucHJvdG90eXBlLm1hbnlJbnRlcm5hbExvZ2ljPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcixvLGE9dGhpcyx1PXRoaXMuZ2V0TG9va2FoZWFkRnVuY0Zvck1hbnkobix0KTtpZih2b2lkIDAhPT1lLkRFRil7aWYocj1lLkRFRix2b2lkIDAhPT0obz1lLkdBVEUpKXt2YXIgYz11O3U9ZnVuY3Rpb24oKXtyZXR1cm4gby5jYWxsKGEpJiZjLmNhbGwoYSl9O319ZWxzZSByPWU7Zm9yKHZhciBwPSEwOyEwPT09dS5jYWxsKHRoaXMpJiYhMD09PXA7KXA9dGhpcy5kb1NpbmdsZVJlcGV0aXRpb24ocik7dGhpcy5hdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnkodGhpcy5tYW55SW50ZXJuYWwsW3QsZV0sdSxpLk1BTllfSURYLHQscy5OZXh0VGVybWluYWxBZnRlck1hbnlXYWxrZXIpO30sdC5wcm90b3R5cGUubWFueVNlcEZpcnN0SW50ZXJuYWw9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChpLk1BTllfU0VQX0lEWCx0KSxyPXRoaXMubmVzdGVkUnVsZUJlZm9yZUNsYXVzZShlLG4pO3RyeXt0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsTG9naWModCxlLG4pO31maW5hbGx5e3ZvaWQgMCE9PXImJnRoaXMubmVzdGVkUnVsZUZpbmFsbHlDbGF1c2UobixyKTt9fSx0LnByb3RvdHlwZS5tYW55U2VwRmlyc3RJbnRlcm5hbE5vQ3N0PWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoaS5NQU5ZX1NFUF9JRFgsdCk7dGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbExvZ2ljKHQsZSxuKTt9LHQucHJvdG90eXBlLm1hbnlTZXBGaXJzdEludGVybmFsTG9naWM9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXRoaXMsbz1lLkRFRixhPWUuU0VQO2lmKCEwPT09dGhpcy5nZXRMb29rYWhlYWRGdW5jRm9yTWFueVNlcChuLHQpLmNhbGwodGhpcykpe28uY2FsbCh0aGlzKTtmb3IodmFyIHU9ZnVuY3Rpb24oKXtyZXR1cm4gci50b2tlbk1hdGNoZXIoci5MQSgxKSxhKX07ITA9PT10aGlzLnRva2VuTWF0Y2hlcih0aGlzLkxBKDEpLGEpOyl0aGlzLkNPTlNVTUUoYSksby5jYWxsKHRoaXMpO3RoaXMuYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5KHRoaXMucmVwZXRpdGlvblNlcFNlY29uZEludGVybmFsLFt0LGEsdSxvLHMuTmV4dFRlcm1pbmFsQWZ0ZXJNYW55U2VwV2Fsa2VyXSx1LGkuTUFOWV9TRVBfSURYLHQscy5OZXh0VGVybWluYWxBZnRlck1hbnlTZXBXYWxrZXIpO319LHQucHJvdG90eXBlLnJlcGV0aXRpb25TZXBTZWNvbmRJbnRlcm5hbD1mdW5jdGlvbih0LGUsbixyLG8pe2Zvcig7bigpOyl0aGlzLkNPTlNVTUUoZSksci5jYWxsKHRoaXMpO3RoaXMuYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5KHRoaXMucmVwZXRpdGlvblNlcFNlY29uZEludGVybmFsLFt0LGUsbixyLG9dLG4saS5BVF9MRUFTVF9PTkVfU0VQX0lEWCx0LG8pO30sdC5wcm90b3R5cGUuZG9TaW5nbGVSZXBldGl0aW9uPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0TGV4ZXJQb3NpdGlvbigpO3JldHVybiB0LmNhbGwodGhpcyksdGhpcy5nZXRMZXhlclBvc2l0aW9uKCk+ZX0sdC5wcm90b3R5cGUub3JJbnRlcm5hbE5vQ3N0PWZ1bmN0aW9uKHQsZSl7dmFyIG49ci5pc0FycmF5KHQpP3Q6dC5ERUYsaT10aGlzLmdldExvb2thaGVhZEZ1bmNGb3JPcihlLG4pLmNhbGwodGhpcyxuKTtpZih2b2lkIDAhPT1pKXJldHVybiBuW2ldLkFMVC5jYWxsKHRoaXMpO3RoaXMucmFpc2VOb0FsdEV4Y2VwdGlvbihlLHQuRVJSX01TRyk7fSx0LnByb3RvdHlwZS5vckludGVybmFsPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoaS5PUl9JRFgsZSksbz10aGlzLm5lc3RlZFJ1bGVCZWZvcmVDbGF1c2UodCxuKTt0cnl7dmFyIGE9ci5pc0FycmF5KHQpP3Q6dC5ERUYscz10aGlzLmdldExvb2thaGVhZEZ1bmNGb3JPcihlLGEpLmNhbGwodGhpcyxhKTtpZih2b2lkIDAhPT1zKXt2YXIgdT1hW3NdLGM9dGhpcy5uZXN0ZWRBbHRCZWZvcmVDbGF1c2UodSxlLGkuT1JfSURYLHMpO3RyeXtyZXR1cm4gdS5BTFQuY2FsbCh0aGlzKX1maW5hbGx5e3ZvaWQgMCE9PWMmJnRoaXMubmVzdGVkUnVsZUZpbmFsbHlDbGF1c2UoYy5zaG9ydE5hbWUsYy5uZXN0ZWROYW1lKTt9fXRoaXMucmFpc2VOb0FsdEV4Y2VwdGlvbihlLHQuRVJSX01TRyk7fWZpbmFsbHl7dm9pZCAwIT09byYmdGhpcy5uZXN0ZWRSdWxlRmluYWxseUNsYXVzZShuLG8pO319LHQucHJvdG90eXBlLnJ1bGVGaW5hbGx5U3RhdGVVcGRhdGU9ZnVuY3Rpb24oKXtpZih0aGlzLlJVTEVfU1RBQ0sucG9wKCksdGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0sucG9wKCksdGhpcy5jc3RGaW5hbGx5U3RhdGVVcGRhdGUoKSwwPT09dGhpcy5SVUxFX1NUQUNLLmxlbmd0aCYmIXRoaXMuaXNBdEVuZE9mSW5wdXQoKSl7dmFyIHQ9dGhpcy5MQSgxKSxlPXRoaXMuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGROb3RBbGxJbnB1dFBhcnNlZE1lc3NhZ2Uoe2ZpcnN0UmVkdW5kYW50OnQscnVsZU5hbWU6dGhpcy5nZXRDdXJyUnVsZUZ1bGxOYW1lKCl9KTt0aGlzLlNBVkVfRVJST1IobmV3IG8uTm90QWxsSW5wdXRQYXJzZWRFeGNlcHRpb24oZSx0KSk7fX0sdC5wcm90b3R5cGUuc3VicnVsZUludGVybmFsPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcjt0cnl7dmFyIGk9dm9pZCAwIT09bj9uLkFSR1M6dm9pZCAwO3JldHVybiByPXQuY2FsbCh0aGlzLGUsaSksdGhpcy5jc3RQb3N0Tm9uVGVybWluYWwocix2b2lkIDAhPT1uJiZ2b2lkIDAhPT1uLkxBQkVMP24uTEFCRUw6dC5ydWxlTmFtZSkscn1jYXRjaChlKXt0aHJvdyBvLmlzUmVjb2duaXRpb25FeGNlcHRpb24oZSkmJnZvaWQgMCE9PWUucGFydGlhbENzdFJlc3VsdCYmKHRoaXMuY3N0UG9zdE5vblRlcm1pbmFsKGUucGFydGlhbENzdFJlc3VsdCx2b2lkIDAhPT1uJiZ2b2lkIDAhPT1uLkxBQkVMP24uTEFCRUw6dC5ydWxlTmFtZSksZGVsZXRlIGUucGFydGlhbENzdFJlc3VsdCksZX19LHQucHJvdG90eXBlLmNvbnN1bWVJbnRlcm5hbD1mdW5jdGlvbih0LGUsbil7dmFyIHI7dHJ5e3ZhciBpPXRoaXMuTEEoMSk7aWYoITAhPT10aGlzLnRva2VuTWF0Y2hlcihpLHQpKXt2YXIgYT12b2lkIDAscz10aGlzLkxBKDApO3Rocm93IGE9dm9pZCAwIT09biYmbi5FUlJfTVNHP24uRVJSX01TRzp0aGlzLmVycm9yTWVzc2FnZVByb3ZpZGVyLmJ1aWxkTWlzbWF0Y2hUb2tlbk1lc3NhZ2Uoe2V4cGVjdGVkOnQsYWN0dWFsOmkscHJldmlvdXM6cyxydWxlTmFtZTp0aGlzLmdldEN1cnJSdWxlRnVsbE5hbWUoKX0pLHRoaXMuU0FWRV9FUlJPUihuZXcgby5NaXNtYXRjaGVkVG9rZW5FeGNlcHRpb24oYSxpLHMpKX10aGlzLmNvbnN1bWVUb2tlbigpLHI9aTt9Y2F0Y2gobil7aWYoIXRoaXMucmVjb3ZlcnlFbmFibGVkfHxcIk1pc21hdGNoZWRUb2tlbkV4Y2VwdGlvblwiIT09bi5uYW1lfHx0aGlzLmlzQmFja1RyYWNraW5nKCkpdGhyb3cgbjt2YXIgdT10aGlzLmdldEZvbGxvd3NGb3JJblJ1bGVSZWNvdmVyeSh0LGUpO3RyeXtyPXRoaXMudHJ5SW5SdWxlUmVjb3ZlcnkodCx1KTt9Y2F0Y2godCl7dGhyb3cgdC5uYW1lPT09Yy5JTl9SVUxFX1JFQ09WRVJZX0VYQ0VQVElPTj9uOnR9fXJldHVybiB0aGlzLmNzdFBvc3RUZXJtaW5hbCh2b2lkIDAhPT1uJiZ2b2lkIDAhPT1uLkxBQkVMP24uTEFCRUw6dC50b2tlbk5hbWUscikscn0sdC5wcm90b3R5cGUuc2F2ZVJlY29nU3RhdGU9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmVycm9ycyxlPXIuY2xvbmVBcnIodGhpcy5SVUxFX1NUQUNLKTtyZXR1cm4ge2Vycm9yczp0LGxleGVyU3RhdGU6dGhpcy5leHBvcnRMZXhlclN0YXRlKCksUlVMRV9TVEFDSzplLENTVF9TVEFDSzp0aGlzLkNTVF9TVEFDSyxMQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0s6dGhpcy5MQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0t9fSx0LnByb3RvdHlwZS5yZWxvYWRSZWNvZ1N0YXRlPWZ1bmN0aW9uKHQpe3RoaXMuZXJyb3JzPXQuZXJyb3JzLHRoaXMuaW1wb3J0TGV4ZXJTdGF0ZSh0LmxleGVyU3RhdGUpLHRoaXMuUlVMRV9TVEFDSz10LlJVTEVfU1RBQ0s7fSx0LnByb3RvdHlwZS5ydWxlSW52b2NhdGlvblN0YXRlVXBkYXRlPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSy5wdXNoKG4pLHRoaXMuUlVMRV9TVEFDSy5wdXNoKHQpLHRoaXMuY3N0SW52b2NhdGlvblN0YXRlVXBkYXRlKGUsdCk7fSx0LnByb3RvdHlwZS5pc0JhY2tUcmFja2luZz1mdW5jdGlvbigpe3JldHVybiAhci5pc0VtcHR5KHRoaXMuaXNCYWNrVHJhY2tpbmdTdGFjayl9LHQucHJvdG90eXBlLmdldEN1cnJSdWxlRnVsbE5hbWU9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmdldExhc3RFeHBsaWNpdFJ1bGVTaG9ydE5hbWUoKTtyZXR1cm4gdGhpcy5zaG9ydFJ1bGVOYW1lVG9GdWxsLmdldCh0KX0sdC5wcm90b3R5cGUuc2hvcnRSdWxlTmFtZVRvRnVsbE5hbWU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc2hvcnRSdWxlTmFtZVRvRnVsbC5nZXQodCl9LHQucHJvdG90eXBlLmlzQXRFbmRPZklucHV0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG9rZW5NYXRjaGVyKHRoaXMuTEEoMSkscC5FT0YpfSx0LnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3RoaXMucmVzZXRMZXhlclN0YXRlKCksdGhpcy5pc0JhY2tUcmFja2luZ1N0YWNrPVtdLHRoaXMuZXJyb3JzPVtdLHRoaXMuUlVMRV9TVEFDSz1bXSx0aGlzLkxBU1RfRVhQTElDSVRfUlVMRV9TVEFDSz1bXSx0aGlzLkNTVF9TVEFDSz1bXSx0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSz1bXTt9LHR9KCk7ZS5SZWNvZ25pemVyRW5naW5lPWY7fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9big2KSxpPW4oMCksbz1uKDEyKSxhPW4oMykscz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQucHJvdG90eXBlLmluaXRFcnJvckhhbmRsZXI9ZnVuY3Rpb24odCl7dGhpcy5fZXJyb3JzPVtdLHRoaXMuZXJyb3JNZXNzYWdlUHJvdmlkZXI9aS5kZWZhdWx0cyh0LmVycm9yTWVzc2FnZVByb3ZpZGVyLGEuREVGQVVMVF9QQVJTRVJfQ09ORklHLmVycm9yTWVzc2FnZVByb3ZpZGVyKTt9LHQucHJvdG90eXBlLlNBVkVfRVJST1I9ZnVuY3Rpb24odCl7aWYoci5pc1JlY29nbml0aW9uRXhjZXB0aW9uKHQpKXJldHVybiB0LmNvbnRleHQ9e3J1bGVTdGFjazp0aGlzLmdldEh1bWFuUmVhZGFibGVSdWxlU3RhY2soKSxydWxlT2NjdXJyZW5jZVN0YWNrOmkuY2xvbmVBcnIodGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0spfSx0aGlzLl9lcnJvcnMucHVzaCh0KSx0O3Rocm93IEVycm9yKFwiVHJ5aW5nIHRvIHNhdmUgYW4gRXJyb3Igd2hpY2ggaXMgbm90IGEgUmVjb2duaXRpb25FeGNlcHRpb25cIil9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImVycm9yc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaS5jbG9uZUFycih0aGlzLl9lcnJvcnMpfSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5fZXJyb3JzPXQ7fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLnJhaXNlRWFybHlFeGl0RXhjZXB0aW9uPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9dGhpcy5nZXRDdXJyUnVsZUZ1bGxOYW1lKCksYT10aGlzLmdldEdBc3RQcm9kdWN0aW9ucygpLmdldChpKSxzPW8uZ2V0TG9va2FoZWFkUGF0aHNGb3JPcHRpb25hbFByb2QodCxhLGUsdGhpcy5tYXhMb29rYWhlYWQpWzBdLHU9W10sYz0xO2M8dGhpcy5tYXhMb29rYWhlYWQ7YysrKXUucHVzaCh0aGlzLkxBKGMpKTt2YXIgcD10aGlzLmVycm9yTWVzc2FnZVByb3ZpZGVyLmJ1aWxkRWFybHlFeGl0TWVzc2FnZSh7ZXhwZWN0ZWRJdGVyYXRpb25QYXRoczpzLGFjdHVhbDp1LHByZXZpb3VzOnRoaXMuTEEoMCksY3VzdG9tVXNlckRlc2NyaXB0aW9uOm4scnVsZU5hbWU6aX0pO3Rocm93IHRoaXMuU0FWRV9FUlJPUihuZXcgci5FYXJseUV4aXRFeGNlcHRpb24ocCx0aGlzLkxBKDEpLHRoaXMuTEEoMCkpKX0sdC5wcm90b3R5cGUucmFpc2VOb0FsdEV4Y2VwdGlvbj1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10aGlzLmdldEN1cnJSdWxlRnVsbE5hbWUoKSxpPXRoaXMuZ2V0R0FzdFByb2R1Y3Rpb25zKCkuZ2V0KG4pLGE9by5nZXRMb29rYWhlYWRQYXRoc0Zvck9yKHQsaSx0aGlzLm1heExvb2thaGVhZCkscz1bXSx1PTE7dTw9dGhpcy5tYXhMb29rYWhlYWQ7dSsrKXMucHVzaCh0aGlzLkxBKHUpKTt2YXIgYz10aGlzLkxBKDApLHA9dGhpcy5lcnJvck1lc3NhZ2VQcm92aWRlci5idWlsZE5vVmlhYmxlQWx0TWVzc2FnZSh7ZXhwZWN0ZWRQYXRoc1BlckFsdDphLGFjdHVhbDpzLHByZXZpb3VzOmMsY3VzdG9tVXNlckRlc2NyaXB0aW9uOmUscnVsZU5hbWU6dGhpcy5nZXRDdXJyUnVsZUZ1bGxOYW1lKCl9KTt0aHJvdyB0aGlzLlNBVkVfRVJST1IobmV3IHIuTm9WaWFibGVBbHRFeGNlcHRpb24ocCx0aGlzLkxBKDEpLGMpKX0sdH0oKTtlLkVycm9ySGFuZGxlcj1zO30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPW4oMTMpLGk9bigwKSxvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUuaW5pdENvbnRlbnRBc3Npc3Q9ZnVuY3Rpb24oKXt9LHQucHJvdG90eXBlLmNvbXB1dGVDb250ZW50QXNzaXN0PWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZS5nZXQodCk7aWYoaS5pc1VuZGVmaW5lZChuKSl0aHJvdyBFcnJvcihcIlJ1bGUgLT5cIit0K1wiPC0gZG9lcyBub3QgZXhpc3QgaW4gdGhpcyBncmFtbWFyLlwiKTtyZXR1cm4gci5uZXh0UG9zc2libGVUb2tlbnNBZnRlcihbbl0sZSx0aGlzLnRva2VuTWF0Y2hlcix0aGlzLm1heExvb2thaGVhZCl9LHQucHJvdG90eXBlLmdldE5leHRQb3NzaWJsZVRva2VuVHlwZXM9ZnVuY3Rpb24odCl7dmFyIGU9aS5maXJzdCh0LnJ1bGVTdGFjayksbj10aGlzLmdldEdBc3RQcm9kdWN0aW9ucygpLmdldChlKTtyZXR1cm4gbmV3IHIuTmV4dEFmdGVyVG9rZW5XYWxrZXIobix0KS5zdGFydFdhbGtpbmcoKX0sdH0oKTtlLkNvbnRlbnRBc3Npc3Q9bzt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1uKDE3KTtlLmNyZWF0ZVN5bnRheERpYWdyYW1zQ29kZT1mdW5jdGlvbih0LGUpe3ZhciBuPXZvaWQgMD09PWU/e306ZSxpPW4ucmVzb3VyY2VCYXNlLG89dm9pZCAwPT09aT9cImh0dHBzOi8vdW5wa2cuY29tL2NoZXZyb3RhaW5AXCIrci5WRVJTSU9OK1wiL2RpYWdyYW1zL1wiOmksYT1uLmNzcztyZXR1cm4gXCJcXG5cXHgzYyEtLSBUaGlzIGlzIGEgZ2VuZXJhdGVkIGZpbGUgLS1cXHgzZVxcbjwhRE9DVFlQRSBodG1sPlxcbjxtZXRhIGNoYXJzZXQ9XFxcInV0Zi04XFxcIj5cXG48c3R5bGU+XFxuICBib2R5IHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogaHNsKDMwLCAyMCUsIDk1JSlcXG4gIH1cXG48L3N0eWxlPlxcblxcblxcbjxsaW5rIHJlbD0nc3R5bGVzaGVldCcgaHJlZj0nXCIrKHZvaWQgMD09PWE/XCJodHRwczovL3VucGtnLmNvbS9jaGV2cm90YWluQFwiK3IuVkVSU0lPTitcIi9kaWFncmFtcy9kaWFncmFtcy5jc3NcIjphKStcIic+XFxuXFxuPHNjcmlwdCBzcmM9J1wiK28rXCJ2ZW5kb3IvcmFpbHJvYWQtZGlhZ3JhbXMuanMnPjxcXC9zY3JpcHQ+XFxuPHNjcmlwdCBzcmM9J1wiK28rXCJzcmMvZGlhZ3JhbXNfYnVpbGRlci5qcyc+PFxcL3NjcmlwdD5cXG48c2NyaXB0IHNyYz0nXCIrbytcInNyYy9kaWFncmFtc19iZWhhdmlvci5qcyc+PFxcL3NjcmlwdD5cXG48c2NyaXB0IHNyYz0nXCIrbysnc3JjL21haW4uanNcXCc+PFxcL3NjcmlwdD5cXG5cXG48ZGl2IGlkPVwiZGlhZ3JhbXNcIiBhbGlnbj1cImNlbnRlclwiPjwvZGl2PiAgICBcXG5cXG48c2NyaXB0PlxcbiAgICB3aW5kb3cuc2VyaWFsaXplZEdyYW1tYXIgPSAnK0pTT04uc3RyaW5naWZ5KHQsbnVsbCxcIiAgXCIpKyc7XFxuPFxcL3NjcmlwdD5cXG5cXG48c2NyaXB0PlxcbiAgICB2YXIgZGlhZ3JhbXNEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRpYWdyYW1zXCIpO1xcbiAgICBtYWluLmRyYXdEaWFncmFtc0Zyb21TZXJpYWxpemVkR3JhbW1hcihzZXJpYWxpemVkR3JhbW1hciwgZGlhZ3JhbXNEaXYpO1xcbjxcXC9zY3JpcHQ+XFxuJ307fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9big0MSk7ZS5nZW5lcmF0ZVBhcnNlckZhY3Rvcnk9ZnVuY3Rpb24odCl7dmFyIGU9ci5nZW5XcmFwcGVyRnVuY3Rpb24oe25hbWU6dC5uYW1lLHJ1bGVzOnQucnVsZXN9KSxpPW5ldyBGdW5jdGlvbihcInRva2VuVm9jYWJ1bGFyeVwiLFwiY29uZmlnXCIsXCJjaGV2cm90YWluXCIsZSk7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBpKHQudG9rZW5Wb2NhYnVsYXJ5LGUsbigxOCkpfX0sZS5nZW5lcmF0ZVBhcnNlck1vZHVsZT1mdW5jdGlvbih0KXtyZXR1cm4gci5nZW5VbWRNb2R1bGUoe25hbWU6dC5uYW1lLHJ1bGVzOnQucnVsZXN9KX07fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9bigwKSxpPW4oMiksbz1uKDEpLGE9XCJcXG5cIjtmdW5jdGlvbiBzKHQpe3JldHVybiBcIlxcbmZ1bmN0aW9uIFwiK3QubmFtZStcIih0b2tlblZvY2FidWxhcnksIGNvbmZpZykge1xcbiAgICAvLyBpbnZva2Ugc3VwZXIgY29uc3RydWN0b3JcXG4gICAgLy8gTm8gc3VwcG9ydCBmb3IgZW1iZWRkZWQgYWN0aW9ucyBjdXJyZW50bHksIHNvIHdlIGNhbiAnaGFyZGNvZGUnXFxuICAgIC8vIFRoZSB1c2Ugb2YgQ3N0UGFyc2VyLlxcbiAgICBjaGV2cm90YWluLkNzdFBhcnNlci5jYWxsKHRoaXMsIHRva2VuVm9jYWJ1bGFyeSwgY29uZmlnKVxcblxcbiAgICBjb25zdCAkID0gdGhpc1xcblxcbiAgICBcIit1KHQucnVsZXMpK1wiXFxuXFxuICAgIC8vIHZlcnkgaW1wb3J0YW50IHRvIGNhbGwgdGhpcyBhZnRlciBhbGwgdGhlIHJ1bGVzIGhhdmUgYmVlbiBkZWZpbmVkLlxcbiAgICAvLyBvdGhlcndpc2UgdGhlIHBhcnNlciBtYXkgbm90IHdvcmsgY29ycmVjdGx5IGFzIGl0IHdpbGwgbGFjayBpbmZvcm1hdGlvblxcbiAgICAvLyBkZXJpdmVkIGR1cmluZyB0aGUgc2VsZiBhbmFseXNpcyBwaGFzZS5cXG4gICAgdGhpcy5wZXJmb3JtU2VsZkFuYWx5c2lzKHRoaXMpXFxufVxcblxcbi8vIGluaGVyaXRhbmNlIGFzIGltcGxlbWVudGVkIGluIGphdmFzY3JpcHQgaW4gdGhlIHByZXZpb3VzIGRlY2FkZS4uLiA6KFxcblwiK3QubmFtZStcIi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNoZXZyb3RhaW4uQ3N0UGFyc2VyLnByb3RvdHlwZSlcXG5cIit0Lm5hbWUrXCIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gXCIrdC5uYW1lK1wiICAgIFxcbiAgICBcIn1mdW5jdGlvbiB1KHQpe3JldHVybiByLm1hcCh0LGZ1bmN0aW9uKHQpe3JldHVybiBjKHQsMSl9KS5qb2luKFwiXFxuXCIpfWZ1bmN0aW9uIGModCxlKXt2YXIgbj15KGUsJyQuUlVMRShcIicrdC5uYW1lKydcIiwgZnVuY3Rpb24oKSB7JykrYTtyZXR1cm4gbis9bSh0LmRlZmluaXRpb24sZSsxKSxuKz15KGUrMSxcIn0pXCIpK2F9ZnVuY3Rpb24gcCh0LGUpe3ZhciBuPWkudG9rZW5OYW1lKHQudGVybWluYWxUeXBlKTtyZXR1cm4geShlLFwiJC5DT05TVU1FXCIrdC5pZHgrXCIodGhpcy50b2tlbnNNYXAuXCIrbitcIilcIithKX1mdW5jdGlvbiBsKHQsZSl7cmV0dXJuIHkoZSxcIiQuU1VCUlVMRVwiK3QuaWR4K1wiKCQuXCIrdC5ub25UZXJtaW5hbE5hbWUrXCIpXCIrYSl9ZnVuY3Rpb24gaCh0LGUpe3ZhciBuPXkoZSxcIiQuT1JcIit0LmlkeCtcIihbXCIpK2E7cmV0dXJuIG4rPXIubWFwKHQuZGVmaW5pdGlvbixmdW5jdGlvbih0KXtyZXR1cm4gZih0LGUrMSl9KS5qb2luKFwiLFwiK2EpLG4rPWEreShlLFwiXSlcIithKX1mdW5jdGlvbiBmKHQsZSl7dmFyIG49eShlLFwie1wiKSthO3JldHVybiB0Lm5hbWUmJihuKz15KGUrMSwnTkFNRTogXCInK3QubmFtZSsnXCIsJykrYSksbis9eShlKzEsXCJBTFQ6IGZ1bmN0aW9uKCkge1wiKSthLG4rPW0odC5kZWZpbml0aW9uLGUrMSksbis9eShlKzEsXCJ9XCIpK2Esbis9eShlLFwifVwiKX1mdW5jdGlvbiBkKHQsZSxuKXt2YXIgcj15KG4sXCIkLlwiKyh0K2UuaWR4KStcIihcIik7cmV0dXJuIGUubmFtZXx8ZS5zZXBhcmF0b3I/KHIrPVwie1wiK2EsZS5uYW1lJiYocis9eShuKzEsJ05BTUU6IFwiJytlLm5hbWUrJ1wiJykrXCIsXCIrYSksZS5zZXBhcmF0b3ImJihyKz15KG4rMSxcIlNFUDogdGhpcy50b2tlbnNNYXAuXCIraS50b2tlbk5hbWUoZS5zZXBhcmF0b3IpKStcIixcIithKSxyKz1cIkRFRjogXCIrRShlLmRlZmluaXRpb24sbisyKSthLHIrPXkobixcIn1cIikrYSk6cis9RShlLmRlZmluaXRpb24sbisxKSxyKz15KG4sXCIpXCIpK2F9ZnVuY3Rpb24gRSh0LGUpe3ZhciBuPVwiZnVuY3Rpb24oKSB7XCIrYTtyZXR1cm4gbis9bSh0LGUpLG4rPXkoZSxcIn1cIikrYX1mdW5jdGlvbiBtKHQsZSl7dmFyIG49XCJcIjtyZXR1cm4gci5mb3JFYWNoKHQsZnVuY3Rpb24odCl7bis9ZnVuY3Rpb24odCxlKXtpZih0IGluc3RhbmNlb2Ygby5Ob25UZXJtaW5hbClyZXR1cm4gbCh0LGUpO2lmKHQgaW5zdGFuY2VvZiBvLk9wdGlvbilyZXR1cm4gZChcIk9QVElPTlwiLHQsZSk7aWYodCBpbnN0YW5jZW9mIG8uUmVwZXRpdGlvbk1hbmRhdG9yeSlyZXR1cm4gZChcIkFUX0xFQVNUX09ORVwiLHQsZSk7aWYodCBpbnN0YW5jZW9mIG8uUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IpcmV0dXJuIGQoXCJBVF9MRUFTVF9PTkVfU0VQXCIsdCxlKTtpZih0IGluc3RhbmNlb2Ygby5SZXBldGl0aW9uV2l0aFNlcGFyYXRvcilyZXR1cm4gZChcIk1BTllfU0VQXCIsdCxlKTtpZih0IGluc3RhbmNlb2Ygby5SZXBldGl0aW9uKXJldHVybiBkKFwiTUFOWVwiLHQsZSk7aWYodCBpbnN0YW5jZW9mIG8uQWx0ZXJuYXRpb24pcmV0dXJuIGgodCxlKTtpZih0IGluc3RhbmNlb2Ygby5UZXJtaW5hbClyZXR1cm4gcCh0LGUpO2lmKHQgaW5zdGFuY2VvZiBvLkZsYXQpcmV0dXJuIG0odC5kZWZpbml0aW9uLGUpO3Rocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIil9KHQsZSsxKTt9KSxufWZ1bmN0aW9uIHkodCxlKXtyZXR1cm4gQXJyYXkoNCp0KzEpLmpvaW4oXCIgXCIpK2V9ZS5nZW5VbWRNb2R1bGU9ZnVuY3Rpb24odCl7cmV0dXJuIFwiXFxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XFxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcXG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cXG4gICAgICAgIGRlZmluZShbJ2NoZXZyb3RhaW4nXSwgZmFjdG9yeSk7XFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcXG4gICAgICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxcbiAgICAgICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXFxuICAgICAgICAvLyBsaWtlIE5vZGUuXFxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnY2hldnJvdGFpbicpKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXFxuICAgICAgICByb290LnJldHVybkV4cG9ydHMgPSBmYWN0b3J5KHJvb3QuYik7XFxuICAgIH1cXG59KHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbiAoY2hldnJvdGFpbikge1xcblxcblwiK3ModCkrXCJcXG4gICAgXFxucmV0dXJuIHtcXG4gICAgXCIrdC5uYW1lK1wiOiBcIit0Lm5hbWUrXCIgXFxufVxcbn0pKTtcXG5cIn0sZS5nZW5XcmFwcGVyRnVuY3Rpb249ZnVuY3Rpb24odCl7cmV0dXJuIFwiICAgIFxcblwiK3ModCkrXCJcXG5yZXR1cm4gbmV3IFwiK3QubmFtZStcIih0b2tlblZvY2FidWxhcnksIGNvbmZpZykgICAgXFxuXCJ9LGUuZ2VuQ2xhc3M9cyxlLmdlbkFsbFJ1bGVzPXUsZS5nZW5SdWxlPWMsZS5nZW5UZXJtaW5hbD1wLGUuZ2VuTm9uVGVybWluYWw9bCxlLmdlbkFsdGVybmF0aW9uPWgsZS5nZW5TaW5nbGVBbHQ9Zjt9XSl9KTtcbnZhciBjaGV2cm90YWluID0gd2luZG93LmNoZXZyb3RhaW47XG5cbnZhciBWUk1MTG9hZGVyID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0Ly8gZGVwZW5kZW5jeSBjaGVja1xuXG5cdGlmICggdHlwZW9mIGNoZXZyb3RhaW4gPT09ICd1bmRlZmluZWQnICkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblx0XHR0aHJvdyBFcnJvciggJ1RIUkVFLlZSTUxMb2FkZXI6IEV4dGVybmFsIGxpYnJhcnkgY2hldnJvdGFpbi5taW4uanMgcmVxdWlyZWQuJyApO1xuXG5cdH1cblxuXHQvLyBjbGFzcyBkZWZpbml0aW9uc1xuXG5cdGZ1bmN0aW9uIFZSTUxMb2FkZXIoIG1hbmFnZXIgKSB7XG5cblx0XHRMb2FkZXIkMS5jYWxsKCB0aGlzLCBtYW5hZ2VyICk7XG5cblx0fVxuXG5cdFZSTUxMb2FkZXIucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTG9hZGVyJDEucHJvdG90eXBlICksIHtcblxuXHRcdGNvbnN0cnVjdG9yOiBWUk1MTG9hZGVyLFxuXG5cdFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdFx0dmFyIHBhdGggPSAoIHNjb3BlLnBhdGggPT09ICcnICkgPyBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSggdXJsICkgOiBzY29wZS5wYXRoO1xuXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcblx0XHRcdGxvYWRlci5zZXRQYXRoKCBzY29wZS5wYXRoICk7XG5cdFx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggc2NvcGUucmVxdWVzdEhlYWRlciApO1xuXHRcdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggc2NvcGUud2l0aENyZWRlbnRpYWxzICk7XG5cdFx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIHRleHQsIHBhdGggKSApO1xuXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBvbkVycm9yICkge1xuXG5cdFx0XHRcdFx0XHRvbkVycm9yKCBlICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBlICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0XHR9LFxuXG5cdFx0cGFyc2U6IGZ1bmN0aW9uICggZGF0YSwgcGF0aCApIHtcblxuXHRcdFx0dmFyIG5vZGVNYXAgPSB7fTtcblxuXHRcdFx0ZnVuY3Rpb24gZ2VuZXJhdGVWUk1MVHJlZSggZGF0YSApIHtcblxuXHRcdFx0XHQvLyBjcmVhdGUgbGV4ZXIsIHBhcnNlciBhbmQgdmlzaXRvclxuXG5cdFx0XHRcdHZhciB0b2tlbkRhdGEgPSBjcmVhdGVUb2tlbnMoKTtcblxuXHRcdFx0XHR2YXIgbGV4ZXIgPSBuZXcgVlJNTExleGVyKCB0b2tlbkRhdGEudG9rZW5zICk7XG5cdFx0XHRcdHZhciBwYXJzZXIgPSBuZXcgVlJNTFBhcnNlciggdG9rZW5EYXRhLnRva2VuVm9jYWJ1bGFyeSApO1xuXHRcdFx0XHR2YXIgdmlzaXRvciA9IGNyZWF0ZVZpc2l0b3IoIHBhcnNlci5nZXRCYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yKCkgKTtcblxuXHRcdFx0XHQvLyBsZXhpbmdcblxuXHRcdFx0XHR2YXIgbGV4aW5nUmVzdWx0ID0gbGV4ZXIubGV4KCBkYXRhICk7XG5cdFx0XHRcdHBhcnNlci5pbnB1dCA9IGxleGluZ1Jlc3VsdC50b2tlbnM7XG5cblx0XHRcdFx0Ly8gcGFyc2luZ1xuXG5cdFx0XHRcdHZhciBjc3RPdXRwdXQgPSBwYXJzZXIudnJtbCgpO1xuXG5cdFx0XHRcdGlmICggcGFyc2VyLmVycm9ycy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggcGFyc2VyLmVycm9ycyApO1xuXG5cdFx0XHRcdFx0dGhyb3cgRXJyb3IoICdUSFJFRS5WUk1MTG9hZGVyOiBQYXJzaW5nIGVycm9ycyBkZXRlY3RlZC4nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGFjdGlvbnNcblxuXHRcdFx0XHR2YXIgYXN0ID0gdmlzaXRvci52aXNpdCggY3N0T3V0cHV0ICk7XG5cblx0XHRcdFx0cmV0dXJuIGFzdDtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBjcmVhdGVUb2tlbnMoKSB7XG5cblx0XHRcdFx0dmFyIGNyZWF0ZVRva2VuID0gY2hldnJvdGFpbi5jcmVhdGVUb2tlbjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cdFx0XHRcdC8vIGZyb20gaHR0cDovL2d1bi50ZWlwaXIuZ3IvVlJNTC1hbWdlbS9zcGVjL3BhcnQxL2NvbmNlcHRzLmh0bWwjU3ludGF4QmFzaWNzXG5cblx0XHRcdFx0dmFyIFJvdXRlSWRlbnRpZmllciA9IGNyZWF0ZVRva2VuKCB7IG5hbWU6ICdSb3V0ZUlkZW50aWZpZXInLCBwYXR0ZXJuOiAvW15cXHgzMC1cXHgzOVxcMC1cXHgyMFxceDIyXFx4MjdcXHgyM1xceDJiXFx4MmNcXHgyZFxceDJlXFx4NWJcXHg1ZFxceDVjXFx4N2JcXHg3ZF1bXlxcMC1cXHgyMFxceDIyXFx4MjdcXHgyM1xceDJiXFx4MmNcXHgyZFxceDJlXFx4NWJcXHg1ZFxceDVjXFx4N2JcXHg3ZF0qW1xcLl1bXlxceDMwLVxceDM5XFwwLVxceDIwXFx4MjJcXHgyN1xceDIzXFx4MmJcXHgyY1xceDJkXFx4MmVcXHg1YlxceDVkXFx4NWNcXHg3YlxceDdkXVteXFwwLVxceDIwXFx4MjJcXHgyN1xceDIzXFx4MmJcXHgyY1xceDJkXFx4MmVcXHg1YlxceDVkXFx4NWNcXHg3YlxceDdkXSovIH0gKTtcblx0XHRcdFx0dmFyIElkZW50aWZpZXIgPSBjcmVhdGVUb2tlbiggeyBuYW1lOiAnSWRlbnRpZmllcicsIHBhdHRlcm46IC9bXlxceDMwLVxceDM5XFwwLVxceDIwXFx4MjJcXHgyN1xceDIzXFx4MmJcXHgyY1xceDJkXFx4MmVcXHg1YlxceDVkXFx4NWNcXHg3YlxceDdkXVteXFwwLVxceDIwXFx4MjJcXHgyN1xceDIzXFx4MmJcXHgyY1xceDJkXFx4MmVcXHg1YlxceDVkXFx4NWNcXHg3YlxceDdkXSovLCBsb25nZXJfYWx0OiBSb3V0ZUlkZW50aWZpZXIgfSApO1xuXG5cdFx0XHRcdC8vIGZyb20gaHR0cDovL2d1bi50ZWlwaXIuZ3IvVlJNTC1hbWdlbS9zcGVjL3BhcnQxL25vZGVzUmVmLmh0bWxcblxuXHRcdFx0XHR2YXIgbm9kZVR5cGVzID0gW1xuXHRcdFx0XHRcdCdBbmNob3InLCAnQmlsbGJvYXJkJywgJ0NvbGxpc2lvbicsICdHcm91cCcsICdUcmFuc2Zvcm0nLCAvLyBncm91cGluZyBub2Rlc1xuXHRcdFx0XHRcdCdJbmxpbmUnLCAnTE9EJywgJ1N3aXRjaCcsIC8vIHNwZWNpYWwgZ3JvdXBzXG5cdFx0XHRcdFx0J0F1ZGlvQ2xpcCcsICdEaXJlY3Rpb25hbExpZ2h0JywgJ1BvaW50TGlnaHQnLCAnU2NyaXB0JywgJ1NoYXBlJywgJ1NvdW5kJywgJ1Nwb3RMaWdodCcsICdXb3JsZEluZm8nLCAvLyBjb21tb24gbm9kZXNcblx0XHRcdFx0XHQnQ3lsaW5kZXJTZW5zb3InLCAnUGxhbmVTZW5zb3InLCAnUHJveGltaXR5U2Vuc29yJywgJ1NwaGVyZVNlbnNvcicsICdUaW1lU2Vuc29yJywgJ1RvdWNoU2Vuc29yJywgJ1Zpc2liaWxpdHlTZW5zb3InLCAvLyBzZW5zb3JzXG5cdFx0XHRcdFx0J0JveCcsICdDb25lJywgJ0N5bGluZGVyJywgJ0VsZXZhdGlvbkdyaWQnLCAnRXh0cnVzaW9uJywgJ0luZGV4ZWRGYWNlU2V0JywgJ0luZGV4ZWRMaW5lU2V0JywgJ1BvaW50U2V0JywgJ1NwaGVyZScsIC8vIGdlb21ldHJpZXNcblx0XHRcdFx0XHQnQ29sb3InLCAnQ29vcmRpbmF0ZScsICdOb3JtYWwnLCAnVGV4dHVyZUNvb3JkaW5hdGUnLCAvLyBnZW9tZXRyaWMgcHJvcGVydGllc1xuXHRcdFx0XHRcdCdBcHBlYXJhbmNlJywgJ0ZvbnRTdHlsZScsICdJbWFnZVRleHR1cmUnLCAnTWF0ZXJpYWwnLCAnTW92aWVUZXh0dXJlJywgJ1BpeGVsVGV4dHVyZScsICdUZXh0dXJlVHJhbnNmb3JtJywgLy8gYXBwZWFyYW5jZVxuXHRcdFx0XHRcdCdDb2xvckludGVycG9sYXRvcicsICdDb29yZGluYXRlSW50ZXJwb2xhdG9yJywgJ05vcm1hbEludGVycG9sYXRvcicsICdPcmllbnRhdGlvbkludGVycG9sYXRvcicsICdQb3NpdGlvbkludGVycG9sYXRvcicsICdTY2FsYXJJbnRlcnBvbGF0b3InLCAvLyBpbnRlcnBvbGF0b3JzXG5cdFx0XHRcdFx0J0JhY2tncm91bmQnLCAnRm9nJywgJ05hdmlnYXRpb25JbmZvJywgJ1ZpZXdwb2ludCcsIC8vIGJpbmRhYmxlIG5vZGVzXG5cdFx0XHRcdFx0J1RleHQnIC8vIFRleHQgbXVzdCBiZSBwbGFjZWQgYXQgdGhlIGVuZCBvZiB0aGUgcmVnZXggc28gdGhlcmUgYXJlIG5vIG1hdGNoZXMgZm9yIFRleHR1cmVUcmFuc2Zvcm0gYW5kIFRleHR1cmVDb29yZGluYXRlXG5cdFx0XHRcdF07XG5cblx0XHRcdFx0Ly9cblxuXHRcdFx0XHR2YXIgVmVyc2lvbiA9IGNyZWF0ZVRva2VuKCB7XG5cdFx0XHRcdFx0bmFtZTogJ1ZlcnNpb24nLFxuXHRcdFx0XHRcdHBhdHRlcm46IC8jVlJNTC4qLyxcblx0XHRcdFx0XHRsb25nZXJfYWx0OiBJZGVudGlmaWVyXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR2YXIgTm9kZU5hbWUgPSBjcmVhdGVUb2tlbigge1xuXHRcdFx0XHRcdG5hbWU6ICdOb2RlTmFtZScsXG5cdFx0XHRcdFx0cGF0dGVybjogbmV3IFJlZ0V4cCggbm9kZVR5cGVzLmpvaW4oICd8JyApICksXG5cdFx0XHRcdFx0bG9uZ2VyX2FsdDogSWRlbnRpZmllclxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0dmFyIERFRiA9IGNyZWF0ZVRva2VuKCB7XG5cdFx0XHRcdFx0bmFtZTogJ0RFRicsXG5cdFx0XHRcdFx0cGF0dGVybjogL0RFRi8sXG5cdFx0XHRcdFx0bG9uZ2VyX2FsdDogSWRlbnRpZmllclxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0dmFyIFVTRSA9IGNyZWF0ZVRva2VuKCB7XG5cdFx0XHRcdFx0bmFtZTogJ1VTRScsXG5cdFx0XHRcdFx0cGF0dGVybjogL1VTRS8sXG5cdFx0XHRcdFx0bG9uZ2VyX2FsdDogSWRlbnRpZmllclxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0dmFyIFJPVVRFID0gY3JlYXRlVG9rZW4oIHtcblx0XHRcdFx0XHRuYW1lOiAnUk9VVEUnLFxuXHRcdFx0XHRcdHBhdHRlcm46IC9ST1VURS8sXG5cdFx0XHRcdFx0bG9uZ2VyX2FsdDogSWRlbnRpZmllclxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0dmFyIFRPID0gY3JlYXRlVG9rZW4oIHtcblx0XHRcdFx0XHRuYW1lOiAnVE8nLFxuXHRcdFx0XHRcdHBhdHRlcm46IC9UTy8sXG5cdFx0XHRcdFx0bG9uZ2VyX2FsdDogSWRlbnRpZmllclxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly9cblxuXHRcdFx0XHR2YXIgU3RyaW5nTGl0ZXJhbCA9IGNyZWF0ZVRva2VuKCB7IG5hbWU6ICdTdHJpbmdMaXRlcmFsJywgcGF0dGVybjogL1wiKDo/W15cXFxcXCJcXG5cXHJdK3xcXFxcKDo/W2JmbnJ0dlwiXFxcXC9dfHVbMC05YS1mQS1GXXs0fSkpKlwiLyB9ICk7XG5cdFx0XHRcdHZhciBIZXhMaXRlcmFsID0gY3JlYXRlVG9rZW4oIHsgbmFtZTogJ0hleExpdGVyYWwnLCBwYXR0ZXJuOiAvMFt4WF1bMC05YS1mQS1GXSsvIH0gKTtcblx0XHRcdFx0dmFyIE51bWJlckxpdGVyYWwgPSBjcmVhdGVUb2tlbiggeyBuYW1lOiAnTnVtYmVyTGl0ZXJhbCcsIHBhdHRlcm46IC9bLStdP1swLTldKlxcLj9bMC05XSsoW2VFXVstK10/WzAtOV0rKT8vIH0gKTtcblx0XHRcdFx0dmFyIFRydWVMaXRlcmFsID0gY3JlYXRlVG9rZW4oIHsgbmFtZTogJ1RydWVMaXRlcmFsJywgcGF0dGVybjogL1RSVUUvIH0gKTtcblx0XHRcdFx0dmFyIEZhbHNlTGl0ZXJhbCA9IGNyZWF0ZVRva2VuKCB7IG5hbWU6ICdGYWxzZUxpdGVyYWwnLCBwYXR0ZXJuOiAvRkFMU0UvIH0gKTtcblx0XHRcdFx0dmFyIE51bGxMaXRlcmFsID0gY3JlYXRlVG9rZW4oIHsgbmFtZTogJ051bGxMaXRlcmFsJywgcGF0dGVybjogL05VTEwvIH0gKTtcblx0XHRcdFx0dmFyIExTcXVhcmUgPSBjcmVhdGVUb2tlbiggeyBuYW1lOiAnTFNxdWFyZScsIHBhdHRlcm46IC9cXFsvIH0gKTtcblx0XHRcdFx0dmFyIFJTcXVhcmUgPSBjcmVhdGVUb2tlbiggeyBuYW1lOiAnUlNxdWFyZScsIHBhdHRlcm46IC9dLyB9ICk7XG5cdFx0XHRcdHZhciBMQ3VybHkgPSBjcmVhdGVUb2tlbiggeyBuYW1lOiAnTEN1cmx5JywgcGF0dGVybjogL3svIH0gKTtcblx0XHRcdFx0dmFyIFJDdXJseSA9IGNyZWF0ZVRva2VuKCB7IG5hbWU6ICdSQ3VybHknLCBwYXR0ZXJuOiAvfS8gfSApO1xuXHRcdFx0XHR2YXIgQ29tbWVudCA9IGNyZWF0ZVRva2VuKCB7XG5cdFx0XHRcdFx0bmFtZTogJ0NvbW1lbnQnLFxuXHRcdFx0XHRcdHBhdHRlcm46IC8jLiovLFxuXHRcdFx0XHRcdGdyb3VwOiBjaGV2cm90YWluLkxleGVyLlNLSVBQRUQgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gY29tbWFzLCBibGFua3MsIHRhYnMsIG5ld2xpbmVzIGFuZCBjYXJyaWFnZSByZXR1cm5zIGFyZSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgd2hlcmV2ZXIgdGhleSBhcHBlYXIgb3V0c2lkZSBvZiBzdHJpbmcgZmllbGRzXG5cblx0XHRcdFx0dmFyIFdoaXRlU3BhY2UgPSBjcmVhdGVUb2tlbigge1xuXHRcdFx0XHRcdG5hbWU6ICdXaGl0ZVNwYWNlJyxcblx0XHRcdFx0XHRwYXR0ZXJuOiAvWyAsXFxzXS8sXG5cdFx0XHRcdFx0Z3JvdXA6IGNoZXZyb3RhaW4uTGV4ZXIuU0tJUFBFRCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR2YXIgdG9rZW5zID0gW1xuXHRcdFx0XHRcdFdoaXRlU3BhY2UsXG5cdFx0XHRcdFx0Ly8ga2V5d29yZHMgYXBwZWFyIGJlZm9yZSB0aGUgSWRlbnRpZmllclxuXHRcdFx0XHRcdE5vZGVOYW1lLFxuXHRcdFx0XHRcdERFRixcblx0XHRcdFx0XHRVU0UsXG5cdFx0XHRcdFx0Uk9VVEUsXG5cdFx0XHRcdFx0VE8sXG5cdFx0XHRcdFx0VHJ1ZUxpdGVyYWwsXG5cdFx0XHRcdFx0RmFsc2VMaXRlcmFsLFxuXHRcdFx0XHRcdE51bGxMaXRlcmFsLFxuXHRcdFx0XHRcdC8vIHRoZSBJZGVudGlmaWVyIG11c3QgYXBwZWFyIGFmdGVyIHRoZSBrZXl3b3JkcyBiZWNhdXNlIGFsbCBrZXl3b3JkcyBhcmUgdmFsaWQgaWRlbnRpZmllcnNcblx0XHRcdFx0XHRWZXJzaW9uLFxuXHRcdFx0XHRcdElkZW50aWZpZXIsXG5cdFx0XHRcdFx0Um91dGVJZGVudGlmaWVyLFxuXHRcdFx0XHRcdFN0cmluZ0xpdGVyYWwsXG5cdFx0XHRcdFx0SGV4TGl0ZXJhbCxcblx0XHRcdFx0XHROdW1iZXJMaXRlcmFsLFxuXHRcdFx0XHRcdExTcXVhcmUsXG5cdFx0XHRcdFx0UlNxdWFyZSxcblx0XHRcdFx0XHRMQ3VybHksXG5cdFx0XHRcdFx0UkN1cmx5LFxuXHRcdFx0XHRcdENvbW1lbnRcblx0XHRcdFx0XTtcblxuXHRcdFx0XHR2YXIgdG9rZW5Wb2NhYnVsYXJ5ID0ge307XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgdG9rZW4gPSB0b2tlbnNbIGkgXTtcblxuXHRcdFx0XHRcdHRva2VuVm9jYWJ1bGFyeVsgdG9rZW4ubmFtZSBdID0gdG9rZW47XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB7IHRva2VuczogdG9rZW5zLCB0b2tlblZvY2FidWxhcnk6IHRva2VuVm9jYWJ1bGFyeSB9O1xuXG5cdFx0XHR9XG5cblxuXHRcdFx0ZnVuY3Rpb24gY3JlYXRlVmlzaXRvciggQmFzZVZSTUxWaXNpdG9yICkge1xuXG5cdFx0XHRcdC8vIHRoZSB2aXNpdG9yIGlzIGNyZWF0ZWQgZHlubWFpY2FsbHkgYmFzZWQgb24gdGhlIGdpdmVuIGJhc2UgY2xhc3NcblxuXHRcdFx0XHRmdW5jdGlvbiBWUk1MVG9BU1RWaXNpdG9yKCkge1xuXG5cdFx0XHRcdFx0QmFzZVZSTUxWaXNpdG9yLmNhbGwoIHRoaXMgKTtcblxuXHRcdFx0XHRcdHRoaXMudmFsaWRhdGVWaXNpdG9yKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdFZSTUxUb0FTVFZpc2l0b3IucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggQmFzZVZSTUxWaXNpdG9yLnByb3RvdHlwZSApLCB7XG5cblx0XHRcdFx0XHRjb25zdHJ1Y3RvcjogVlJNTFRvQVNUVmlzaXRvcixcblxuXHRcdFx0XHRcdHZybWw6IGZ1bmN0aW9uICggY3R4ICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0XHRcdFx0dmVyc2lvbjogdGhpcy52aXNpdCggY3R4LnZlcnNpb24gKSxcblx0XHRcdFx0XHRcdFx0bm9kZXM6IFtdLFxuXHRcdFx0XHRcdFx0XHRyb3V0ZXM6IFtdXG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjdHgubm9kZS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBub2RlID0gY3R4Lm5vZGVbIGkgXTtcblxuXHRcdFx0XHRcdFx0XHRkYXRhLm5vZGVzLnB1c2goIHRoaXMudmlzaXQoIG5vZGUgKSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICggY3R4LnJvdXRlICkge1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGN0eC5yb3V0ZS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJvdXRlID0gY3R4LnJvdXRlWyBpIF07XG5cblx0XHRcdFx0XHRcdFx0XHRkYXRhLnJvdXRlcy5wdXNoKCB0aGlzLnZpc2l0KCByb3V0ZSApICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdHZlcnNpb246IGZ1bmN0aW9uICggY3R4ICkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gY3R4LlZlcnNpb25bIDAgXS5pbWFnZTtcblxuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRub2RlOiBmdW5jdGlvbiAoIGN0eCApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdFx0XHRcdG5hbWU6IGN0eC5Ob2RlTmFtZVsgMCBdLmltYWdlLFxuXHRcdFx0XHRcdFx0XHRmaWVsZHM6IFtdXG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRpZiAoIGN0eC5maWVsZCApIHtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjdHguZmllbGQubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHZhciBmaWVsZCA9IGN0eC5maWVsZFsgaSBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5maWVsZHMucHVzaCggdGhpcy52aXNpdCggZmllbGQgKSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBERUZcblxuXHRcdFx0XHRcdFx0aWYgKCBjdHguZGVmICkge1xuXG5cdFx0XHRcdFx0XHRcdGRhdGEuREVGID0gdGhpcy52aXNpdCggY3R4LmRlZlsgMCBdICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0ZmllbGQ6IGZ1bmN0aW9uICggY3R4ICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0XHRcdFx0bmFtZTogY3R4LklkZW50aWZpZXJbIDAgXS5pbWFnZSxcblx0XHRcdFx0XHRcdFx0dHlwZTogbnVsbCxcblx0XHRcdFx0XHRcdFx0dmFsdWVzOiBudWxsXG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHRcdFx0XHQvLyBTRlZhbHVlXG5cblx0XHRcdFx0XHRcdGlmICggY3R4LnNpbmdsZUZpZWxkVmFsdWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0cmVzdWx0ID0gdGhpcy52aXNpdCggY3R4LnNpbmdsZUZpZWxkVmFsdWVbIDAgXSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE1GVmFsdWVcblxuXHRcdFx0XHRcdFx0aWYgKCBjdHgubXVsdGlGaWVsZFZhbHVlICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlc3VsdCA9IHRoaXMudmlzaXQoIGN0eC5tdWx0aUZpZWxkVmFsdWVbIDAgXSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGRhdGEudHlwZSA9IHJlc3VsdC50eXBlO1xuXHRcdFx0XHRcdFx0ZGF0YS52YWx1ZXMgPSByZXN1bHQudmFsdWVzO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRkZWY6IGZ1bmN0aW9uICggY3R4ICkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gKCBjdHguSWRlbnRpZmllciB8fCBjdHguTm9kZU5hbWUgKVsgMCBdLmltYWdlO1xuXG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdHVzZTogZnVuY3Rpb24gKCBjdHggKSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiB7IFVTRTogKCBjdHguSWRlbnRpZmllciB8fCBjdHguTm9kZU5hbWUgKVsgMCBdLmltYWdlIH07XG5cblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0c2luZ2xlRmllbGRWYWx1ZTogZnVuY3Rpb24gKCBjdHggKSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiBwcm9jZXNzRmllbGQoIHRoaXMsIGN0eCApO1xuXG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdG11bHRpRmllbGRWYWx1ZTogZnVuY3Rpb24gKCBjdHggKSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiBwcm9jZXNzRmllbGQoIHRoaXMsIGN0eCApO1xuXG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdHJvdXRlOiBmdW5jdGlvbiAoIGN0eCApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdFx0XHRcdEZST006IGN0eC5Sb3V0ZUlkZW50aWZpZXJbIDAgXS5pbWFnZSxcblx0XHRcdFx0XHRcdFx0VE86IGN0eC5Sb3V0ZUlkZW50aWZpZXJbIDEgXS5pbWFnZVxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdGZ1bmN0aW9uIHByb2Nlc3NGaWVsZCggc2NvcGUsIGN0eCApIHtcblxuXHRcdFx0XHRcdHZhciBmaWVsZCA9IHtcblx0XHRcdFx0XHRcdHR5cGU6IG51bGwsXG5cdFx0XHRcdFx0XHR2YWx1ZXM6IFtdXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGlmICggY3R4Lm5vZGUgKSB7XG5cblx0XHRcdFx0XHRcdGZpZWxkLnR5cGUgPSAnbm9kZSc7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGN0eC5ub2RlLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIG5vZGUgPSBjdHgubm9kZVsgaSBdO1xuXG5cdFx0XHRcdFx0XHRcdGZpZWxkLnZhbHVlcy5wdXNoKCBzY29wZS52aXNpdCggbm9kZSApICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggY3R4LnVzZSApIHtcblxuXHRcdFx0XHRcdFx0ZmllbGQudHlwZSA9ICd1c2UnO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjdHgudXNlLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHVzZSA9IGN0eC51c2VbIGkgXTtcblxuXHRcdFx0XHRcdFx0XHRmaWVsZC52YWx1ZXMucHVzaCggc2NvcGUudmlzaXQoIHVzZSApICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggY3R4LlN0cmluZ0xpdGVyYWwgKSB7XG5cblx0XHRcdFx0XHRcdGZpZWxkLnR5cGUgPSAnc3RyaW5nJztcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY3R4LlN0cmluZ0xpdGVyYWwubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgc3RyaW5nTGl0ZXJhbCA9IGN0eC5TdHJpbmdMaXRlcmFsWyBpIF07XG5cblx0XHRcdFx0XHRcdFx0ZmllbGQudmFsdWVzLnB1c2goIHN0cmluZ0xpdGVyYWwuaW1hZ2UucmVwbGFjZSggLyd8XCIvZywgJycgKSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGN0eC5OdW1iZXJMaXRlcmFsICkge1xuXG5cdFx0XHRcdFx0XHRmaWVsZC50eXBlID0gJ251bWJlcic7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGN0eC5OdW1iZXJMaXRlcmFsLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIG51bWJlckxpdGVyYWwgPSBjdHguTnVtYmVyTGl0ZXJhbFsgaSBdO1xuXG5cdFx0XHRcdFx0XHRcdGZpZWxkLnZhbHVlcy5wdXNoKCBwYXJzZUZsb2F0KCBudW1iZXJMaXRlcmFsLmltYWdlICkgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBjdHguSGV4TGl0ZXJhbCApIHtcblxuXHRcdFx0XHRcdFx0ZmllbGQudHlwZSA9ICdoZXgnO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjdHguSGV4TGl0ZXJhbC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBoZXhMaXRlcmFsID0gY3R4LkhleExpdGVyYWxbIGkgXTtcblxuXHRcdFx0XHRcdFx0XHRmaWVsZC52YWx1ZXMucHVzaCggaGV4TGl0ZXJhbC5pbWFnZSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGN0eC5UcnVlTGl0ZXJhbCApIHtcblxuXHRcdFx0XHRcdFx0ZmllbGQudHlwZSA9ICdib29sZWFuJztcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY3R4LlRydWVMaXRlcmFsLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHRydWVMaXRlcmFsID0gY3R4LlRydWVMaXRlcmFsWyBpIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0cnVlTGl0ZXJhbC5pbWFnZSA9PT0gJ1RSVUUnICkgZmllbGQudmFsdWVzLnB1c2goIHRydWUgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBjdHguRmFsc2VMaXRlcmFsICkge1xuXG5cdFx0XHRcdFx0XHRmaWVsZC50eXBlID0gJ2Jvb2xlYW4nO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjdHguRmFsc2VMaXRlcmFsLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIGZhbHNlTGl0ZXJhbCA9IGN0eC5GYWxzZUxpdGVyYWxbIGkgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGZhbHNlTGl0ZXJhbC5pbWFnZSA9PT0gJ0ZBTFNFJyApIGZpZWxkLnZhbHVlcy5wdXNoKCBmYWxzZSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGN0eC5OdWxsTGl0ZXJhbCApIHtcblxuXHRcdFx0XHRcdFx0ZmllbGQudHlwZSA9ICdudWxsJztcblxuXHRcdFx0XHRcdFx0Y3R4Lk51bGxMaXRlcmFsLmZvckVhY2goIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdFx0XHRmaWVsZC52YWx1ZXMucHVzaCggbnVsbCApO1xuXG5cdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gZmllbGQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBuZXcgVlJNTFRvQVNUVmlzaXRvcigpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHBhcnNlVHJlZSggdHJlZSApIHtcblxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyggSlNPTi5zdHJpbmdpZnkoIHRyZWUsIG51bGwsIDIgKSApO1xuXG5cdFx0XHRcdHZhciBub2RlcyA9IHRyZWUubm9kZXM7XG5cdFx0XHRcdHZhciBzY2VuZSA9IG5ldyBTY2VuZSgpO1xuXG5cdFx0XHRcdC8vIGZpcnN0IGl0ZXJhdGlvbjogYnVpbGQgbm9kZW1hcCBiYXNlZCBvbiBERUYgc3RhdGVtZW50c1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgbm9kZSA9IG5vZGVzWyBpIF07XG5cblx0XHRcdFx0XHRidWlsZE5vZGVNYXAoIG5vZGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gc2Vjb25kIGl0ZXJhdGlvbjogYnVpbGQgbm9kZXNcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIG5vZGUgPSBub2Rlc1sgaSBdO1xuXHRcdFx0XHRcdHZhciBvYmplY3QgPSBnZXROb2RlKCBub2RlICk7XG5cblx0XHRcdFx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIE9iamVjdDNEICkgc2NlbmUuYWRkKCBvYmplY3QgKTtcblxuXHRcdFx0XHRcdGlmICggbm9kZS5uYW1lID09PSAnV29ybGRJbmZvJyApIHNjZW5lLnVzZXJEYXRhLndvcmxkSW5mbyA9IG9iamVjdDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHNjZW5lO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGJ1aWxkTm9kZU1hcCggbm9kZSApIHtcblxuXHRcdFx0XHRpZiAoIG5vZGUuREVGICkge1xuXG5cdFx0XHRcdFx0bm9kZU1hcFsgbm9kZS5ERUYgXSA9IG5vZGU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBmaWVsZHMgPSBub2RlLmZpZWxkcztcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXG5cdFx0XHRcdFx0aWYgKCBmaWVsZC50eXBlID09PSAnbm9kZScgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZpZWxkVmFsdWVzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdGJ1aWxkTm9kZU1hcCggZmllbGRWYWx1ZXNbIGogXSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXG5cdFx0XHRmdW5jdGlvbiBnZXROb2RlKCBub2RlICkge1xuXG5cdFx0XHRcdC8vIGhhbmRsZSBjYXNlIHdoZXJlIGEgbm9kZSByZWZlcnMgdG8gYSBkaWZmZXJlbnQgb25lXG5cblx0XHRcdFx0aWYgKCBub2RlLlVTRSApIHtcblxuXHRcdFx0XHRcdHJldHVybiByZXNvbHZlVVNFKCBub2RlLlVTRSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG5vZGUuYnVpbGQgIT09IHVuZGVmaW5lZCApIHJldHVybiBub2RlLmJ1aWxkO1xuXG5cdFx0XHRcdG5vZGUuYnVpbGQgPSBidWlsZE5vZGUoIG5vZGUgKTtcblxuXHRcdFx0XHRyZXR1cm4gbm9kZS5idWlsZDtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBub2RlIGJ1aWxkZXJcblxuXHRcdFx0ZnVuY3Rpb24gYnVpbGROb2RlKCBub2RlICkge1xuXG5cdFx0XHRcdHZhciBub2RlTmFtZSA9IG5vZGUubmFtZTtcblx0XHRcdFx0dmFyIGJ1aWxkO1xuXG5cdFx0XHRcdHN3aXRjaCAoIG5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnR3JvdXAnOlxuXHRcdFx0XHRcdGNhc2UgJ1RyYW5zZm9ybSc6XG5cdFx0XHRcdFx0Y2FzZSAnQ29sbGlzaW9uJzpcblx0XHRcdFx0XHRcdGJ1aWxkID0gYnVpbGRHcm91cGluZ05vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnQmFja2dyb3VuZCc6XG5cdFx0XHRcdFx0XHRidWlsZCA9IGJ1aWxkQmFja2dyb3VuZE5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnU2hhcGUnOlxuXHRcdFx0XHRcdFx0YnVpbGQgPSBidWlsZFNoYXBlTm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdBcHBlYXJhbmNlJzpcblx0XHRcdFx0XHRcdGJ1aWxkID0gYnVpbGRBcHBlYXJhbmNlTm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdNYXRlcmlhbCc6XG5cdFx0XHRcdFx0XHRidWlsZCA9IGJ1aWxkTWF0ZXJpYWxOb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0ltYWdlVGV4dHVyZSc6XG5cdFx0XHRcdFx0XHRidWlsZCA9IGJ1aWxkSW1hZ2VUZXh0dXJlTm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdQaXhlbFRleHR1cmUnOlxuXHRcdFx0XHRcdFx0YnVpbGQgPSBidWlsZFBpeGVsVGV4dHVyZU5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnVGV4dHVyZVRyYW5zZm9ybSc6XG5cdFx0XHRcdFx0XHRidWlsZCA9IGJ1aWxkVGV4dHVyZVRyYW5zZm9ybU5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnSW5kZXhlZEZhY2VTZXQnOlxuXHRcdFx0XHRcdFx0YnVpbGQgPSBidWlsZEluZGV4ZWRGYWNlU2V0Tm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdJbmRleGVkTGluZVNldCc6XG5cdFx0XHRcdFx0XHRidWlsZCA9IGJ1aWxkSW5kZXhlZExpbmVTZXROb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1BvaW50U2V0Jzpcblx0XHRcdFx0XHRcdGJ1aWxkID0gYnVpbGRQb2ludFNldE5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnQm94Jzpcblx0XHRcdFx0XHRcdGJ1aWxkID0gYnVpbGRCb3hOb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0NvbmUnOlxuXHRcdFx0XHRcdFx0YnVpbGQgPSBidWlsZENvbmVOb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0N5bGluZGVyJzpcblx0XHRcdFx0XHRcdGJ1aWxkID0gYnVpbGRDeWxpbmRlck5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnU3BoZXJlJzpcblx0XHRcdFx0XHRcdGJ1aWxkID0gYnVpbGRTcGhlcmVOb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0VsZXZhdGlvbkdyaWQnOlxuXHRcdFx0XHRcdFx0YnVpbGQgPSBidWlsZEVsZXZhdGlvbkdyaWROb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0V4dHJ1c2lvbic6XG5cdFx0XHRcdFx0XHRidWlsZCA9IGJ1aWxkRXh0cnVzaW9uTm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdDb2xvcic6XG5cdFx0XHRcdFx0Y2FzZSAnQ29vcmRpbmF0ZSc6XG5cdFx0XHRcdFx0Y2FzZSAnTm9ybWFsJzpcblx0XHRcdFx0XHRjYXNlICdUZXh0dXJlQ29vcmRpbmF0ZSc6XG5cdFx0XHRcdFx0XHRidWlsZCA9IGJ1aWxkR2VvbWV0cmljTm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdXb3JsZEluZm8nOlxuXHRcdFx0XHRcdFx0YnVpbGQgPSBidWlsZFdvcmxkSW5mb05vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnQW5jaG9yJzpcblx0XHRcdFx0XHRjYXNlICdCaWxsYm9hcmQnOlxuXG5cdFx0XHRcdFx0Y2FzZSAnSW5saW5lJzpcblx0XHRcdFx0XHRjYXNlICdMT0QnOlxuXHRcdFx0XHRcdGNhc2UgJ1N3aXRjaCc6XG5cblx0XHRcdFx0XHRjYXNlICdBdWRpb0NsaXAnOlxuXHRcdFx0XHRcdGNhc2UgJ0RpcmVjdGlvbmFsTGlnaHQnOlxuXHRcdFx0XHRcdGNhc2UgJ1BvaW50TGlnaHQnOlxuXHRcdFx0XHRcdGNhc2UgJ1NjcmlwdCc6XG5cdFx0XHRcdFx0Y2FzZSAnU291bmQnOlxuXHRcdFx0XHRcdGNhc2UgJ1Nwb3RMaWdodCc6XG5cblx0XHRcdFx0XHRjYXNlICdDeWxpbmRlclNlbnNvcic6XG5cdFx0XHRcdFx0Y2FzZSAnUGxhbmVTZW5zb3InOlxuXHRcdFx0XHRcdGNhc2UgJ1Byb3hpbWl0eVNlbnNvcic6XG5cdFx0XHRcdFx0Y2FzZSAnU3BoZXJlU2Vuc29yJzpcblx0XHRcdFx0XHRjYXNlICdUaW1lU2Vuc29yJzpcblx0XHRcdFx0XHRjYXNlICdUb3VjaFNlbnNvcic6XG5cdFx0XHRcdFx0Y2FzZSAnVmlzaWJpbGl0eVNlbnNvcic6XG5cblx0XHRcdFx0XHRjYXNlICdUZXh0JzpcblxuXHRcdFx0XHRcdGNhc2UgJ0ZvbnRTdHlsZSc6XG5cdFx0XHRcdFx0Y2FzZSAnTW92aWVUZXh0dXJlJzpcblxuXHRcdFx0XHRcdGNhc2UgJ0NvbG9ySW50ZXJwb2xhdG9yJzpcblx0XHRcdFx0XHRjYXNlICdDb29yZGluYXRlSW50ZXJwb2xhdG9yJzpcblx0XHRcdFx0XHRjYXNlICdOb3JtYWxJbnRlcnBvbGF0b3InOlxuXHRcdFx0XHRcdGNhc2UgJ09yaWVudGF0aW9uSW50ZXJwb2xhdG9yJzpcblx0XHRcdFx0XHRjYXNlICdQb3NpdGlvbkludGVycG9sYXRvcic6XG5cdFx0XHRcdFx0Y2FzZSAnU2NhbGFySW50ZXJwb2xhdG9yJzpcblxuXHRcdFx0XHRcdGNhc2UgJ0ZvZyc6XG5cdFx0XHRcdFx0Y2FzZSAnTmF2aWdhdGlvbkluZm8nOlxuXHRcdFx0XHRcdGNhc2UgJ1ZpZXdwb2ludCc6XG5cdFx0XHRcdFx0XHQvLyBub2RlIG5vdCBzdXBwb3J0ZWQgeWV0XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUk1MTG9hZGVyOiBVbmtub3duIG5vZGU6Jywgbm9kZU5hbWUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGJ1aWxkICE9PSB1bmRlZmluZWQgJiYgbm9kZS5ERUYgIT09IHVuZGVmaW5lZCAmJiBidWlsZC5oYXNPd25Qcm9wZXJ0eSggJ25hbWUnICkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRidWlsZC5uYW1lID0gbm9kZS5ERUY7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBidWlsZDtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBidWlsZEdyb3VwaW5nTm9kZSggbm9kZSApIHtcblxuXHRcdFx0XHR2YXIgb2JqZWN0ID0gbmV3IEdyb3VwKCk7XG5cblx0XHRcdFx0Ly9cblxuXHRcdFx0XHR2YXIgZmllbGRzID0gbm9kZS5maWVsZHM7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmllbGRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgZmllbGQgPSBmaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR2YXIgZmllbGROYW1lID0gZmllbGQubmFtZTtcblx0XHRcdFx0XHR2YXIgZmllbGRWYWx1ZXMgPSBmaWVsZC52YWx1ZXM7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2Jib3hDZW50ZXInOlxuXHRcdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdiYm94U2l6ZSc6XG5cdFx0XHRcdFx0XHRcdC8vIGZpZWxkIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2NlbnRlcic6XG5cdFx0XHRcdFx0XHRcdC8vIGZpZWxkIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2NoaWxkcmVuJzpcblx0XHRcdFx0XHRcdFx0cGFyc2VGaWVsZENoaWxkcmVuKCBmaWVsZFZhbHVlcywgb2JqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdjb2xsaWRlJzpcblx0XHRcdFx0XHRcdFx0Ly8gZmllbGQgbm90IHN1cHBvcnRlZFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAncm90YXRpb24nOlxuXHRcdFx0XHRcdFx0XHR2YXIgYXhpcyA9IG5ldyBWZWN0b3IzKCBmaWVsZFZhbHVlc1sgMCBdLCBmaWVsZFZhbHVlc1sgMSBdLCBmaWVsZFZhbHVlc1sgMiBdICk7XG5cdFx0XHRcdFx0XHRcdHZhciBhbmdsZSA9IGZpZWxkVmFsdWVzWyAzIF07XG5cdFx0XHRcdFx0XHRcdG9iamVjdC5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdzY2FsZSc6XG5cdFx0XHRcdFx0XHRcdG9iamVjdC5zY2FsZS5zZXQoIGZpZWxkVmFsdWVzWyAwIF0sIGZpZWxkVmFsdWVzWyAxIF0sIGZpZWxkVmFsdWVzWyAyIF0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3NjYWxlT3JpZW50YXRpb24nOlxuXHRcdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICd0cmFuc2xhdGlvbic6XG5cdFx0XHRcdFx0XHRcdG9iamVjdC5wb3NpdGlvbi5zZXQoIGZpZWxkVmFsdWVzWyAwIF0sIGZpZWxkVmFsdWVzWyAxIF0sIGZpZWxkVmFsdWVzWyAyIF0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3Byb3h5Jzpcblx0XHRcdFx0XHRcdFx0Ly8gZmllbGQgbm90IHN1cHBvcnRlZFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJNTExvYWRlcjogVW5rbm93biBmaWVsZDonLCBmaWVsZE5hbWUgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBvYmplY3Q7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYnVpbGRCYWNrZ3JvdW5kTm9kZSggbm9kZSApIHtcblxuXHRcdFx0XHR2YXIgZ3JvdXAgPSBuZXcgR3JvdXAoKTtcblxuXHRcdFx0XHR2YXIgZ3JvdW5kQW5nbGUsIGdyb3VuZENvbG9yO1xuXHRcdFx0XHR2YXIgc2t5QW5nbGUsIHNreUNvbG9yO1xuXG5cdFx0XHRcdHZhciBmaWVsZHMgPSBub2RlLmZpZWxkcztcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdHZhciBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRcdHZhciBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRcdHN3aXRjaCAoIGZpZWxkTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnZ3JvdW5kQW5nbGUnOlxuXHRcdFx0XHRcdFx0XHRncm91bmRBbmdsZSA9IGZpZWxkVmFsdWVzO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnZ3JvdW5kQ29sb3InOlxuXHRcdFx0XHRcdFx0XHRncm91bmRDb2xvciA9IGZpZWxkVmFsdWVzO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnYmFja1VybCc6XG5cdFx0XHRcdFx0XHRcdC8vIGZpZWxkIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2JvdHRvbVVybCc6XG5cdFx0XHRcdFx0XHRcdC8vIGZpZWxkIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2Zyb250VXJsJzpcblx0XHRcdFx0XHRcdFx0Ly8gZmllbGQgbm90IHN1cHBvcnRlZFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnbGVmdFVybCc6XG5cdFx0XHRcdFx0XHRcdC8vIGZpZWxkIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3JpZ2h0VXJsJzpcblx0XHRcdFx0XHRcdFx0Ly8gZmllbGQgbm90IHN1cHBvcnRlZFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAndG9wVXJsJzpcblx0XHRcdFx0XHRcdFx0Ly8gZmllbGQgbm90IHN1cHBvcnRlZFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnc2t5QW5nbGUnOlxuXHRcdFx0XHRcdFx0XHRza3lBbmdsZSA9IGZpZWxkVmFsdWVzO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnc2t5Q29sb3InOlxuXHRcdFx0XHRcdFx0XHRza3lDb2xvciA9IGZpZWxkVmFsdWVzO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJNTExvYWRlcjogVW5rbm93biBmaWVsZDonLCBmaWVsZE5hbWUgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciByYWRpdXMgPSAxMDAwMDtcblxuXHRcdFx0XHQvLyBza3lcblxuXHRcdFx0XHRpZiAoIHNreUNvbG9yICkge1xuXG5cdFx0XHRcdFx0dmFyIHNreUdlb21ldHJ5ID0gbmV3IFNwaGVyZUdlb21ldHJ5KCByYWRpdXMsIDMyLCAxNiApO1xuXHRcdFx0XHRcdHZhciBza3lNYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyBmb2c6IGZhbHNlLCBzaWRlOiBCYWNrU2lkZSwgZGVwdGhXcml0ZTogZmFsc2UsIGRlcHRoVGVzdDogZmFsc2UgfSApO1xuXG5cdFx0XHRcdFx0aWYgKCBza3lDb2xvci5sZW5ndGggPiAzICkge1xuXG5cdFx0XHRcdFx0XHRwYWludEZhY2VzKCBza3lHZW9tZXRyeSwgcmFkaXVzLCBza3lBbmdsZSwgdG9Db2xvckFycmF5KCBza3lDb2xvciApLCB0cnVlICk7XG5cdFx0XHRcdFx0XHRza3lNYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0cnVlO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0c2t5TWF0ZXJpYWwuY29sb3Iuc2V0UkdCKCBza3lDb2xvclsgMCBdLCBza3lDb2xvclsgMSBdLCBza3lDb2xvclsgMiBdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgc2t5ID0gbmV3IE1lc2goIHNreUdlb21ldHJ5LCBza3lNYXRlcmlhbCApO1xuXHRcdFx0XHRcdGdyb3VwLmFkZCggc2t5ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGdyb3VuZFxuXG5cdFx0XHRcdGlmICggZ3JvdW5kQ29sb3IgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGdyb3VuZENvbG9yLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBncm91bmRHZW9tZXRyeSA9IG5ldyBTcGhlcmVHZW9tZXRyeSggcmFkaXVzLCAzMiwgMTYsIDAsIDIgKiBNYXRoLlBJLCAwLjUgKiBNYXRoLlBJLCAxLjUgKiBNYXRoLlBJICk7XG5cdFx0XHRcdFx0XHR2YXIgZ3JvdW5kTWF0ZXJpYWwgPSBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoIHsgZm9nOiBmYWxzZSwgc2lkZTogQmFja1NpZGUsIHZlcnRleENvbG9yczogdHJ1ZSwgZGVwdGhXcml0ZTogZmFsc2UsIGRlcHRoVGVzdDogZmFsc2UgfSApO1xuXG5cdFx0XHRcdFx0XHRwYWludEZhY2VzKCBncm91bmRHZW9tZXRyeSwgcmFkaXVzLCBncm91bmRBbmdsZSwgdG9Db2xvckFycmF5KCBncm91bmRDb2xvciApLCBmYWxzZSApO1xuXG5cdFx0XHRcdFx0XHR2YXIgZ3JvdW5kID0gbmV3IE1lc2goIGdyb3VuZEdlb21ldHJ5LCBncm91bmRNYXRlcmlhbCApO1xuXHRcdFx0XHRcdFx0Z3JvdXAuYWRkKCBncm91bmQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmVuZGVyIGJhY2tncm91bmQgZ3JvdXAgZmlyc3RcblxuXHRcdFx0XHRncm91cC5yZW5kZXJPcmRlciA9IC0gSW5maW5pdHk7XG5cblx0XHRcdFx0cmV0dXJuIGdyb3VwO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGJ1aWxkU2hhcGVOb2RlKCBub2RlICkge1xuXG5cdFx0XHRcdHZhciBmaWVsZHMgPSBub2RlLmZpZWxkcztcblxuXHRcdFx0XHQvLyBpZiB0aGUgYXBwZWFyYW5jZSBmaWVsZCBpcyBOVUxMIG9yIHVuc3BlY2lmaWVkLCBsaWdodGluZyBpcyBvZmYgYW5kIHRoZSB1bmxpdCBvYmplY3QgY29sb3IgaXMgKDAsIDAsIDApXG5cblx0XHRcdFx0dmFyIG1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiAweDAwMDAwMCB9ICk7XG5cdFx0XHRcdHZhciBnZW9tZXRyeTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdHZhciBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRcdHZhciBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRcdHN3aXRjaCAoIGZpZWxkTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnYXBwZWFyYW5jZSc6XG5cdFx0XHRcdFx0XHRcdGlmICggZmllbGRWYWx1ZXNbIDAgXSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdG1hdGVyaWFsID0gZ2V0Tm9kZSggZmllbGRWYWx1ZXNbIDAgXSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnZ2VvbWV0cnknOlxuXHRcdFx0XHRcdFx0XHRpZiAoIGZpZWxkVmFsdWVzWyAwIF0gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRnZW9tZXRyeSA9IGdldE5vZGUoIGZpZWxkVmFsdWVzWyAwIF0gKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gZmllbGQ6JywgZmllbGROYW1lICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBidWlsZCAzRCBvYmplY3RcblxuXHRcdFx0XHR2YXIgb2JqZWN0O1xuXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbiApIHtcblxuXHRcdFx0XHRcdHZhciB0eXBlID0gZ2VvbWV0cnkuX3R5cGU7XG5cblx0XHRcdFx0XHRpZiAoIHR5cGUgPT09ICdwb2ludHMnICkgeyAvLyBwb2ludHNcblxuXHRcdFx0XHRcdFx0dmFyIHBvaW50c01hdGVyaWFsID0gbmV3IFBvaW50c01hdGVyaWFsKCB7IGNvbG9yOiAweGZmZmZmZiB9ICk7XG5cblx0XHRcdFx0XHRcdGlmICggZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdHBvaW50c01hdGVyaWFsLnZlcnRleENvbG9ycyA9IHRydWU7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlIGNvbG9yIGZpZWxkIGlzIE5VTEwgYW5kIHRoZXJlIGlzIGEgbWF0ZXJpYWwgZGVmaW5lZCBmb3IgdGhlIGFwcGVhcmFuY2UgYWZmZWN0aW5nIHRoaXMgUG9pbnRTZXQsIHRoZW4gdXNlIHRoZSBlbWlzc2l2ZUNvbG9yIG9mIHRoZSBtYXRlcmlhbCB0byBkcmF3IHRoZSBwb2ludHNcblxuXHRcdFx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLmlzTWVzaFBob25nTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRwb2ludHNNYXRlcmlhbC5jb2xvci5jb3B5KCBtYXRlcmlhbC5lbWlzc2l2ZSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgUG9pbnRzKCBnZW9tZXRyeSwgcG9pbnRzTWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09ICdsaW5lJyApIHsgLy8gbGluZXNcblxuXHRcdFx0XHRcdFx0dmFyIGxpbmVNYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmZmYgfSApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRsaW5lTWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBpZiB0aGUgY29sb3IgZmllbGQgaXMgTlVMTCBhbmQgdGhlcmUgaXMgYSBtYXRlcmlhbCBkZWZpbmVkIGZvciB0aGUgYXBwZWFyYW5jZSBhZmZlY3RpbmcgdGhpcyBJbmRleGVkTGluZVNldCwgdGhlbiB1c2UgdGhlIGVtaXNzaXZlQ29sb3Igb2YgdGhlIG1hdGVyaWFsIHRvIGRyYXcgdGhlIGxpbmVzXG5cblx0XHRcdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5pc01lc2hQaG9uZ01hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0bGluZU1hdGVyaWFsLmNvbG9yLmNvcHkoIG1hdGVyaWFsLmVtaXNzaXZlICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG9iamVjdCA9IG5ldyBMaW5lU2VnbWVudHMoIGdlb21ldHJ5LCBsaW5lTWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7IC8vIGNvbnNpZGVyIG1lc2hlc1xuXG5cdFx0XHRcdFx0XHQvLyBjaGVjayBcInNvbGlkXCIgaGludCAoaXQncyBwbGFjZWQgaW4gdGhlIGdlb21ldHJ5IGJ1dCBhZmZlY3RzIHRoZSBtYXRlcmlhbClcblxuXHRcdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5fc29saWQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbC5zaWRlID0gKCBnZW9tZXRyeS5fc29saWQgKSA/IEZyb250U2lkZSA6IERvdWJsZVNpZGU7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gY2hlY2sgZm9yIHZlcnRleCBjb2xvcnNcblxuXHRcdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBPYmplY3QzRCgpO1xuXG5cdFx0XHRcdFx0Ly8gaWYgdGhlIGdlb21ldHJ5IGZpZWxkIGlzIE5VTEwgb3Igbm8gdmVydGljZXMgYXJlIGRlZmluZWQgdGhlIG9iamVjdCBpcyBub3QgZHJhd25cblxuXHRcdFx0XHRcdG9iamVjdC52aXNpYmxlID0gZmFsc2U7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBvYmplY3Q7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYnVpbGRBcHBlYXJhbmNlTm9kZSggbm9kZSApIHtcblxuXHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgTWVzaFBob25nTWF0ZXJpYWwoKTtcblx0XHRcdFx0dmFyIHRyYW5zZm9ybURhdGE7XG5cblx0XHRcdFx0dmFyIGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGZpZWxkID0gZmllbGRzWyBpIF07XG5cdFx0XHRcdFx0dmFyIGZpZWxkTmFtZSA9IGZpZWxkLm5hbWU7XG5cdFx0XHRcdFx0dmFyIGZpZWxkVmFsdWVzID0gZmllbGQudmFsdWVzO1xuXG5cdFx0XHRcdFx0c3dpdGNoICggZmllbGROYW1lICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlICdtYXRlcmlhbCc6XG5cdFx0XHRcdFx0XHRcdGlmICggZmllbGRWYWx1ZXNbIDAgXSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHZhciBtYXRlcmlhbERhdGEgPSBnZXROb2RlKCBmaWVsZFZhbHVlc1sgMCBdICk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsRGF0YS5kaWZmdXNlQ29sb3IgKSBtYXRlcmlhbC5jb2xvci5jb3B5KCBtYXRlcmlhbERhdGEuZGlmZnVzZUNvbG9yICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBtYXRlcmlhbERhdGEuZW1pc3NpdmVDb2xvciApIG1hdGVyaWFsLmVtaXNzaXZlLmNvcHkoIG1hdGVyaWFsRGF0YS5lbWlzc2l2ZUNvbG9yICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBtYXRlcmlhbERhdGEuc2hpbmluZXNzICkgbWF0ZXJpYWwuc2hpbmluZXNzID0gbWF0ZXJpYWxEYXRhLnNoaW5pbmVzcztcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsRGF0YS5zcGVjdWxhckNvbG9yICkgbWF0ZXJpYWwuc3BlY3VsYXIuY29weSggbWF0ZXJpYWxEYXRhLnNwZWN1bGFyQ29sb3IgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsRGF0YS50cmFuc3BhcmVuY3kgKSBtYXRlcmlhbC5vcGFjaXR5ID0gMSAtIG1hdGVyaWFsRGF0YS50cmFuc3BhcmVuY3k7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBtYXRlcmlhbERhdGEudHJhbnNwYXJlbmN5ID4gMCApIG1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlIG1hdGVyaWFsIGZpZWxkIGlzIE5VTEwgb3IgdW5zcGVjaWZpZWQsIGxpZ2h0aW5nIGlzIG9mZiBhbmQgdGhlIHVubGl0IG9iamVjdCBjb2xvciBpcyAoMCwgMCwgMClcblxuXHRcdFx0XHRcdFx0XHRcdG1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiAweDAwMDAwMCB9ICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICd0ZXh0dXJlJzpcblx0XHRcdFx0XHRcdFx0dmFyIHRleHR1cmVOb2RlID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0aWYgKCB0ZXh0dXJlTm9kZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggdGV4dHVyZU5vZGUubmFtZSA9PT0gJ0ltYWdlVGV4dHVyZScgfHwgdGV4dHVyZU5vZGUubmFtZSA9PT0gJ1BpeGVsVGV4dHVyZScgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdG1hdGVyaWFsLm1hcCA9IGdldE5vZGUoIHRleHR1cmVOb2RlICk7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICd0ZXh0dXJlVHJhbnNmb3JtJzpcblx0XHRcdFx0XHRcdFx0aWYgKCBmaWVsZFZhbHVlc1sgMCBdICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtRGF0YSA9IGdldE5vZGUoIGZpZWxkVmFsdWVzWyAwIF0gKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gZmllbGQ6JywgZmllbGROYW1lICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBvbmx5IGFwcGx5IHRleHR1cmUgdHJhbnNmb3JtIGRhdGEgaWYgYSB0ZXh0dXJlIHdhcyBkZWZpbmVkXG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAgKSB7XG5cblx0XHRcdFx0XHQvLyByZXNwZWN0IFZSTUwgbGlnaHRpbmcgbW9kZWxcblxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwubWFwLl9fdHlwZSApIHtcblxuXHRcdFx0XHRcdFx0c3dpdGNoICggbWF0ZXJpYWwubWFwLl9fdHlwZSApIHtcblxuXHRcdFx0XHRcdFx0XHRjYXNlIFRFWFRVUkVfVFlQRS5JTlRFTlNJVFlfQUxQSEE6XG5cdFx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwub3BhY2l0eSA9IDE7IC8vIGlnbm9yZSB0cmFuc3BhcmVuY3lcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlIFRFWFRVUkVfVFlQRS5SR0I6XG5cdFx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwuY29sb3Iuc2V0KCAweGZmZmZmZiApOyAvLyBpZ25vcmUgbWF0ZXJpYWwgY29sb3Jcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlIFRFWFRVUkVfVFlQRS5SR0JBOlxuXHRcdFx0XHRcdFx0XHRcdG1hdGVyaWFsLmNvbG9yLnNldCggMHhmZmZmZmYgKTsgLy8gaWdub3JlIG1hdGVyaWFsIGNvbG9yXG5cdFx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwub3BhY2l0eSA9IDE7IC8vIGlnbm9yZSB0cmFuc3BhcmVuY3lcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRkZWxldGUgbWF0ZXJpYWwubWFwLl9fdHlwZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGFwcGx5IHRleHR1cmUgdHJhbnNmb3JtXG5cblx0XHRcdFx0XHRpZiAoIHRyYW5zZm9ybURhdGEgKSB7XG5cblx0XHRcdFx0XHRcdG1hdGVyaWFsLm1hcC5jZW50ZXIuY29weSggdHJhbnNmb3JtRGF0YS5jZW50ZXIgKTtcblx0XHRcdFx0XHRcdG1hdGVyaWFsLm1hcC5yb3RhdGlvbiA9IHRyYW5zZm9ybURhdGEucm90YXRpb247XG5cdFx0XHRcdFx0XHRtYXRlcmlhbC5tYXAucmVwZWF0LmNvcHkoIHRyYW5zZm9ybURhdGEuc2NhbGUgKTtcblx0XHRcdFx0XHRcdG1hdGVyaWFsLm1hcC5vZmZzZXQuY29weSggdHJhbnNmb3JtRGF0YS50cmFuc2xhdGlvbiApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWF0ZXJpYWw7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYnVpbGRNYXRlcmlhbE5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdFx0dmFyIG1hdGVyaWFsRGF0YSA9IHt9O1xuXG5cdFx0XHRcdHZhciBmaWVsZHMgPSBub2RlLmZpZWxkcztcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdHZhciBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRcdHZhciBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRcdHN3aXRjaCAoIGZpZWxkTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnYW1iaWVudEludGVuc2l0eSc6XG5cdFx0XHRcdFx0XHRcdC8vIGZpZWxkIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2RpZmZ1c2VDb2xvcic6XG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsRGF0YS5kaWZmdXNlQ29sb3IgPSBuZXcgQ29sb3IoIGZpZWxkVmFsdWVzWyAwIF0sIGZpZWxkVmFsdWVzWyAxIF0sIGZpZWxkVmFsdWVzWyAyIF0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2VtaXNzaXZlQ29sb3InOlxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbERhdGEuZW1pc3NpdmVDb2xvciA9IG5ldyBDb2xvciggZmllbGRWYWx1ZXNbIDAgXSwgZmllbGRWYWx1ZXNbIDEgXSwgZmllbGRWYWx1ZXNbIDIgXSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnc2hpbmluZXNzJzpcblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWxEYXRhLnNoaW5pbmVzcyA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdzcGVjdWxhckNvbG9yJzpcblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWxEYXRhLmVtaXNzaXZlQ29sb3IgPSBuZXcgQ29sb3IoIGZpZWxkVmFsdWVzWyAwIF0sIGZpZWxkVmFsdWVzWyAxIF0sIGZpZWxkVmFsdWVzWyAyIF0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3RyYW5zcGFyZW5jeSc6XG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsRGF0YS50cmFuc3BhcmVuY3kgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJNTExvYWRlcjogVW5rbm93biBmaWVsZDonLCBmaWVsZE5hbWUgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXRlcmlhbERhdGE7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gcGFyc2VIZXhDb2xvciggaGV4LCB0ZXh0dXJlVHlwZSwgY29sb3IgKSB7XG5cblx0XHRcdFx0c3dpdGNoICggdGV4dHVyZVR5cGUgKSB7XG5cblx0XHRcdFx0XHRjYXNlIFRFWFRVUkVfVFlQRS5JTlRFTlNJVFk6XG5cdFx0XHRcdFx0XHQvLyBJbnRlbnNpdHkgdGV4dHVyZTogQSBvbmUtY29tcG9uZW50IGltYWdlIHNwZWNpZmllcyBvbmUtYnl0ZSBoZXhhZGVjaW1hbCBvciBpbnRlZ2VyIHZhbHVlcyByZXByZXNlbnRpbmcgdGhlIGludGVuc2l0eSBvZiB0aGUgaW1hZ2Vcblx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9IHBhcnNlSW50KCBoZXggKTtcblx0XHRcdFx0XHRcdGNvbG9yLnIgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdGNvbG9yLmcgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdGNvbG9yLmIgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBURVhUVVJFX1RZUEUuSU5URU5TSVRZX0FMUEhBOlxuXHRcdFx0XHRcdFx0Ly8gSW50ZW5zaXR5K0FscGhhIHRleHR1cmU6IEEgdHdvLWNvbXBvbmVudCBpbWFnZSBzcGVjaWZpZXMgdGhlIGludGVuc2l0eSBpbiB0aGUgZmlyc3QgKGhpZ2gpIGJ5dGUgYW5kIHRoZSBhbHBoYSBvcGFjaXR5IGluIHRoZSBzZWNvbmQgKGxvdykgYnl0ZS5cblx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9IHBhcnNlSW50KCAnMHgnICsgaGV4LnN1YnN0cmluZyggMiwgNCApICk7XG5cdFx0XHRcdFx0XHRjb2xvci5yID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRjb2xvci5nID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRjb2xvci5iID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRjb2xvci5hID0gcGFyc2VJbnQoICcweCcgKyBoZXguc3Vic3RyaW5nKCA0LCA2ICkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBURVhUVVJFX1RZUEUuUkdCOlxuXHRcdFx0XHRcdFx0Ly8gUkdCIHRleHR1cmU6IFBpeGVscyBpbiBhIHRocmVlLWNvbXBvbmVudCBpbWFnZSBzcGVjaWZ5IHRoZSByZWQgY29tcG9uZW50IGluIHRoZSBmaXJzdCAoaGlnaCkgYnl0ZSwgZm9sbG93ZWQgYnkgdGhlIGdyZWVuIGFuZCBibHVlIGNvbXBvbmVudHNcblx0XHRcdFx0XHRcdGNvbG9yLnIgPSBwYXJzZUludCggJzB4JyArIGhleC5zdWJzdHJpbmcoIDIsIDQgKSApO1xuXHRcdFx0XHRcdFx0Y29sb3IuZyA9IHBhcnNlSW50KCAnMHgnICsgaGV4LnN1YnN0cmluZyggNCwgNiApICk7XG5cdFx0XHRcdFx0XHRjb2xvci5iID0gcGFyc2VJbnQoICcweCcgKyBoZXguc3Vic3RyaW5nKCA2LCA4ICkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBURVhUVVJFX1RZUEUuUkdCQTpcblx0XHRcdFx0XHRcdC8vIFJHQkEgdGV4dHVyZTogRm91ci1jb21wb25lbnQgaW1hZ2VzIHNwZWNpZnkgdGhlIGFscGhhIG9wYWNpdHkgYnl0ZSBhZnRlciByZWQvZ3JlZW4vYmx1ZVxuXHRcdFx0XHRcdFx0Y29sb3IuciA9IHBhcnNlSW50KCAnMHgnICsgaGV4LnN1YnN0cmluZyggMiwgNCApICk7XG5cdFx0XHRcdFx0XHRjb2xvci5nID0gcGFyc2VJbnQoICcweCcgKyBoZXguc3Vic3RyaW5nKCA0LCA2ICkgKTtcblx0XHRcdFx0XHRcdGNvbG9yLmIgPSBwYXJzZUludCggJzB4JyArIGhleC5zdWJzdHJpbmcoIDYsIDggKSApO1xuXHRcdFx0XHRcdFx0Y29sb3IuYSA9IHBhcnNlSW50KCAnMHgnICsgaGV4LnN1YnN0cmluZyggOCwgMTAgKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGdldFRleHR1cmVUeXBlKCBudW1fY29tcG9uZW50cyApIHtcblxuXHRcdFx0XHR2YXIgdHlwZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBudW1fY29tcG9uZW50cyApIHtcblxuXHRcdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0XHRcdHR5cGUgPSBURVhUVVJFX1RZUEUuSU5URU5TSVRZO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdFx0XHR0eXBlID0gVEVYVFVSRV9UWVBFLklOVEVOU0lUWV9BTFBIQTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAzOlxuXHRcdFx0XHRcdFx0dHlwZSA9IFRFWFRVUkVfVFlQRS5SR0I7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgNDpcblx0XHRcdFx0XHRcdHR5cGUgPSBURVhUVVJFX1RZUEUuUkdCQTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdHlwZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBidWlsZFBpeGVsVGV4dHVyZU5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdFx0dmFyIHRleHR1cmU7XG5cdFx0XHRcdHZhciB3cmFwUyA9IFJlcGVhdFdyYXBwaW5nO1xuXHRcdFx0XHR2YXIgd3JhcFQgPSBSZXBlYXRXcmFwcGluZztcblxuXHRcdFx0XHR2YXIgZmllbGRzID0gbm9kZS5maWVsZHM7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmllbGRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgZmllbGQgPSBmaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR2YXIgZmllbGROYW1lID0gZmllbGQubmFtZTtcblx0XHRcdFx0XHR2YXIgZmllbGRWYWx1ZXMgPSBmaWVsZC52YWx1ZXM7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2ltYWdlJzpcblx0XHRcdFx0XHRcdFx0dmFyIHdpZHRoID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0dmFyIGhlaWdodCA9IGZpZWxkVmFsdWVzWyAxIF07XG5cdFx0XHRcdFx0XHRcdHZhciBudW1fY29tcG9uZW50cyA9IGZpZWxkVmFsdWVzWyAyIF07XG5cblx0XHRcdFx0XHRcdFx0dmFyIHVzZUFscGhhID0gKCBudW1fY29tcG9uZW50cyA9PT0gMiB8fCBudW1fY29tcG9uZW50cyA9PT0gNCApO1xuXHRcdFx0XHRcdFx0XHR2YXIgdGV4dHVyZVR5cGUgPSBnZXRUZXh0dXJlVHlwZSggbnVtX2NvbXBvbmVudHMgKTtcblxuXHRcdFx0XHRcdFx0XHR2YXIgc2l6ZSA9ICggKCB1c2VBbHBoYSA9PT0gdHJ1ZSApID8gNCA6IDMgKSAqICggd2lkdGggKiBoZWlnaHQgKTtcblx0XHRcdFx0XHRcdFx0dmFyIGRhdGEgPSBuZXcgVWludDhBcnJheSggc2l6ZSApO1xuXG5cdFx0XHRcdFx0XHRcdHZhciBjb2xvciA9IHsgcjogMCwgZzogMCwgYjogMCwgYTogMCB9O1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMywgayA9IDAsIGpsID0gZmllbGRWYWx1ZXMubGVuZ3RoOyBqIDwgamw7IGogKyssIGsgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRwYXJzZUhleENvbG9yKCBmaWVsZFZhbHVlc1sgaiBdLCB0ZXh0dXJlVHlwZSwgY29sb3IgKTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQWxwaGEgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHZhciBzdHJpZGUgPSBrICogNDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVsgc3RyaWRlICsgMCBdID0gY29sb3Iucjtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFbIHN0cmlkZSArIDEgXSA9IGNvbG9yLmc7XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhWyBzdHJpZGUgKyAyIF0gPSBjb2xvci5iO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVsgc3RyaWRlICsgMyBdID0gY29sb3IuYTtcblxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHZhciBzdHJpZGUgPSBrICogMztcblxuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVsgc3RyaWRlICsgMCBdID0gY29sb3Iucjtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFbIHN0cmlkZSArIDEgXSA9IGNvbG9yLmc7XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhWyBzdHJpZGUgKyAyIF0gPSBjb2xvci5iO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR0ZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlKCBkYXRhLCB3aWR0aCwgaGVpZ2h0LCAoIHVzZUFscGhhID09PSB0cnVlICkgPyBSR0JBRm9ybWF0IDogUkdCRm9ybWF0ICk7XG5cdFx0XHRcdFx0XHRcdHRleHR1cmUuX190eXBlID0gdGV4dHVyZVR5cGU7IC8vIG5lZWRlZCBmb3IgbWF0ZXJpYWwgbW9kaWZpY2F0aW9uc1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAncmVwZWF0Uyc6XG5cdFx0XHRcdFx0XHRcdGlmICggZmllbGRWYWx1ZXNbIDAgXSA9PT0gZmFsc2UgKSB3cmFwUyA9IENsYW1wVG9FZGdlV3JhcHBpbmc7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdyZXBlYXRUJzpcblx0XHRcdFx0XHRcdFx0aWYgKCBmaWVsZFZhbHVlc1sgMCBdID09PSBmYWxzZSApIHdyYXBUID0gQ2xhbXBUb0VkZ2VXcmFwcGluZztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gZmllbGQ6JywgZmllbGROYW1lICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHRleHR1cmUgKSB7XG5cblx0XHRcdFx0XHR0ZXh0dXJlLndyYXBTID0gd3JhcFM7XG5cdFx0XHRcdFx0dGV4dHVyZS53cmFwVCA9IHdyYXBUO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBidWlsZEltYWdlVGV4dHVyZU5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdFx0dmFyIHRleHR1cmU7XG5cdFx0XHRcdHZhciB3cmFwUyA9IFJlcGVhdFdyYXBwaW5nO1xuXHRcdFx0XHR2YXIgd3JhcFQgPSBSZXBlYXRXcmFwcGluZztcblxuXHRcdFx0XHR2YXIgZmllbGRzID0gbm9kZS5maWVsZHM7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmllbGRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgZmllbGQgPSBmaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR2YXIgZmllbGROYW1lID0gZmllbGQubmFtZTtcblx0XHRcdFx0XHR2YXIgZmllbGRWYWx1ZXMgPSBmaWVsZC52YWx1ZXM7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3VybCc6XG5cdFx0XHRcdFx0XHRcdHZhciB1cmwgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIHVybCApIHRleHR1cmUgPSB0ZXh0dXJlTG9hZGVyLmxvYWQoIHVybCApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAncmVwZWF0Uyc6XG5cdFx0XHRcdFx0XHRcdGlmICggZmllbGRWYWx1ZXNbIDAgXSA9PT0gZmFsc2UgKSB3cmFwUyA9IENsYW1wVG9FZGdlV3JhcHBpbmc7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdyZXBlYXRUJzpcblx0XHRcdFx0XHRcdFx0aWYgKCBmaWVsZFZhbHVlc1sgMCBdID09PSBmYWxzZSApIHdyYXBUID0gQ2xhbXBUb0VkZ2VXcmFwcGluZztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gZmllbGQ6JywgZmllbGROYW1lICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHRleHR1cmUgKSB7XG5cblx0XHRcdFx0XHR0ZXh0dXJlLndyYXBTID0gd3JhcFM7XG5cdFx0XHRcdFx0dGV4dHVyZS53cmFwVCA9IHdyYXBUO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBidWlsZFRleHR1cmVUcmFuc2Zvcm1Ob2RlKCBub2RlICkge1xuXG5cdFx0XHRcdHZhciB0cmFuc2Zvcm1EYXRhID0ge1xuXHRcdFx0XHRcdGNlbnRlcjogbmV3IFZlY3RvcjIoKSxcblx0XHRcdFx0XHRyb3RhdGlvbjogbmV3IFZlY3RvcjIoKSxcblx0XHRcdFx0XHRzY2FsZTogbmV3IFZlY3RvcjIoKSxcblx0XHRcdFx0XHR0cmFuc2xhdGlvbjogbmV3IFZlY3RvcjIoKVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHZhciBmaWVsZHMgPSBub2RlLmZpZWxkcztcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdHZhciBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRcdHZhciBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRcdHN3aXRjaCAoIGZpZWxkTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnY2VudGVyJzpcblx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtRGF0YS5jZW50ZXIuc2V0KCBmaWVsZFZhbHVlc1sgMCBdLCBmaWVsZFZhbHVlc1sgMSBdICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdyb3RhdGlvbic6XG5cdFx0XHRcdFx0XHRcdHRyYW5zZm9ybURhdGEucm90YXRpb24gPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnc2NhbGUnOlxuXHRcdFx0XHRcdFx0XHR0cmFuc2Zvcm1EYXRhLnNjYWxlLnNldCggZmllbGRWYWx1ZXNbIDAgXSwgZmllbGRWYWx1ZXNbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAndHJhbnNsYXRpb24nOlxuXHRcdFx0XHRcdFx0XHR0cmFuc2Zvcm1EYXRhLnRyYW5zbGF0aW9uLnNldCggZmllbGRWYWx1ZXNbIDAgXSwgZmllbGRWYWx1ZXNbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJNTExvYWRlcjogVW5rbm93biBmaWVsZDonLCBmaWVsZE5hbWUgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0cmFuc2Zvcm1EYXRhO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGJ1aWxkR2VvbWV0cmljTm9kZSggbm9kZSApIHtcblxuXHRcdFx0XHRyZXR1cm4gbm9kZS5maWVsZHNbIDAgXS52YWx1ZXM7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYnVpbGRXb3JsZEluZm9Ob2RlKCBub2RlICkge1xuXG5cdFx0XHRcdHZhciB3b3JsZEluZm8gPSB7fTtcblxuXHRcdFx0XHR2YXIgZmllbGRzID0gbm9kZS5maWVsZHM7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmllbGRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgZmllbGQgPSBmaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR2YXIgZmllbGROYW1lID0gZmllbGQubmFtZTtcblx0XHRcdFx0XHR2YXIgZmllbGRWYWx1ZXMgPSBmaWVsZC52YWx1ZXM7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3RpdGxlJzpcblx0XHRcdFx0XHRcdFx0d29ybGRJbmZvLnRpdGxlID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2luZm8nOlxuXHRcdFx0XHRcdFx0XHR3b3JsZEluZm8uaW5mbyA9IGZpZWxkVmFsdWVzO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJNTExvYWRlcjogVW5rbm93biBmaWVsZDonLCBmaWVsZE5hbWUgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB3b3JsZEluZm87XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYnVpbGRJbmRleGVkRmFjZVNldE5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdFx0dmFyIGNvbG9yLCBjb29yZCwgbm9ybWFsLCB0ZXhDb29yZDtcblx0XHRcdFx0dmFyIGNjdyA9IHRydWUsIHNvbGlkID0gdHJ1ZSwgY3JlYXNlQW5nbGUgPSAwO1xuXHRcdFx0XHR2YXIgY29sb3JJbmRleCwgY29vcmRJbmRleCwgbm9ybWFsSW5kZXgsIHRleENvb3JkSW5kZXg7XG5cdFx0XHRcdHZhciBjb2xvclBlclZlcnRleCA9IHRydWUsIG5vcm1hbFBlclZlcnRleCA9IHRydWU7XG5cblx0XHRcdFx0dmFyIGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGZpZWxkID0gZmllbGRzWyBpIF07XG5cdFx0XHRcdFx0dmFyIGZpZWxkTmFtZSA9IGZpZWxkLm5hbWU7XG5cdFx0XHRcdFx0dmFyIGZpZWxkVmFsdWVzID0gZmllbGQudmFsdWVzO1xuXG5cdFx0XHRcdFx0c3dpdGNoICggZmllbGROYW1lICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlICdjb2xvcic6XG5cdFx0XHRcdFx0XHRcdHZhciBjb2xvck5vZGUgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggY29sb3JOb2RlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Y29sb3IgPSBnZXROb2RlKCBjb2xvck5vZGUgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2Nvb3JkJzpcblx0XHRcdFx0XHRcdFx0dmFyIGNvb3JkTm9kZSA9IGZpZWxkVmFsdWVzWyAwIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBjb29yZE5vZGUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb29yZCA9IGdldE5vZGUoIGNvb3JkTm9kZSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnbm9ybWFsJzpcblx0XHRcdFx0XHRcdFx0dmFyIG5vcm1hbE5vZGUgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggbm9ybWFsTm9kZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbCA9IGdldE5vZGUoIG5vcm1hbE5vZGUgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3RleENvb3JkJzpcblx0XHRcdFx0XHRcdFx0dmFyIHRleENvb3JkTm9kZSA9IGZpZWxkVmFsdWVzWyAwIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0ZXhDb29yZE5vZGUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR0ZXhDb29yZCA9IGdldE5vZGUoIHRleENvb3JkTm9kZSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnY2N3Jzpcblx0XHRcdFx0XHRcdFx0Y2N3ID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2NvbG9ySW5kZXgnOlxuXHRcdFx0XHRcdFx0XHRjb2xvckluZGV4ID0gZmllbGRWYWx1ZXM7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdjb2xvclBlclZlcnRleCc6XG5cdFx0XHRcdFx0XHRcdGNvbG9yUGVyVmVydGV4ID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2NvbnZleCc6XG5cdFx0XHRcdFx0XHRcdC8vIGZpZWxkIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2Nvb3JkSW5kZXgnOlxuXHRcdFx0XHRcdFx0XHRjb29yZEluZGV4ID0gZmllbGRWYWx1ZXM7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdjcmVhc2VBbmdsZSc6XG5cdFx0XHRcdFx0XHRcdGNyZWFzZUFuZ2xlID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ25vcm1hbEluZGV4Jzpcblx0XHRcdFx0XHRcdFx0bm9ybWFsSW5kZXggPSBmaWVsZFZhbHVlcztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ25vcm1hbFBlclZlcnRleCc6XG5cdFx0XHRcdFx0XHRcdG5vcm1hbFBlclZlcnRleCA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdzb2xpZCc6XG5cdFx0XHRcdFx0XHRcdHNvbGlkID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3RleENvb3JkSW5kZXgnOlxuXHRcdFx0XHRcdFx0XHR0ZXhDb29yZEluZGV4ID0gZmllbGRWYWx1ZXM7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUk1MTG9hZGVyOiBVbmtub3duIGZpZWxkOicsIGZpZWxkTmFtZSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjb29yZEluZGV4ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUk1MTG9hZGVyOiBNaXNzaW5nIGNvb3JkSW5kZXguJyApO1xuXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBCdWZmZXJHZW9tZXRyeSgpOyAvLyBoYW5kbGUgVlJNTCBmaWxlcyB3aXRoIGluY29tcGxldGUgZ2VvbWV0cnkgZGVmaW5pdGlvblxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgdHJpYW5ndWxhdGVkQ29vcmRJbmRleCA9IHRyaWFuZ3VsYXRlRmFjZUluZGV4KCBjb29yZEluZGV4LCBjY3cgKTtcblxuXHRcdFx0XHR2YXIgcG9zaXRpb25BdHRyaWJ1dGU7XG5cdFx0XHRcdHZhciBjb2xvckF0dHJpYnV0ZTtcblx0XHRcdFx0dmFyIG5vcm1hbEF0dHJpYnV0ZTtcblx0XHRcdFx0dmFyIHV2QXR0cmlidXRlO1xuXG5cdFx0XHRcdGlmICggY29sb3IgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGNvbG9yUGVyVmVydGV4ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGNvbG9ySW5kZXggJiYgY29sb3JJbmRleC5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIGlmIHRoZSBjb2xvckluZGV4IGZpZWxkIGlzIG5vdCBlbXB0eSwgdGhlbiBpdCBpcyB1c2VkIHRvIGNob29zZSBjb2xvcnMgZm9yIGVhY2ggdmVydGV4IG9mIHRoZSBJbmRleGVkRmFjZVNldC5cblxuXHRcdFx0XHRcdFx0XHR2YXIgdHJpYW5ndWxhdGVkQ29sb3JJbmRleCA9IHRyaWFuZ3VsYXRlRmFjZUluZGV4KCBjb2xvckluZGV4LCBjY3cgKTtcblx0XHRcdFx0XHRcdFx0Y29sb3JBdHRyaWJ1dGUgPSBjb21wdXRlQXR0cmlidXRlRnJvbUluZGV4ZWREYXRhKCB0cmlhbmd1bGF0ZWRDb29yZEluZGV4LCB0cmlhbmd1bGF0ZWRDb2xvckluZGV4LCBjb2xvciwgMyApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIGlmIHRoZSBjb2xvckluZGV4IGZpZWxkIGlzIGVtcHR5LCB0aGVuIHRoZSBjb29yZEluZGV4IGZpZWxkIGlzIHVzZWQgdG8gY2hvb3NlIGNvbG9ycyBmcm9tIHRoZSBDb2xvciBub2RlXG5cblx0XHRcdFx0XHRcdFx0Y29sb3JBdHRyaWJ1dGUgPSB0b05vbkluZGV4ZWRBdHRyaWJ1dGUoIHRyaWFuZ3VsYXRlZENvb3JkSW5kZXgsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb2xvciwgMyApICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGlmICggY29sb3JJbmRleCAmJiBjb2xvckluZGV4Lmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlIGNvbG9ySW5kZXggZmllbGQgaXMgbm90IGVtcHR5LCB0aGVuIHRoZXkgYXJlIHVzZWQgdG8gY2hvb3NlIG9uZSBjb2xvciBmb3IgZWFjaCBmYWNlIG9mIHRoZSBJbmRleGVkRmFjZVNldFxuXG5cdFx0XHRcdFx0XHRcdHZhciBmbGF0dGVuRmFjZUNvbG9ycyA9IGZsYXR0ZW5EYXRhKCBjb2xvciwgY29sb3JJbmRleCApO1xuXHRcdFx0XHRcdFx0XHR2YXIgdHJpYW5ndWxhdGVkRmFjZUNvbG9ycyA9IHRyaWFuZ3VsYXRlRmFjZURhdGEoIGZsYXR0ZW5GYWNlQ29sb3JzLCBjb29yZEluZGV4ICk7XG5cdFx0XHRcdFx0XHRcdGNvbG9yQXR0cmlidXRlID0gY29tcHV0ZUF0dHJpYnV0ZUZyb21GYWNlRGF0YSggdHJpYW5ndWxhdGVkQ29vcmRJbmRleCwgdHJpYW5ndWxhdGVkRmFjZUNvbG9ycyApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIGlmIHRoZSBjb2xvckluZGV4IGZpZWxkIGlzIGVtcHR5LCB0aGVuIHRoZSBjb2xvciBhcmUgYXBwbGllZCB0byBlYWNoIGZhY2Ugb2YgdGhlIEluZGV4ZWRGYWNlU2V0IGluIG9yZGVyXG5cblx0XHRcdFx0XHRcdFx0dmFyIHRyaWFuZ3VsYXRlZEZhY2VDb2xvcnMgPSB0cmlhbmd1bGF0ZUZhY2VEYXRhKCBjb2xvciwgY29vcmRJbmRleCApO1xuXHRcdFx0XHRcdFx0XHRjb2xvckF0dHJpYnV0ZSA9IGNvbXB1dGVBdHRyaWJ1dGVGcm9tRmFjZURhdGEoIHRyaWFuZ3VsYXRlZENvb3JkSW5kZXgsIHRyaWFuZ3VsYXRlZEZhY2VDb2xvcnMgKTtcblxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbm9ybWFsICkge1xuXG5cdFx0XHRcdFx0aWYgKCBub3JtYWxQZXJWZXJ0ZXggPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGNvbnNpZGVyIHZlcnRleCBub3JtYWxzXG5cblx0XHRcdFx0XHRcdGlmICggbm9ybWFsSW5kZXggJiYgbm9ybWFsSW5kZXgubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBpZiB0aGUgbm9ybWFsSW5kZXggZmllbGQgaXMgbm90IGVtcHR5LCB0aGVuIGl0IGlzIHVzZWQgdG8gY2hvb3NlIG5vcm1hbHMgZm9yIGVhY2ggdmVydGV4IG9mIHRoZSBJbmRleGVkRmFjZVNldC5cblxuXHRcdFx0XHRcdFx0XHR2YXIgdHJpYW5ndWxhdGVkTm9ybWFsSW5kZXggPSB0cmlhbmd1bGF0ZUZhY2VJbmRleCggbm9ybWFsSW5kZXgsIGNjdyApO1xuXHRcdFx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUgPSBjb21wdXRlQXR0cmlidXRlRnJvbUluZGV4ZWREYXRhKCB0cmlhbmd1bGF0ZWRDb29yZEluZGV4LCB0cmlhbmd1bGF0ZWROb3JtYWxJbmRleCwgbm9ybWFsLCAzICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlIG5vcm1hbEluZGV4IGZpZWxkIGlzIGVtcHR5LCB0aGVuIHRoZSBjb29yZEluZGV4IGZpZWxkIGlzIHVzZWQgdG8gY2hvb3NlIG5vcm1hbHMgZnJvbSB0aGUgTm9ybWFsIG5vZGVcblxuXHRcdFx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUgPSB0b05vbkluZGV4ZWRBdHRyaWJ1dGUoIHRyaWFuZ3VsYXRlZENvb3JkSW5kZXgsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWwsIDMgKSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBjb25zaWRlciBmYWNlIG5vcm1hbHNcblxuXHRcdFx0XHRcdFx0aWYgKCBub3JtYWxJbmRleCAmJiBub3JtYWxJbmRleC5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIGlmIHRoZSBub3JtYWxJbmRleCBmaWVsZCBpcyBub3QgZW1wdHksIHRoZW4gdGhleSBhcmUgdXNlZCB0byBjaG9vc2Ugb25lIG5vcm1hbCBmb3IgZWFjaCBmYWNlIG9mIHRoZSBJbmRleGVkRmFjZVNldFxuXG5cdFx0XHRcdFx0XHRcdHZhciBmbGF0dGVuRmFjZU5vcm1hbHMgPSBmbGF0dGVuRGF0YSggbm9ybWFsLCBub3JtYWxJbmRleCApO1xuXHRcdFx0XHRcdFx0XHR2YXIgdHJpYW5ndWxhdGVkRmFjZU5vcm1hbHMgPSB0cmlhbmd1bGF0ZUZhY2VEYXRhKCBmbGF0dGVuRmFjZU5vcm1hbHMsIGNvb3JkSW5kZXggKTtcblx0XHRcdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlID0gY29tcHV0ZUF0dHJpYnV0ZUZyb21GYWNlRGF0YSggdHJpYW5ndWxhdGVkQ29vcmRJbmRleCwgdHJpYW5ndWxhdGVkRmFjZU5vcm1hbHMgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBpZiB0aGUgbm9ybWFsSW5kZXggZmllbGQgaXMgZW1wdHksIHRoZW4gdGhlIG5vcm1hbHMgYXJlIGFwcGxpZWQgdG8gZWFjaCBmYWNlIG9mIHRoZSBJbmRleGVkRmFjZVNldCBpbiBvcmRlclxuXG5cdFx0XHRcdFx0XHRcdHZhciB0cmlhbmd1bGF0ZWRGYWNlTm9ybWFscyA9IHRyaWFuZ3VsYXRlRmFjZURhdGEoIG5vcm1hbCwgY29vcmRJbmRleCApO1xuXHRcdFx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUgPSBjb21wdXRlQXR0cmlidXRlRnJvbUZhY2VEYXRhKCB0cmlhbmd1bGF0ZWRDb29yZEluZGV4LCB0cmlhbmd1bGF0ZWRGYWNlTm9ybWFscyApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIGlmIHRoZSBub3JtYWwgZmllbGQgaXMgTlVMTCwgdGhlbiB0aGUgbG9hZGVyIHNob3VsZCBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlIG5vcm1hbHMsIHVzaW5nIGNyZWFzZUFuZ2xlIHRvIGRldGVybWluZSBpZiBhbmQgaG93IG5vcm1hbHMgYXJlIHNtb290aGVkIGFjcm9zcyBzaGFyZWQgdmVydGljZXNcblxuXHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZSA9IGNvbXB1dGVOb3JtYWxBdHRyaWJ1dGUoIHRyaWFuZ3VsYXRlZENvb3JkSW5kZXgsIGNvb3JkLCBjcmVhc2VBbmdsZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHRleENvb3JkICkge1xuXG5cdFx0XHRcdFx0Ly8gdGV4dHVyZSBjb29yZGluYXRlcyBhcmUgYWx3YXlzIGRlZmluZWQgb24gdmVydGV4IGxldmVsXG5cblx0XHRcdFx0XHRpZiAoIHRleENvb3JkSW5kZXggJiYgdGV4Q29vcmRJbmRleC5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0XHQvLyBpZiB0aGUgdGV4Q29vcmRJbmRleCBmaWVsZCBpcyBub3QgZW1wdHksIHRoZW4gaXQgaXMgdXNlZCB0byBjaG9vc2UgdGV4dHVyZSBjb29yZGluYXRlcyBmb3IgZWFjaCB2ZXJ0ZXggb2YgdGhlIEluZGV4ZWRGYWNlU2V0LlxuXG5cdFx0XHRcdFx0XHR2YXIgdHJpYW5ndWxhdGVkVGV4Q29vcmRJbmRleCA9IHRyaWFuZ3VsYXRlRmFjZUluZGV4KCB0ZXhDb29yZEluZGV4LCBjY3cgKTtcblx0XHRcdFx0XHRcdHV2QXR0cmlidXRlID0gY29tcHV0ZUF0dHJpYnV0ZUZyb21JbmRleGVkRGF0YSggdHJpYW5ndWxhdGVkQ29vcmRJbmRleCwgdHJpYW5ndWxhdGVkVGV4Q29vcmRJbmRleCwgdGV4Q29vcmQsIDIgKTtcblxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gaWYgdGhlIHRleENvb3JkSW5kZXggZmllbGQgaXMgZW1wdHksIHRoZW4gdGhlIGNvb3JkSW5kZXggYXJyYXkgaXMgdXNlZCB0byBjaG9vc2UgdGV4dHVyZSBjb29yZGluYXRlcyBmcm9tIHRoZSBUZXh0dXJlQ29vcmRpbmF0ZSBub2RlXG5cblx0XHRcdFx0XHRcdHV2QXR0cmlidXRlID0gdG9Ob25JbmRleGVkQXR0cmlidXRlKCB0cmlhbmd1bGF0ZWRDb29yZEluZGV4LCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdGV4Q29vcmQsIDIgKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRcdFx0cG9zaXRpb25BdHRyaWJ1dGUgPSB0b05vbkluZGV4ZWRBdHRyaWJ1dGUoIHRyaWFuZ3VsYXRlZENvb3JkSW5kZXgsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb29yZCwgMyApICk7XG5cblx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbkF0dHJpYnV0ZSApO1xuXHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBub3JtYWxBdHRyaWJ1dGUgKTtcblxuXHRcdFx0XHQvLyBvcHRpb25hbCBhdHRyaWJ1dGVzXG5cblx0XHRcdFx0aWYgKCBjb2xvckF0dHJpYnV0ZSApIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ2NvbG9yJywgY29sb3JBdHRyaWJ1dGUgKTtcblx0XHRcdFx0aWYgKCB1dkF0dHJpYnV0ZSApIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3V2JywgdXZBdHRyaWJ1dGUgKTtcblxuXHRcdFx0XHQvLyBcInNvbGlkXCIgaW5mbHVlbmNlcyB0aGUgbWF0ZXJpYWwgc28gbGV0J3Mgc3RvcmUgaXQgZm9yIGxhdGVyIHVzZVxuXG5cdFx0XHRcdGdlb21ldHJ5Ll9zb2xpZCA9IHNvbGlkO1xuXHRcdFx0XHRnZW9tZXRyeS5fdHlwZSA9ICdtZXNoJztcblxuXHRcdFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYnVpbGRJbmRleGVkTGluZVNldE5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdFx0dmFyIGNvbG9yLCBjb29yZDtcblx0XHRcdFx0dmFyIGNvbG9ySW5kZXgsIGNvb3JkSW5kZXg7XG5cdFx0XHRcdHZhciBjb2xvclBlclZlcnRleCA9IHRydWU7XG5cblx0XHRcdFx0dmFyIGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGZpZWxkID0gZmllbGRzWyBpIF07XG5cdFx0XHRcdFx0dmFyIGZpZWxkTmFtZSA9IGZpZWxkLm5hbWU7XG5cdFx0XHRcdFx0dmFyIGZpZWxkVmFsdWVzID0gZmllbGQudmFsdWVzO1xuXG5cdFx0XHRcdFx0c3dpdGNoICggZmllbGROYW1lICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlICdjb2xvcic6XG5cdFx0XHRcdFx0XHRcdHZhciBjb2xvck5vZGUgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggY29sb3JOb2RlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Y29sb3IgPSBnZXROb2RlKCBjb2xvck5vZGUgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2Nvb3JkJzpcblx0XHRcdFx0XHRcdFx0dmFyIGNvb3JkTm9kZSA9IGZpZWxkVmFsdWVzWyAwIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBjb29yZE5vZGUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb29yZCA9IGdldE5vZGUoIGNvb3JkTm9kZSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnY29sb3JJbmRleCc6XG5cdFx0XHRcdFx0XHRcdGNvbG9ySW5kZXggPSBmaWVsZFZhbHVlcztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2NvbG9yUGVyVmVydGV4Jzpcblx0XHRcdFx0XHRcdFx0Y29sb3JQZXJWZXJ0ZXggPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnY29vcmRJbmRleCc6XG5cdFx0XHRcdFx0XHRcdGNvb3JkSW5kZXggPSBmaWVsZFZhbHVlcztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gZmllbGQ6JywgZmllbGROYW1lICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBidWlsZCBsaW5lc1xuXG5cdFx0XHRcdHZhciBjb2xvckF0dHJpYnV0ZTtcblxuXHRcdFx0XHR2YXIgZXhwYW5kZWRMaW5lSW5kZXggPSBleHBhbmRMaW5lSW5kZXgoIGNvb3JkSW5kZXggKTsgLy8gY3JlYXRlIGFuIGluZGV4IGZvciB0aHJlZS5qcydzIGxpbmVzZWdtZW50IHByaW1pdGl2ZVxuXG5cdFx0XHRcdGlmICggY29sb3IgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGNvbG9yUGVyVmVydGV4ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGNvbG9ySW5kZXgubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBpZiB0aGUgY29sb3JJbmRleCBmaWVsZCBpcyBub3QgZW1wdHksIHRoZW4gb25lIGNvbG9yIGlzIHVzZWQgZm9yIGVhY2ggcG9seWxpbmUgb2YgdGhlIEluZGV4ZWRMaW5lU2V0LlxuXG5cdFx0XHRcdFx0XHRcdHZhciBleHBhbmRlZENvbG9ySW5kZXggPSBleHBhbmRMaW5lSW5kZXgoIGNvbG9ySW5kZXggKTsgLy8gY29tcHV0ZSBjb2xvcnMgZm9yIGVhY2ggbGluZSBzZWdtZW50IChyZW5kZXJpbmcgcHJpbWl0dmUpXG5cdFx0XHRcdFx0XHRcdGNvbG9yQXR0cmlidXRlID0gY29tcHV0ZUF0dHJpYnV0ZUZyb21JbmRleGVkRGF0YSggZXhwYW5kZWRMaW5lSW5kZXgsIGV4cGFuZGVkQ29sb3JJbmRleCwgY29sb3IsIDMgKTsgLy8gY29tcHV0ZSBkYXRhIG9uIHZlcnRleCBsZXZlbFxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIGlmIHRoZSBjb2xvckluZGV4IGZpZWxkIGlzIGVtcHR5LCB0aGVuIHRoZSBjb2xvcnMgYXJlIGFwcGxpZWQgdG8gZWFjaCBwb2x5bGluZSBvZiB0aGUgSW5kZXhlZExpbmVTZXQgaW4gb3JkZXIuXG5cblx0XHRcdFx0XHRcdFx0Y29sb3JBdHRyaWJ1dGUgPSB0b05vbkluZGV4ZWRBdHRyaWJ1dGUoIGV4cGFuZGVkTGluZUluZGV4LCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3IsIDMgKSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGNvbG9ySW5kZXgubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBpZiB0aGUgY29sb3JJbmRleCBmaWVsZCBpcyBub3QgZW1wdHksIHRoZW4gY29sb3JzIGFyZSBhcHBsaWVkIHRvIGVhY2ggdmVydGV4IG9mIHRoZSBJbmRleGVkTGluZVNldFxuXG5cdFx0XHRcdFx0XHRcdHZhciBmbGF0dGVuTGluZUNvbG9ycyA9IGZsYXR0ZW5EYXRhKCBjb2xvciwgY29sb3JJbmRleCApOyAvLyBjb21wdXRlIGNvbG9ycyBmb3IgZWFjaCBWUk1MIHByaW1pdHZlXG5cdFx0XHRcdFx0XHRcdHZhciBleHBhbmRlZExpbmVDb2xvcnMgPSBleHBhbmRMaW5lRGF0YSggZmxhdHRlbkxpbmVDb2xvcnMsIGNvb3JkSW5kZXggKTsgLy8gY29tcHV0ZSBjb2xvcnMgZm9yIGVhY2ggbGluZSBzZWdtZW50IChyZW5kZXJpbmcgcHJpbWl0dmUpXG5cdFx0XHRcdFx0XHRcdGNvbG9yQXR0cmlidXRlID0gY29tcHV0ZUF0dHJpYnV0ZUZyb21MaW5lRGF0YSggZXhwYW5kZWRMaW5lSW5kZXgsIGV4cGFuZGVkTGluZUNvbG9ycyApOyAvLyBjb21wdXRlIGRhdGEgb24gdmVydGV4IGxldmVsXG5cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBpZiB0aGUgY29sb3JJbmRleCBmaWVsZCBpcyBlbXB0eSwgdGhlbiB0aGUgY29vcmRJbmRleCBmaWVsZCBpcyB1c2VkIHRvIGNob29zZSBjb2xvcnMgZnJvbSB0aGUgQ29sb3Igbm9kZVxuXG5cdFx0XHRcdFx0XHRcdHZhciBleHBhbmRlZExpbmVDb2xvcnMgPSBleHBhbmRMaW5lRGF0YSggY29sb3IsIGNvb3JkSW5kZXggKTsgLy8gY29tcHV0ZSBjb2xvcnMgZm9yIGVhY2ggbGluZSBzZWdtZW50IChyZW5kZXJpbmcgcHJpbWl0dmUpXG5cdFx0XHRcdFx0XHRcdGNvbG9yQXR0cmlidXRlID0gY29tcHV0ZUF0dHJpYnV0ZUZyb21MaW5lRGF0YSggZXhwYW5kZWRMaW5lSW5kZXgsIGV4cGFuZGVkTGluZUNvbG9ycyApOyAvLyBjb21wdXRlIGRhdGEgb24gdmVydGV4IGxldmVsXG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9cblxuXHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdFx0XHR2YXIgcG9zaXRpb25BdHRyaWJ1dGUgPSB0b05vbkluZGV4ZWRBdHRyaWJ1dGUoIGV4cGFuZGVkTGluZUluZGV4LCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29vcmQsIDMgKSApO1xuXHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9uQXR0cmlidXRlICk7XG5cblx0XHRcdFx0aWYgKCBjb2xvckF0dHJpYnV0ZSApIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ2NvbG9yJywgY29sb3JBdHRyaWJ1dGUgKTtcblxuXHRcdFx0XHRnZW9tZXRyeS5fdHlwZSA9ICdsaW5lJztcblxuXHRcdFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYnVpbGRQb2ludFNldE5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdFx0dmFyIGdlb21ldHJ5O1xuXHRcdFx0XHR2YXIgY29sb3IsIGNvb3JkO1xuXG5cdFx0XHRcdHZhciBmaWVsZHMgPSBub2RlLmZpZWxkcztcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdHZhciBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRcdHZhciBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRcdHN3aXRjaCAoIGZpZWxkTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnY29sb3InOlxuXHRcdFx0XHRcdFx0XHR2YXIgY29sb3JOb2RlID0gZmllbGRWYWx1ZXNbIDAgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbG9yTm9kZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGNvbG9yID0gZ2V0Tm9kZSggY29sb3JOb2RlICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdjb29yZCc6XG5cdFx0XHRcdFx0XHRcdHZhciBjb29yZE5vZGUgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggY29vcmROb2RlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Y29vcmQgPSBnZXROb2RlKCBjb29yZE5vZGUgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJNTExvYWRlcjogVW5rbm93biBmaWVsZDonLCBmaWVsZE5hbWUgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXG5cdFx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGNvb3JkLCAzICkgKTtcblx0XHRcdFx0aWYgKCBjb2xvciApIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGNvbG9yLCAzICkgKTtcblxuXHRcdFx0XHRnZW9tZXRyeS5fdHlwZSA9ICdwb2ludHMnO1xuXG5cdFx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBidWlsZEJveE5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdFx0dmFyIHNpemUgPSBuZXcgVmVjdG9yMyggMiwgMiwgMiApO1xuXG5cdFx0XHRcdHZhciBmaWVsZHMgPSBub2RlLmZpZWxkcztcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdHZhciBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRcdHZhciBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRcdHN3aXRjaCAoIGZpZWxkTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnc2l6ZSc6XG5cdFx0XHRcdFx0XHRcdHNpemUueCA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdHNpemUueSA9IGZpZWxkVmFsdWVzWyAxIF07XG5cdFx0XHRcdFx0XHRcdHNpemUueiA9IGZpZWxkVmFsdWVzWyAyIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUk1MTG9hZGVyOiBVbmtub3duIGZpZWxkOicsIGZpZWxkTmFtZSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJveEdlb21ldHJ5KCBzaXplLngsIHNpemUueSwgc2l6ZS56ICk7XG5cblx0XHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGJ1aWxkQ29uZU5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdFx0dmFyIHJhZGl1cyA9IDEsIGhlaWdodCA9IDIsIG9wZW5FbmRlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdHZhciBmaWVsZHMgPSBub2RlLmZpZWxkcztcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdHZhciBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRcdHZhciBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRcdHN3aXRjaCAoIGZpZWxkTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnYm90dG9tJzpcblx0XHRcdFx0XHRcdFx0b3BlbkVuZGVkID0gISBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnYm90dG9tUmFkaXVzJzpcblx0XHRcdFx0XHRcdFx0cmFkaXVzID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2hlaWdodCc6XG5cdFx0XHRcdFx0XHRcdGhlaWdodCA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdzaWRlJzpcblx0XHRcdFx0XHRcdFx0Ly8gZmllbGQgbm90IHN1cHBvcnRlZFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJNTExvYWRlcjogVW5rbm93biBmaWVsZDonLCBmaWVsZE5hbWUgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBnZW9tZXRyeSA9IG5ldyBDb25lR2VvbWV0cnkoIHJhZGl1cywgaGVpZ2h0LCAxNiwgMSwgb3BlbkVuZGVkICk7XG5cblx0XHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGJ1aWxkQ3lsaW5kZXJOb2RlKCBub2RlICkge1xuXG5cdFx0XHRcdHZhciByYWRpdXMgPSAxLCBoZWlnaHQgPSAyO1xuXG5cdFx0XHRcdHZhciBmaWVsZHMgPSBub2RlLmZpZWxkcztcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdHZhciBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRcdHZhciBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRcdHN3aXRjaCAoIGZpZWxkTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnYm90dG9tJzpcblx0XHRcdFx0XHRcdFx0Ly8gZmllbGQgbm90IHN1cHBvcnRlZFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAncmFkaXVzJzpcblx0XHRcdFx0XHRcdFx0cmFkaXVzID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2hlaWdodCc6XG5cdFx0XHRcdFx0XHRcdGhlaWdodCA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdzaWRlJzpcblx0XHRcdFx0XHRcdFx0Ly8gZmllbGQgbm90IHN1cHBvcnRlZFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAndG9wJzpcblx0XHRcdFx0XHRcdFx0Ly8gZmllbGQgbm90IHN1cHBvcnRlZFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJNTExvYWRlcjogVW5rbm93biBmaWVsZDonLCBmaWVsZE5hbWUgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBnZW9tZXRyeSA9IG5ldyBDeWxpbmRlckdlb21ldHJ5KCByYWRpdXMsIHJhZGl1cywgaGVpZ2h0LCAxNiwgMSApO1xuXG5cdFx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBidWlsZFNwaGVyZU5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdFx0dmFyIHJhZGl1cyA9IDE7XG5cblx0XHRcdFx0dmFyIGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGZpZWxkID0gZmllbGRzWyBpIF07XG5cdFx0XHRcdFx0dmFyIGZpZWxkTmFtZSA9IGZpZWxkLm5hbWU7XG5cdFx0XHRcdFx0dmFyIGZpZWxkVmFsdWVzID0gZmllbGQudmFsdWVzO1xuXG5cdFx0XHRcdFx0c3dpdGNoICggZmllbGROYW1lICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlICdyYWRpdXMnOlxuXHRcdFx0XHRcdFx0XHRyYWRpdXMgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJNTExvYWRlcjogVW5rbm93biBmaWVsZDonLCBmaWVsZE5hbWUgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBnZW9tZXRyeSA9IG5ldyBTcGhlcmVHZW9tZXRyeSggcmFkaXVzLCAxNiwgMTYgKTtcblxuXHRcdFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYnVpbGRFbGV2YXRpb25HcmlkTm9kZSggbm9kZSApIHtcblxuXHRcdFx0XHR2YXIgY29sb3I7XG5cdFx0XHRcdHZhciBub3JtYWw7XG5cdFx0XHRcdHZhciB0ZXhDb29yZDtcblx0XHRcdFx0dmFyIGhlaWdodDtcblxuXHRcdFx0XHR2YXIgY29sb3JQZXJWZXJ0ZXggPSB0cnVlO1xuXHRcdFx0XHR2YXIgbm9ybWFsUGVyVmVydGV4ID0gdHJ1ZTtcblx0XHRcdFx0dmFyIHNvbGlkID0gdHJ1ZTtcblx0XHRcdFx0dmFyIGNjdyA9IHRydWU7XG5cdFx0XHRcdHZhciBjcmVhc2VBbmdsZSA9IDA7XG5cdFx0XHRcdHZhciB4RGltZW5zaW9uID0gMjtcblx0XHRcdFx0dmFyIHpEaW1lbnNpb24gPSAyO1xuXHRcdFx0XHR2YXIgeFNwYWNpbmcgPSAxO1xuXHRcdFx0XHR2YXIgelNwYWNpbmcgPSAxO1xuXG5cdFx0XHRcdHZhciBmaWVsZHMgPSBub2RlLmZpZWxkcztcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdHZhciBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRcdHZhciBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRcdHN3aXRjaCAoIGZpZWxkTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnY29sb3InOlxuXHRcdFx0XHRcdFx0XHR2YXIgY29sb3JOb2RlID0gZmllbGRWYWx1ZXNbIDAgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbG9yTm9kZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGNvbG9yID0gZ2V0Tm9kZSggY29sb3JOb2RlICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdub3JtYWwnOlxuXHRcdFx0XHRcdFx0XHR2YXIgbm9ybWFsTm9kZSA9IGZpZWxkVmFsdWVzWyAwIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBub3JtYWxOb2RlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsID0gZ2V0Tm9kZSggbm9ybWFsTm9kZSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAndGV4Q29vcmQnOlxuXHRcdFx0XHRcdFx0XHR2YXIgdGV4Q29vcmROb2RlID0gZmllbGRWYWx1ZXNbIDAgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHRleENvb3JkTm9kZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHRleENvb3JkID0gZ2V0Tm9kZSggdGV4Q29vcmROb2RlICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdoZWlnaHQnOlxuXHRcdFx0XHRcdFx0XHRoZWlnaHQgPSBmaWVsZFZhbHVlcztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2Njdyc6XG5cdFx0XHRcdFx0XHRcdGNjdyA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdjb2xvclBlclZlcnRleCc6XG5cdFx0XHRcdFx0XHRcdGNvbG9yUGVyVmVydGV4ID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2NyZWFzZUFuZ2xlJzpcblx0XHRcdFx0XHRcdFx0Y3JlYXNlQW5nbGUgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnbm9ybWFsUGVyVmVydGV4Jzpcblx0XHRcdFx0XHRcdFx0bm9ybWFsUGVyVmVydGV4ID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3NvbGlkJzpcblx0XHRcdFx0XHRcdFx0c29saWQgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAneERpbWVuc2lvbic6XG5cdFx0XHRcdFx0XHRcdHhEaW1lbnNpb24gPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAneFNwYWNpbmcnOlxuXHRcdFx0XHRcdFx0XHR4U3BhY2luZyA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICd6RGltZW5zaW9uJzpcblx0XHRcdFx0XHRcdFx0ekRpbWVuc2lvbiA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICd6U3BhY2luZyc6XG5cdFx0XHRcdFx0XHRcdHpTcGFjaW5nID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gZmllbGQ6JywgZmllbGROYW1lICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB2ZXJ0ZXggZGF0YVxuXG5cdFx0XHRcdHZhciB2ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0XHR2YXIgbm9ybWFscyA9IFtdO1xuXHRcdFx0XHR2YXIgY29sb3JzID0gW107XG5cdFx0XHRcdHZhciB1dnMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB6RGltZW5zaW9uOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgeERpbWVuc2lvbjsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gY29tcHV0ZSBhIHJvdyBtYWpvciBpbmRleFxuXG5cdFx0XHRcdFx0XHR2YXIgaW5kZXggPSAoIGkgKiB4RGltZW5zaW9uICkgKyBqO1xuXG5cdFx0XHRcdFx0XHQvLyB2ZXJ0aWNlc1xuXG5cdFx0XHRcdFx0XHR2YXIgeCA9IHhTcGFjaW5nICogaTtcblx0XHRcdFx0XHRcdHZhciB5ID0gaGVpZ2h0WyBpbmRleCBdO1xuXHRcdFx0XHRcdFx0dmFyIHogPSB6U3BhY2luZyAqIGo7XG5cblx0XHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIHgsIHksIHogKTtcblxuXHRcdFx0XHRcdFx0Ly8gY29sb3JzXG5cblx0XHRcdFx0XHRcdGlmICggY29sb3IgJiYgY29sb3JQZXJWZXJ0ZXggPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHIgPSBjb2xvclsgaW5kZXggKiAzICsgMCBdO1xuXHRcdFx0XHRcdFx0XHR2YXIgZyA9IGNvbG9yWyBpbmRleCAqIDMgKyAxIF07XG5cdFx0XHRcdFx0XHRcdHZhciBiID0gY29sb3JbIGluZGV4ICogMyArIDIgXTtcblxuXHRcdFx0XHRcdFx0XHRjb2xvcnMucHVzaCggciwgZywgYiApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIG5vcm1hbHNcblxuXHRcdFx0XHRcdFx0aWYgKCBub3JtYWwgJiYgbm9ybWFsUGVyVmVydGV4ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciB4biA9IG5vcm1hbFsgaW5kZXggKiAzICsgMCBdO1xuXHRcdFx0XHRcdFx0XHR2YXIgeW4gPSBub3JtYWxbIGluZGV4ICogMyArIDEgXTtcblx0XHRcdFx0XHRcdFx0dmFyIHpuID0gbm9ybWFsWyBpbmRleCAqIDMgKyAyIF07XG5cblx0XHRcdFx0XHRcdFx0bm9ybWFscy5wdXNoKCB4biwgeW4sIHpuICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gdXZzXG5cblx0XHRcdFx0XHRcdGlmICggdGV4Q29vcmQgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHMgPSB0ZXhDb29yZFsgaW5kZXggKiAyICsgMCBdO1xuXHRcdFx0XHRcdFx0XHR2YXIgdCA9IHRleENvb3JkWyBpbmRleCAqIDIgKyAxIF07XG5cblx0XHRcdFx0XHRcdFx0dXZzLnB1c2goIHMsIHQgKTtcblxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdHV2cy5wdXNoKCBpIC8gKCB4RGltZW5zaW9uIC0gMSApLCBqIC8gKCB6RGltZW5zaW9uIC0gMSApICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaW5kaWNlc1xuXG5cdFx0XHRcdHZhciBpbmRpY2VzID0gW107XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgeERpbWVuc2lvbiAtIDE7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCB6RGltZW5zaW9uIC0gMTsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gZnJvbSBodHRwczovL3RlY2ZhLnVuaWdlLmNoL2d1aWRlcy92cm1sL3ZybWw5Ny9zcGVjL3BhcnQxL25vZGVzUmVmLmh0bWwjRWxldmF0aW9uR3JpZFxuXG5cdFx0XHRcdFx0XHR2YXIgYSA9IGkgKyBqICogeERpbWVuc2lvbjtcblx0XHRcdFx0XHRcdHZhciBiID0gaSArICggaiArIDEgKSAqIHhEaW1lbnNpb247XG5cdFx0XHRcdFx0XHR2YXIgYyA9ICggaSArIDEgKSArICggaiArIDEgKSAqIHhEaW1lbnNpb247XG5cdFx0XHRcdFx0XHR2YXIgZCA9ICggaSArIDEgKSArIGogKiB4RGltZW5zaW9uO1xuXG5cdFx0XHRcdFx0XHQvLyBmYWNlc1xuXG5cdFx0XHRcdFx0XHRpZiAoIGNjdyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGMsIGIgKTtcblx0XHRcdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBjLCBhLCBkICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBjICk7XG5cdFx0XHRcdFx0XHRcdGluZGljZXMucHVzaCggYywgZCwgYSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vXG5cblx0XHRcdFx0dmFyIHBvc2l0aW9uQXR0cmlidXRlID0gdG9Ob25JbmRleGVkQXR0cmlidXRlKCBpbmRpY2VzLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdFx0XHR2YXIgdXZBdHRyaWJ1dGUgPSB0b05vbkluZGV4ZWRBdHRyaWJ1dGUoIGluZGljZXMsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXHRcdFx0XHR2YXIgY29sb3JBdHRyaWJ1dGU7XG5cdFx0XHRcdHZhciBub3JtYWxBdHRyaWJ1dGU7XG5cblx0XHRcdFx0Ly8gY29sb3IgYXR0cmlidXRlXG5cblx0XHRcdFx0aWYgKCBjb2xvciApIHtcblxuXHRcdFx0XHRcdGlmICggY29sb3JQZXJWZXJ0ZXggPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB4RGltZW5zaW9uIC0gMTsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCB6RGltZW5zaW9uIC0gMTsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHZhciBpbmRleCA9IGkgKyBqICogKCB4RGltZW5zaW9uIC0gMSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHIgPSBjb2xvclsgaW5kZXggKiAzICsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdHZhciBnID0gY29sb3JbIGluZGV4ICogMyArIDEgXTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgYiA9IGNvbG9yWyBpbmRleCAqIDMgKyAyIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBvbmUgY29sb3IgcGVyIHF1YWRcblxuXHRcdFx0XHRcdFx0XHRcdGNvbG9ycy5wdXNoKCByLCBnLCBiICk7IGNvbG9ycy5wdXNoKCByLCBnLCBiICk7IGNvbG9ycy5wdXNoKCByLCBnLCBiICk7XG5cdFx0XHRcdFx0XHRcdFx0Y29sb3JzLnB1c2goIHIsIGcsIGIgKTsgY29sb3JzLnB1c2goIHIsIGcsIGIgKTsgY29sb3JzLnB1c2goIHIsIGcsIGIgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y29sb3JBdHRyaWJ1dGUgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRjb2xvckF0dHJpYnV0ZSA9IHRvTm9uSW5kZXhlZEF0dHJpYnV0ZSggaW5kaWNlcywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG5vcm1hbCBhdHRyaWJ1dGVcblxuXHRcdFx0XHRpZiAoIG5vcm1hbCApIHtcblxuXHRcdFx0XHRcdGlmICggbm9ybWFsUGVyVmVydGV4ID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgeERpbWVuc2lvbiAtIDE7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgekRpbWVuc2lvbiAtIDE7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR2YXIgaW5kZXggPSBpICsgaiAqICggeERpbWVuc2lvbiAtIDEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdHZhciB4biA9IG5vcm1hbFsgaW5kZXggKiAzICsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdHZhciB5biA9IG5vcm1hbFsgaW5kZXggKiAzICsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdHZhciB6biA9IG5vcm1hbFsgaW5kZXggKiAzICsgMiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gb25lIG5vcm1hbCBwZXIgcXVhZFxuXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFscy5wdXNoKCB4biwgeW4sIHpuICk7IG5vcm1hbHMucHVzaCggeG4sIHluLCB6biApOyBub3JtYWxzLnB1c2goIHhuLCB5biwgem4gKTtcblx0XHRcdFx0XHRcdFx0XHRub3JtYWxzLnB1c2goIHhuLCB5biwgem4gKTsgbm9ybWFscy5wdXNoKCB4biwgeW4sIHpuICk7IG5vcm1hbHMucHVzaCggeG4sIHluLCB6biApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlID0gdG9Ob25JbmRleGVkQXR0cmlidXRlKCBpbmRpY2VzLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZSA9IGNvbXB1dGVOb3JtYWxBdHRyaWJ1dGUoIGluZGljZXMsIHZlcnRpY2VzLCBjcmVhc2VBbmdsZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0XHRcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9uQXR0cmlidXRlICk7XG5cdFx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5vcm1hbEF0dHJpYnV0ZSApO1xuXHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICd1dicsIHV2QXR0cmlidXRlICk7XG5cblx0XHRcdFx0aWYgKCBjb2xvckF0dHJpYnV0ZSApIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ2NvbG9yJywgY29sb3JBdHRyaWJ1dGUgKTtcblxuXHRcdFx0XHQvLyBcInNvbGlkXCIgaW5mbHVlbmNlcyB0aGUgbWF0ZXJpYWwgc28gbGV0J3Mgc3RvcmUgaXQgZm9yIGxhdGVyIHVzZVxuXG5cdFx0XHRcdGdlb21ldHJ5Ll9zb2xpZCA9IHNvbGlkO1xuXHRcdFx0XHRnZW9tZXRyeS5fdHlwZSA9ICdtZXNoJztcblxuXHRcdFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYnVpbGRFeHRydXNpb25Ob2RlKCBub2RlICkge1xuXG5cdFx0XHRcdHZhciBjcm9zc1NlY3Rpb24gPSBbIDEsIDEsIDEsIC0gMSwgLSAxLCAtIDEsIC0gMSwgMSwgMSwgMSBdO1xuXHRcdFx0XHR2YXIgc3BpbmUgPSBbIDAsIDAsIDAsIDAsIDEsIDAgXTtcblx0XHRcdFx0dmFyIHNjYWxlO1xuXHRcdFx0XHR2YXIgb3JpZW50YXRpb247XG5cblx0XHRcdFx0dmFyIGJlZ2luQ2FwID0gdHJ1ZTtcblx0XHRcdFx0dmFyIGNjdyA9IHRydWU7XG5cdFx0XHRcdHZhciBjcmVhc2VBbmdsZSA9IDA7XG5cdFx0XHRcdHZhciBlbmRDYXAgPSB0cnVlO1xuXHRcdFx0XHR2YXIgc29saWQgPSB0cnVlO1xuXG5cdFx0XHRcdHZhciBmaWVsZHMgPSBub2RlLmZpZWxkcztcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdHZhciBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRcdHZhciBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRcdHN3aXRjaCAoIGZpZWxkTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnYmVnaW5DYXAnOlxuXHRcdFx0XHRcdFx0XHRiZWdpbkNhcCA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdjY3cnOlxuXHRcdFx0XHRcdFx0XHRjY3cgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnY29udmV4Jzpcblx0XHRcdFx0XHRcdFx0Ly8gZmllbGQgbm90IHN1cHBvcnRlZFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnY3JlYXNlQW5nbGUnOlxuXHRcdFx0XHRcdFx0XHRjcmVhc2VBbmdsZSA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdjcm9zc1NlY3Rpb24nOlxuXHRcdFx0XHRcdFx0XHRjcm9zc1NlY3Rpb24gPSBmaWVsZFZhbHVlcztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2VuZENhcCc6XG5cdFx0XHRcdFx0XHRcdGVuZENhcCA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdvcmllbnRhdGlvbic6XG5cdFx0XHRcdFx0XHRcdG9yaWVudGF0aW9uID0gZmllbGRWYWx1ZXM7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdzY2FsZSc6XG5cdFx0XHRcdFx0XHRcdHNjYWxlID0gZmllbGRWYWx1ZXM7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdzb2xpZCc6XG5cdFx0XHRcdFx0XHRcdHNvbGlkID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3NwaW5lJzpcblx0XHRcdFx0XHRcdFx0c3BpbmUgPSBmaWVsZFZhbHVlczsgLy8gb25seSBleHRydXNpb24gYWxvbmcgdGhlIFktYXhpcyBhcmUgc3VwcG9ydGVkIHNvIGZhclxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJNTExvYWRlcjogVW5rbm93biBmaWVsZDonLCBmaWVsZE5hbWUgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBjcm9zc1NlY3Rpb25DbG9zZWQgPSAoIGNyb3NzU2VjdGlvblsgMCBdID09PSBjcm9zc1NlY3Rpb25bIGNyb3NzU2VjdGlvbi5sZW5ndGggLSAyIF0gJiYgY3Jvc3NTZWN0aW9uWyAxIF0gPT09IGNyb3NzU2VjdGlvblsgY3Jvc3NTZWN0aW9uLmxlbmd0aCAtIDEgXSApO1xuXG5cdFx0XHRcdC8vIHZlcnRpY2VzXG5cblx0XHRcdFx0dmFyIHZlcnRpY2VzID0gW107XG5cdFx0XHRcdHZhciBzcGluZVZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdHZhciBzY2FsaW5nID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0XHR2YXIgYXhpcyA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBqID0gMCwgbyA9IDAsIGlsID0gc3BpbmUubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMywgaiArPSAyLCBvICs9IDQgKSB7XG5cblx0XHRcdFx0XHRzcGluZVZlY3Rvci5mcm9tQXJyYXkoIHNwaW5lLCBpICk7XG5cblx0XHRcdFx0XHRzY2FsaW5nLnggPSBzY2FsZSA/IHNjYWxlWyBqICsgMCBdIDogMTtcblx0XHRcdFx0XHRzY2FsaW5nLnkgPSAxO1xuXHRcdFx0XHRcdHNjYWxpbmcueiA9IHNjYWxlID8gc2NhbGVbIGogKyAxIF0gOiAxO1xuXG5cdFx0XHRcdFx0YXhpcy54ID0gb3JpZW50YXRpb24gPyBvcmllbnRhdGlvblsgbyArIDAgXSA6IDA7XG5cdFx0XHRcdFx0YXhpcy55ID0gb3JpZW50YXRpb24gPyBvcmllbnRhdGlvblsgbyArIDEgXSA6IDA7XG5cdFx0XHRcdFx0YXhpcy56ID0gb3JpZW50YXRpb24gPyBvcmllbnRhdGlvblsgbyArIDIgXSA6IDE7XG5cdFx0XHRcdFx0dmFyIGFuZ2xlID0gb3JpZW50YXRpb24gPyBvcmllbnRhdGlvblsgbyArIDMgXSA6IDA7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgayA9IDAsIGtsID0gY3Jvc3NTZWN0aW9uLmxlbmd0aDsgayA8IGtsOyBrICs9IDIgKSB7XG5cblx0XHRcdFx0XHRcdHZlcnRleC54ID0gY3Jvc3NTZWN0aW9uWyBrICsgMCBdO1xuXHRcdFx0XHRcdFx0dmVydGV4LnkgPSAwO1xuXHRcdFx0XHRcdFx0dmVydGV4LnogPSBjcm9zc1NlY3Rpb25bIGsgKyAxIF07XG5cblx0XHRcdFx0XHRcdC8vIHNjYWxlXG5cblx0XHRcdFx0XHRcdHZlcnRleC5tdWx0aXBseSggc2NhbGluZyApO1xuXG5cdFx0XHRcdFx0XHQvLyByb3RhdGVcblxuXHRcdFx0XHRcdFx0cXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xuXHRcdFx0XHRcdFx0dmVydGV4LmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuXG5cdFx0XHRcdFx0XHQvLyB0cmFuc2xhdGVcblxuXHRcdFx0XHRcdFx0dmVydGV4LmFkZCggc3BpbmVWZWN0b3IgKTtcblxuXHRcdFx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpbmRpY2VzXG5cblx0XHRcdFx0dmFyIGluZGljZXMgPSBbXTtcblxuXHRcdFx0XHR2YXIgc3BpbmVDb3VudCA9IHNwaW5lLmxlbmd0aCAvIDM7XG5cdFx0XHRcdHZhciBjcm9zc1NlY3Rpb25Db3VudCA9IGNyb3NzU2VjdGlvbi5sZW5ndGggLyAyO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHNwaW5lQ291bnQgLSAxOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgY3Jvc3NTZWN0aW9uQ291bnQgLSAxOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgYSA9IGogKyBpICogY3Jvc3NTZWN0aW9uQ291bnQ7XG5cdFx0XHRcdFx0XHR2YXIgYiA9ICggaiArIDEgKSArIGkgKiBjcm9zc1NlY3Rpb25Db3VudDtcblx0XHRcdFx0XHRcdHZhciBjID0gaiArICggaSArIDEgKSAqIGNyb3NzU2VjdGlvbkNvdW50O1xuXHRcdFx0XHRcdFx0dmFyIGQgPSAoIGogKyAxICkgKyAoIGkgKyAxICkgKiBjcm9zc1NlY3Rpb25Db3VudDtcblxuXHRcdFx0XHRcdFx0aWYgKCAoIGogPT09IGNyb3NzU2VjdGlvbkNvdW50IC0gMiApICYmICggY3Jvc3NTZWN0aW9uQ2xvc2VkID09PSB0cnVlICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0YiA9IGkgKiBjcm9zc1NlY3Rpb25Db3VudDtcblx0XHRcdFx0XHRcdFx0ZCA9ICggaSArIDEgKSAqIGNyb3NzU2VjdGlvbkNvdW50O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICggY2N3ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgYyApO1xuXHRcdFx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGMsIGIsIGQgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGMsIGIgKTtcblx0XHRcdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBjLCBkLCBiICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdHJpYW5ndWxhdGUgY2FwXG5cblx0XHRcdFx0aWYgKCBiZWdpbkNhcCA9PT0gdHJ1ZSB8fCBlbmRDYXAgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHR2YXIgY29udG91ciA9IFtdO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY3Jvc3NTZWN0aW9uLmxlbmd0aDsgaSA8IGw7IGkgKz0gMiApIHtcblxuXHRcdFx0XHRcdFx0Y29udG91ci5wdXNoKCBuZXcgVmVjdG9yMiggY3Jvc3NTZWN0aW9uWyBpIF0sIGNyb3NzU2VjdGlvblsgaSArIDEgXSApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgZmFjZXMgPSBTaGFwZVV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUoIGNvbnRvdXIsIFtdICk7XG5cdFx0XHRcdFx0dmFyIGNhcEluZGljZXMgPSBbXTtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Y2FwSW5kaWNlcy5wdXNoKCBmYWNlWyAwIF0sIGZhY2VbIDEgXSwgZmFjZVsgMiBdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBiZWdpbiBjYXBcblxuXHRcdFx0XHRcdGlmICggYmVnaW5DYXAgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNhcEluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggY2N3ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBjYXBJbmRpY2VzWyBpICsgMCBdLCBjYXBJbmRpY2VzWyBpICsgMSBdLCBjYXBJbmRpY2VzWyBpICsgMiBdICk7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdGluZGljZXMucHVzaCggY2FwSW5kaWNlc1sgaSArIDAgXSwgY2FwSW5kaWNlc1sgaSArIDIgXSwgY2FwSW5kaWNlc1sgaSArIDEgXSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gZW5kIGNhcFxuXG5cdFx0XHRcdFx0aWYgKCBlbmRDYXAgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBpbmRleE9mZnNldCA9IGNyb3NzU2VjdGlvbkNvdW50ICogKCBzcGluZUNvdW50IC0gMSApOyAvLyByZWZlcmVuY2VzIHRvIHRoZSBmaXJzdCB2ZXJ0ZXggb2YgdGhlIGxhc3QgY3Jvc3Mgc2VjdGlvblxuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjYXBJbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGNjdyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGluZGljZXMucHVzaCggaW5kZXhPZmZzZXQgKyBjYXBJbmRpY2VzWyBpICsgMCBdLCBpbmRleE9mZnNldCArIGNhcEluZGljZXNbIGkgKyAyIF0sIGluZGV4T2Zmc2V0ICsgY2FwSW5kaWNlc1sgaSArIDEgXSApO1xuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGluZGV4T2Zmc2V0ICsgY2FwSW5kaWNlc1sgaSArIDAgXSwgaW5kZXhPZmZzZXQgKyBjYXBJbmRpY2VzWyBpICsgMSBdLCBpbmRleE9mZnNldCArIGNhcEluZGljZXNbIGkgKyAyIF0gKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHBvc2l0aW9uQXR0cmlidXRlID0gdG9Ob25JbmRleGVkQXR0cmlidXRlKCBpbmRpY2VzLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdFx0XHR2YXIgbm9ybWFsQXR0cmlidXRlID0gY29tcHV0ZU5vcm1hbEF0dHJpYnV0ZSggaW5kaWNlcywgdmVydGljZXMsIGNyZWFzZUFuZ2xlICk7XG5cblx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25BdHRyaWJ1dGUgKTtcblx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbm9ybWFsQXR0cmlidXRlICk7XG5cdFx0XHRcdC8vIG5vIHV2cyB5ZXRcblxuXHRcdFx0XHQvLyBcInNvbGlkXCIgaW5mbHVlbmNlcyB0aGUgbWF0ZXJpYWwgc28gbGV0J3Mgc3RvcmUgaXQgZm9yIGxhdGVyIHVzZVxuXG5cdFx0XHRcdGdlb21ldHJ5Ll9zb2xpZCA9IHNvbGlkO1xuXHRcdFx0XHRnZW9tZXRyeS5fdHlwZSA9ICdtZXNoJztcblxuXHRcdFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaGVscGVyIGZ1bmN0aW9uc1xuXG5cdFx0XHRmdW5jdGlvbiByZXNvbHZlVVNFKCBpZGVudGlmaWVyICkge1xuXG5cdFx0XHRcdHZhciBub2RlID0gbm9kZU1hcFsgaWRlbnRpZmllciBdO1xuXHRcdFx0XHR2YXIgYnVpbGQgPSBnZXROb2RlKCBub2RlICk7XG5cblx0XHRcdFx0Ly8gYmVjYXVzZSB0aGUgc2FtZSAzRCBvYmplY3RzIGNhbiBoYXZlIGRpZmZlcmVudCB0cmFuc2Zvcm1hdGlvbnMsIGl0J3MgbmVjZXNzYXJ5IHRvIGNsb25lIHRoZW0uXG5cdFx0XHRcdC8vIG1hdGVyaWFscyBjYW4gYmUgaW5mbHVlbmNlZCBieSB0aGUgZ2VvbWV0cnkgKGUuZy4gdmVydGV4IG5vcm1hbHMpLiBjbG9uaW5nIGlzIG5lY2Vzc2FyeSB0byBhdm9pZFxuXHRcdFx0XHQvLyBhbnkgc2lkZSBlZmZlY3RzXG5cblx0XHRcdFx0cmV0dXJuICggYnVpbGQuaXNPYmplY3QzRCB8fCBidWlsZC5pc01hdGVyaWFsICkgPyBidWlsZC5jbG9uZSgpIDogYnVpbGQ7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gcGFyc2VGaWVsZENoaWxkcmVuKCBjaGlsZHJlbiwgb3duZXIgKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBvYmplY3QgPSBnZXROb2RlKCBjaGlsZHJlblsgaSBdICk7XG5cblx0XHRcdFx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIE9iamVjdDNEICkgb3duZXIuYWRkKCBvYmplY3QgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gdHJpYW5ndWxhdGVGYWNlSW5kZXgoIGluZGV4LCBjY3cgKSB7XG5cblx0XHRcdFx0dmFyIGluZGljZXMgPSBbXTtcblxuXHRcdFx0XHQvLyBzaW5jZSBmYWNlIGRlZmludGlvbnMgY2FuIGhhdmUgbW9yZSB0aGFuIHRocmVlIHZlcnRpY2VzLCBpdCdzIG5lY2Vzc2FyeSB0b1xuXHRcdFx0XHQvLyBwZXJmb3JtIGEgc2ltcGxlIHRyaWFuZ3VsYXRpb25cblxuXHRcdFx0XHR2YXIgc3RhcnQgPSAwO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluZGV4Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgaTEgPSBpbmRleFsgc3RhcnQgXTtcblx0XHRcdFx0XHR2YXIgaTIgPSBpbmRleFsgaSArICggY2N3ID8gMSA6IDIgKSBdO1xuXHRcdFx0XHRcdHZhciBpMyA9IGluZGV4WyBpICsgKCBjY3cgPyAyIDogMSApIF07XG5cblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGkxLCBpMiwgaTMgKTtcblxuXHRcdFx0XHRcdC8vIGFuIGluZGV4IG9mIC0xIGluZGljYXRlcyB0aGF0IHRoZSBjdXJyZW50IGZhY2UgaGFzIGVuZGVkIGFuZCB0aGUgbmV4dCBvbmUgYmVnaW5zXG5cblx0XHRcdFx0XHRpZiAoIGluZGV4WyBpICsgMyBdID09PSAtIDEgfHwgaSArIDMgPj0gbCApIHtcblxuXHRcdFx0XHRcdFx0aSArPSAzO1xuXHRcdFx0XHRcdFx0c3RhcnQgPSBpICsgMTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGluZGljZXM7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gdHJpYW5ndWxhdGVGYWNlRGF0YSggZGF0YSwgaW5kZXggKSB7XG5cblx0XHRcdFx0dmFyIHRyaWFuZ3VsYXRlZERhdGEgPSBbXTtcblxuXHRcdFx0XHR2YXIgc3RhcnQgPSAwO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluZGV4Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgc3RyaWRlID0gc3RhcnQgKiAzO1xuXG5cdFx0XHRcdFx0dmFyIHggPSBkYXRhWyBzdHJpZGUgXTtcblx0XHRcdFx0XHR2YXIgeSA9IGRhdGFbIHN0cmlkZSArIDEgXTtcblx0XHRcdFx0XHR2YXIgeiA9IGRhdGFbIHN0cmlkZSArIDIgXTtcblxuXHRcdFx0XHRcdHRyaWFuZ3VsYXRlZERhdGEucHVzaCggeCwgeSwgeiApO1xuXG5cdFx0XHRcdFx0Ly8gYW4gaW5kZXggb2YgLTEgaW5kaWNhdGVzIHRoYXQgdGhlIGN1cnJlbnQgZmFjZSBoYXMgZW5kZWQgYW5kIHRoZSBuZXh0IG9uZSBiZWdpbnNcblxuXHRcdFx0XHRcdGlmICggaW5kZXhbIGkgKyAzIF0gPT09IC0gMSB8fCBpICsgMyA+PSBsICkge1xuXG5cdFx0XHRcdFx0XHRpICs9IDM7XG5cdFx0XHRcdFx0XHRzdGFydCArKztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRyaWFuZ3VsYXRlZERhdGE7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZmxhdHRlbkRhdGEoIGRhdGEsIGluZGV4ICkge1xuXG5cdFx0XHRcdHZhciBmbGF0dGVuRGF0YSA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluZGV4Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgaTEgPSBpbmRleFsgaSBdO1xuXG5cdFx0XHRcdFx0dmFyIHN0cmlkZSA9IGkxICogMztcblxuXHRcdFx0XHRcdHZhciB4ID0gZGF0YVsgc3RyaWRlIF07XG5cdFx0XHRcdFx0dmFyIHkgPSBkYXRhWyBzdHJpZGUgKyAxIF07XG5cdFx0XHRcdFx0dmFyIHogPSBkYXRhWyBzdHJpZGUgKyAyIF07XG5cblx0XHRcdFx0XHRmbGF0dGVuRGF0YS5wdXNoKCB4LCB5LCB6ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBmbGF0dGVuRGF0YTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBleHBhbmRMaW5lSW5kZXgoIGluZGV4ICkge1xuXG5cdFx0XHRcdHZhciBpbmRpY2VzID0gW107XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kZXgubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBpMSA9IGluZGV4WyBpIF07XG5cdFx0XHRcdFx0dmFyIGkyID0gaW5kZXhbIGkgKyAxIF07XG5cblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGkxLCBpMiApO1xuXG5cdFx0XHRcdFx0Ly8gYW4gaW5kZXggb2YgLTEgaW5kaWNhdGVzIHRoYXQgdGhlIGN1cnJlbnQgbGluZSBoYXMgZW5kZWQgYW5kIHRoZSBuZXh0IG9uZSBiZWdpbnNcblxuXHRcdFx0XHRcdGlmICggaW5kZXhbIGkgKyAyIF0gPT09IC0gMSB8fCBpICsgMiA+PSBsICkge1xuXG5cdFx0XHRcdFx0XHRpICs9IDI7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBpbmRpY2VzO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGV4cGFuZExpbmVEYXRhKCBkYXRhLCBpbmRleCApIHtcblxuXHRcdFx0XHR2YXIgdHJpYW5ndWxhdGVkRGF0YSA9IFtdO1xuXG5cdFx0XHRcdHZhciBzdGFydCA9IDA7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kZXgubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBzdHJpZGUgPSBzdGFydCAqIDM7XG5cblx0XHRcdFx0XHR2YXIgeCA9IGRhdGFbIHN0cmlkZSBdO1xuXHRcdFx0XHRcdHZhciB5ID0gZGF0YVsgc3RyaWRlICsgMSBdO1xuXHRcdFx0XHRcdHZhciB6ID0gZGF0YVsgc3RyaWRlICsgMiBdO1xuXG5cdFx0XHRcdFx0dHJpYW5ndWxhdGVkRGF0YS5wdXNoKCB4LCB5LCB6ICk7XG5cblx0XHRcdFx0XHQvLyBhbiBpbmRleCBvZiAtMSBpbmRpY2F0ZXMgdGhhdCB0aGUgY3VycmVudCBsaW5lIGhhcyBlbmRlZCBhbmQgdGhlIG5leHQgb25lIGJlZ2luc1xuXG5cdFx0XHRcdFx0aWYgKCBpbmRleFsgaSArIDIgXSA9PT0gLSAxIHx8IGkgKyAyID49IGwgKSB7XG5cblx0XHRcdFx0XHRcdGkgKz0gMjtcblx0XHRcdFx0XHRcdHN0YXJ0ICsrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdHJpYW5ndWxhdGVkRGF0YTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdkEgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0dmFyIHZCID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdHZhciB2QyA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdHZhciB1dkEgPSBuZXcgVmVjdG9yMigpO1xuXHRcdFx0dmFyIHV2QiA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0XHR2YXIgdXZDID0gbmV3IFZlY3RvcjIoKTtcblxuXHRcdFx0ZnVuY3Rpb24gY29tcHV0ZUF0dHJpYnV0ZUZyb21JbmRleGVkRGF0YSggY29vcmRJbmRleCwgaW5kZXgsIGRhdGEsIGl0ZW1TaXplICkge1xuXG5cdFx0XHRcdHZhciBhcnJheSA9IFtdO1xuXG5cdFx0XHRcdC8vIHdlIHVzZSB0aGUgY29vcmRJbmRleC5sZW5ndGggYXMgZGVsaW1pdGVyIHNpbmNlIG5vcm1hbEluZGV4IG11c3QgY29udGFpbiBhdCBsZWFzdCBhcyBtYW55IGluZGljZXNcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjb29yZEluZGV4Lmxlbmd0aDsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdHZhciBhID0gaW5kZXhbIGkgXTtcblx0XHRcdFx0XHR2YXIgYiA9IGluZGV4WyBpICsgMSBdO1xuXHRcdFx0XHRcdHZhciBjID0gaW5kZXhbIGkgKyAyIF07XG5cblx0XHRcdFx0XHRpZiAoIGl0ZW1TaXplID09PSAyICkge1xuXG5cdFx0XHRcdFx0XHR1dkEuZnJvbUFycmF5KCBkYXRhLCBhICogaXRlbVNpemUgKTtcblx0XHRcdFx0XHRcdHV2Qi5mcm9tQXJyYXkoIGRhdGEsIGIgKiBpdGVtU2l6ZSApO1xuXHRcdFx0XHRcdFx0dXZDLmZyb21BcnJheSggZGF0YSwgYyAqIGl0ZW1TaXplICk7XG5cblx0XHRcdFx0XHRcdGFycmF5LnB1c2goIHV2QS54LCB1dkEueSApO1xuXHRcdFx0XHRcdFx0YXJyYXkucHVzaCggdXZCLngsIHV2Qi55ICk7XG5cdFx0XHRcdFx0XHRhcnJheS5wdXNoKCB1dkMueCwgdXZDLnkgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHZBLmZyb21BcnJheSggZGF0YSwgYSAqIGl0ZW1TaXplICk7XG5cdFx0XHRcdFx0XHR2Qi5mcm9tQXJyYXkoIGRhdGEsIGIgKiBpdGVtU2l6ZSApO1xuXHRcdFx0XHRcdFx0dkMuZnJvbUFycmF5KCBkYXRhLCBjICogaXRlbVNpemUgKTtcblxuXHRcdFx0XHRcdFx0YXJyYXkucHVzaCggdkEueCwgdkEueSwgdkEueiApO1xuXHRcdFx0XHRcdFx0YXJyYXkucHVzaCggdkIueCwgdkIueSwgdkIueiApO1xuXHRcdFx0XHRcdFx0YXJyYXkucHVzaCggdkMueCwgdkMueSwgdkMueiApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGNvbXB1dGVBdHRyaWJ1dGVGcm9tRmFjZURhdGEoIGluZGV4LCBmYWNlRGF0YSApIHtcblxuXHRcdFx0XHR2YXIgYXJyYXkgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGogPSAwLCBsID0gaW5kZXgubGVuZ3RoOyBpIDwgbDsgaSArPSAzLCBqICsrICkge1xuXG5cdFx0XHRcdFx0dkEuZnJvbUFycmF5KCBmYWNlRGF0YSwgaiAqIDMgKTtcblxuXHRcdFx0XHRcdGFycmF5LnB1c2goIHZBLngsIHZBLnksIHZBLnogKTtcblx0XHRcdFx0XHRhcnJheS5wdXNoKCB2QS54LCB2QS55LCB2QS56ICk7XG5cdFx0XHRcdFx0YXJyYXkucHVzaCggdkEueCwgdkEueSwgdkEueiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCAzICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gY29tcHV0ZUF0dHJpYnV0ZUZyb21MaW5lRGF0YSggaW5kZXgsIGxpbmVEYXRhICkge1xuXG5cdFx0XHRcdHZhciBhcnJheSA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IDAsIGwgPSBpbmRleC5sZW5ndGg7IGkgPCBsOyBpICs9IDIsIGogKysgKSB7XG5cblx0XHRcdFx0XHR2QS5mcm9tQXJyYXkoIGxpbmVEYXRhLCBqICogMyApO1xuXG5cdFx0XHRcdFx0YXJyYXkucHVzaCggdkEueCwgdkEueSwgdkEueiApO1xuXHRcdFx0XHRcdGFycmF5LnB1c2goIHZBLngsIHZBLnksIHZBLnogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgMyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHRvTm9uSW5kZXhlZEF0dHJpYnV0ZSggaW5kaWNlcywgYXR0cmlidXRlICkge1xuXG5cdFx0XHRcdHZhciBhcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcblx0XHRcdFx0dmFyIGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xuXG5cdFx0XHRcdHZhciBhcnJheTIgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IoIGluZGljZXMubGVuZ3RoICogaXRlbVNpemUgKTtcblxuXHRcdFx0XHR2YXIgaW5kZXggPSAwLCBpbmRleDIgPSAwO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGluZGV4ID0gaW5kaWNlc1sgaSBdICogaXRlbVNpemU7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBpdGVtU2l6ZTsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0YXJyYXkyWyBpbmRleDIgKysgXSA9IGFycmF5WyBpbmRleCArKyBdO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGFycmF5MiwgaXRlbVNpemUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgYWIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0dmFyIGNiID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0ZnVuY3Rpb24gY29tcHV0ZU5vcm1hbEF0dHJpYnV0ZSggaW5kZXgsIGNvb3JkLCBjcmVhc2VBbmdsZSApIHtcblxuXHRcdFx0XHR2YXIgZmFjZXMgPSBbXTtcblx0XHRcdFx0dmFyIHZlcnRleE5vcm1hbHMgPSB7fTtcblxuXHRcdFx0XHQvLyBwcmVwYXJlIGZhY2UgYW5kIHJhdyB2ZXJ0ZXggbm9ybWFsc1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluZGV4Lmxlbmd0aDsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdHZhciBhID0gaW5kZXhbIGkgXTtcblx0XHRcdFx0XHR2YXIgYiA9IGluZGV4WyBpICsgMSBdO1xuXHRcdFx0XHRcdHZhciBjID0gaW5kZXhbIGkgKyAyIF07XG5cblx0XHRcdFx0XHR2YXIgZmFjZSA9IG5ldyBGYWNlKCBhLCBiLCBjICk7XG5cblx0XHRcdFx0XHR2QS5mcm9tQXJyYXkoIGNvb3JkLCBhICogMyApO1xuXHRcdFx0XHRcdHZCLmZyb21BcnJheSggY29vcmQsIGIgKiAzICk7XG5cdFx0XHRcdFx0dkMuZnJvbUFycmF5KCBjb29yZCwgYyAqIDMgKTtcblxuXHRcdFx0XHRcdGNiLnN1YlZlY3RvcnMoIHZDLCB2QiApO1xuXHRcdFx0XHRcdGFiLnN1YlZlY3RvcnMoIHZBLCB2QiApO1xuXHRcdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xuXG5cdFx0XHRcdFx0Y2Iubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0XHRmYWNlLm5vcm1hbC5jb3B5KCBjYiApO1xuXG5cdFx0XHRcdFx0aWYgKCB2ZXJ0ZXhOb3JtYWxzWyBhIF0gPT09IHVuZGVmaW5lZCApIHZlcnRleE5vcm1hbHNbIGEgXSA9IFtdO1xuXHRcdFx0XHRcdGlmICggdmVydGV4Tm9ybWFsc1sgYiBdID09PSB1bmRlZmluZWQgKSB2ZXJ0ZXhOb3JtYWxzWyBiIF0gPSBbXTtcblx0XHRcdFx0XHRpZiAoIHZlcnRleE5vcm1hbHNbIGMgXSA9PT0gdW5kZWZpbmVkICkgdmVydGV4Tm9ybWFsc1sgYyBdID0gW107XG5cblx0XHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyBhIF0ucHVzaCggZmFjZS5ub3JtYWwgKTtcblx0XHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyBiIF0ucHVzaCggZmFjZS5ub3JtYWwgKTtcblx0XHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyBjIF0ucHVzaCggZmFjZS5ub3JtYWwgKTtcblxuXHRcdFx0XHRcdGZhY2VzLnB1c2goIGZhY2UgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY29tcHV0ZSB2ZXJ0ZXggbm9ybWFscyBhbmQgYnVpbGQgZmluYWwgZ2VvbWV0cnlcblxuXHRcdFx0XHR2YXIgbm9ybWFscyA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cblx0XHRcdFx0XHR2YXIgbkEgPSB3ZWlnaHRlZE5vcm1hbCggdmVydGV4Tm9ybWFsc1sgZmFjZS5hIF0sIGZhY2Uubm9ybWFsLCBjcmVhc2VBbmdsZSApO1xuXHRcdFx0XHRcdHZhciBuQiA9IHdlaWdodGVkTm9ybWFsKCB2ZXJ0ZXhOb3JtYWxzWyBmYWNlLmIgXSwgZmFjZS5ub3JtYWwsIGNyZWFzZUFuZ2xlICk7XG5cdFx0XHRcdFx0dmFyIG5DID0gd2VpZ2h0ZWROb3JtYWwoIHZlcnRleE5vcm1hbHNbIGZhY2UuYyBdLCBmYWNlLm5vcm1hbCwgY3JlYXNlQW5nbGUgKTtcblxuXHRcdFx0XHRcdHZBLmZyb21BcnJheSggY29vcmQsIGZhY2UuYSAqIDMgKTtcblx0XHRcdFx0XHR2Qi5mcm9tQXJyYXkoIGNvb3JkLCBmYWNlLmIgKiAzICk7XG5cdFx0XHRcdFx0dkMuZnJvbUFycmF5KCBjb29yZCwgZmFjZS5jICogMyApO1xuXG5cdFx0XHRcdFx0bm9ybWFscy5wdXNoKCBuQS54LCBuQS55LCBuQS56ICk7XG5cdFx0XHRcdFx0bm9ybWFscy5wdXNoKCBuQi54LCBuQi55LCBuQi56ICk7XG5cdFx0XHRcdFx0bm9ybWFscy5wdXNoKCBuQy54LCBuQy55LCBuQy56ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHdlaWdodGVkTm9ybWFsKCBub3JtYWxzLCB2ZWN0b3IsIGNyZWFzZUFuZ2xlICkge1xuXG5cdFx0XHRcdHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRcdGlmICggY3JlYXNlQW5nbGUgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRub3JtYWwuY29weSggdmVjdG9yICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG5vcm1hbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub3JtYWxzWyBpIF0uYW5nbGVUbyggdmVjdG9yICkgPCBjcmVhc2VBbmdsZSApIHtcblxuXHRcdFx0XHRcdFx0XHRub3JtYWwuYWRkKCBub3JtYWxzWyBpIF0gKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbm9ybWFsLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHRvQ29sb3JBcnJheSggY29sb3JzICkge1xuXG5cdFx0XHRcdHZhciBhcnJheSA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNvbG9ycy5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHRhcnJheS5wdXNoKCBuZXcgQ29sb3IoIGNvbG9yc1sgaSBdLCBjb2xvcnNbIGkgKyAxIF0sIGNvbG9yc1sgaSArIDIgXSApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBhcnJheTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFZlcnRpY2FsbHkgcGFpbnRzIHRoZSBmYWNlcyBpbnRlcnBvbGF0aW5nIGJldHdlZW4gdGhlXG5cdFx0XHQgKiBzcGVjaWZpZWQgY29sb3JzIGF0IHRoZSBzcGVjaWZpZWQgYW5nZWxzLiBUaGlzIGlzIHVzZWQgZm9yIHRoZSBCYWNrZ3JvdW5kXG5cdFx0XHQgKiBub2RlLCBidXQgY291bGQgYmUgYXBwbGllZCB0byBvdGhlciBub2RlcyB3aXRoIG11bHRpcGxlIGZhY2VzIGFzIHdlbGwuXG5cdFx0XHQgKlxuXHRcdFx0ICogV2hlbiB1c2VkIHdpdGggdGhlIEJhY2tncm91bmQgbm9kZSwgZGVmYXVsdCBpcyBkaXJlY3Rpb25Jc0Rvd24gaXMgdHJ1ZSBpZlxuXHRcdFx0ICogaW50ZXJwb2xhdGluZyB0aGUgc2t5Q29sb3IgZG93biBmcm9tIHRoZSBaZW5pdGguIFdoZW4gaW50ZXJwb2xhdGlvbmcgdXAgZnJvbVxuXHRcdFx0ICogdGhlIE5hZGlyIGkuZS4gaW50ZXJwb2xhdGluZyB0aGUgZ3JvdW5kQ29sb3IsIHRoZSBkaXJlY3Rpb25Jc0Rvd24gaXMgZmFsc2UuXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhlIGZpcnN0IGFuZ2xlIGlzIG5ldmVyIHNwZWNpZmllZCwgaXQgaXMgdGhlIFplbml0aCAoMCByYWQpLiBBbmdsZXMgYXJlIHNwZWNpZmllZFxuXHRcdFx0ICogaW4gcmFkaWFucy4gVGhlIGdlb21ldHJ5IGlzIHRob3VnaHQgYSBzcGhlcmUsIGJ1dCBjb3VsZCBiZSBhbnl0aGluZy4gVGhlIGNvbG9yIGludGVycG9sYXRpb25cblx0XHRcdCAqIGlzIGxpbmVhciBhbG9uZyB0aGUgWSBheGlzIGluIGFueSBjYXNlLlxuXHRcdFx0ICpcblx0XHRcdCAqIFlvdSBtdXN0IHNwZWNpZnkgb25lIG1vcmUgY29sb3IgdGhhbiB5b3UgaGF2ZSBhbmdsZXMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY29sb3JzIGFycmF5LlxuXHRcdFx0ICogVGhpcyBpcyB0aGUgY29sb3Igb2YgdGhlIFplbml0aCAodGhlIHRvcCBvZiB0aGUgc2hhcGUpLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7QnVmZmVyR2VvbWV0cnl9IGdlb21ldHJ5XG5cdFx0XHQgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzXG5cdFx0XHQgKiBAcGFyYW0ge2FycmF5fSBhbmdsZXNcblx0XHRcdCAqIEBwYXJhbSB7YXJyYXl9IGNvbG9yc1xuXHRcdFx0ICogQHBhcmFtIHtib29sZWFufSB0b3BEb3duIC0gV2hldGhlciB0byB3b3JrIHRvcCBkb3duIG9yIGJvdHRvbSB1cC5cblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gcGFpbnRGYWNlcyggZ2VvbWV0cnksIHJhZGl1cywgYW5nbGVzLCBjb2xvcnMsIHRvcERvd24gKSB7XG5cblx0XHRcdFx0Ly8gY29tcHV0ZSB0aHJlc2hvbGQgdmFsdWVzXG5cblx0XHRcdFx0dmFyIHRocmVzaG9sZHMgPSBbXTtcblx0XHRcdFx0dmFyIHN0YXJ0QW5nbGUgPSAoIHRvcERvd24gPT09IHRydWUgKSA/IDAgOiBNYXRoLlBJO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNvbG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGFuZ2xlID0gKCBpID09PSAwICkgPyAwIDogYW5nbGVzWyBpIC0gMSBdO1xuXHRcdFx0XHRcdGFuZ2xlID0gKCB0b3BEb3duID09PSB0cnVlICkgPyBhbmdsZSA6ICggc3RhcnRBbmdsZSAtIGFuZ2xlICk7XG5cblx0XHRcdFx0XHR2YXIgcG9pbnQgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHRcdHBvaW50LnNldEZyb21TcGhlcmljYWxDb29yZHMoIHJhZGl1cywgYW5nbGUsIDAgKTtcblxuXHRcdFx0XHRcdHRocmVzaG9sZHMucHVzaCggcG9pbnQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZ2VuZXJhdGUgdmVydGV4IGNvbG9yc1xuXG5cdFx0XHRcdHZhciBpbmRpY2VzID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRcdHZhciBwb3NpdGlvbkF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHRcdHZhciBjb2xvckF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQgKiAzICksIDMgKTtcblxuXHRcdFx0XHR2YXIgcG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHR2YXIgY29sb3IgPSBuZXcgQ29sb3IoKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmNvdW50OyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGluZGV4ID0gaW5kaWNlcy5nZXRYKCBpICk7XG5cdFx0XHRcdFx0cG9zaXRpb24uZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIGluZGV4ICk7XG5cblx0XHRcdFx0XHR2YXIgdGhyZXNob2xkSW5kZXhBLCB0aHJlc2hvbGRJbmRleEI7XG5cdFx0XHRcdFx0dmFyIHQgPSAxO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAxOyBqIDwgdGhyZXNob2xkcy5sZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdHRocmVzaG9sZEluZGV4QSA9IGogLSAxO1xuXHRcdFx0XHRcdFx0dGhyZXNob2xkSW5kZXhCID0gajtcblxuXHRcdFx0XHRcdFx0dmFyIHRocmVzaG9sZEEgPSB0aHJlc2hvbGRzWyB0aHJlc2hvbGRJbmRleEEgXTtcblx0XHRcdFx0XHRcdHZhciB0aHJlc2hvbGRCID0gdGhyZXNob2xkc1sgdGhyZXNob2xkSW5kZXhCIF07XG5cblx0XHRcdFx0XHRcdGlmICggdG9wRG93biA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBpbnRlcnBvbGF0aW9uIGZvciBza3kgY29sb3JcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHBvc2l0aW9uLnkgPD0gdGhyZXNob2xkQS55ICYmIHBvc2l0aW9uLnkgPiB0aHJlc2hvbGRCLnkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR0ID0gTWF0aC5hYnMoIHRocmVzaG9sZEEueSAtIHBvc2l0aW9uLnkgKSAvIE1hdGguYWJzKCB0aHJlc2hvbGRBLnkgLSB0aHJlc2hvbGRCLnkgKTtcblxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBpbnRlcnBvbGF0aW9uIGZvciBncm91bmQgY29sb3JcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHBvc2l0aW9uLnkgPj0gdGhyZXNob2xkQS55ICYmIHBvc2l0aW9uLnkgPCB0aHJlc2hvbGRCLnkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR0ID0gTWF0aC5hYnMoIHRocmVzaG9sZEEueSAtIHBvc2l0aW9uLnkgKSAvIE1hdGguYWJzKCB0aHJlc2hvbGRBLnkgLSB0aHJlc2hvbGRCLnkgKTtcblxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIGNvbG9yQSA9IGNvbG9yc1sgdGhyZXNob2xkSW5kZXhBIF07XG5cdFx0XHRcdFx0dmFyIGNvbG9yQiA9IGNvbG9yc1sgdGhyZXNob2xkSW5kZXhCIF07XG5cblx0XHRcdFx0XHRjb2xvci5jb3B5KCBjb2xvckEgKS5sZXJwKCBjb2xvckIsIHQgKTtcblxuXHRcdFx0XHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggaW5kZXgsIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnY29sb3InLCBjb2xvckF0dHJpYnV0ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vXG5cblx0XHRcdHZhciB0ZXh0dXJlTG9hZGVyID0gbmV3IFRleHR1cmVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdFx0dGV4dHVyZUxvYWRlci5zZXRQYXRoKCB0aGlzLnJlc291cmNlUGF0aCB8fCBwYXRoICkuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcblxuXHRcdFx0Ly8gY2hlY2sgdmVyc2lvbiAob25seSAyLjAgaXMgc3VwcG9ydGVkKVxuXG5cdFx0XHRpZiAoIGRhdGEuaW5kZXhPZiggJyNWUk1MIFYyLjAnICkgPT09IC0gMSApIHtcblxuXHRcdFx0XHR0aHJvdyBFcnJvciggJ1RIUkVFLlZSTUxMZXhlcjogVmVyc2lvbiBvZiBWUk1MIGFzc2V0IG5vdCBzdXBwb3J0ZWQuJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGNyZWF0ZSBKU09OIHJlcHJlc2VudGluZyB0aGUgdHJlZSBzdHJ1Y3R1cmUgb2YgdGhlIFZSTUwgYXNzZXRcblxuXHRcdFx0dmFyIHRyZWUgPSBnZW5lcmF0ZVZSTUxUcmVlKCBkYXRhICk7XG5cblx0XHRcdC8vIHBhcnNlIHRoZSB0cmVlIHN0cnVjdHVyZSB0byBhIHRocmVlLmpzIHNjZW5lXG5cblx0XHRcdHZhciBzY2VuZSA9IHBhcnNlVHJlZSggdHJlZSApO1xuXG5cdFx0XHRyZXR1cm4gc2NlbmU7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdGZ1bmN0aW9uIFZSTUxMZXhlciggdG9rZW5zICkge1xuXG5cdFx0dGhpcy5sZXhlciA9IG5ldyBjaGV2cm90YWluLkxleGVyKCB0b2tlbnMgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cdH1cblxuXHRWUk1MTGV4ZXIucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IFZSTUxMZXhlcixcblxuXHRcdGxleDogZnVuY3Rpb24gKCBpbnB1dFRleHQgKSB7XG5cblx0XHRcdHZhciBsZXhpbmdSZXN1bHQgPSB0aGlzLmxleGVyLnRva2VuaXplKCBpbnB1dFRleHQgKTtcblxuXHRcdFx0aWYgKCBsZXhpbmdSZXN1bHQuZXJyb3JzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggbGV4aW5nUmVzdWx0LmVycm9ycyApO1xuXG5cdFx0XHRcdHRocm93IEVycm9yKCAnVEhSRUUuVlJNTExleGVyOiBMZXhpbmcgZXJyb3JzIGRldGVjdGVkLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbGV4aW5nUmVzdWx0O1xuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gVlJNTFBhcnNlciggdG9rZW5Wb2NhYnVsYXJ5ICkge1xuXG5cdFx0Y2hldnJvdGFpbi5QYXJzZXIuY2FsbCggdGhpcywgdG9rZW5Wb2NhYnVsYXJ5ICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXHRcdHZhciAkID0gdGhpcztcblxuXHRcdHZhciBWZXJzaW9uID0gdG9rZW5Wb2NhYnVsYXJ5WyAnVmVyc2lvbicgXTtcblx0XHR2YXIgTEN1cmx5ID0gdG9rZW5Wb2NhYnVsYXJ5WyAnTEN1cmx5JyBdO1xuXHRcdHZhciBSQ3VybHkgPSB0b2tlblZvY2FidWxhcnlbICdSQ3VybHknIF07XG5cdFx0dmFyIExTcXVhcmUgPSB0b2tlblZvY2FidWxhcnlbICdMU3F1YXJlJyBdO1xuXHRcdHZhciBSU3F1YXJlID0gdG9rZW5Wb2NhYnVsYXJ5WyAnUlNxdWFyZScgXTtcblx0XHR2YXIgSWRlbnRpZmllciA9IHRva2VuVm9jYWJ1bGFyeVsgJ0lkZW50aWZpZXInIF07XG5cdFx0dmFyIFJvdXRlSWRlbnRpZmllciA9IHRva2VuVm9jYWJ1bGFyeVsgJ1JvdXRlSWRlbnRpZmllcicgXTtcblx0XHR2YXIgU3RyaW5nTGl0ZXJhbCA9IHRva2VuVm9jYWJ1bGFyeVsgJ1N0cmluZ0xpdGVyYWwnIF07XG5cdFx0dmFyIEhleExpdGVyYWwgPSB0b2tlblZvY2FidWxhcnlbICdIZXhMaXRlcmFsJyBdO1xuXHRcdHZhciBOdW1iZXJMaXRlcmFsID0gdG9rZW5Wb2NhYnVsYXJ5WyAnTnVtYmVyTGl0ZXJhbCcgXTtcblx0XHR2YXIgVHJ1ZUxpdGVyYWwgPSB0b2tlblZvY2FidWxhcnlbICdUcnVlTGl0ZXJhbCcgXTtcblx0XHR2YXIgRmFsc2VMaXRlcmFsID0gdG9rZW5Wb2NhYnVsYXJ5WyAnRmFsc2VMaXRlcmFsJyBdO1xuXHRcdHZhciBOdWxsTGl0ZXJhbCA9IHRva2VuVm9jYWJ1bGFyeVsgJ051bGxMaXRlcmFsJyBdO1xuXHRcdHZhciBERUYgPSB0b2tlblZvY2FidWxhcnlbICdERUYnIF07XG5cdFx0dmFyIFVTRSA9IHRva2VuVm9jYWJ1bGFyeVsgJ1VTRScgXTtcblx0XHR2YXIgUk9VVEUgPSB0b2tlblZvY2FidWxhcnlbICdST1VURScgXTtcblx0XHR2YXIgVE8gPSB0b2tlblZvY2FidWxhcnlbICdUTycgXTtcblx0XHR2YXIgTm9kZU5hbWUgPSB0b2tlblZvY2FidWxhcnlbICdOb2RlTmFtZScgXTtcblxuXHRcdCQuUlVMRSggJ3ZybWwnLCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdCQuU1VCUlVMRSggJC52ZXJzaW9uICk7XG5cdFx0XHQkLkFUX0xFQVNUX09ORSggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdCQuU1VCUlVMRSggJC5ub2RlICk7XG5cblx0XHRcdH0gKTtcblx0XHRcdCQuTUFOWSggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdCQuU1VCUlVMRSggJC5yb3V0ZSApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHR9ICk7XG5cblx0XHQkLlJVTEUoICd2ZXJzaW9uJywgZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQkLkNPTlNVTUUoIFZlcnNpb24gKTtcblxuXHRcdH0gKTtcblxuXHRcdCQuUlVMRSggJ25vZGUnLCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdCQuT1BUSU9OKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0JC5TVUJSVUxFKCAkLmRlZiApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHRcdCQuQ09OU1VNRSggTm9kZU5hbWUgKTtcblx0XHRcdCQuQ09OU1VNRSggTEN1cmx5ICk7XG5cdFx0XHQkLk1BTlkoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHQkLlNVQlJVTEUoICQuZmllbGQgKTtcblxuXHRcdFx0fSApO1xuXHRcdFx0JC5DT05TVU1FKCBSQ3VybHkgKTtcblxuXHRcdH0gKTtcblxuXHRcdCQuUlVMRSggJ2ZpZWxkJywgZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQkLkNPTlNVTUUoIElkZW50aWZpZXIgKTtcblxuXHRcdFx0JC5PUjIoIFtcblx0XHRcdFx0eyBBTFQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdCQuU1VCUlVMRSggJC5zaW5nbGVGaWVsZFZhbHVlICk7XG5cblx0XHRcdFx0fSB9LFxuXHRcdFx0XHR7IEFMVDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0JC5TVUJSVUxFKCAkLm11bHRpRmllbGRWYWx1ZSApO1xuXG5cdFx0XHRcdH0gfVxuXHRcdFx0XSApO1xuXG5cdFx0fSApO1xuXG5cdFx0JC5SVUxFKCAnZGVmJywgZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQkLkNPTlNVTUUoIERFRiApO1xuXHRcdFx0JC5PUiggW1xuXHRcdFx0XHR7IEFMVDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0JC5DT05TVU1FKCBJZGVudGlmaWVyICk7XG5cblx0XHRcdFx0fSB9LFxuXHRcdFx0XHR7IEFMVDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0JC5DT05TVU1FKCBOb2RlTmFtZSApO1xuXG5cdFx0XHRcdH0gfVxuXHRcdFx0XSApO1xuXG5cdFx0fSApO1xuXG5cdFx0JC5SVUxFKCAndXNlJywgZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQkLkNPTlNVTUUoIFVTRSApO1xuXHRcdFx0JC5PUiggW1xuXHRcdFx0XHR7IEFMVDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0JC5DT05TVU1FKCBJZGVudGlmaWVyICk7XG5cblx0XHRcdFx0fSB9LFxuXHRcdFx0XHR7IEFMVDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0JC5DT05TVU1FKCBOb2RlTmFtZSApO1xuXG5cdFx0XHRcdH0gfVxuXHRcdFx0XSApO1xuXG5cdFx0fSApO1xuXG5cdFx0JC5SVUxFKCAnc2luZ2xlRmllbGRWYWx1ZScsIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0JC5BVF9MRUFTVF9PTkUoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHQkLk9SKCBbXG5cdFx0XHRcdFx0eyBBTFQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdFx0JC5TVUJSVUxFKCAkLm5vZGUgKTtcblxuXHRcdFx0XHRcdH0gfSxcblx0XHRcdFx0XHR7IEFMVDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHQkLlNVQlJVTEUoICQudXNlICk7XG5cblx0XHRcdFx0XHR9IH0sXG5cdFx0XHRcdFx0eyBBTFQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdFx0JC5DT05TVU1FKCBTdHJpbmdMaXRlcmFsICk7XG5cblx0XHRcdFx0XHR9IH0sXG5cdFx0XHRcdFx0eyBBTFQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdFx0JC5DT05TVU1FKCBIZXhMaXRlcmFsICk7XG5cblx0XHRcdFx0XHR9IH0sXG5cdFx0XHRcdFx0eyBBTFQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdFx0JC5DT05TVU1FKCBOdW1iZXJMaXRlcmFsICk7XG5cblx0XHRcdFx0XHR9IH0sXG5cdFx0XHRcdFx0eyBBTFQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdFx0JC5DT05TVU1FKCBUcnVlTGl0ZXJhbCApO1xuXG5cdFx0XHRcdFx0fSB9LFxuXHRcdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdCQuQ09OU1VNRSggRmFsc2VMaXRlcmFsICk7XG5cblx0XHRcdFx0XHR9IH0sXG5cdFx0XHRcdFx0eyBBTFQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdFx0JC5DT05TVU1FKCBOdWxsTGl0ZXJhbCApO1xuXG5cdFx0XHRcdFx0fSB9XG5cdFx0XHRcdF0gKTtcblxuXG5cdFx0XHR9ICk7XG5cblx0XHR9ICk7XG5cblx0XHQkLlJVTEUoICdtdWx0aUZpZWxkVmFsdWUnLCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdCQuQ09OU1VNRSggTFNxdWFyZSApO1xuXHRcdFx0JC5NQU5ZKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0JC5PUiggW1xuXHRcdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdCQuU1VCUlVMRSggJC5ub2RlICk7XG5cblx0XHRcdFx0XHR9IH0sXG5cdFx0XHRcdFx0eyBBTFQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdFx0JC5TVUJSVUxFKCAkLnVzZSApO1xuXG5cdFx0XHRcdFx0fSB9LFxuXHRcdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdCQuQ09OU1VNRSggU3RyaW5nTGl0ZXJhbCApO1xuXG5cdFx0XHRcdFx0fSB9LFxuXHRcdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdCQuQ09OU1VNRSggSGV4TGl0ZXJhbCApO1xuXG5cdFx0XHRcdFx0fSB9LFxuXHRcdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdCQuQ09OU1VNRSggTnVtYmVyTGl0ZXJhbCApO1xuXG5cdFx0XHRcdFx0fSB9LFxuXHRcdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdCQuQ09OU1VNRSggTnVsbExpdGVyYWwgKTtcblxuXHRcdFx0XHRcdH0gfVxuXHRcdFx0XHRdICk7XG5cblx0XHRcdH0gKTtcblx0XHRcdCQuQ09OU1VNRSggUlNxdWFyZSApO1xuXG5cdFx0fSApO1xuXG5cdFx0JC5SVUxFKCAncm91dGUnLCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdCQuQ09OU1VNRSggUk9VVEUgKTtcblx0XHRcdCQuQ09OU1VNRSggUm91dGVJZGVudGlmaWVyICk7XG5cdFx0XHQkLkNPTlNVTUUoIFRPICk7XG5cdFx0XHQkLkNPTlNVTUUyKCBSb3V0ZUlkZW50aWZpZXIgKTtcblxuXHRcdH0gKTtcblxuXHRcdHRoaXMucGVyZm9ybVNlbGZBbmFseXNpcygpO1xuXG5cdH1cblxuXHRWUk1MUGFyc2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIGNoZXZyb3RhaW4uUGFyc2VyLnByb3RvdHlwZSApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cdFZSTUxQYXJzZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVlJNTFBhcnNlcjtcblxuXHRmdW5jdGlvbiBGYWNlKCBhLCBiLCBjICkge1xuXG5cdFx0dGhpcy5hID0gYTtcblx0XHR0aGlzLmIgPSBiO1xuXHRcdHRoaXMuYyA9IGM7XG5cdFx0dGhpcy5ub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXG5cdH1cblxuXHR2YXIgVEVYVFVSRV9UWVBFID0ge1xuXHRcdElOVEVOU0lUWTogMSxcblx0XHRJTlRFTlNJVFlfQUxQSEE6IDIsXG5cdFx0UkdCOiAzLFxuXHRcdFJHQkE6IDRcblx0fTtcblxuXHRyZXR1cm4gVlJNTExvYWRlcjtcblxufSApKCk7XG5cbnZhciBQQ0RMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XG5cblx0TG9hZGVyJDEuY2FsbCggdGhpcywgbWFuYWdlciApO1xuXG5cdHRoaXMubGl0dGxlRW5kaWFuID0gdHJ1ZTtcblxufTtcblxuXG5QQ0RMb2FkZXIucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTG9hZGVyJDEucHJvdG90eXBlICksIHtcblxuXHRjb25zdHJ1Y3RvcjogUENETG9hZGVyLFxuXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XG5cdFx0bG9hZGVyLnNldFBhdGgoIHNjb3BlLnBhdGggKTtcblx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHNjb3BlLnJlcXVlc3RIZWFkZXIgKTtcblx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCBzY29wZS53aXRoQ3JlZGVudGlhbHMgKTtcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cblx0XHRcdHRyeSB7XG5cblx0XHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggZGF0YSwgdXJsICkgKTtcblxuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICkge1xuXG5cdFx0XHRcdFx0b25FcnJvciggZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdH0sXG5cblx0cGFyc2U6IGZ1bmN0aW9uICggZGF0YSwgdXJsICkge1xuXG5cdFx0Ly8gZnJvbSBodHRwczovL2dpdGxhYi5jb20vdGFrZXR3by90aHJlZS1wY2QtbG9hZGVyL2Jsb2IvbWFzdGVyL2RlY29tcHJlc3MtbHpmLmpzXG5cblx0XHRmdW5jdGlvbiBkZWNvbXByZXNzTFpGKCBpbkRhdGEsIG91dExlbmd0aCApIHtcblxuXHRcdFx0dmFyIGluTGVuZ3RoID0gaW5EYXRhLmxlbmd0aDtcblx0XHRcdHZhciBvdXREYXRhID0gbmV3IFVpbnQ4QXJyYXkoIG91dExlbmd0aCApO1xuXHRcdFx0dmFyIGluUHRyID0gMDtcblx0XHRcdHZhciBvdXRQdHIgPSAwO1xuXHRcdFx0dmFyIGN0cmw7XG5cdFx0XHR2YXIgbGVuO1xuXHRcdFx0dmFyIHJlZjtcblx0XHRcdGRvIHtcblxuXHRcdFx0XHRjdHJsID0gaW5EYXRhWyBpblB0ciArKyBdO1xuXHRcdFx0XHRpZiAoIGN0cmwgPCAoIDEgPDwgNSApICkge1xuXG5cdFx0XHRcdFx0Y3RybCArKztcblx0XHRcdFx0XHRpZiAoIG91dFB0ciArIGN0cmwgPiBvdXRMZW5ndGggKSB0aHJvdyBuZXcgRXJyb3IoICdPdXRwdXQgYnVmZmVyIGlzIG5vdCBsYXJnZSBlbm91Z2gnICk7XG5cdFx0XHRcdFx0aWYgKCBpblB0ciArIGN0cmwgPiBpbkxlbmd0aCApIHRocm93IG5ldyBFcnJvciggJ0ludmFsaWQgY29tcHJlc3NlZCBkYXRhJyApO1xuXHRcdFx0XHRcdGRvIHtcblxuXHRcdFx0XHRcdFx0b3V0RGF0YVsgb3V0UHRyICsrIF0gPSBpbkRhdGFbIGluUHRyICsrIF07XG5cblx0XHRcdFx0XHR9IHdoaWxlICggLS0gY3RybCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRsZW4gPSBjdHJsID4+IDU7XG5cdFx0XHRcdFx0cmVmID0gb3V0UHRyIC0gKCAoIGN0cmwgJiAweDFmICkgPDwgOCApIC0gMTtcblx0XHRcdFx0XHRpZiAoIGluUHRyID49IGluTGVuZ3RoICkgdGhyb3cgbmV3IEVycm9yKCAnSW52YWxpZCBjb21wcmVzc2VkIGRhdGEnICk7XG5cdFx0XHRcdFx0aWYgKCBsZW4gPT09IDcgKSB7XG5cblx0XHRcdFx0XHRcdGxlbiArPSBpbkRhdGFbIGluUHRyICsrIF07XG5cdFx0XHRcdFx0XHRpZiAoIGluUHRyID49IGluTGVuZ3RoICkgdGhyb3cgbmV3IEVycm9yKCAnSW52YWxpZCBjb21wcmVzc2VkIGRhdGEnICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZWYgLT0gaW5EYXRhWyBpblB0ciArKyBdO1xuXHRcdFx0XHRcdGlmICggb3V0UHRyICsgbGVuICsgMiA+IG91dExlbmd0aCApIHRocm93IG5ldyBFcnJvciggJ091dHB1dCBidWZmZXIgaXMgbm90IGxhcmdlIGVub3VnaCcgKTtcblx0XHRcdFx0XHRpZiAoIHJlZiA8IDAgKSB0aHJvdyBuZXcgRXJyb3IoICdJbnZhbGlkIGNvbXByZXNzZWQgZGF0YScgKTtcblx0XHRcdFx0XHRpZiAoIHJlZiA+PSBvdXRQdHIgKSB0aHJvdyBuZXcgRXJyb3IoICdJbnZhbGlkIGNvbXByZXNzZWQgZGF0YScgKTtcblx0XHRcdFx0XHRkbyB7XG5cblx0XHRcdFx0XHRcdG91dERhdGFbIG91dFB0ciArKyBdID0gb3V0RGF0YVsgcmVmICsrIF07XG5cblx0XHRcdFx0XHR9IHdoaWxlICggLS0gbGVuICsgMiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSB3aGlsZSAoIGluUHRyIDwgaW5MZW5ndGggKTtcblxuXHRcdFx0cmV0dXJuIG91dERhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUhlYWRlciggZGF0YSApIHtcblxuXHRcdFx0dmFyIFBDRGhlYWRlciA9IHt9O1xuXHRcdFx0dmFyIHJlc3VsdDEgPSBkYXRhLnNlYXJjaCggL1tcXHJcXG5dREFUQVxccyhcXFMqKVxccy9pICk7XG5cdFx0XHR2YXIgcmVzdWx0MiA9IC9bXFxyXFxuXURBVEFcXHMoXFxTKilcXHMvaS5leGVjKCBkYXRhLnN1YnN0ciggcmVzdWx0MSAtIDEgKSApO1xuXG5cdFx0XHRQQ0RoZWFkZXIuZGF0YSA9IHJlc3VsdDJbIDEgXTtcblx0XHRcdFBDRGhlYWRlci5oZWFkZXJMZW4gPSByZXN1bHQyWyAwIF0ubGVuZ3RoICsgcmVzdWx0MTtcblx0XHRcdFBDRGhlYWRlci5zdHIgPSBkYXRhLnN1YnN0ciggMCwgUENEaGVhZGVyLmhlYWRlckxlbiApO1xuXG5cdFx0XHQvLyByZW1vdmUgY29tbWVudHNcblxuXHRcdFx0UENEaGVhZGVyLnN0ciA9IFBDRGhlYWRlci5zdHIucmVwbGFjZSggL1xcIy4qL2dpLCAnJyApO1xuXG5cdFx0XHQvLyBwYXJzZVxuXG5cdFx0XHRQQ0RoZWFkZXIudmVyc2lvbiA9IC9WRVJTSU9OICguKikvaS5leGVjKCBQQ0RoZWFkZXIuc3RyICk7XG5cdFx0XHRQQ0RoZWFkZXIuZmllbGRzID0gL0ZJRUxEUyAoLiopL2kuZXhlYyggUENEaGVhZGVyLnN0ciApO1xuXHRcdFx0UENEaGVhZGVyLnNpemUgPSAvU0laRSAoLiopL2kuZXhlYyggUENEaGVhZGVyLnN0ciApO1xuXHRcdFx0UENEaGVhZGVyLnR5cGUgPSAvVFlQRSAoLiopL2kuZXhlYyggUENEaGVhZGVyLnN0ciApO1xuXHRcdFx0UENEaGVhZGVyLmNvdW50ID0gL0NPVU5UICguKikvaS5leGVjKCBQQ0RoZWFkZXIuc3RyICk7XG5cdFx0XHRQQ0RoZWFkZXIud2lkdGggPSAvV0lEVEggKC4qKS9pLmV4ZWMoIFBDRGhlYWRlci5zdHIgKTtcblx0XHRcdFBDRGhlYWRlci5oZWlnaHQgPSAvSEVJR0hUICguKikvaS5leGVjKCBQQ0RoZWFkZXIuc3RyICk7XG5cdFx0XHRQQ0RoZWFkZXIudmlld3BvaW50ID0gL1ZJRVdQT0lOVCAoLiopL2kuZXhlYyggUENEaGVhZGVyLnN0ciApO1xuXHRcdFx0UENEaGVhZGVyLnBvaW50cyA9IC9QT0lOVFMgKC4qKS9pLmV4ZWMoIFBDRGhlYWRlci5zdHIgKTtcblxuXHRcdFx0Ly8gZXZhbHVhdGVcblxuXHRcdFx0aWYgKCBQQ0RoZWFkZXIudmVyc2lvbiAhPT0gbnVsbCApXG5cdFx0XHRcdFBDRGhlYWRlci52ZXJzaW9uID0gcGFyc2VGbG9hdCggUENEaGVhZGVyLnZlcnNpb25bIDEgXSApO1xuXG5cdFx0XHRpZiAoIFBDRGhlYWRlci5maWVsZHMgIT09IG51bGwgKVxuXHRcdFx0XHRQQ0RoZWFkZXIuZmllbGRzID0gUENEaGVhZGVyLmZpZWxkc1sgMSBdLnNwbGl0KCAnICcgKTtcblxuXHRcdFx0aWYgKCBQQ0RoZWFkZXIudHlwZSAhPT0gbnVsbCApXG5cdFx0XHRcdFBDRGhlYWRlci50eXBlID0gUENEaGVhZGVyLnR5cGVbIDEgXS5zcGxpdCggJyAnICk7XG5cblx0XHRcdGlmICggUENEaGVhZGVyLndpZHRoICE9PSBudWxsIClcblx0XHRcdFx0UENEaGVhZGVyLndpZHRoID0gcGFyc2VJbnQoIFBDRGhlYWRlci53aWR0aFsgMSBdICk7XG5cblx0XHRcdGlmICggUENEaGVhZGVyLmhlaWdodCAhPT0gbnVsbCApXG5cdFx0XHRcdFBDRGhlYWRlci5oZWlnaHQgPSBwYXJzZUludCggUENEaGVhZGVyLmhlaWdodFsgMSBdICk7XG5cblx0XHRcdGlmICggUENEaGVhZGVyLnZpZXdwb2ludCAhPT0gbnVsbCApXG5cdFx0XHRcdFBDRGhlYWRlci52aWV3cG9pbnQgPSBQQ0RoZWFkZXIudmlld3BvaW50WyAxIF07XG5cblx0XHRcdGlmICggUENEaGVhZGVyLnBvaW50cyAhPT0gbnVsbCApXG5cdFx0XHRcdFBDRGhlYWRlci5wb2ludHMgPSBwYXJzZUludCggUENEaGVhZGVyLnBvaW50c1sgMSBdLCAxMCApO1xuXG5cdFx0XHRpZiAoIFBDRGhlYWRlci5wb2ludHMgPT09IG51bGwgKVxuXHRcdFx0XHRQQ0RoZWFkZXIucG9pbnRzID0gUENEaGVhZGVyLndpZHRoICogUENEaGVhZGVyLmhlaWdodDtcblxuXHRcdFx0aWYgKCBQQ0RoZWFkZXIuc2l6ZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRQQ0RoZWFkZXIuc2l6ZSA9IFBDRGhlYWRlci5zaXplWyAxIF0uc3BsaXQoICcgJyApLm1hcCggZnVuY3Rpb24gKCB4ICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCB4LCAxMCApO1xuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIFBDRGhlYWRlci5jb3VudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRQQ0RoZWFkZXIuY291bnQgPSBQQ0RoZWFkZXIuY291bnRbIDEgXS5zcGxpdCggJyAnICkubWFwKCBmdW5jdGlvbiAoIHggKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQoIHgsIDEwICk7XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFBDRGhlYWRlci5jb3VudCA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IFBDRGhlYWRlci5maWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFBDRGhlYWRlci5jb3VudC5wdXNoKCAxICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdFBDRGhlYWRlci5vZmZzZXQgPSB7fTtcblxuXHRcdFx0dmFyIHNpemVTdW0gPSAwO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBQQ0RoZWFkZXIuZmllbGRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCBQQ0RoZWFkZXIuZGF0YSA9PT0gJ2FzY2lpJyApIHtcblxuXHRcdFx0XHRcdFBDRGhlYWRlci5vZmZzZXRbIFBDRGhlYWRlci5maWVsZHNbIGkgXSBdID0gaTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0UENEaGVhZGVyLm9mZnNldFsgUENEaGVhZGVyLmZpZWxkc1sgaSBdIF0gPSBzaXplU3VtO1xuXHRcdFx0XHRcdHNpemVTdW0gKz0gUENEaGVhZGVyLnNpemVbIGkgXSAqIFBDRGhlYWRlci5jb3VudFsgaSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBmb3IgYmluYXJ5IG9ubHlcblxuXHRcdFx0UENEaGVhZGVyLnJvd1NpemUgPSBzaXplU3VtO1xuXG5cdFx0XHRyZXR1cm4gUENEaGVhZGVyO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHRleHREYXRhID0gTG9hZGVyVXRpbHMuZGVjb2RlVGV4dCggbmV3IFVpbnQ4QXJyYXkoIGRhdGEgKSApO1xuXG5cdFx0Ly8gcGFyc2UgaGVhZGVyIChhbHdheXMgYXNjaWkgZm9ybWF0KVxuXG5cdFx0dmFyIFBDRGhlYWRlciA9IHBhcnNlSGVhZGVyKCB0ZXh0RGF0YSApO1xuXG5cdFx0Ly8gcGFyc2UgZGF0YVxuXG5cdFx0dmFyIHBvc2l0aW9uID0gW107XG5cdFx0dmFyIG5vcm1hbCA9IFtdO1xuXHRcdHZhciBjb2xvciA9IFtdO1xuXG5cdFx0Ly8gYXNjaWlcblxuXHRcdGlmICggUENEaGVhZGVyLmRhdGEgPT09ICdhc2NpaScgKSB7XG5cblx0XHRcdHZhciBvZmZzZXQgPSBQQ0RoZWFkZXIub2Zmc2V0O1xuXHRcdFx0dmFyIHBjZERhdGEgPSB0ZXh0RGF0YS5zdWJzdHIoIFBDRGhlYWRlci5oZWFkZXJMZW4gKTtcblx0XHRcdHZhciBsaW5lcyA9IHBjZERhdGEuc3BsaXQoICdcXG4nICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGxpbmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCBsaW5lc1sgaSBdID09PSAnJyApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHZhciBsaW5lID0gbGluZXNbIGkgXS5zcGxpdCggJyAnICk7XG5cblx0XHRcdFx0aWYgKCBvZmZzZXQueCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0cG9zaXRpb24ucHVzaCggcGFyc2VGbG9hdCggbGluZVsgb2Zmc2V0LnggXSApICk7XG5cdFx0XHRcdFx0cG9zaXRpb24ucHVzaCggcGFyc2VGbG9hdCggbGluZVsgb2Zmc2V0LnkgXSApICk7XG5cdFx0XHRcdFx0cG9zaXRpb24ucHVzaCggcGFyc2VGbG9hdCggbGluZVsgb2Zmc2V0LnogXSApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggb2Zmc2V0LnJnYiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0dmFyIHJnYiA9IHBhcnNlRmxvYXQoIGxpbmVbIG9mZnNldC5yZ2IgXSApO1xuXHRcdFx0XHRcdHZhciByID0gKCByZ2IgPj4gMTYgKSAmIDB4MDAwMGZmO1xuXHRcdFx0XHRcdHZhciBnID0gKCByZ2IgPj4gOCApICYgMHgwMDAwZmY7XG5cdFx0XHRcdFx0dmFyIGIgPSAoIHJnYiA+PiAwICkgJiAweDAwMDBmZjtcblx0XHRcdFx0XHRjb2xvci5wdXNoKCByIC8gMjU1LCBnIC8gMjU1LCBiIC8gMjU1ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggb2Zmc2V0Lm5vcm1hbF94ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRub3JtYWwucHVzaCggcGFyc2VGbG9hdCggbGluZVsgb2Zmc2V0Lm5vcm1hbF94IF0gKSApO1xuXHRcdFx0XHRcdG5vcm1hbC5wdXNoKCBwYXJzZUZsb2F0KCBsaW5lWyBvZmZzZXQubm9ybWFsX3kgXSApICk7XG5cdFx0XHRcdFx0bm9ybWFsLnB1c2goIHBhcnNlRmxvYXQoIGxpbmVbIG9mZnNldC5ub3JtYWxfeiBdICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGJpbmFyeS1jb21wcmVzc2VkXG5cblx0XHQvLyBub3JtYWxseSBkYXRhIGluIFBDRCBmaWxlcyBhcmUgb3JnYW5pemVkIGFzIGFycmF5IG9mIHN0cnVjdHVyZXM6IFhZWlJHQlhZWlJHQlxuXHRcdC8vIGJpbmFyeSBjb21wcmVzc2VkIFBDRCBmaWxlcyBvcmdhbml6ZSB0aGVpciBkYXRhIGFzIHN0cnVjdHVyZSBvZiBhcnJheXM6IFhYWVlaWlJHQlJHQlxuXHRcdC8vIHRoYXQgcmVxdWlyZXMgYSB0b3RhbGx5IGRpZmZlcmVudCBwYXJzaW5nIGFwcHJvYWNoIGNvbXBhcmVkIHRvIG5vbi1jb21wcmVzc2VkIGRhdGFcblxuXHRcdGlmICggUENEaGVhZGVyLmRhdGEgPT09ICdiaW5hcnlfY29tcHJlc3NlZCcgKSB7XG5cblx0XHRcdHZhciBzaXplcyA9IG5ldyBVaW50MzJBcnJheSggZGF0YS5zbGljZSggUENEaGVhZGVyLmhlYWRlckxlbiwgUENEaGVhZGVyLmhlYWRlckxlbiArIDggKSApO1xuXHRcdFx0dmFyIGNvbXByZXNzZWRTaXplID0gc2l6ZXNbIDAgXTtcblx0XHRcdHZhciBkZWNvbXByZXNzZWRTaXplID0gc2l6ZXNbIDEgXTtcblx0XHRcdHZhciBkZWNvbXByZXNzZWQgPSBkZWNvbXByZXNzTFpGKCBuZXcgVWludDhBcnJheSggZGF0YSwgUENEaGVhZGVyLmhlYWRlckxlbiArIDgsIGNvbXByZXNzZWRTaXplICksIGRlY29tcHJlc3NlZFNpemUgKTtcblx0XHRcdHZhciBkYXRhdmlldyA9IG5ldyBEYXRhVmlldyggZGVjb21wcmVzc2VkLmJ1ZmZlciApO1xuXG5cdFx0XHR2YXIgb2Zmc2V0ID0gUENEaGVhZGVyLm9mZnNldDtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgUENEaGVhZGVyLnBvaW50czsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIG9mZnNldC54ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRwb3NpdGlvbi5wdXNoKCBkYXRhdmlldy5nZXRGbG9hdDMyKCAoIFBDRGhlYWRlci5wb2ludHMgKiBvZmZzZXQueCApICsgUENEaGVhZGVyLnNpemVbIDAgXSAqIGksIHRoaXMubGl0dGxlRW5kaWFuICkgKTtcblx0XHRcdFx0XHRwb3NpdGlvbi5wdXNoKCBkYXRhdmlldy5nZXRGbG9hdDMyKCAoIFBDRGhlYWRlci5wb2ludHMgKiBvZmZzZXQueSApICsgUENEaGVhZGVyLnNpemVbIDEgXSAqIGksIHRoaXMubGl0dGxlRW5kaWFuICkgKTtcblx0XHRcdFx0XHRwb3NpdGlvbi5wdXNoKCBkYXRhdmlldy5nZXRGbG9hdDMyKCAoIFBDRGhlYWRlci5wb2ludHMgKiBvZmZzZXQueiApICsgUENEaGVhZGVyLnNpemVbIDIgXSAqIGksIHRoaXMubGl0dGxlRW5kaWFuICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBvZmZzZXQucmdiICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb2xvci5wdXNoKCBkYXRhdmlldy5nZXRVaW50OCggKCBQQ0RoZWFkZXIucG9pbnRzICogb2Zmc2V0LnJnYiApICsgUENEaGVhZGVyLnNpemVbIDMgXSAqIGkgKyAwICkgLyAyNTUuMCApO1xuXHRcdFx0XHRcdGNvbG9yLnB1c2goIGRhdGF2aWV3LmdldFVpbnQ4KCAoIFBDRGhlYWRlci5wb2ludHMgKiBvZmZzZXQucmdiICkgKyBQQ0RoZWFkZXIuc2l6ZVsgMyBdICogaSArIDEgKSAvIDI1NS4wICk7XG5cdFx0XHRcdFx0Y29sb3IucHVzaCggZGF0YXZpZXcuZ2V0VWludDgoICggUENEaGVhZGVyLnBvaW50cyAqIG9mZnNldC5yZ2IgKSArIFBDRGhlYWRlci5zaXplWyAzIF0gKiBpICsgMiApIC8gMjU1LjAgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBvZmZzZXQubm9ybWFsX3ggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdG5vcm1hbC5wdXNoKCBkYXRhdmlldy5nZXRGbG9hdDMyKCAoIFBDRGhlYWRlci5wb2ludHMgKiBvZmZzZXQubm9ybWFsX3ggKSArIFBDRGhlYWRlci5zaXplWyA0IF0gKiBpLCB0aGlzLmxpdHRsZUVuZGlhbiApICk7XG5cdFx0XHRcdFx0bm9ybWFsLnB1c2goIGRhdGF2aWV3LmdldEZsb2F0MzIoICggUENEaGVhZGVyLnBvaW50cyAqIG9mZnNldC5ub3JtYWxfeSApICsgUENEaGVhZGVyLnNpemVbIDUgXSAqIGksIHRoaXMubGl0dGxlRW5kaWFuICkgKTtcblx0XHRcdFx0XHRub3JtYWwucHVzaCggZGF0YXZpZXcuZ2V0RmxvYXQzMiggKCBQQ0RoZWFkZXIucG9pbnRzICogb2Zmc2V0Lm5vcm1hbF96ICkgKyBQQ0RoZWFkZXIuc2l6ZVsgNiBdICogaSwgdGhpcy5saXR0bGVFbmRpYW4gKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gYmluYXJ5XG5cblx0XHRpZiAoIFBDRGhlYWRlci5kYXRhID09PSAnYmluYXJ5JyApIHtcblxuXHRcdFx0dmFyIGRhdGF2aWV3ID0gbmV3IERhdGFWaWV3KCBkYXRhLCBQQ0RoZWFkZXIuaGVhZGVyTGVuICk7XG5cdFx0XHR2YXIgb2Zmc2V0ID0gUENEaGVhZGVyLm9mZnNldDtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCByb3cgPSAwOyBpIDwgUENEaGVhZGVyLnBvaW50czsgaSArKywgcm93ICs9IFBDRGhlYWRlci5yb3dTaXplICkge1xuXG5cdFx0XHRcdGlmICggb2Zmc2V0LnggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHBvc2l0aW9uLnB1c2goIGRhdGF2aWV3LmdldEZsb2F0MzIoIHJvdyArIG9mZnNldC54LCB0aGlzLmxpdHRsZUVuZGlhbiApICk7XG5cdFx0XHRcdFx0cG9zaXRpb24ucHVzaCggZGF0YXZpZXcuZ2V0RmxvYXQzMiggcm93ICsgb2Zmc2V0LnksIHRoaXMubGl0dGxlRW5kaWFuICkgKTtcblx0XHRcdFx0XHRwb3NpdGlvbi5wdXNoKCBkYXRhdmlldy5nZXRGbG9hdDMyKCByb3cgKyBvZmZzZXQueiwgdGhpcy5saXR0bGVFbmRpYW4gKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG9mZnNldC5yZ2IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbG9yLnB1c2goIGRhdGF2aWV3LmdldFVpbnQ4KCByb3cgKyBvZmZzZXQucmdiICsgMiApIC8gMjU1LjAgKTtcblx0XHRcdFx0XHRjb2xvci5wdXNoKCBkYXRhdmlldy5nZXRVaW50OCggcm93ICsgb2Zmc2V0LnJnYiArIDEgKSAvIDI1NS4wICk7XG5cdFx0XHRcdFx0Y29sb3IucHVzaCggZGF0YXZpZXcuZ2V0VWludDgoIHJvdyArIG9mZnNldC5yZ2IgKyAwICkgLyAyNTUuMCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG9mZnNldC5ub3JtYWxfeCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0bm9ybWFsLnB1c2goIGRhdGF2aWV3LmdldEZsb2F0MzIoIHJvdyArIG9mZnNldC5ub3JtYWxfeCwgdGhpcy5saXR0bGVFbmRpYW4gKSApO1xuXHRcdFx0XHRcdG5vcm1hbC5wdXNoKCBkYXRhdmlldy5nZXRGbG9hdDMyKCByb3cgKyBvZmZzZXQubm9ybWFsX3ksIHRoaXMubGl0dGxlRW5kaWFuICkgKTtcblx0XHRcdFx0XHRub3JtYWwucHVzaCggZGF0YXZpZXcuZ2V0RmxvYXQzMiggcm93ICsgb2Zmc2V0Lm5vcm1hbF96LCB0aGlzLmxpdHRsZUVuZGlhbiApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRpZiAoIHBvc2l0aW9uLmxlbmd0aCA+IDAgKSBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgMyApICk7XG5cdFx0aWYgKCBub3JtYWwubGVuZ3RoID4gMCApIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWwsIDMgKSApO1xuXHRcdGlmICggY29sb3IubGVuZ3RoID4gMCApIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGNvbG9yLCAzICkgKTtcblxuXHRcdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0Ly8gYnVpbGQgbWF0ZXJpYWxcblxuXHRcdHZhciBtYXRlcmlhbCA9IG5ldyBQb2ludHNNYXRlcmlhbCggeyBzaXplOiAwLjAwNSB9ICk7XG5cblx0XHRpZiAoIGNvbG9yLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IHRydWU7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRtYXRlcmlhbC5jb2xvci5zZXRIZXgoIE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZiApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgcG9pbnQgY2xvdWRcblxuXHRcdHZhciBtZXNoID0gbmV3IFBvaW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cdFx0dmFyIG5hbWUgPSB1cmwuc3BsaXQoICcnICkucmV2ZXJzZSgpLmpvaW4oICcnICk7XG5cdFx0bmFtZSA9IC8oW15cXC9dKikvLmV4ZWMoIG5hbWUgKTtcblx0XHRuYW1lID0gbmFtZVsgMSBdLnNwbGl0KCAnJyApLnJldmVyc2UoKS5qb2luKCAnJyApO1xuXHRcdG1lc2gubmFtZSA9IG5hbWU7XG5cblx0XHRyZXR1cm4gbWVzaDtcblxuXHR9XG5cbn0gKTtcblxuLyoqXG4gKiBEZXNjcmlwdGlvbjogQSBUSFJFRSBsb2FkZXIgZm9yIFBMWSBBU0NJSSBmaWxlcyAoa25vd24gYXMgdGhlIFBvbHlnb25cbiAqIEZpbGUgRm9ybWF0IG9yIHRoZSBTdGFuZm9yZCBUcmlhbmdsZSBGb3JtYXQpLlxuICpcbiAqIExpbWl0YXRpb25zOiBBU0NJSSBkZWNvZGluZyBhc3N1bWVzIGZpbGUgaXMgVVRGLTguXG4gKlxuICogVXNhZ2U6XG4gKlx0dmFyIGxvYWRlciA9IG5ldyBQTFlMb2FkZXIoKTtcbiAqXHRsb2FkZXIubG9hZCgnLi9tb2RlbHMvcGx5L2FzY2lpL2RvbHBoaW5zLnBseScsIGZ1bmN0aW9uIChnZW9tZXRyeSkge1xuICpcbiAqXHRcdHNjZW5lLmFkZCggbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5ICkgKTtcbiAqXG4gKlx0fSApO1xuICpcbiAqIElmIHRoZSBQTFkgZmlsZSB1c2VzIG5vbiBzdGFuZGFyZCBwcm9wZXJ0eSBuYW1lcywgdGhleSBjYW4gYmUgbWFwcGVkIHdoaWxlXG4gKiBsb2FkaW5nLiBGb3IgZXhhbXBsZSwgdGhlIGZvbGxvd2luZyBtYXBzIHRoZSBwcm9wZXJ0aWVzXG4gKiDigJxkaWZmdXNlXyhyZWR8Z3JlZW58Ymx1ZSnigJ0gaW4gdGhlIGZpbGUgdG8gc3RhbmRhcmQgY29sb3IgbmFtZXMuXG4gKlxuICogbG9hZGVyLnNldFByb3BlcnR5TmFtZU1hcHBpbmcoIHtcbiAqXHRkaWZmdXNlX3JlZDogJ3JlZCcsXG4gKlx0ZGlmZnVzZV9ncmVlbjogJ2dyZWVuJyxcbiAqXHRkaWZmdXNlX2JsdWU6ICdibHVlJ1xuICogfSApO1xuICpcbiAqL1xuXG5cbnZhciBQTFlMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XG5cblx0TG9hZGVyJDEuY2FsbCggdGhpcywgbWFuYWdlciApO1xuXG5cdHRoaXMucHJvcGVydHlOYW1lTWFwcGluZyA9IHt9O1xuXG59O1xuXG5QTFlMb2FkZXIucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTG9hZGVyJDEucHJvdG90eXBlICksIHtcblxuXHRjb25zdHJ1Y3RvcjogUExZTG9hZGVyLFxuXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XG5cdFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xuXHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCB0aGlzLnJlcXVlc3RIZWFkZXIgKTtcblx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCB0aGlzLndpdGhDcmVkZW50aWFscyApO1xuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcblxuXHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRvbkxvYWQoIHNjb3BlLnBhcnNlKCB0ZXh0ICkgKTtcblxuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICkge1xuXG5cdFx0XHRcdFx0b25FcnJvciggZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdH0sXG5cblx0c2V0UHJvcGVydHlOYW1lTWFwcGluZzogZnVuY3Rpb24gKCBtYXBwaW5nICkge1xuXG5cdFx0dGhpcy5wcm9wZXJ0eU5hbWVNYXBwaW5nID0gbWFwcGluZztcblxuXHR9LFxuXG5cdHBhcnNlOiBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cblx0XHRmdW5jdGlvbiBwYXJzZUhlYWRlciggZGF0YSApIHtcblxuXHRcdFx0dmFyIHBhdHRlcm5IZWFkZXIgPSAvcGx5KFtcXHNcXFNdKillbmRfaGVhZGVyXFxyP1xcbi87XG5cdFx0XHR2YXIgaGVhZGVyVGV4dCA9ICcnO1xuXHRcdFx0dmFyIGhlYWRlckxlbmd0aCA9IDA7XG5cdFx0XHR2YXIgcmVzdWx0ID0gcGF0dGVybkhlYWRlci5leGVjKCBkYXRhICk7XG5cblx0XHRcdGlmICggcmVzdWx0ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGhlYWRlclRleHQgPSByZXN1bHRbIDEgXTtcblx0XHRcdFx0aGVhZGVyTGVuZ3RoID0gbmV3IEJsb2IoIFsgcmVzdWx0WyAwIF0gXSApLnNpemU7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGhlYWRlciA9IHtcblx0XHRcdFx0Y29tbWVudHM6IFtdLFxuXHRcdFx0XHRlbGVtZW50czogW10sXG5cdFx0XHRcdGhlYWRlckxlbmd0aDogaGVhZGVyTGVuZ3RoLFxuXHRcdFx0XHRvYmpJbmZvOiAnJ1xuXHRcdFx0fTtcblxuXHRcdFx0dmFyIGxpbmVzID0gaGVhZGVyVGV4dC5zcGxpdCggJ1xcbicgKTtcblx0XHRcdHZhciBjdXJyZW50RWxlbWVudDtcblx0XHRcdHZhciBsaW5lVHlwZSwgbGluZVZhbHVlcztcblxuXHRcdFx0ZnVuY3Rpb24gbWFrZV9wbHlfZWxlbWVudF9wcm9wZXJ0eSggcHJvcGVydFZhbHVlcywgcHJvcGVydHlOYW1lTWFwcGluZyApIHtcblxuXHRcdFx0XHR2YXIgcHJvcGVydHkgPSB7IHR5cGU6IHByb3BlcnRWYWx1ZXNbIDAgXSB9O1xuXG5cdFx0XHRcdGlmICggcHJvcGVydHkudHlwZSA9PT0gJ2xpc3QnICkge1xuXG5cdFx0XHRcdFx0cHJvcGVydHkubmFtZSA9IHByb3BlcnRWYWx1ZXNbIDMgXTtcblx0XHRcdFx0XHRwcm9wZXJ0eS5jb3VudFR5cGUgPSBwcm9wZXJ0VmFsdWVzWyAxIF07XG5cdFx0XHRcdFx0cHJvcGVydHkuaXRlbVR5cGUgPSBwcm9wZXJ0VmFsdWVzWyAyIF07XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHByb3BlcnR5Lm5hbWUgPSBwcm9wZXJ0VmFsdWVzWyAxIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggcHJvcGVydHkubmFtZSBpbiBwcm9wZXJ0eU5hbWVNYXBwaW5nICkge1xuXG5cdFx0XHRcdFx0cHJvcGVydHkubmFtZSA9IHByb3BlcnR5TmFtZU1hcHBpbmdbIHByb3BlcnR5Lm5hbWUgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHByb3BlcnR5O1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgbGluZSA9IGxpbmVzWyBpIF07XG5cdFx0XHRcdGxpbmUgPSBsaW5lLnRyaW0oKTtcblxuXHRcdFx0XHRpZiAoIGxpbmUgPT09ICcnICkgY29udGludWU7XG5cblx0XHRcdFx0bGluZVZhbHVlcyA9IGxpbmUuc3BsaXQoIC9cXHMrLyApO1xuXHRcdFx0XHRsaW5lVHlwZSA9IGxpbmVWYWx1ZXMuc2hpZnQoKTtcblx0XHRcdFx0bGluZSA9IGxpbmVWYWx1ZXMuam9pbiggJyAnICk7XG5cblx0XHRcdFx0c3dpdGNoICggbGluZVR5cGUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdmb3JtYXQnOlxuXG5cdFx0XHRcdFx0XHRoZWFkZXIuZm9ybWF0ID0gbGluZVZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0aGVhZGVyLnZlcnNpb24gPSBsaW5lVmFsdWVzWyAxIF07XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnY29tbWVudCc6XG5cblx0XHRcdFx0XHRcdGhlYWRlci5jb21tZW50cy5wdXNoKCBsaW5lICk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnZWxlbWVudCc6XG5cblx0XHRcdFx0XHRcdGlmICggY3VycmVudEVsZW1lbnQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRoZWFkZXIuZWxlbWVudHMucHVzaCggY3VycmVudEVsZW1lbnQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjdXJyZW50RWxlbWVudCA9IHt9O1xuXHRcdFx0XHRcdFx0Y3VycmVudEVsZW1lbnQubmFtZSA9IGxpbmVWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdGN1cnJlbnRFbGVtZW50LmNvdW50ID0gcGFyc2VJbnQoIGxpbmVWYWx1ZXNbIDEgXSApO1xuXHRcdFx0XHRcdFx0Y3VycmVudEVsZW1lbnQucHJvcGVydGllcyA9IFtdO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3Byb3BlcnR5JzpcblxuXHRcdFx0XHRcdFx0Y3VycmVudEVsZW1lbnQucHJvcGVydGllcy5wdXNoKCBtYWtlX3BseV9lbGVtZW50X3Byb3BlcnR5KCBsaW5lVmFsdWVzLCBzY29wZS5wcm9wZXJ0eU5hbWVNYXBwaW5nICkgKTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdvYmpfaW5mbyc6XG5cblx0XHRcdFx0XHRcdGhlYWRlci5vYmpJbmZvID0gbGluZTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCAndW5oYW5kbGVkJywgbGluZVR5cGUsIGxpbmVWYWx1ZXMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBjdXJyZW50RWxlbWVudCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGhlYWRlci5lbGVtZW50cy5wdXNoKCBjdXJyZW50RWxlbWVudCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBoZWFkZXI7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUFTQ0lJTnVtYmVyKCBuLCB0eXBlICkge1xuXG5cdFx0XHRzd2l0Y2ggKCB0eXBlICkge1xuXG5cdFx0XHRcdGNhc2UgJ2NoYXInOiBjYXNlICd1Y2hhcic6IGNhc2UgJ3Nob3J0JzogY2FzZSAndXNob3J0JzogY2FzZSAnaW50JzogY2FzZSAndWludCc6XG5cdFx0XHRcdGNhc2UgJ2ludDgnOiBjYXNlICd1aW50OCc6IGNhc2UgJ2ludDE2JzogY2FzZSAndWludDE2JzogY2FzZSAnaW50MzInOiBjYXNlICd1aW50MzInOlxuXG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCBuICk7XG5cblx0XHRcdFx0Y2FzZSAnZmxvYXQnOiBjYXNlICdkb3VibGUnOiBjYXNlICdmbG9hdDMyJzogY2FzZSAnZmxvYXQ2NCc6XG5cblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VGbG9hdCggbiApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUFTQ0lJRWxlbWVudCggcHJvcGVydGllcywgbGluZSApIHtcblxuXHRcdFx0dmFyIHZhbHVlcyA9IGxpbmUuc3BsaXQoIC9cXHMrLyApO1xuXG5cdFx0XHR2YXIgZWxlbWVudCA9IHt9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIHByb3BlcnRpZXNbIGkgXS50eXBlID09PSAnbGlzdCcgKSB7XG5cblx0XHRcdFx0XHR2YXIgbGlzdCA9IFtdO1xuXHRcdFx0XHRcdHZhciBuID0gcGFyc2VBU0NJSU51bWJlciggdmFsdWVzLnNoaWZ0KCksIHByb3BlcnRpZXNbIGkgXS5jb3VudFR5cGUgKTtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IG47IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdGxpc3QucHVzaCggcGFyc2VBU0NJSU51bWJlciggdmFsdWVzLnNoaWZ0KCksIHByb3BlcnRpZXNbIGkgXS5pdGVtVHlwZSApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtZW50WyBwcm9wZXJ0aWVzWyBpIF0ubmFtZSBdID0gbGlzdDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0ZWxlbWVudFsgcHJvcGVydGllc1sgaSBdLm5hbWUgXSA9IHBhcnNlQVNDSUlOdW1iZXIoIHZhbHVlcy5zaGlmdCgpLCBwcm9wZXJ0aWVzWyBpIF0udHlwZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbWVudDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlQVNDSUkoIGRhdGEsIGhlYWRlciApIHtcblxuXHRcdFx0Ly8gUExZIGFzY2lpIGZvcm1hdCBzcGVjaWZpY2F0aW9uLCBhcyBwZXIgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QTFlfKGZpbGVfZm9ybWF0KVxuXG5cdFx0XHR2YXIgYnVmZmVyID0ge1xuXHRcdFx0XHRpbmRpY2VzOiBbXSxcblx0XHRcdFx0dmVydGljZXM6IFtdLFxuXHRcdFx0XHRub3JtYWxzOiBbXSxcblx0XHRcdFx0dXZzOiBbXSxcblx0XHRcdFx0ZmFjZVZlcnRleFV2czogW10sXG5cdFx0XHRcdGNvbG9yczogW11cblx0XHRcdH07XG5cblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdHZhciBwYXR0ZXJuQm9keSA9IC9lbmRfaGVhZGVyXFxzKFtcXHNcXFNdKikkLztcblx0XHRcdHZhciBib2R5ID0gJyc7XG5cdFx0XHRpZiAoICggcmVzdWx0ID0gcGF0dGVybkJvZHkuZXhlYyggZGF0YSApICkgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0Ym9keSA9IHJlc3VsdFsgMSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBsaW5lcyA9IGJvZHkuc3BsaXQoICdcXG4nICk7XG5cdFx0XHR2YXIgY3VycmVudEVsZW1lbnQgPSAwO1xuXHRcdFx0dmFyIGN1cnJlbnRFbGVtZW50Q291bnQgPSAwO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGxpbmUgPSBsaW5lc1sgaSBdO1xuXHRcdFx0XHRsaW5lID0gbGluZS50cmltKCk7XG5cdFx0XHRcdGlmICggbGluZSA9PT0gJycgKSB7XG5cblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjdXJyZW50RWxlbWVudENvdW50ID49IGhlYWRlci5lbGVtZW50c1sgY3VycmVudEVsZW1lbnQgXS5jb3VudCApIHtcblxuXHRcdFx0XHRcdGN1cnJlbnRFbGVtZW50ICsrO1xuXHRcdFx0XHRcdGN1cnJlbnRFbGVtZW50Q291bnQgPSAwO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgZWxlbWVudCA9IHBhcnNlQVNDSUlFbGVtZW50KCBoZWFkZXIuZWxlbWVudHNbIGN1cnJlbnRFbGVtZW50IF0ucHJvcGVydGllcywgbGluZSApO1xuXG5cdFx0XHRcdGhhbmRsZUVsZW1lbnQoIGJ1ZmZlciwgaGVhZGVyLmVsZW1lbnRzWyBjdXJyZW50RWxlbWVudCBdLm5hbWUsIGVsZW1lbnQgKTtcblxuXHRcdFx0XHRjdXJyZW50RWxlbWVudENvdW50ICsrO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwb3N0UHJvY2VzcyggYnVmZmVyICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwb3N0UHJvY2VzcyggYnVmZmVyICkge1xuXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdFx0Ly8gbWFuZGF0b3J5IGJ1ZmZlciBkYXRhXG5cblx0XHRcdGlmICggYnVmZmVyLmluZGljZXMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRnZW9tZXRyeS5zZXRJbmRleCggYnVmZmVyLmluZGljZXMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBidWZmZXIudmVydGljZXMsIDMgKSApO1xuXG5cdFx0XHQvLyBvcHRpb25hbCBidWZmZXIgZGF0YVxuXG5cdFx0XHRpZiAoIGJ1ZmZlci5ub3JtYWxzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGJ1ZmZlci5ub3JtYWxzLCAzICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1ZmZlci51dnMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBidWZmZXIudXZzLCAyICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1ZmZlci5jb2xvcnMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBidWZmZXIuY29sb3JzLCAzICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1ZmZlci5mYWNlVmVydGV4VXZzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnkgPSBnZW9tZXRyeS50b05vbkluZGV4ZWQoKTtcblx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggYnVmZmVyLmZhY2VWZXJ0ZXhVdnMsIDIgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVFbGVtZW50KCBidWZmZXIsIGVsZW1lbnROYW1lLCBlbGVtZW50ICkge1xuXG5cdFx0XHRpZiAoIGVsZW1lbnROYW1lID09PSAndmVydGV4JyApIHtcblxuXHRcdFx0XHRidWZmZXIudmVydGljZXMucHVzaCggZWxlbWVudC54LCBlbGVtZW50LnksIGVsZW1lbnQueiApO1xuXG5cdFx0XHRcdGlmICggJ254JyBpbiBlbGVtZW50ICYmICdueScgaW4gZWxlbWVudCAmJiAnbnonIGluIGVsZW1lbnQgKSB7XG5cblx0XHRcdFx0XHRidWZmZXIubm9ybWFscy5wdXNoKCBlbGVtZW50Lm54LCBlbGVtZW50Lm55LCBlbGVtZW50Lm56ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggJ3MnIGluIGVsZW1lbnQgJiYgJ3QnIGluIGVsZW1lbnQgKSB7XG5cblx0XHRcdFx0XHRidWZmZXIudXZzLnB1c2goIGVsZW1lbnQucywgZWxlbWVudC50ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggJ3JlZCcgaW4gZWxlbWVudCAmJiAnZ3JlZW4nIGluIGVsZW1lbnQgJiYgJ2JsdWUnIGluIGVsZW1lbnQgKSB7XG5cblx0XHRcdFx0XHRidWZmZXIuY29sb3JzLnB1c2goIGVsZW1lbnQucmVkIC8gMjU1LjAsIGVsZW1lbnQuZ3JlZW4gLyAyNTUuMCwgZWxlbWVudC5ibHVlIC8gMjU1LjAgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIGVsZW1lbnROYW1lID09PSAnZmFjZScgKSB7XG5cblx0XHRcdFx0dmFyIHZlcnRleF9pbmRpY2VzID0gZWxlbWVudC52ZXJ0ZXhfaW5kaWNlcyB8fCBlbGVtZW50LnZlcnRleF9pbmRleDsgLy8gaXNzdWUgIzkzMzhcblx0XHRcdFx0dmFyIHRleGNvb3JkID0gZWxlbWVudC50ZXhjb29yZDtcblxuXHRcdFx0XHRpZiAoIHZlcnRleF9pbmRpY2VzLmxlbmd0aCA9PT0gMyApIHtcblxuXHRcdFx0XHRcdGJ1ZmZlci5pbmRpY2VzLnB1c2goIHZlcnRleF9pbmRpY2VzWyAwIF0sIHZlcnRleF9pbmRpY2VzWyAxIF0sIHZlcnRleF9pbmRpY2VzWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggdGV4Y29vcmQgJiYgdGV4Y29vcmQubGVuZ3RoID09PSA2ICkge1xuXG5cdFx0XHRcdFx0XHRidWZmZXIuZmFjZVZlcnRleFV2cy5wdXNoKCB0ZXhjb29yZFsgMCBdLCB0ZXhjb29yZFsgMSBdICk7XG5cdFx0XHRcdFx0XHRidWZmZXIuZmFjZVZlcnRleFV2cy5wdXNoKCB0ZXhjb29yZFsgMiBdLCB0ZXhjb29yZFsgMyBdICk7XG5cdFx0XHRcdFx0XHRidWZmZXIuZmFjZVZlcnRleFV2cy5wdXNoKCB0ZXhjb29yZFsgNCBdLCB0ZXhjb29yZFsgNSBdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdmVydGV4X2luZGljZXMubGVuZ3RoID09PSA0ICkge1xuXG5cdFx0XHRcdFx0YnVmZmVyLmluZGljZXMucHVzaCggdmVydGV4X2luZGljZXNbIDAgXSwgdmVydGV4X2luZGljZXNbIDEgXSwgdmVydGV4X2luZGljZXNbIDMgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlci5pbmRpY2VzLnB1c2goIHZlcnRleF9pbmRpY2VzWyAxIF0sIHZlcnRleF9pbmRpY2VzWyAyIF0sIHZlcnRleF9pbmRpY2VzWyAzIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJpbmFyeVJlYWQoIGRhdGF2aWV3LCBhdCwgdHlwZSwgbGl0dGxlX2VuZGlhbiApIHtcblxuXHRcdFx0c3dpdGNoICggdHlwZSApIHtcblxuXHRcdFx0XHQvLyBjb3Jlc3BvbmRlbmNlcyBmb3Igbm9uLXNwZWNpZmljIGxlbmd0aCB0eXBlcyBoZXJlIG1hdGNoIHJwbHk6XG5cdFx0XHRcdGNhc2UgJ2ludDgnOlx0XHRjYXNlICdjaGFyJzpcdCByZXR1cm4gWyBkYXRhdmlldy5nZXRJbnQ4KCBhdCApLCAxIF07XG5cdFx0XHRcdGNhc2UgJ3VpbnQ4JzpcdFx0Y2FzZSAndWNoYXInOlx0IHJldHVybiBbIGRhdGF2aWV3LmdldFVpbnQ4KCBhdCApLCAxIF07XG5cdFx0XHRcdGNhc2UgJ2ludDE2JzpcdFx0Y2FzZSAnc2hvcnQnOlx0IHJldHVybiBbIGRhdGF2aWV3LmdldEludDE2KCBhdCwgbGl0dGxlX2VuZGlhbiApLCAyIF07XG5cdFx0XHRcdGNhc2UgJ3VpbnQxNic6XHRjYXNlICd1c2hvcnQnOiByZXR1cm4gWyBkYXRhdmlldy5nZXRVaW50MTYoIGF0LCBsaXR0bGVfZW5kaWFuICksIDIgXTtcblx0XHRcdFx0Y2FzZSAnaW50MzInOlx0XHRjYXNlICdpbnQnOlx0XHQgcmV0dXJuIFsgZGF0YXZpZXcuZ2V0SW50MzIoIGF0LCBsaXR0bGVfZW5kaWFuICksIDQgXTtcblx0XHRcdFx0Y2FzZSAndWludDMyJzpcdGNhc2UgJ3VpbnQnOlx0IHJldHVybiBbIGRhdGF2aWV3LmdldFVpbnQzMiggYXQsIGxpdHRsZV9lbmRpYW4gKSwgNCBdO1xuXHRcdFx0XHRjYXNlICdmbG9hdDMyJzogY2FzZSAnZmxvYXQnOlx0IHJldHVybiBbIGRhdGF2aWV3LmdldEZsb2F0MzIoIGF0LCBsaXR0bGVfZW5kaWFuICksIDQgXTtcblx0XHRcdFx0Y2FzZSAnZmxvYXQ2NCc6IGNhc2UgJ2RvdWJsZSc6IHJldHVybiBbIGRhdGF2aWV3LmdldEZsb2F0NjQoIGF0LCBsaXR0bGVfZW5kaWFuICksIDggXTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYmluYXJ5UmVhZEVsZW1lbnQoIGRhdGF2aWV3LCBhdCwgcHJvcGVydGllcywgbGl0dGxlX2VuZGlhbiApIHtcblxuXHRcdFx0dmFyIGVsZW1lbnQgPSB7fTtcblx0XHRcdHZhciByZXN1bHQsIHJlYWQgPSAwO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIHByb3BlcnRpZXNbIGkgXS50eXBlID09PSAnbGlzdCcgKSB7XG5cblx0XHRcdFx0XHR2YXIgbGlzdCA9IFtdO1xuXG5cdFx0XHRcdFx0cmVzdWx0ID0gYmluYXJ5UmVhZCggZGF0YXZpZXcsIGF0ICsgcmVhZCwgcHJvcGVydGllc1sgaSBdLmNvdW50VHlwZSwgbGl0dGxlX2VuZGlhbiApO1xuXHRcdFx0XHRcdHZhciBuID0gcmVzdWx0WyAwIF07XG5cdFx0XHRcdFx0cmVhZCArPSByZXN1bHRbIDEgXTtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IG47IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdHJlc3VsdCA9IGJpbmFyeVJlYWQoIGRhdGF2aWV3LCBhdCArIHJlYWQsIHByb3BlcnRpZXNbIGkgXS5pdGVtVHlwZSwgbGl0dGxlX2VuZGlhbiApO1xuXHRcdFx0XHRcdFx0bGlzdC5wdXNoKCByZXN1bHRbIDAgXSApO1xuXHRcdFx0XHRcdFx0cmVhZCArPSByZXN1bHRbIDEgXTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW1lbnRbIHByb3BlcnRpZXNbIGkgXS5uYW1lIF0gPSBsaXN0O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRyZXN1bHQgPSBiaW5hcnlSZWFkKCBkYXRhdmlldywgYXQgKyByZWFkLCBwcm9wZXJ0aWVzWyBpIF0udHlwZSwgbGl0dGxlX2VuZGlhbiApO1xuXHRcdFx0XHRcdGVsZW1lbnRbIHByb3BlcnRpZXNbIGkgXS5uYW1lIF0gPSByZXN1bHRbIDAgXTtcblx0XHRcdFx0XHRyZWFkICs9IHJlc3VsdFsgMSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gWyBlbGVtZW50LCByZWFkIF07XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUJpbmFyeSggZGF0YSwgaGVhZGVyICkge1xuXG5cdFx0XHR2YXIgYnVmZmVyID0ge1xuXHRcdFx0XHRpbmRpY2VzOiBbXSxcblx0XHRcdFx0dmVydGljZXM6IFtdLFxuXHRcdFx0XHRub3JtYWxzOiBbXSxcblx0XHRcdFx0dXZzOiBbXSxcblx0XHRcdFx0ZmFjZVZlcnRleFV2czogW10sXG5cdFx0XHRcdGNvbG9yczogW11cblx0XHRcdH07XG5cblx0XHRcdHZhciBsaXR0bGVfZW5kaWFuID0gKCBoZWFkZXIuZm9ybWF0ID09PSAnYmluYXJ5X2xpdHRsZV9lbmRpYW4nICk7XG5cdFx0XHR2YXIgYm9keSA9IG5ldyBEYXRhVmlldyggZGF0YSwgaGVhZGVyLmhlYWRlckxlbmd0aCApO1xuXHRcdFx0dmFyIHJlc3VsdCwgbG9jID0gMDtcblxuXHRcdFx0Zm9yICggdmFyIGN1cnJlbnRFbGVtZW50ID0gMDsgY3VycmVudEVsZW1lbnQgPCBoZWFkZXIuZWxlbWVudHMubGVuZ3RoOyBjdXJyZW50RWxlbWVudCArKyApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgY3VycmVudEVsZW1lbnRDb3VudCA9IDA7IGN1cnJlbnRFbGVtZW50Q291bnQgPCBoZWFkZXIuZWxlbWVudHNbIGN1cnJlbnRFbGVtZW50IF0uY291bnQ7IGN1cnJlbnRFbGVtZW50Q291bnQgKysgKSB7XG5cblx0XHRcdFx0XHRyZXN1bHQgPSBiaW5hcnlSZWFkRWxlbWVudCggYm9keSwgbG9jLCBoZWFkZXIuZWxlbWVudHNbIGN1cnJlbnRFbGVtZW50IF0ucHJvcGVydGllcywgbGl0dGxlX2VuZGlhbiApO1xuXHRcdFx0XHRcdGxvYyArPSByZXN1bHRbIDEgXTtcblx0XHRcdFx0XHR2YXIgZWxlbWVudCA9IHJlc3VsdFsgMCBdO1xuXG5cdFx0XHRcdFx0aGFuZGxlRWxlbWVudCggYnVmZmVyLCBoZWFkZXIuZWxlbWVudHNbIGN1cnJlbnRFbGVtZW50IF0ubmFtZSwgZWxlbWVudCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcG9zdFByb2Nlc3MoIGJ1ZmZlciApO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdHZhciBnZW9tZXRyeTtcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0aWYgKCBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgKSB7XG5cblx0XHRcdHZhciB0ZXh0ID0gTG9hZGVyVXRpbHMuZGVjb2RlVGV4dCggbmV3IFVpbnQ4QXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0dmFyIGhlYWRlciA9IHBhcnNlSGVhZGVyKCB0ZXh0ICk7XG5cblx0XHRcdGdlb21ldHJ5ID0gaGVhZGVyLmZvcm1hdCA9PT0gJ2FzY2lpJyA/IHBhcnNlQVNDSUkoIHRleHQsIGhlYWRlciApIDogcGFyc2VCaW5hcnkoIGRhdGEsIGhlYWRlciApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Z2VvbWV0cnkgPSBwYXJzZUFTQ0lJKCBkYXRhLCBwYXJzZUhlYWRlciggZGF0YSApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0fVxuXG59ICk7XG5cbi8qIVxuZmZsYXRlIC0gZmFzdCBKYXZhU2NyaXB0IGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb25cbjxodHRwczovLzEwMWFycm93ei5naXRodWIuaW8vZmZsYXRlPlxuTGljZW5zZWQgdW5kZXIgTUlULiBodHRwczovL2dpdGh1Yi5jb20vMTAxYXJyb3d6L2ZmbGF0ZS9ibG9iL21hc3Rlci9MSUNFTlNFXG4qL1xudmFyIGduPXt9LGJuPWZ1bmN0aW9uKG4scix0LGUsaSl7dmFyIGE9Z25bcl18fChnbltyXT1VUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtuXSx7dHlwZTpcInRleHQvamF2YXNjcmlwdFwifSkpKSxvPW5ldyBXb3JrZXIoYSk7cmV0dXJuIG8ub25lcnJvcj1mdW5jdGlvbihmKXtyZXR1cm4gaShmLmVycm9yLG51bGwpfSxvLm9ubWVzc2FnZT1mdW5jdGlvbihmKXtyZXR1cm4gaShudWxsLGYuZGF0YSl9LG8ucG9zdE1lc3NhZ2UodCxlKSxvfSxBPVVpbnQ4QXJyYXksUj1VaW50MTZBcnJheSxucj1VaW50MzJBcnJheSx1cj1uZXcgQShbMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMiwyLDIsMiwzLDMsMywzLDQsNCw0LDQsNSw1LDUsNSwwLDAsMCwwXSksbHI9bmV3IEEoWzAsMCwwLDAsMSwxLDIsMiwzLDMsNCw0LDUsNSw2LDYsNyw3LDgsOCw5LDksMTAsMTAsMTEsMTEsMTIsMTIsMTMsMTMsMCwwXSksTXI9bmV3IEEoWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdKSx3bj1mdW5jdGlvbihuLHIpe2Zvcih2YXIgdD1uZXcgUigzMSksZT0wO2U8MzE7KytlKXRbZV09cis9MTw8bltlLTFdO2Zvcih2YXIgaT1uZXcgbnIodFszMF0pLGU9MTtlPDMwOysrZSlmb3IodmFyIGE9dFtlXTthPHRbZSsxXTsrK2EpaVthXT1hLXRbZV08PDV8ZTtyZXR1cm4gW3QsaV19LHluPXduKHVyLDIpLE5yPXluWzBdLElyPXluWzFdO05yWzI4XT0yNTgsSXJbMjU4XT0yODtmb3IodmFyIG1uPXduKGxyLDApLHpuPW1uWzBdLFFyPW1uWzFdLFVyPW5ldyBSKDMyNzY4KSxUPTA7VDwzMjc2ODsrK1Qpe3ZhciBpcj0oVCY0MzY5MCk+Pj4xfChUJjIxODQ1KTw8MTtpcj0oaXImNTI0MjgpPj4+MnwoaXImMTMxMDcpPDwyLGlyPShpciY2MTY4MCk+Pj40fChpciYzODU1KTw8NCxVcltUXT0oKGlyJjY1MjgwKT4+Pjh8KGlyJjI1NSk8PDgpPj4+MTt9Zm9yKHZhciBWPWZ1bmN0aW9uKG4scix0KXtmb3IodmFyIGU9bi5sZW5ndGgsaT0wLGE9bmV3IFIocik7aTxlOysraSkrK2FbbltpXS0xXTt2YXIgbz1uZXcgUihyKTtmb3IoaT0wO2k8cjsrK2kpb1tpXT1vW2ktMV0rYVtpLTFdPDwxO3ZhciBmO2lmKHQpe2Y9bmV3IFIoMTw8cik7dmFyIGg9MTUtcjtmb3IoaT0wO2k8ZTsrK2kpaWYobltpXSlmb3IodmFyIHM9aTw8NHxuW2ldLHU9ci1uW2ldLGw9b1tuW2ldLTFdKys8PHUscD1sfCgxPDx1KS0xO2w8PXA7KytsKWZbVXJbbF0+Pj5oXT1zO31lbHNlIGZvcihmPW5ldyBSKGUpLGk9MDtpPGU7KytpKW5baV0mJihmW2ldPVVyW29bbltpXS0xXSsrXT4+PjE1LW5baV0pO3JldHVybiBmfSx0cj1uZXcgQSgyODgpLFQ9MDtUPDE0NDsrK1QpdHJbVF09ODtmb3IodmFyIFQ9MTQ0O1Q8MjU2OysrVCl0cltUXT05O2Zvcih2YXIgVD0yNTY7VDwyODA7KytUKXRyW1RdPTc7Zm9yKHZhciBUPTI4MDtUPDI4ODsrK1QpdHJbVF09ODtmb3IodmFyIHZyPW5ldyBBKDMyKSxUPTA7VDwzMjsrK1QpdnJbVF09NTt2YXIgeG49Vih0ciw5LDApLEFuPVYodHIsOSwxKSxEbj1WKHZyLDUsMCksTW49Vih2ciw1LDEpLEdyPWZ1bmN0aW9uKG4pe2Zvcih2YXIgcj1uWzBdLHQ9MTt0PG4ubGVuZ3RoOysrdCluW3RdPnImJihyPW5bdF0pO3JldHVybiByfSxYPWZ1bmN0aW9uKG4scix0KXt2YXIgZT1yLzh8MDtyZXR1cm4gKG5bZV18bltlKzFdPDw4KT4+KHImNykmdH0sT3I9ZnVuY3Rpb24obixyKXt2YXIgdD1yLzh8MDtyZXR1cm4gKG5bdF18blt0KzFdPDw4fG5bdCsyXTw8MTYpPj4ociY3KX0sQ3I9ZnVuY3Rpb24obil7cmV0dXJuIChuLzh8MCkrKG4mNyYmMSl9LCQ9ZnVuY3Rpb24obixyLHQpeyhyPT1udWxsfHxyPDApJiYocj0wKSwodD09bnVsbHx8dD5uLmxlbmd0aCkmJih0PW4ubGVuZ3RoKTt2YXIgZT1uZXcobiBpbnN0YW5jZW9mIFI/UjpuIGluc3RhbmNlb2YgbnI/bnI6QSkodC1yKTtyZXR1cm4gZS5zZXQobi5zdWJhcnJheShyLHQpKSxlfSxGcj1mdW5jdGlvbihuLHIsdCl7dmFyIGU9bi5sZW5ndGg7aWYoIWV8fHQmJiF0LmwmJmU8NSlyZXR1cm4gcnx8bmV3IEEoMCk7dmFyIGk9IXJ8fHQsYT0hdHx8dC5pO3R8fCh0PXt9KSxyfHwocj1uZXcgQShlKjMpKTt2YXIgbz1mdW5jdGlvbihUcil7dmFyIERyPXIubGVuZ3RoO2lmKFRyPkRyKXt2YXIgaHI9bmV3IEEoTWF0aC5tYXgoRHIqMixUcikpO2hyLnNldChyKSxyPWhyO319LGY9dC5mfHwwLGg9dC5wfHwwLHM9dC5ifHwwLHU9dC5sLGw9dC5kLHA9dC5tLHk9dC5uLGM9ZSo4O2Rve2lmKCF1KXt0LmY9Zj1YKG4saCwxKTt2YXIgZz1YKG4saCsxLDMpO2lmKGgrPTMsZylpZihnPT0xKXU9QW4sbD1NbixwPTkseT01O2Vsc2UgaWYoZz09Mil7dmFyIG09WChuLGgsMzEpKzI1NyxEPVgobixoKzEwLDE1KSs0LEM9bStYKG4saCs1LDMxKSsxO2grPTE0O2Zvcih2YXIgVT1uZXcgQShDKSx4PW5ldyBBKDE5KSx2PTA7djxEOysrdil4W01yW3ZdXT1YKG4saCt2KjMsNyk7aCs9RCozO3ZhciBFPUdyKHgpLFM9KDE8PEUpLTE7aWYoIWEmJmgrQyooRSs3KT5jKWJyZWFrO2Zvcih2YXIgSz1WKHgsRSwxKSx2PTA7djxDOyl7dmFyIEk9S1tYKG4saCxTKV07aCs9SSYxNTt2YXIgdz1JPj4+NDtpZih3PDE2KVVbdisrXT13O2Vsc2Uge3ZhciBaPTAsQj0wO2Zvcih3PT0xNj8oQj0zK1gobixoLDMpLGgrPTIsWj1VW3YtMV0pOnc9PTE3PyhCPTMrWChuLGgsNyksaCs9Myk6dz09MTgmJihCPTExK1gobixoLDEyNyksaCs9Nyk7Qi0tOylVW3YrK109Wjt9fXZhciBHPVUuc3ViYXJyYXkoMCxtKSxrPVUuc3ViYXJyYXkobSk7cD1HcihHKSx5PUdyKGspLHU9VihHLHAsMSksbD1WKGsseSwxKTt9ZWxzZSB0aHJvdyBcImludmFsaWQgYmxvY2sgdHlwZVwiO2Vsc2Uge3ZhciB3PUNyKGgpKzQsTT1uW3ctNF18blt3LTNdPDw4LHo9dytNO2lmKHo+ZSl7aWYoYSl0aHJvdyBcInVuZXhwZWN0ZWQgRU9GXCI7YnJlYWt9aSYmbyhzK00pLHIuc2V0KG4uc3ViYXJyYXkodyx6KSxzKSx0LmI9cys9TSx0LnA9aD16Kjg7Y29udGludWV9aWYoaD5jKXRocm93IFwidW5leHBlY3RlZCBFT0ZcIn1pJiZvKHMrMTMxMDcyKTtmb3IodmFyIE89KDE8PHApLTEsSD0oMTw8eSktMSxOPXAreSsxODthfHxoK048Yzspe3ZhciBaPXVbT3IobixoKSZPXSxRPVo+Pj40O2lmKGgrPVomMTUsaD5jKXRocm93IFwidW5leHBlY3RlZCBFT0ZcIjtpZighWil0aHJvdyBcImludmFsaWQgbGVuZ3RoL2xpdGVyYWxcIjtpZihRPDI1NilyW3MrK109UTtlbHNlIGlmKFE9PTI1Nil7dT1udWxsO2JyZWFrfWVsc2Uge3ZhciBXPVEtMjU0O2lmKFE+MjY0KXt2YXIgdj1RLTI1NyxkPXVyW3ZdO1c9WChuLGgsKDE8PGQpLTEpK05yW3ZdLGgrPWQ7fXZhciBfPWxbT3IobixoKSZIXSxqPV8+Pj40O2lmKCFfKXRocm93IFwiaW52YWxpZCBkaXN0YW5jZVwiO2grPV8mMTU7dmFyIGs9em5bal07aWYoaj4zKXt2YXIgZD1scltqXTtrKz1PcihuLGgpJigxPDxkKS0xLGgrPWQ7fWlmKGg+Yyl0aHJvdyBcInVuZXhwZWN0ZWQgRU9GXCI7aSYmbyhzKzEzMTA3Mik7Zm9yKHZhciBxPXMrVztzPHE7cys9NClyW3NdPXJbcy1rXSxyW3MrMV09cltzKzEta10scltzKzJdPXJbcysyLWtdLHJbcyszXT1yW3MrMy1rXTtzPXE7fX10Lmw9dSx0LnA9aCx0LmI9cyx1JiYoZj0xLHQubT1wLHQuZD1sLHQubj15KTt9d2hpbGUoIWYpO3JldHVybiBzPT1yLmxlbmd0aD9yOiQociwwLHMpfSxiPWZ1bmN0aW9uKG4scix0KXt0PDw9ciY3O3ZhciBlPXIvOHwwO25bZV18PXQsbltlKzFdfD10Pj4+ODt9LGNyPWZ1bmN0aW9uKG4scix0KXt0PDw9ciY3O3ZhciBlPXIvOHwwO25bZV18PXQsbltlKzFdfD10Pj4+OCxuW2UrMl18PXQ+Pj4xNjt9LEVyPWZ1bmN0aW9uKG4scil7Zm9yKHZhciB0PVtdLGU9MDtlPG4ubGVuZ3RoOysrZSluW2VdJiZ0LnB1c2goe3M6ZSxmOm5bZV19KTt2YXIgaT10Lmxlbmd0aCxhPXQuc2xpY2UoKTtpZighaSlyZXR1cm4gW2VyLDBdO2lmKGk9PTEpe3ZhciBvPW5ldyBBKHRbMF0ucysxKTtyZXR1cm4gb1t0WzBdLnNdPTEsW28sMV19dC5zb3J0KGZ1bmN0aW9uKEMsVSl7cmV0dXJuIEMuZi1VLmZ9KSx0LnB1c2goe3M6LTEsZjoyNTAwMX0pO3ZhciBmPXRbMF0saD10WzFdLHM9MCx1PTEsbD0yO2Zvcih0WzBdPXtzOi0xLGY6Zi5mK2guZixsOmYscjpofTt1IT1pLTE7KWY9dFt0W3NdLmY8dFtsXS5mP3MrKzpsKytdLGg9dFtzIT11JiZ0W3NdLmY8dFtsXS5mP3MrKzpsKytdLHRbdSsrXT17czotMSxmOmYuZitoLmYsbDpmLHI6aH07Zm9yKHZhciBwPWFbMF0ucyxlPTE7ZTxpOysrZSlhW2VdLnM+cCYmKHA9YVtlXS5zKTt2YXIgeT1uZXcgUihwKzEpLGM9UHIodFt1LTFdLHksMCk7aWYoYz5yKXt2YXIgZT0wLGc9MCx3PWMtcixNPTE8PHc7Zm9yKGEuc29ydChmdW5jdGlvbihVLHgpe3JldHVybiB5W3guc10teVtVLnNdfHxVLmYteC5mfSk7ZTxpOysrZSl7dmFyIHo9YVtlXS5zO2lmKHlbel0+cilnKz1NLSgxPDxjLXlbel0pLHlbel09cjtlbHNlIGJyZWFrfWZvcihnPj4+PXc7Zz4wOyl7dmFyIG09YVtlXS5zO3lbbV08cj9nLT0xPDxyLXlbbV0rKy0xOisrZTt9Zm9yKDtlPj0wJiZnOy0tZSl7dmFyIEQ9YVtlXS5zO3lbRF09PXImJigtLXlbRF0sKytnKTt9Yz1yO31yZXR1cm4gW25ldyBBKHkpLGNdfSxQcj1mdW5jdGlvbihuLHIsdCl7cmV0dXJuIG4ucz09LTE/TWF0aC5tYXgoUHIobi5sLHIsdCsxKSxQcihuLnIscix0KzEpKTpyW24uc109dH0sVnI9ZnVuY3Rpb24obil7Zm9yKHZhciByPW4ubGVuZ3RoO3ImJiFuWy0tcl07KTtmb3IodmFyIHQ9bmV3IFIoKytyKSxlPTAsaT1uWzBdLGE9MSxvPWZ1bmN0aW9uKGgpe3RbZSsrXT1oO30sZj0xO2Y8PXI7KytmKWlmKG5bZl09PWkmJmYhPXIpKythO2Vsc2Uge2lmKCFpJiZhPjIpe2Zvcig7YT4xMzg7YS09MTM4KW8oMzI3NTQpO2E+MiYmKG8oYT4xMD9hLTExPDw1fDI4NjkwOmEtMzw8NXwxMjMwNSksYT0wKTt9ZWxzZSBpZihhPjMpe2ZvcihvKGkpLC0tYTthPjY7YS09NilvKDgzMDQpO2E+MiYmKG8oYS0zPDw1fDgyMDgpLGE9MCk7fWZvcig7YS0tOylvKGkpO2E9MSxpPW5bZl07fXJldHVybiBbdC5zdWJhcnJheSgwLGUpLHJdfSxwcj1mdW5jdGlvbihuLHIpe2Zvcih2YXIgdD0wLGU9MDtlPHIubGVuZ3RoOysrZSl0Kz1uW2VdKnJbZV07cmV0dXJuIHR9LFNyPWZ1bmN0aW9uKG4scix0KXt2YXIgZT10Lmxlbmd0aCxpPUNyKHIrMik7bltpXT1lJjI1NSxuW2krMV09ZT4+PjgsbltpKzJdPW5baV1eMjU1LG5baSszXT1uW2krMV1eMjU1O2Zvcih2YXIgYT0wO2E8ZTsrK2EpbltpK2ErNF09dFthXTtyZXR1cm4gKGkrNCtlKSo4fSxYcj1mdW5jdGlvbihuLHIsdCxlLGksYSxvLGYsaCxzLHUpe2Iocix1KyssdCksKytpWzI1Nl07Zm9yKHZhciBsPUVyKGksMTUpLHA9bFswXSx5PWxbMV0sYz1FcihhLDE1KSxnPWNbMF0sdz1jWzFdLE09VnIocCksej1NWzBdLG09TVsxXSxEPVZyKGcpLEM9RFswXSxVPURbMV0seD1uZXcgUigxOSksdj0wO3Y8ei5sZW5ndGg7Kyt2KXhbelt2XSYzMV0rKztmb3IodmFyIHY9MDt2PEMubGVuZ3RoOysrdil4W0Nbdl0mMzFdKys7Zm9yKHZhciBFPUVyKHgsNyksUz1FWzBdLEs9RVsxXSxJPTE5O0k+NCYmIVNbTXJbSS0xXV07LS1JKTt2YXIgWj1zKzU8PDMsQj1wcihpLHRyKStwcihhLHZyKStvLEc9cHIoaSxwKStwcihhLGcpK28rMTQrMypJK3ByKHgsUykrKDIqeFsxNl0rMyp4WzE3XSs3KnhbMThdKTtpZihaPD1CJiZaPD1HKXJldHVybiBTcihyLHUsbi5zdWJhcnJheShoLGgrcykpO3ZhciBrLE8sSCxOO2lmKGIocix1LDErKEc8QikpLHUrPTIsRzxCKXtrPVYocCx5LDApLE89cCxIPVYoZyx3LDApLE49Zzt2YXIgUT1WKFMsSywwKTtiKHIsdSxtLTI1NyksYihyLHUrNSxVLTEpLGIocix1KzEwLEktNCksdSs9MTQ7Zm9yKHZhciB2PTA7djxJOysrdiliKHIsdSszKnYsU1tNclt2XV0pO3UrPTMqSTtmb3IodmFyIFc9W3osQ10sZD0wO2Q8MjsrK2QpZm9yKHZhciBfPVdbZF0sdj0wO3Y8Xy5sZW5ndGg7Kyt2KXt2YXIgaj1fW3ZdJjMxO2Iocix1LFFbal0pLHUrPVNbal0saj4xNSYmKGIocix1LF9bdl0+Pj41JjEyNyksdSs9X1t2XT4+PjEyKTt9fWVsc2Ugaz14bixPPXRyLEg9RG4sTj12cjtmb3IodmFyIHY9MDt2PGY7Kyt2KWlmKGVbdl0+MjU1KXt2YXIgaj1lW3ZdPj4+MTgmMzE7Y3Iocix1LGtbaisyNTddKSx1Kz1PW2orMjU3XSxqPjcmJihiKHIsdSxlW3ZdPj4+MjMmMzEpLHUrPXVyW2pdKTt2YXIgcT1lW3ZdJjMxO2NyKHIsdSxIW3FdKSx1Kz1OW3FdLHE+MyYmKGNyKHIsdSxlW3ZdPj4+NSY4MTkxKSx1Kz1scltxXSk7fWVsc2UgY3Iocix1LGtbZVt2XV0pLHUrPU9bZVt2XV07cmV0dXJuIGNyKHIsdSxrWzI1Nl0pLHUrT1syNTZdfSxVbj1uZXcgbnIoWzY1NTQwLDEzMTA4MCwxMzEwODgsMTMxMTA0LDI2MjE3NiwxMDQ4NzA0LDEwNDg4MzIsMjExNDU2MCwyMTE3NjMyXSksZXI9bmV3IEEoMCksQ249ZnVuY3Rpb24obixyLHQsZSxpLGEpe3ZhciBvPW4ubGVuZ3RoLGY9bmV3IEEoZStvKzUqKDErTWF0aC5jZWlsKG8vN2UzKSkraSksaD1mLnN1YmFycmF5KGUsZi5sZW5ndGgtaSkscz0wO2lmKCFyfHxvPDgpZm9yKHZhciB1PTA7dTw9bzt1Kz02NTUzNSl7dmFyIGw9dSs2NTUzNTtsPG8/cz1TcihoLHMsbi5zdWJhcnJheSh1LGwpKTooaFt1XT1hLHM9U3IoaCxzLG4uc3ViYXJyYXkodSxvKSkpO31lbHNlIHtmb3IodmFyIHA9VW5bci0xXSx5PXA+Pj4xMyxjPXAmODE5MSxnPSgxPDx0KS0xLHc9bmV3IFIoMzI3NjgpLE09bmV3IFIoZysxKSx6PU1hdGguY2VpbCh0LzMpLG09Mip6LEQ9ZnVuY3Rpb24oS3Ipe3JldHVybiAobltLcl1ebltLcisxXTw8el5uW0tyKzJdPDxtKSZnfSxDPW5ldyBucigyNWUzKSxVPW5ldyBSKDI4OCkseD1uZXcgUigzMiksdj0wLEU9MCx1PTAsUz0wLEs9MCxJPTA7dTxvOysrdSl7dmFyIFo9RCh1KSxCPXUmMzI3NjcsRz1NW1pdO2lmKHdbQl09RyxNW1pdPUIsSzw9dSl7dmFyIGs9by11O2lmKCh2PjdlM3x8Uz4yNDU3NikmJms+NDIzKXtzPVhyKG4saCwwLEMsVSx4LEUsUyxJLHUtSSxzKSxTPXY9RT0wLEk9dTtmb3IodmFyIE89MDtPPDI4NjsrK08pVVtPXT0wO2Zvcih2YXIgTz0wO088MzA7KytPKXhbT109MDt9dmFyIEg9MixOPTAsUT1jLFc9Qi1HJjMyNzY3O2lmKGs+MiYmWj09RCh1LVcpKWZvcih2YXIgZD1NYXRoLm1pbih5LGspLTEsXz1NYXRoLm1pbigzMjc2Nyx1KSxqPU1hdGgubWluKDI1OCxrKTtXPD1fJiYtLVEmJkIhPUc7KXtpZihuW3UrSF09PW5bdStILVddKXtmb3IodmFyIHE9MDtxPGomJm5bdStxXT09blt1K3EtV107KytxKTtpZihxPkgpe2lmKEg9cSxOPVcscT5kKWJyZWFrO2Zvcih2YXIgVHI9TWF0aC5taW4oVyxxLTIpLERyPTAsTz0wO088VHI7KytPKXt2YXIgaHI9dS1XK08rMzI3NjgmMzI3NjcsX249d1tocl0sdm49aHItX24rMzI3NjgmMzI3Njc7dm4+RHImJihEcj12bixHPWhyKTt9fX1CPUcsRz13W0JdLFcrPUItRyszMjc2OCYzMjc2Nzt9aWYoTil7Q1tTKytdPTI2ODQzNTQ1NnxJcltIXTw8MTh8UXJbTl07dmFyIGNuPUlyW0hdJjMxLHBuPVFyW05dJjMxO0UrPXVyW2NuXStscltwbl0sKytVWzI1Nytjbl0sKyt4W3BuXSxLPXUrSCwrK3Y7fWVsc2UgQ1tTKytdPW5bdV0sKytVW25bdV1dO319cz1YcihuLGgsYSxDLFUseCxFLFMsSSx1LUkscyksIWEmJnMmNyYmKHM9U3IoaCxzKzEsZXIpKTt9cmV0dXJuICQoZiwwLGUrQ3IocykraSl9LEZuPWZ1bmN0aW9uKCl7Zm9yKHZhciBuPW5ldyBucigyNTYpLHI9MDtyPDI1NjsrK3Ipe2Zvcih2YXIgdD1yLGU9OTstLWU7KXQ9KHQmMSYmMzk4ODI5MjM4NCledD4+PjE7bltyXT10O31yZXR1cm4gbn0oKSxncj1mdW5jdGlvbigpe3ZhciBuPS0xO3JldHVybiB7cDpmdW5jdGlvbihyKXtmb3IodmFyIHQ9bixlPTA7ZTxyLmxlbmd0aDsrK2UpdD1Gblt0JjI1NV5yW2VdXV50Pj4+ODtuPXQ7fSxkOmZ1bmN0aW9uKCl7cmV0dXJuIH5ufX19LCRyPWZ1bmN0aW9uKCl7dmFyIG49MSxyPTA7cmV0dXJuIHtwOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uLGk9cixhPXQubGVuZ3RoLG89MDtvIT1hOyl7Zm9yKHZhciBmPU1hdGgubWluKG8rMjY1NSxhKTtvPGY7KytvKWkrPWUrPXRbb107ZT0oZSY2NTUzNSkrMTUqKGU+PjE2KSxpPShpJjY1NTM1KSsxNSooaT4+MTYpO31uPWUscj1pO30sZDpmdW5jdGlvbigpe3JldHVybiBuJT02NTUyMSxyJT02NTUyMSwobj4+Pjg8PDE2fChyJjI1NSk8PDh8cj4+PjgpKygobiYyNTUpPDwyMykqMn19fSxzcj1mdW5jdGlvbihuLHIsdCxlLGkpe3JldHVybiBDbihuLHIubGV2ZWw9PW51bGw/NjpyLmxldmVsLHIubWVtPT1udWxsP01hdGguY2VpbChNYXRoLm1heCg4LE1hdGgubWluKDEzLE1hdGgubG9nKG4ubGVuZ3RoKSkpKjEuNSk6MTIrci5tZW0sdCxlLCFpKX0sWnI9ZnVuY3Rpb24obixyKXt2YXIgdD17fTtmb3IodmFyIGUgaW4gbil0W2VdPW5bZV07Zm9yKHZhciBlIGluIHIpdFtlXT1yW2VdO3JldHVybiB0fSxTbj1mdW5jdGlvbihuLHIsdCl7Zm9yKHZhciBlPW4oKSxpPW4udG9TdHJpbmcoKSxhPWkuc2xpY2UoaS5pbmRleE9mKFwiW1wiKSsxLGkubGFzdEluZGV4T2YoXCJdXCIpKS5yZXBsYWNlKC8gL2csXCJcIikuc3BsaXQoXCIsXCIpLG89MDtvPGUubGVuZ3RoOysrbyl7dmFyIGY9ZVtvXSxoPWFbb107aWYodHlwZW9mIGY9PVwiZnVuY3Rpb25cIil7cis9XCI7XCIraCtcIj1cIjt2YXIgcz1mLnRvU3RyaW5nKCk7aWYoZi5wcm90b3R5cGUpaWYocy5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSE9LTEpe3ZhciB1PXMuaW5kZXhPZihcIiBcIiw4KSsxO3IrPXMuc2xpY2UodSxzLmluZGV4T2YoXCIoXCIsdSkpO31lbHNlIHtyKz1zO2Zvcih2YXIgbCBpbiBmLnByb3RvdHlwZSlyKz1cIjtcIitoK1wiLnByb3RvdHlwZS5cIitsK1wiPVwiK2YucHJvdG90eXBlW2xdLnRvU3RyaW5nKCk7fWVsc2Ugcis9czt9ZWxzZSB0W2hdPWY7fXJldHVybiBbcix0XX0sUnI9W10scnQ9ZnVuY3Rpb24obil7dmFyIHI9W107Zm9yKHZhciB0IGluIG4pKG5bdF1pbnN0YW5jZW9mIEF8fG5bdF1pbnN0YW5jZW9mIFJ8fG5bdF1pbnN0YW5jZW9mIG5yKSYmci5wdXNoKChuW3RdPW5ldyBuW3RdLmNvbnN0cnVjdG9yKG5bdF0pKS5idWZmZXIpO3JldHVybiByfSxabj1mdW5jdGlvbihuLHIsdCxlKXt2YXIgaTtpZighUnJbdF0pe2Zvcih2YXIgYT1cIlwiLG89e30sZj1uLmxlbmd0aC0xLGg9MDtoPGY7KytoKWk9U24obltoXSxhLG8pLGE9aVswXSxvPWlbMV07UnJbdF09U24obltmXSxhLG8pO312YXIgcz1acih7fSxSclt0XVsxXSk7cmV0dXJuIGJuKFJyW3RdWzBdK1wiO29ubWVzc2FnZT1mdW5jdGlvbihlKXtmb3IodmFyIGsgaW4gZS5kYXRhKXNlbGZba109ZS5kYXRhW2tdO29ubWVzc2FnZT1cIityLnRvU3RyaW5nKCkrXCJ9XCIsdCxzLHJ0KHMpLGUpfSx3cj1mdW5jdGlvbigpe3JldHVybiBbQSxSLG5yLHVyLGxyLE1yLE5yLHpuLEFuLE1uLFVyLFYsR3IsWCxPcixDciwkLEZyLHhyLGFyLExyXX0seXI9ZnVuY3Rpb24oKXtyZXR1cm4gW0EsUixucix1cixscixNcixJcixRcix4bix0cixEbix2cixVcixVbixlcixWLGIsY3IsRXIsUHIsVnIscHIsU3IsWHIsQ3IsJCxDbixzcixrcixhcl19LGtuPWZ1bmN0aW9uKCl7cmV0dXJuIFtfcixybixGLGdyLEZuXX0sQm49ZnVuY3Rpb24oKXtyZXR1cm4gW2JyLEduXX0sVG49ZnVuY3Rpb24oKXtyZXR1cm4gW25uLEYsJHJdfSxJbj1mdW5jdGlvbigpe3JldHVybiBbT25dfSxhcj1mdW5jdGlvbihuKXtyZXR1cm4gcG9zdE1lc3NhZ2Uobixbbi5idWZmZXJdKX0sTHI9ZnVuY3Rpb24obil7cmV0dXJuIG4mJm4uc2l6ZSYmbmV3IEEobi5zaXplKX0sbXI9ZnVuY3Rpb24obixyLHQsZSxpLGEpe3ZhciBvPVpuKHQsZSxpLGZ1bmN0aW9uKGYsaCl7by50ZXJtaW5hdGUoKSxhKGYsaCk7fSk7cmV0dXJuIG8ucG9zdE1lc3NhZ2UoW24scl0sci5jb25zdW1lP1tuLmJ1ZmZlcl06W10pLGZ1bmN0aW9uKCl7by50ZXJtaW5hdGUoKTt9fSxMPWZ1bmN0aW9uKG4pe3JldHVybiBuLm9uZGF0YT1mdW5jdGlvbihyLHQpe3JldHVybiBwb3N0TWVzc2FnZShbcix0XSxbci5idWZmZXJdKX0sZnVuY3Rpb24ocil7cmV0dXJuIG4ucHVzaChyLmRhdGFbMF0sci5kYXRhWzFdKX19LHpyPWZ1bmN0aW9uKG4scix0LGUsaSl7dmFyIGEsbz1abihuLGUsaSxmdW5jdGlvbihmLGgpe2Y/KG8udGVybWluYXRlKCksci5vbmRhdGEuY2FsbChyLGYpKTooaFsxXSYmby50ZXJtaW5hdGUoKSxyLm9uZGF0YS5jYWxsKHIsZixoWzBdLGhbMV0pKTt9KTtvLnBvc3RNZXNzYWdlKHQpLHIucHVzaD1mdW5jdGlvbihmLGgpe2lmKGEpdGhyb3cgXCJzdHJlYW0gZmluaXNoZWRcIjtpZighci5vbmRhdGEpdGhyb3cgXCJubyBzdHJlYW0gaGFuZGxlclwiO28ucG9zdE1lc3NhZ2UoW2YsYT1oXSxbZi5idWZmZXJdKTt9LHIudGVybWluYXRlPWZ1bmN0aW9uKCl7by50ZXJtaW5hdGUoKTt9O30sWT1mdW5jdGlvbihuLHIpe3JldHVybiBuW3JdfG5bcisxXTw8OH0sUD1mdW5jdGlvbihuLHIpe3JldHVybiAobltyXXxuW3IrMV08PDh8bltyKzJdPDwxNikrKG5bciszXTw8MjMpKjJ9LGRyPWZ1bmN0aW9uKG4scil7cmV0dXJuIFAobixyKXxQKG4scikqNDI5NDk2NzI5Nn0sRj1mdW5jdGlvbihuLHIsdCl7Zm9yKDt0OysrciluW3JdPXQsdD4+Pj04O30sX3I9ZnVuY3Rpb24obixyKXt2YXIgdD1yLmZpbGVuYW1lO2lmKG5bMF09MzEsblsxXT0xMzksblsyXT04LG5bOF09ci5sZXZlbDwyPzQ6ci5sZXZlbD09OT8yOjAsbls5XT0zLHIubXRpbWUhPTAmJkYobiw0LE1hdGguZmxvb3IobmV3IERhdGUoci5tdGltZXx8RGF0ZS5ub3coKSkvMWUzKSksdCl7blszXT04O2Zvcih2YXIgZT0wO2U8PXQubGVuZ3RoOysrZSluW2UrMTBdPXQuY2hhckNvZGVBdChlKTt9fSxicj1mdW5jdGlvbihuKXtpZihuWzBdIT0zMXx8blsxXSE9MTM5fHxuWzJdIT04KXRocm93IFwiaW52YWxpZCBnemlwIGRhdGFcIjt2YXIgcj1uWzNdLHQ9MTA7ciY0JiYodCs9blsxMF18KG5bMTFdPDw4KSsyKTtmb3IodmFyIGU9KHI+PjMmMSkrKHI+PjQmMSk7ZT4wO2UtPSFuW3QrK10pO3JldHVybiB0KyhyJjIpfSxHbj1mdW5jdGlvbihuKXt2YXIgcj1uLmxlbmd0aDtyZXR1cm4gKG5bci00XXxuW3ItM108PDh8bltyLTJdPDwxNikrMioobltyLTFdPDwyMyl9LHJuPWZ1bmN0aW9uKG4pe3JldHVybiAxMCsobi5maWxlbmFtZSYmbi5maWxlbmFtZS5sZW5ndGgrMXx8MCl9LG5uPWZ1bmN0aW9uKG4scil7dmFyIHQ9ci5sZXZlbCxlPXQ9PTA/MDp0PDY/MTp0PT05PzM6MjtuWzBdPTEyMCxuWzFdPWU8PDZ8KGU/MzItMiplOjEpO30sT249ZnVuY3Rpb24obil7aWYoKG5bMF0mMTUpIT04fHxuWzBdPj4+ND43fHwoblswXTw8OHxuWzFdKSUzMSl0aHJvdyBcImludmFsaWQgemxpYiBkYXRhXCI7aWYoblsxXSYzMil0aHJvdyBcImludmFsaWQgemxpYiBkYXRhOiBwcmVzZXQgZGljdGlvbmFyaWVzIG5vdCBzdXBwb3J0ZWRcIn07ZnVuY3Rpb24gdG4obixyKXtyZXR1cm4gIXImJnR5cGVvZiBuPT1cImZ1bmN0aW9uXCImJihyPW4sbj17fSksdGhpcy5vbmRhdGE9cixufXZhciBycj1mdW5jdGlvbigpe2Z1bmN0aW9uIG4ocix0KXshdCYmdHlwZW9mIHI9PVwiZnVuY3Rpb25cIiYmKHQ9cixyPXt9KSx0aGlzLm9uZGF0YT10LHRoaXMubz1yfHx7fTt9cmV0dXJuIG4ucHJvdG90eXBlLnA9ZnVuY3Rpb24ocix0KXt0aGlzLm9uZGF0YShzcihyLHRoaXMubywwLDAsIXQpLHQpO30sbi5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihyLHQpe2lmKHRoaXMuZCl0aHJvdyBcInN0cmVhbSBmaW5pc2hlZFwiO2lmKCF0aGlzLm9uZGF0YSl0aHJvdyBcIm5vIHN0cmVhbSBoYW5kbGVyXCI7dGhpcy5kPXQsdGhpcy5wKHIsdHx8ITEpO30sbn0oKSxFbj1mdW5jdGlvbigpe2Z1bmN0aW9uIG4ocix0KXt6cihbeXIsZnVuY3Rpb24oKXtyZXR1cm4gW0wscnJdfV0sdGhpcyx0bi5jYWxsKHRoaXMscix0KSxmdW5jdGlvbihlKXt2YXIgaT1uZXcgcnIoZS5kYXRhKTtvbm1lc3NhZ2U9TChpKTt9LDYpO31yZXR1cm4gbn0oKTtmdW5jdGlvbiBQbihuLHIsdCl7aWYodHx8KHQ9cixyPXt9KSx0eXBlb2YgdCE9XCJmdW5jdGlvblwiKXRocm93IFwibm8gY2FsbGJhY2tcIjtyZXR1cm4gbXIobixyLFt5cl0sZnVuY3Rpb24oZSl7cmV0dXJuIGFyKGtyKGUuZGF0YVswXSxlLmRhdGFbMV0pKX0sMCx0KX1mdW5jdGlvbiBrcihuLHIpe3JldHVybiBzcihuLHJ8fHt9LDAsMCl9dmFyIEo9ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKHIpe3RoaXMucz17fSx0aGlzLnA9bmV3IEEoMCksdGhpcy5vbmRhdGE9cjt9cmV0dXJuIG4ucHJvdG90eXBlLmU9ZnVuY3Rpb24ocil7aWYodGhpcy5kKXRocm93IFwic3RyZWFtIGZpbmlzaGVkXCI7aWYoIXRoaXMub25kYXRhKXRocm93IFwibm8gc3RyZWFtIGhhbmRsZXJcIjt2YXIgdD10aGlzLnAubGVuZ3RoLGU9bmV3IEEodCtyLmxlbmd0aCk7ZS5zZXQodGhpcy5wKSxlLnNldChyLHQpLHRoaXMucD1lO30sbi5wcm90b3R5cGUuYz1mdW5jdGlvbihyKXt0aGlzLmQ9dGhpcy5zLmk9cnx8ITE7dmFyIHQ9dGhpcy5zLmIsZT1Gcih0aGlzLnAsdGhpcy5vLHRoaXMucyk7dGhpcy5vbmRhdGEoJChlLHQsdGhpcy5zLmIpLHRoaXMuZCksdGhpcy5vPSQoZSx0aGlzLnMuYi0zMjc2OCksdGhpcy5zLmI9dGhpcy5vLmxlbmd0aCx0aGlzLnA9JCh0aGlzLnAsdGhpcy5zLnAvOHwwKSx0aGlzLnMucCY9Nzt9LG4ucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24ocix0KXt0aGlzLmUociksdGhpcy5jKHQpO30sbn0oKSxlbj1mdW5jdGlvbigpe2Z1bmN0aW9uIG4ocil7dGhpcy5vbmRhdGE9cix6cihbd3IsZnVuY3Rpb24oKXtyZXR1cm4gW0wsSl19XSx0aGlzLDAsZnVuY3Rpb24oKXt2YXIgdD1uZXcgSjtvbm1lc3NhZ2U9TCh0KTt9LDcpO31yZXR1cm4gbn0oKTtmdW5jdGlvbiBhbihuLHIsdCl7aWYodHx8KHQ9cixyPXt9KSx0eXBlb2YgdCE9XCJmdW5jdGlvblwiKXRocm93IFwibm8gY2FsbGJhY2tcIjtyZXR1cm4gbXIobixyLFt3cl0sZnVuY3Rpb24oZSl7cmV0dXJuIGFyKHhyKGUuZGF0YVswXSxMcihlLmRhdGFbMV0pKSl9LDEsdCl9ZnVuY3Rpb24geHIobixyKXtyZXR1cm4gRnIobixyKX12YXIgcXI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKHIsdCl7dGhpcy5jPWdyKCksdGhpcy5sPTAsdGhpcy52PTEscnIuY2FsbCh0aGlzLHIsdCk7fXJldHVybiBuLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHIsdCl7cnIucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLHIsdCk7fSxuLnByb3RvdHlwZS5wPWZ1bmN0aW9uKHIsdCl7dGhpcy5jLnAociksdGhpcy5sKz1yLmxlbmd0aDt2YXIgZT1zcihyLHRoaXMubyx0aGlzLnYmJnJuKHRoaXMubyksdCYmOCwhdCk7dGhpcy52JiYoX3IoZSx0aGlzLm8pLHRoaXMudj0wKSx0JiYoRihlLGUubGVuZ3RoLTgsdGhpcy5jLmQoKSksRihlLGUubGVuZ3RoLTQsdGhpcy5sKSksdGhpcy5vbmRhdGEoZSx0KTt9LG59KCksUm49ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKHIsdCl7enIoW3lyLGtuLGZ1bmN0aW9uKCl7cmV0dXJuIFtMLHJyLHFyXX1dLHRoaXMsdG4uY2FsbCh0aGlzLHIsdCksZnVuY3Rpb24oZSl7dmFyIGk9bmV3IHFyKGUuZGF0YSk7b25tZXNzYWdlPUwoaSk7fSw4KTt9cmV0dXJuIG59KCk7ZnVuY3Rpb24gcW4obixyLHQpe2lmKHR8fCh0PXIscj17fSksdHlwZW9mIHQhPVwiZnVuY3Rpb25cIil0aHJvdyBcIm5vIGNhbGxiYWNrXCI7cmV0dXJuIG1yKG4scixbeXIsa24sZnVuY3Rpb24oKXtyZXR1cm4gW0hyXX1dLGZ1bmN0aW9uKGUpe3JldHVybiBhcihIcihlLmRhdGFbMF0sZS5kYXRhWzFdKSl9LDIsdCl9ZnVuY3Rpb24gSHIobixyKXtyfHwocj17fSk7dmFyIHQ9Z3IoKSxlPW4ubGVuZ3RoO3QucChuKTt2YXIgaT1zcihuLHIscm4ociksOCksYT1pLmxlbmd0aDtyZXR1cm4gX3IoaSxyKSxGKGksYS04LHQuZCgpKSxGKGksYS00LGUpLGl9dmFyIFdyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihyKXt0aGlzLnY9MSxKLmNhbGwodGhpcyxyKTt9cmV0dXJuIG4ucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24ocix0KXtpZihKLnByb3RvdHlwZS5lLmNhbGwodGhpcyxyKSx0aGlzLnYpe3ZhciBlPXRoaXMucC5sZW5ndGg+Mz9icih0aGlzLnApOjQ7aWYoZT49dGhpcy5wLmxlbmd0aCYmIXQpcmV0dXJuO3RoaXMucD10aGlzLnAuc3ViYXJyYXkoZSksdGhpcy52PTA7fWlmKHQpe2lmKHRoaXMucC5sZW5ndGg8OCl0aHJvdyBcImludmFsaWQgZ3ppcCBzdHJlYW1cIjt0aGlzLnA9dGhpcy5wLnN1YmFycmF5KDAsLTgpO31KLnByb3RvdHlwZS5jLmNhbGwodGhpcyx0KTt9LG59KCksSG49ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKHIpe3RoaXMub25kYXRhPXIsenIoW3dyLEJuLGZ1bmN0aW9uKCl7cmV0dXJuIFtMLEosV3JdfV0sdGhpcywwLGZ1bmN0aW9uKCl7dmFyIHQ9bmV3IFdyO29ubWVzc2FnZT1MKHQpO30sOSk7fXJldHVybiBufSgpO2Z1bmN0aW9uIFduKG4scix0KXtpZih0fHwodD1yLHI9e30pLHR5cGVvZiB0IT1cImZ1bmN0aW9uXCIpdGhyb3cgXCJubyBjYWxsYmFja1wiO3JldHVybiBtcihuLHIsW3dyLEJuLGZ1bmN0aW9uKCl7cmV0dXJuIFtZcl19XSxmdW5jdGlvbihlKXtyZXR1cm4gYXIoWXIoZS5kYXRhWzBdKSl9LDMsdCl9ZnVuY3Rpb24gWXIobixyKXtyZXR1cm4gRnIobi5zdWJhcnJheShicihuKSwtOCkscnx8bmV3IEEoR24obikpKX12YXIgb249ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKHIsdCl7dGhpcy5jPSRyKCksdGhpcy52PTEscnIuY2FsbCh0aGlzLHIsdCk7fXJldHVybiBuLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHIsdCl7cnIucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLHIsdCk7fSxuLnByb3RvdHlwZS5wPWZ1bmN0aW9uKHIsdCl7dGhpcy5jLnAocik7dmFyIGU9c3Iocix0aGlzLm8sdGhpcy52JiYyLHQmJjQsIXQpO3RoaXMudiYmKG5uKGUsdGhpcy5vKSx0aGlzLnY9MCksdCYmRihlLGUubGVuZ3RoLTQsdGhpcy5jLmQoKSksdGhpcy5vbmRhdGEoZSx0KTt9LG59KCksbnQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKHIsdCl7enIoW3lyLFRuLGZ1bmN0aW9uKCl7cmV0dXJuIFtMLHJyLG9uXX1dLHRoaXMsdG4uY2FsbCh0aGlzLHIsdCksZnVuY3Rpb24oZSl7dmFyIGk9bmV3IG9uKGUuZGF0YSk7b25tZXNzYWdlPUwoaSk7fSwxMCk7fXJldHVybiBufSgpO2Z1bmN0aW9uIHR0KG4scix0KXtpZih0fHwodD1yLHI9e30pLHR5cGVvZiB0IT1cImZ1bmN0aW9uXCIpdGhyb3cgXCJubyBjYWxsYmFja1wiO3JldHVybiBtcihuLHIsW3lyLFRuLGZ1bmN0aW9uKCl7cmV0dXJuIFtmbl19XSxmdW5jdGlvbihlKXtyZXR1cm4gYXIoZm4oZS5kYXRhWzBdLGUuZGF0YVsxXSkpfSw0LHQpfWZ1bmN0aW9uIGZuKG4scil7cnx8KHI9e30pO3ZhciB0PSRyKCk7dC5wKG4pO3ZhciBlPXNyKG4sciwyLDQpO3JldHVybiBubihlLHIpLEYoZSxlLmxlbmd0aC00LHQuZCgpKSxlfXZhciBqcj1mdW5jdGlvbigpe2Z1bmN0aW9uIG4ocil7dGhpcy52PTEsSi5jYWxsKHRoaXMscik7fXJldHVybiBuLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHIsdCl7aWYoSi5wcm90b3R5cGUuZS5jYWxsKHRoaXMsciksdGhpcy52KXtpZih0aGlzLnAubGVuZ3RoPDImJiF0KXJldHVybjt0aGlzLnA9dGhpcy5wLnN1YmFycmF5KDIpLHRoaXMudj0wO31pZih0KXtpZih0aGlzLnAubGVuZ3RoPDQpdGhyb3cgXCJpbnZhbGlkIHpsaWIgc3RyZWFtXCI7dGhpcy5wPXRoaXMucC5zdWJhcnJheSgwLC00KTt9Si5wcm90b3R5cGUuYy5jYWxsKHRoaXMsdCk7fSxufSgpLFluPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihyKXt0aGlzLm9uZGF0YT1yLHpyKFt3cixJbixmdW5jdGlvbigpe3JldHVybiBbTCxKLGpyXX1dLHRoaXMsMCxmdW5jdGlvbigpe3ZhciB0PW5ldyBqcjtvbm1lc3NhZ2U9TCh0KTt9LDExKTt9cmV0dXJuIG59KCk7ZnVuY3Rpb24gam4obixyLHQpe2lmKHR8fCh0PXIscj17fSksdHlwZW9mIHQhPVwiZnVuY3Rpb25cIil0aHJvdyBcIm5vIGNhbGxiYWNrXCI7cmV0dXJuIG1yKG4scixbd3IsSW4sZnVuY3Rpb24oKXtyZXR1cm4gW0pyXX1dLGZ1bmN0aW9uKGUpe3JldHVybiBhcihKcihlLmRhdGFbMF0sTHIoZS5kYXRhWzFdKSkpfSw1LHQpfWZ1bmN0aW9uIEpyKG4scil7cmV0dXJuIEZyKChPbihuKSxuLnN1YmFycmF5KDIsLTQpKSxyKX12YXIgSm49ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKHIpe3RoaXMuRz1Xcix0aGlzLkk9Six0aGlzLlo9anIsdGhpcy5vbmRhdGE9cjt9cmV0dXJuIG4ucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24ocix0KXtpZighdGhpcy5vbmRhdGEpdGhyb3cgXCJubyBzdHJlYW0gaGFuZGxlclwiO2lmKHRoaXMucyl0aGlzLnMucHVzaChyLHQpO2Vsc2Uge2lmKHRoaXMucCYmdGhpcy5wLmxlbmd0aCl7dmFyIGU9bmV3IEEodGhpcy5wLmxlbmd0aCtyLmxlbmd0aCk7ZS5zZXQodGhpcy5wKSxlLnNldChyLHRoaXMucC5sZW5ndGgpO31lbHNlIHRoaXMucD1yO2lmKHRoaXMucC5sZW5ndGg+Mil7dmFyIGk9dGhpcyxhPWZ1bmN0aW9uKCl7aS5vbmRhdGEuYXBwbHkoaSxhcmd1bWVudHMpO307dGhpcy5zPXRoaXMucFswXT09MzEmJnRoaXMucFsxXT09MTM5JiZ0aGlzLnBbMl09PTg/bmV3IHRoaXMuRyhhKToodGhpcy5wWzBdJjE1KSE9OHx8dGhpcy5wWzBdPj40Pjd8fCh0aGlzLnBbMF08PDh8dGhpcy5wWzFdKSUzMT9uZXcgdGhpcy5JKGEpOm5ldyB0aGlzLlooYSksdGhpcy5zLnB1c2godGhpcy5wLHQpLHRoaXMucD1udWxsO319fSxufSgpLGV0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihyKXt0aGlzLkc9SG4sdGhpcy5JPWVuLHRoaXMuWj1Zbix0aGlzLm9uZGF0YT1yO31yZXR1cm4gbi5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihyLHQpe0puLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcyxyLHQpO30sbn0oKTtmdW5jdGlvbiBpdChuLHIsdCl7aWYodHx8KHQ9cixyPXt9KSx0eXBlb2YgdCE9XCJmdW5jdGlvblwiKXRocm93IFwibm8gY2FsbGJhY2tcIjtyZXR1cm4gblswXT09MzEmJm5bMV09PTEzOSYmblsyXT09OD9XbihuLHIsdCk6KG5bMF0mMTUpIT04fHxuWzBdPj40Pjd8fChuWzBdPDw4fG5bMV0pJTMxP2FuKG4scix0KTpqbihuLHIsdCl9ZnVuY3Rpb24gYXQobixyKXtyZXR1cm4gblswXT09MzEmJm5bMV09PTEzOSYmblsyXT09OD9ZcihuLHIpOihuWzBdJjE1KSE9OHx8blswXT4+ND43fHwoblswXTw8OHxuWzFdKSUzMT94cihuLHIpOkpyKG4scil9dmFyIHNuPWZ1bmN0aW9uKG4scix0LGUpe2Zvcih2YXIgaSBpbiBuKXt2YXIgYT1uW2ldLG89citpO2EgaW5zdGFuY2VvZiBBP3Rbb109W2EsZV06QXJyYXkuaXNBcnJheShhKT90W29dPVthWzBdLFpyKGUsYVsxXSldOnNuKGEsbytcIi9cIix0LGUpO319LEtuPXR5cGVvZiBUZXh0RW5jb2RlciE9XCJ1bmRlZmluZWRcIiYmbmV3IFRleHRFbmNvZGVyLGhuPXR5cGVvZiBUZXh0RGVjb2RlciE9XCJ1bmRlZmluZWRcIiYmbmV3IFRleHREZWNvZGVyLE5uPTA7dHJ5e2huLmRlY29kZShlcix7c3RyZWFtOiEwfSksTm49MTt9Y2F0Y2gobil7fXZhciBRbj1mdW5jdGlvbihuKXtmb3IodmFyIHI9XCJcIix0PTA7Oyl7dmFyIGU9blt0KytdLGk9KGU+MTI3KSsoZT4yMjMpKyhlPjIzOSk7aWYodCtpPm4ubGVuZ3RoKXJldHVybiBbciwkKG4sdC0xKV07aT9pPT0zPyhlPSgoZSYxNSk8PDE4fChuW3QrK10mNjMpPDwxMnwoblt0KytdJjYzKTw8NnxuW3QrK10mNjMpLTY1NTM2LHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8ZT4+MTAsNTYzMjB8ZSYxMDIzKSk6aSYxP3IrPVN0cmluZy5mcm9tQ2hhckNvZGUoKGUmMzEpPDw2fG5bdCsrXSY2Myk6cis9U3RyaW5nLmZyb21DaGFyQ29kZSgoZSYxNSk8PDEyfChuW3QrK10mNjMpPDw2fG5bdCsrXSY2Myk6cis9U3RyaW5nLmZyb21DaGFyQ29kZShlKTt9fSxvdD1mdW5jdGlvbigpe2Z1bmN0aW9uIG4ocil7dGhpcy5vbmRhdGE9cixObj90aGlzLnQ9bmV3IFRleHREZWNvZGVyOnRoaXMucD1lcjt9cmV0dXJuIG4ucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24ocix0KXtpZighdGhpcy5vbmRhdGEpdGhyb3cgXCJubyBjYWxsYmFja1wiO2lmKHR8fCh0PSExKSx0aGlzLnQpcmV0dXJuIHRoaXMub25kYXRhKHRoaXMudC5kZWNvZGUocix7c3RyZWFtOiF0fSksdCk7dmFyIGU9bmV3IEEodGhpcy5wLmxlbmd0aCtyLmxlbmd0aCk7ZS5zZXQodGhpcy5wKSxlLnNldChyLHRoaXMucC5sZW5ndGgpO3ZhciBpPVFuKGUpLGE9aVswXSxvPWlbMV07aWYodCYmby5sZW5ndGgpdGhyb3cgXCJpbnZhbGlkIHV0Zi04IGRhdGFcIjt0aGlzLnA9byx0aGlzLm9uZGF0YShhLHQpO30sbn0oKSxmdD1mdW5jdGlvbigpe2Z1bmN0aW9uIG4ocil7dGhpcy5vbmRhdGE9cjt9cmV0dXJuIG4ucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24ocix0KXtpZighdGhpcy5vbmRhdGEpdGhyb3cgXCJubyBjYWxsYmFja1wiO3RoaXMub25kYXRhKG9yKHIpLHR8fCExKTt9LG59KCk7ZnVuY3Rpb24gb3IobixyKXtpZihyKXtmb3IodmFyIHQ9bmV3IEEobi5sZW5ndGgpLGU9MDtlPG4ubGVuZ3RoOysrZSl0W2VdPW4uY2hhckNvZGVBdChlKTtyZXR1cm4gdH1pZihLbilyZXR1cm4gS24uZW5jb2RlKG4pO2Zvcih2YXIgaT1uLmxlbmd0aCxhPW5ldyBBKG4ubGVuZ3RoKyhuLmxlbmd0aD4+MSkpLG89MCxmPWZ1bmN0aW9uKHUpe2FbbysrXT11O30sZT0wO2U8aTsrK2Upe2lmKG8rNT5hLmxlbmd0aCl7dmFyIGg9bmV3IEEobys4KyhpLWU8PDEpKTtoLnNldChhKSxhPWg7fXZhciBzPW4uY2hhckNvZGVBdChlKTtzPDEyOHx8cj9mKHMpOnM8MjA0OD8oZigxOTJ8cz4+PjYpLGYoMTI4fHMmNjMpKTpzPjU1Mjk1JiZzPDU3MzQ0PyhzPTY1NTM2KyhzJjEwMjM8PDEwKXxuLmNoYXJDb2RlQXQoKytlKSYxMDIzLGYoMjQwfHM+Pj4xOCksZigxMjh8cz4+PjEyJjYzKSxmKDEyOHxzPj4+NiY2MyksZigxMjh8cyY2MykpOihmKDIyNHxzPj4+MTIpLGYoMTI4fHM+Pj42JjYzKSxmKDEyOHxzJjYzKSk7fXJldHVybiAkKGEsMCxvKX1mdW5jdGlvbiB1bihuLHIpe2lmKHIpe2Zvcih2YXIgdD1cIlwiLGU9MDtlPG4ubGVuZ3RoO2UrPTE2Mzg0KXQrPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxuLnN1YmFycmF5KGUsZSsxNjM4NCkpO3JldHVybiB0fWVsc2Uge2lmKGhuKXJldHVybiBobi5kZWNvZGUobik7dmFyIGk9UW4obiksYT1pWzBdLG89aVsxXTtpZihvLmxlbmd0aCl0aHJvdyBcImludmFsaWQgdXRmLTggZGF0YVwiO3JldHVybiBhfX12YXIgVm49ZnVuY3Rpb24obil7cmV0dXJuIG49PTE/MzpuPDY/MjpuPT05PzE6MH0sWG49ZnVuY3Rpb24obixyKXtyZXR1cm4gciszMCtZKG4scisyNikrWShuLHIrMjgpfSwkbj1mdW5jdGlvbihuLHIsdCl7dmFyIGU9WShuLHIrMjgpLGk9dW4obi5zdWJhcnJheShyKzQ2LHIrNDYrZSksIShZKG4scis4KSYyMDQ4KSksYT1yKzQ2K2Usbz1QKG4scisyMCksZj10JiZvPT00Mjk0OTY3Mjk1P0xuKG4sYSk6W28sUChuLHIrMjQpLFAobixyKzQyKV0saD1mWzBdLHM9ZlsxXSx1PWZbMl07cmV0dXJuIFtZKG4scisxMCksaCxzLGksYStZKG4sciszMCkrWShuLHIrMzIpLHVdfSxMbj1mdW5jdGlvbihuLHIpe2Zvcig7WShuLHIpIT0xO3IrPTQrWShuLHIrMikpO3JldHVybiBbZHIobixyKzEyKSxkcihuLHIrNCksZHIobixyKzIwKV19LGZyPWZ1bmN0aW9uKG4pe3ZhciByPTA7aWYobilmb3IodmFyIHQgaW4gbil7dmFyIGU9blt0XS5sZW5ndGg7aWYoZT42NTUzNSl0aHJvdyBcImV4dHJhIGZpZWxkIHRvbyBsb25nXCI7cis9ZSs0O31yZXR1cm4gcn0sQXI9ZnVuY3Rpb24obixyLHQsZSxpLGEsbyxmKXt2YXIgaD1lLmxlbmd0aCxzPXQuZXh0cmEsdT1mJiZmLmxlbmd0aCxsPWZyKHMpO0YobixyLG8hPW51bGw/MzM2MzkyNDg6NjczMjQ3NTIpLHIrPTQsbyE9bnVsbCYmKG5bcisrXT0yMCxuW3IrK109dC5vcyksbltyXT0yMCxyKz0yLG5bcisrXT10LmZsYWc8PDF8KGE9PW51bGwmJjgpLG5bcisrXT1pJiY4LG5bcisrXT10LmNvbXByZXNzaW9uJjI1NSxuW3IrK109dC5jb21wcmVzc2lvbj4+ODt2YXIgcD1uZXcgRGF0ZSh0Lm10aW1lPT1udWxsP0RhdGUubm93KCk6dC5tdGltZSkseT1wLmdldEZ1bGxZZWFyKCktMTk4MDtpZih5PDB8fHk+MTE5KXRocm93IFwiZGF0ZSBub3QgaW4gcmFuZ2UgMTk4MC0yMDk5XCI7aWYoRihuLHIsKHk8PDI0KSoyfHAuZ2V0TW9udGgoKSsxPDwyMXxwLmdldERhdGUoKTw8MTZ8cC5nZXRIb3VycygpPDwxMXxwLmdldE1pbnV0ZXMoKTw8NXxwLmdldFNlY29uZHMoKT4+PjEpLHIrPTQsYSE9bnVsbCYmKEYobixyLHQuY3JjKSxGKG4scis0LGEpLEYobixyKzgsdC5zaXplKSksRihuLHIrMTIsaCksRihuLHIrMTQsbCkscis9MTYsbyE9bnVsbCYmKEYobixyLHUpLEYobixyKzYsdC5hdHRycyksRihuLHIrMTAsbykscis9MTQpLG4uc2V0KGUscikscis9aCxsKWZvcih2YXIgYyBpbiBzKXt2YXIgZz1zW2NdLHc9Zy5sZW5ndGg7RihuLHIsK2MpLEYobixyKzIsdyksbi5zZXQoZyxyKzQpLHIrPTQrdzt9cmV0dXJuIHUmJihuLnNldChmLHIpLHIrPXUpLHJ9LGxuPWZ1bmN0aW9uKG4scix0LGUsaSl7RihuLHIsMTAxMDEwMjU2KSxGKG4scis4LHQpLEYobixyKzEwLHQpLEYobixyKzEyLGUpLEYobixyKzE2LGkpO30sQnI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKHIpe3RoaXMuZmlsZW5hbWU9cix0aGlzLmM9Z3IoKSx0aGlzLnNpemU9MCx0aGlzLmNvbXByZXNzaW9uPTA7fXJldHVybiBuLnByb3RvdHlwZS5wcm9jZXNzPWZ1bmN0aW9uKHIsdCl7dGhpcy5vbmRhdGEobnVsbCxyLHQpO30sbi5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihyLHQpe2lmKCF0aGlzLm9uZGF0YSl0aHJvdyBcIm5vIGNhbGxiYWNrIC0gYWRkIHRvIFpJUCBhcmNoaXZlIGJlZm9yZSBwdXNoaW5nXCI7dGhpcy5jLnAociksdGhpcy5zaXplKz1yLmxlbmd0aCx0JiYodGhpcy5jcmM9dGhpcy5jLmQoKSksdGhpcy5wcm9jZXNzKHIsdHx8ITEpO30sbn0oKSxzdD1mdW5jdGlvbigpe2Z1bmN0aW9uIG4ocix0KXt2YXIgZT10aGlzO3R8fCh0PXt9KSxCci5jYWxsKHRoaXMsciksdGhpcy5kPW5ldyBycih0LGZ1bmN0aW9uKGksYSl7ZS5vbmRhdGEobnVsbCxpLGEpO30pLHRoaXMuY29tcHJlc3Npb249OCx0aGlzLmZsYWc9Vm4odC5sZXZlbCk7fXJldHVybiBuLnByb3RvdHlwZS5wcm9jZXNzPWZ1bmN0aW9uKHIsdCl7dHJ5e3RoaXMuZC5wdXNoKHIsdCk7fWNhdGNoKGUpe3RoaXMub25kYXRhKGUsbnVsbCx0KTt9fSxuLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHIsdCl7QnIucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLHIsdCk7fSxufSgpLGh0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihyLHQpe3ZhciBlPXRoaXM7dHx8KHQ9e30pLEJyLmNhbGwodGhpcyxyKSx0aGlzLmQ9bmV3IEVuKHQsZnVuY3Rpb24oaSxhLG8pe2Uub25kYXRhKGksYSxvKTt9KSx0aGlzLmNvbXByZXNzaW9uPTgsdGhpcy5mbGFnPVZuKHQubGV2ZWwpLHRoaXMudGVybWluYXRlPXRoaXMuZC50ZXJtaW5hdGU7fXJldHVybiBuLnByb3RvdHlwZS5wcm9jZXNzPWZ1bmN0aW9uKHIsdCl7dGhpcy5kLnB1c2gocix0KTt9LG4ucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24ocix0KXtCci5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMscix0KTt9LG59KCksdXQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKHIpe3RoaXMub25kYXRhPXIsdGhpcy51PVtdLHRoaXMuZD0xO31yZXR1cm4gbi5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHIpe3ZhciB0PXRoaXM7aWYodGhpcy5kJjIpdGhyb3cgXCJzdHJlYW0gZmluaXNoZWRcIjt2YXIgZT1vcihyLmZpbGVuYW1lKSxpPWUubGVuZ3RoLGE9ci5jb21tZW50LG89YSYmb3IoYSksZj1pIT1yLmZpbGVuYW1lLmxlbmd0aHx8byYmYS5sZW5ndGghPW8ubGVuZ3RoLGg9aStmcihyLmV4dHJhKSszMDtpZihpPjY1NTM1KXRocm93IFwiZmlsZW5hbWUgdG9vIGxvbmdcIjt2YXIgcz1uZXcgQShoKTtBcihzLDAscixlLGYpO3ZhciB1PVtzXSxsPWZ1bmN0aW9uKCl7Zm9yKHZhciB3PTAsTT11O3c8TS5sZW5ndGg7dysrKXt2YXIgej1NW3ddO3Qub25kYXRhKG51bGwseiwhMSk7fXU9W107fSxwPXRoaXMuZDt0aGlzLmQ9MDt2YXIgeT10aGlzLnUubGVuZ3RoLGM9WnIocix7ZjplLHU6ZixvLHQ6ZnVuY3Rpb24oKXtyLnRlcm1pbmF0ZSYmci50ZXJtaW5hdGUoKTt9LHI6ZnVuY3Rpb24oKXtpZihsKCkscCl7dmFyIHc9dC51W3krMV07dz93LnIoKTp0LmQ9MTt9cD0xO319KSxnPTA7ci5vbmRhdGE9ZnVuY3Rpb24odyxNLHope2lmKHcpdC5vbmRhdGEodyxNLHopLHQudGVybWluYXRlKCk7ZWxzZSBpZihnKz1NLmxlbmd0aCx1LnB1c2goTSkseil7dmFyIG09bmV3IEEoMTYpO0YobSwwLDEzNDY5NTc2MCksRihtLDQsci5jcmMpLEYobSw4LGcpLEYobSwxMixyLnNpemUpLHUucHVzaChtKSxjLmM9ZyxjLmI9aCtnKzE2LGMuY3JjPXIuY3JjLGMuc2l6ZT1yLnNpemUscCYmYy5yKCkscD0xO31lbHNlIHAmJmwoKTt9LHRoaXMudS5wdXNoKGMpO30sbi5wcm90b3R5cGUuZW5kPWZ1bmN0aW9uKCl7dmFyIHI9dGhpcztpZih0aGlzLmQmMil0aHJvdyB0aGlzLmQmMT9cInN0cmVhbSBmaW5pc2hpbmdcIjpcInN0cmVhbSBmaW5pc2hlZFwiO3RoaXMuZD90aGlzLmUoKTp0aGlzLnUucHVzaCh7cjpmdW5jdGlvbigpe2lmKCEoci5kJjEpKXJldHVybjtyLnUuc3BsaWNlKC0xLDEpLHIuZSgpO30sdDpmdW5jdGlvbigpe319KSx0aGlzLmQ9Mzt9LG4ucHJvdG90eXBlLmU9ZnVuY3Rpb24oKXtmb3IodmFyIHI9MCx0PTAsZT0wLGk9MCxhPXRoaXMudTtpPGEubGVuZ3RoO2krKyl7dmFyIG89YVtpXTtlKz00NitvLmYubGVuZ3RoK2ZyKG8uZXh0cmEpKyhvLm8/by5vLmxlbmd0aDowKTt9Zm9yKHZhciBmPW5ldyBBKGUrMjIpLGg9MCxzPXRoaXMudTtoPHMubGVuZ3RoO2grKyl7dmFyIG89c1toXTtBcihmLHIsbyxvLmYsby51LG8uYyx0LG8ubykscis9NDYrby5mLmxlbmd0aCtmcihvLmV4dHJhKSsoby5vP28uby5sZW5ndGg6MCksdCs9by5iO31sbihmLHIsdGhpcy51Lmxlbmd0aCxlLHQpLHRoaXMub25kYXRhKG51bGwsZiwhMCksdGhpcy5kPTI7fSxuLnByb3RvdHlwZS50ZXJtaW5hdGU9ZnVuY3Rpb24oKXtmb3IodmFyIHI9MCx0PXRoaXMudTtyPHQubGVuZ3RoO3IrKyl7dmFyIGU9dFtyXTtlLnQoKTt9dGhpcy5kPTI7fSxufSgpO2Z1bmN0aW9uIGx0KG4scix0KXtpZih0fHwodD1yLHI9e30pLHR5cGVvZiB0IT1cImZ1bmN0aW9uXCIpdGhyb3cgXCJubyBjYWxsYmFja1wiO3ZhciBlPXt9O3NuKG4sXCJcIixlLHIpO3ZhciBpPU9iamVjdC5rZXlzKGUpLGE9aS5sZW5ndGgsbz0wLGY9MCxoPWEscz1uZXcgQXJyYXkoYSksdT1bXSxsPWZ1bmN0aW9uKCl7Zm9yKHZhciBnPTA7Zzx1Lmxlbmd0aDsrK2cpdVtnXSgpO30scD1mdW5jdGlvbigpe3ZhciBnPW5ldyBBKGYrMjIpLHc9byxNPWYtbztmPTA7Zm9yKHZhciB6PTA7ejxoOysreil7dmFyIG09c1t6XTt0cnl7dmFyIEQ9bS5jLmxlbmd0aDtBcihnLGYsbSxtLmYsbS51LEQpO3ZhciBDPTMwK20uZi5sZW5ndGgrZnIobS5leHRyYSksVT1mK0M7Zy5zZXQobS5jLFUpLEFyKGcsbyxtLG0uZixtLnUsRCxmLG0ubSksbys9MTYrQysobS5tP20ubS5sZW5ndGg6MCksZj1VK0Q7fWNhdGNoKHgpe3JldHVybiB0KHgsbnVsbCl9fWxuKGcsbyxzLmxlbmd0aCxNLHcpLHQobnVsbCxnKTt9O2F8fHAoKTtmb3IodmFyIHk9ZnVuY3Rpb24oZyl7dmFyIHc9aVtnXSxNPWVbd10sej1NWzBdLG09TVsxXSxEPWdyKCksQz16Lmxlbmd0aDtELnAoeik7dmFyIFU9b3IodykseD1VLmxlbmd0aCx2PW0uY29tbWVudCxFPXYmJm9yKHYpLFM9RSYmRS5sZW5ndGgsSz1mcihtLmV4dHJhKSxJPW0ubGV2ZWw9PTA/MDo4LFo9ZnVuY3Rpb24oQixHKXtpZihCKWwoKSx0KEIsbnVsbCk7ZWxzZSB7dmFyIGs9Ry5sZW5ndGg7c1tnXT1acihtLHtzaXplOkMsY3JjOkQuZCgpLGM6RyxmOlUsbTpFLHU6eCE9dy5sZW5ndGh8fEUmJnYubGVuZ3RoIT1TLGNvbXByZXNzaW9uOkl9KSxvKz0zMCt4K0srayxmKz03NisyKih4K0spKyhTfHwwKStrLC0tYXx8cCgpO319O2lmKHg+NjU1MzUmJlooXCJmaWxlbmFtZSB0b28gbG9uZ1wiLG51bGwpLCFJKVoobnVsbCx6KTtlbHNlIGlmKEM8MTZlNCl0cnl7WihudWxsLGtyKHosbSkpO31jYXRjaChCKXtaKEIsbnVsbCk7fWVsc2UgdS5wdXNoKFBuKHosbSxaKSk7fSxjPTA7YzxoOysrYyl5KGMpO3JldHVybiBsfWZ1bmN0aW9uIHZ0KG4scil7cnx8KHI9e30pO3ZhciB0PXt9LGU9W107c24obixcIlwiLHQscik7dmFyIGk9MCxhPTA7Zm9yKHZhciBvIGluIHQpe3ZhciBmPXRbb10saD1mWzBdLHM9ZlsxXSx1PXMubGV2ZWw9PTA/MDo4LGw9b3IobykscD1sLmxlbmd0aCx5PXMuY29tbWVudCxjPXkmJm9yKHkpLGc9YyYmYy5sZW5ndGgsdz1mcihzLmV4dHJhKTtpZihwPjY1NTM1KXRocm93IFwiZmlsZW5hbWUgdG9vIGxvbmdcIjt2YXIgTT11P2tyKGgscyk6aCx6PU0ubGVuZ3RoLG09Z3IoKTttLnAoaCksZS5wdXNoKFpyKHMse3NpemU6aC5sZW5ndGgsY3JjOm0uZCgpLGM6TSxmOmwsbTpjLHU6cCE9by5sZW5ndGh8fGMmJnkubGVuZ3RoIT1nLG86aSxjb21wcmVzc2lvbjp1fSkpLGkrPTMwK3Ardyt6LGErPTc2KzIqKHArdykrKGd8fDApK3o7fWZvcih2YXIgRD1uZXcgQShhKzIyKSxDPWksVT1hLWkseD0wO3g8ZS5sZW5ndGg7Kyt4KXt2YXIgbD1lW3hdO0FyKEQsbC5vLGwsbC5mLGwudSxsLmMubGVuZ3RoKTt2YXIgdj0zMCtsLmYubGVuZ3RoK2ZyKGwuZXh0cmEpO0Quc2V0KGwuYyxsLm8rdiksQXIoRCxpLGwsbC5mLGwudSxsLmMubGVuZ3RoLGwubyxsLm0pLGkrPTE2K3YrKGwubT9sLm0ubGVuZ3RoOjApO31yZXR1cm4gbG4oRCxpLGUubGVuZ3RoLFUsQyksRH12YXIgZG49ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKCl7fXJldHVybiBuLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHIsdCl7dGhpcy5vbmRhdGEobnVsbCxyLHQpO30sbi5jb21wcmVzc2lvbj0wLG59KCksY3Q9ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKCl7dmFyIHI9dGhpczt0aGlzLmk9bmV3IEooZnVuY3Rpb24odCxlKXtyLm9uZGF0YShudWxsLHQsZSk7fSk7fXJldHVybiBuLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHIsdCl7dHJ5e3RoaXMuaS5wdXNoKHIsdCk7fWNhdGNoKGUpe3RoaXMub25kYXRhKGUscix0KTt9fSxuLmNvbXByZXNzaW9uPTgsbn0oKSxwdD1mdW5jdGlvbigpe2Z1bmN0aW9uIG4ocix0KXt2YXIgZT10aGlzO3Q8MzJlND90aGlzLmk9bmV3IEooZnVuY3Rpb24oaSxhKXtlLm9uZGF0YShudWxsLGksYSk7fSk6KHRoaXMuaT1uZXcgZW4oZnVuY3Rpb24oaSxhLG8pe2Uub25kYXRhKGksYSxvKTt9KSx0aGlzLnRlcm1pbmF0ZT10aGlzLmkudGVybWluYXRlKTt9cmV0dXJuIG4ucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24ocix0KXt0aGlzLmkudGVybWluYXRlJiYocj0kKHIsMCkpLHRoaXMuaS5wdXNoKHIsdCk7fSxuLmNvbXByZXNzaW9uPTgsbn0oKSxndD1mdW5jdGlvbigpe2Z1bmN0aW9uIG4ocil7dGhpcy5vbmZpbGU9cix0aGlzLms9W10sdGhpcy5vPXswOmRufSx0aGlzLnA9ZXI7fXJldHVybiBuLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHIsdCl7dmFyIGU9dGhpcztpZighdGhpcy5vbmZpbGUpdGhyb3cgXCJubyBjYWxsYmFja1wiO2lmKHRoaXMuYz4wKXt2YXIgaT1NYXRoLm1pbih0aGlzLmMsci5sZW5ndGgpLGE9ci5zdWJhcnJheSgwLGkpO2lmKHRoaXMuYy09aSx0aGlzLmQ/dGhpcy5kLnB1c2goYSwhdGhpcy5jKTp0aGlzLmtbMF0ucHVzaChhKSxyPXIuc3ViYXJyYXkoaSksci5sZW5ndGgpcmV0dXJuIHRoaXMucHVzaChyLHQpfWVsc2Uge3ZhciBvPTAsZj0wLGg9dm9pZCAwLHM9dm9pZCAwO3RoaXMucC5sZW5ndGg/ci5sZW5ndGg/KHM9bmV3IEEodGhpcy5wLmxlbmd0aCtyLmxlbmd0aCkscy5zZXQodGhpcy5wKSxzLnNldChyLHRoaXMucC5sZW5ndGgpKTpzPXRoaXMucDpzPXI7Zm9yKHZhciB1PXMubGVuZ3RoLGw9dGhpcy5jLHA9bCYmdGhpcy5kLHk9ZnVuY3Rpb24oKXt2YXIgTSx6PVAocyxmKTtpZih6PT02NzMyNDc1Mil7bz0xLGg9ZixjLmQ9bnVsbCxjLmM9MDt2YXIgbT1ZKHMsZis2KSxEPVkocyxmKzgpLEM9bSYyMDQ4LFU9bSY4LHg9WShzLGYrMjYpLHY9WShzLGYrMjgpO2lmKHU+ZiszMCt4K3Ype3ZhciBFPVtdO2Muay51bnNoaWZ0KEUpLG89Mjt2YXIgUz1QKHMsZisxOCksSz1QKHMsZisyMiksST11bihzLnN1YmFycmF5KGYrMzAsZis9MzAreCksIUMpO1M9PTQyOTQ5NjcyOTU/KE09VT9bLTJdOkxuKHMsZiksUz1NWzBdLEs9TVsxXSk6VSYmKFM9LTEpLGYrPXYsYy5jPVM7dmFyIFo9e25hbWU6SSxjb21wcmVzc2lvbjpELHN0YXJ0OmZ1bmN0aW9uKCl7aWYoIVoub25kYXRhKXRocm93IFwibm8gY2FsbGJhY2tcIjtpZighUylaLm9uZGF0YShudWxsLGVyLCEwKTtlbHNlIHt2YXIgQj1lLm9bRF07aWYoIUIpdGhyb3cgXCJ1bmtub3duIGNvbXByZXNzaW9uIHR5cGUgXCIrRDt2YXIgRz1TPDA/bmV3IEIoSSk6bmV3IEIoSSxTLEspO0cub25kYXRhPWZ1bmN0aW9uKE4sUSxXKXtaLm9uZGF0YShOLFEsVyk7fTtmb3IodmFyIGs9MCxPPUU7azxPLmxlbmd0aDtrKyspe3ZhciBIPU9ba107Ry5wdXNoKEgsITEpO31lLmtbMF09PUU/ZS5kPUc6Ry5wdXNoKGVyLCEwKTt9fSx0ZXJtaW5hdGU6ZnVuY3Rpb24oKXtlLmtbMF09PUUmJmUuZC50ZXJtaW5hdGUmJmUuZC50ZXJtaW5hdGUoKTt9fTtTPj0wJiYoWi5zaXplPVMsWi5vcmlnaW5hbFNpemU9SyksYy5vbmZpbGUoWik7fXJldHVybiBcImJyZWFrXCJ9ZWxzZSBpZihsKXtpZih6PT0xMzQ2OTU3NjApcmV0dXJuIGg9Zis9MTIrKGw9PS0yJiY4KSxvPTIsYy5jPTAsXCJicmVha1wiO2lmKHo9PTMzNjM5MjQ4KXJldHVybiBoPWYtPTQsbz0yLGMuYz0wLFwiYnJlYWtcIn19LGM9dGhpcztmPHUtNDsrK2Ype3ZhciBnPXkoKTtpZihnPT09XCJicmVha1wiKWJyZWFrfWlmKHRoaXMucD1lcixsPDApe3ZhciB3PW8/cy5zdWJhcnJheSgwLGgtMTItKGw9PS0yJiY4KS0oUChzLGgtMTYpPT0xMzQ2OTU3NjAmJjQpKTpzLnN1YmFycmF5KDAsZik7cD9wLnB1c2godywhIW8pOnRoaXMua1srKG89PTIpXS5wdXNoKHcpO31pZihvJjIpcmV0dXJuIHRoaXMucHVzaChzLnN1YmFycmF5KGYpLHQpO3RoaXMucD1zLnN1YmFycmF5KGYpO31pZih0JiZ0aGlzLmMpdGhyb3cgXCJpbnZhbGlkIHppcCBmaWxlXCJ9LG4ucHJvdG90eXBlLnJlZ2lzdGVyPWZ1bmN0aW9uKHIpe3RoaXMub1tyLmNvbXByZXNzaW9uXT1yO30sbn0oKTtmdW5jdGlvbiB3dChuLHIpe2lmKHR5cGVvZiByIT1cImZ1bmN0aW9uXCIpdGhyb3cgXCJubyBjYWxsYmFja1wiO2Zvcih2YXIgdD1bXSxlPWZ1bmN0aW9uKCl7Zm9yKHZhciBwPTA7cDx0Lmxlbmd0aDsrK3ApdFtwXSgpO30saT17fSxhPW4ubGVuZ3RoLTIyO1AobixhKSE9MTAxMDEwMjU2Oy0tYSlpZighYXx8bi5sZW5ndGgtYT42NTU1OCl7cihcImludmFsaWQgemlwIGZpbGVcIixudWxsKTtyZXR1cm59dmFyIG89WShuLGErOCk7b3x8cihudWxsLHt9KTt2YXIgZj1vLGg9UChuLGErMTYpLHM9aD09NDI5NDk2NzI5NTtpZihzKXtpZihhPVAobixhLTEyKSxQKG4sYSkhPTEwMTA3NTc5Mil7cihcImludmFsaWQgemlwIGZpbGVcIixudWxsKTtyZXR1cm59Zj1vPVAobixhKzMyKSxoPVAobixhKzQ4KTt9Zm9yKHZhciB1PWZ1bmN0aW9uKHApe3ZhciB5PSRuKG4saCxzKSxjPXlbMF0sZz15WzFdLHc9eVsyXSxNPXlbM10sej15WzRdLG09eVs1XSxEPVhuKG4sbSk7aD16O3ZhciBDPWZ1bmN0aW9uKHgsdil7eD8oZSgpLHIoeCxudWxsKSk6KGlbTV09diwtLW98fHIobnVsbCxpKSk7fTtpZighYylDKG51bGwsJChuLEQsRCtnKSk7ZWxzZSBpZihjPT04KXt2YXIgVT1uLnN1YmFycmF5KEQsRCtnKTtpZihnPDMyZTQpdHJ5e0MobnVsbCx4cihVLG5ldyBBKHcpKSk7fWNhdGNoKHgpe0MoeCxudWxsKTt9ZWxzZSB0LnB1c2goYW4oVSx7c2l6ZTp3fSxDKSk7fWVsc2UgQyhcInVua25vd24gY29tcHJlc3Npb24gdHlwZSBcIitjLG51bGwpO30sbD0wO2w8ZjsrK2wpdSgpO3JldHVybiBlfWZ1bmN0aW9uIHl0KG4pe2Zvcih2YXIgcj17fSx0PW4ubGVuZ3RoLTIyO1Aobix0KSE9MTAxMDEwMjU2Oy0tdClpZighdHx8bi5sZW5ndGgtdD42NTU1OCl0aHJvdyBcImludmFsaWQgemlwIGZpbGVcIjt2YXIgZT1ZKG4sdCs4KTtpZighZSlyZXR1cm4ge307dmFyIGk9UChuLHQrMTYpLGE9aT09NDI5NDk2NzI5NTtpZihhKXtpZih0PVAobix0LTEyKSxQKG4sdCkhPTEwMTA3NTc5Mil0aHJvdyBcImludmFsaWQgemlwIGZpbGVcIjtlPVAobix0KzMyKSxpPVAobix0KzQ4KTt9Zm9yKHZhciBvPTA7bzxlOysrbyl7dmFyIGY9JG4obixpLGEpLGg9ZlswXSxzPWZbMV0sdT1mWzJdLGw9ZlszXSxwPWZbNF0seT1mWzVdLGM9WG4obix5KTtpZihpPXAsIWgpcltsXT0kKG4sYyxjK3MpO2Vsc2UgaWYoaD09OClyW2xdPXhyKG4uc3ViYXJyYXkoYyxjK3MpLG5ldyBBKHUpKTtlbHNlIHRocm93IFwidW5rbm93biBjb21wcmVzc2lvbiB0eXBlIFwiK2h9cmV0dXJuIHJ9dmFyIGZmbGF0ZV9tb2R1bGVfbWluID0gbnVsbDtcblxudmFyIGZmbGF0ZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRBc3luY0NvbXByZXNzOiBSbixcblx0QXN5bmNEZWNvbXByZXNzOiBldCxcblx0QXN5bmNEZWZsYXRlOiBFbixcblx0QXN5bmNHdW56aXA6IEhuLFxuXHRBc3luY0d6aXA6IFJuLFxuXHRBc3luY0luZmxhdGU6IGVuLFxuXHRBc3luY1VuemlwSW5mbGF0ZTogcHQsXG5cdEFzeW5jVW56bGliOiBZbixcblx0QXN5bmNaaXBEZWZsYXRlOiBodCxcblx0QXN5bmNabGliOiBudCxcblx0Q29tcHJlc3M6IHFyLFxuXHREZWNvZGVVVEY4OiBvdCxcblx0RGVjb21wcmVzczogSm4sXG5cdERlZmxhdGU6IHJyLFxuXHRFbmNvZGVVVEY4OiBmdCxcblx0R3VuemlwOiBXcixcblx0R3ppcDogcXIsXG5cdEluZmxhdGU6IEosXG5cdFVuemlwOiBndCxcblx0VW56aXBJbmZsYXRlOiBjdCxcblx0VW56aXBQYXNzVGhyb3VnaDogZG4sXG5cdFVuemxpYjoganIsXG5cdFppcDogdXQsXG5cdFppcERlZmxhdGU6IHN0LFxuXHRaaXBQYXNzVGhyb3VnaDogQnIsXG5cdFpsaWI6IG9uLFxuXHRjb21wcmVzczogcW4sXG5cdGNvbXByZXNzU3luYzogSHIsXG5cdGRlY29tcHJlc3M6IGl0LFxuXHRkZWNvbXByZXNzU3luYzogYXQsXG5cdGRlZmxhdGU6IFBuLFxuXHRkZWZsYXRlU3luYzoga3IsXG5cdGd1bnppcDogV24sXG5cdGd1bnppcFN5bmM6IFlyLFxuXHRnemlwOiBxbixcblx0Z3ppcFN5bmM6IEhyLFxuXHRpbmZsYXRlOiBhbixcblx0aW5mbGF0ZVN5bmM6IHhyLFxuXHRzdHJGcm9tVTg6IHVuLFxuXHRzdHJUb1U4OiBvcixcblx0dW56aXA6IHd0LFxuXHR1bnppcFN5bmM6IHl0LFxuXHR1bnpsaWI6IGpuLFxuXHR1bnpsaWJTeW5jOiBKcixcblx0emlwOiBsdCxcblx0emlwU3luYzogdnQsXG5cdHpsaWI6IHR0LFxuXHR6bGliU3luYzogZm4sXG5cdCdkZWZhdWx0JzogZmZsYXRlX21vZHVsZV9taW5cbn0pO1xuXG4vKipcbiAqIE5VUkJTIHV0aWxzXG4gKlxuICogU2VlIE5VUkJTQ3VydmUgYW5kIE5VUkJTU3VyZmFjZS5cbiAqKi9cblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHROVVJCUyBVdGlsc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgTlVSQlNVdGlscyA9IHtcblxuXHQvKlxuXHRGaW5kcyBrbm90IHZlY3RvciBzcGFuLlxuXG5cdHAgOiBkZWdyZWVcblx0dSA6IHBhcmFtZXRyaWMgdmFsdWVcblx0VSA6IGtub3QgdmVjdG9yXG5cblx0cmV0dXJucyB0aGUgc3BhblxuXHQqL1xuXHRmaW5kU3BhbjogZnVuY3Rpb24gKCBwLCB1LCBVICkge1xuXG5cdFx0dmFyIG4gPSBVLmxlbmd0aCAtIHAgLSAxO1xuXG5cdFx0aWYgKCB1ID49IFVbIG4gXSApIHtcblxuXHRcdFx0cmV0dXJuIG4gLSAxO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB1IDw9IFVbIHAgXSApIHtcblxuXHRcdFx0cmV0dXJuIHA7XG5cblx0XHR9XG5cblx0XHR2YXIgbG93ID0gcDtcblx0XHR2YXIgaGlnaCA9IG47XG5cdFx0dmFyIG1pZCA9IE1hdGguZmxvb3IoICggbG93ICsgaGlnaCApIC8gMiApO1xuXG5cdFx0d2hpbGUgKCB1IDwgVVsgbWlkIF0gfHwgdSA+PSBVWyBtaWQgKyAxIF0gKSB7XG5cblx0XHRcdGlmICggdSA8IFVbIG1pZCBdICkge1xuXG5cdFx0XHRcdGhpZ2ggPSBtaWQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bG93ID0gbWlkO1xuXG5cdFx0XHR9XG5cblx0XHRcdG1pZCA9IE1hdGguZmxvb3IoICggbG93ICsgaGlnaCApIC8gMiApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1pZDtcblxuXHR9LFxuXG5cblx0Lypcblx0Q2FsY3VsYXRlIGJhc2lzIGZ1bmN0aW9ucy4gU2VlIFRoZSBOVVJCUyBCb29rLCBwYWdlIDcwLCBhbGdvcml0aG0gQTIuMlxuXG5cdHNwYW4gOiBzcGFuIGluIHdoaWNoIHUgbGllc1xuXHR1ICAgIDogcGFyYW1ldHJpYyBwb2ludFxuXHRwICAgIDogZGVncmVlXG5cdFUgICAgOiBrbm90IHZlY3RvclxuXG5cdHJldHVybnMgYXJyYXlbcCsxXSB3aXRoIGJhc2lzIGZ1bmN0aW9ucyB2YWx1ZXMuXG5cdCovXG5cdGNhbGNCYXNpc0Z1bmN0aW9uczogZnVuY3Rpb24gKCBzcGFuLCB1LCBwLCBVICkge1xuXG5cdFx0dmFyIE4gPSBbXTtcblx0XHR2YXIgbGVmdCA9IFtdO1xuXHRcdHZhciByaWdodCA9IFtdO1xuXHRcdE5bIDAgXSA9IDEuMDtcblxuXHRcdGZvciAoIHZhciBqID0gMTsgaiA8PSBwOyArKyBqICkge1xuXG5cdFx0XHRsZWZ0WyBqIF0gPSB1IC0gVVsgc3BhbiArIDEgLSBqIF07XG5cdFx0XHRyaWdodFsgaiBdID0gVVsgc3BhbiArIGogXSAtIHU7XG5cblx0XHRcdHZhciBzYXZlZCA9IDAuMDtcblxuXHRcdFx0Zm9yICggdmFyIHIgPSAwOyByIDwgajsgKysgciApIHtcblxuXHRcdFx0XHR2YXIgcnYgPSByaWdodFsgciArIDEgXTtcblx0XHRcdFx0dmFyIGx2ID0gbGVmdFsgaiAtIHIgXTtcblx0XHRcdFx0dmFyIHRlbXAgPSBOWyByIF0gLyAoIHJ2ICsgbHYgKTtcblx0XHRcdFx0TlsgciBdID0gc2F2ZWQgKyBydiAqIHRlbXA7XG5cdFx0XHRcdHNhdmVkID0gbHYgKiB0ZW1wO1xuXG5cdFx0XHQgfVxuXG5cdFx0XHQgTlsgaiBdID0gc2F2ZWQ7XG5cblx0XHQgfVxuXG5cdFx0IHJldHVybiBOO1xuXG5cdH0sXG5cblxuXHQvKlxuXHRDYWxjdWxhdGUgQi1TcGxpbmUgY3VydmUgcG9pbnRzLiBTZWUgVGhlIE5VUkJTIEJvb2ssIHBhZ2UgODIsIGFsZ29yaXRobSBBMy4xLlxuXG5cdHAgOiBkZWdyZWUgb2YgQi1TcGxpbmVcblx0VSA6IGtub3QgdmVjdG9yXG5cdFAgOiBjb250cm9sIHBvaW50cyAoeCwgeSwgeiwgdylcblx0dSA6IHBhcmFtZXRyaWMgcG9pbnRcblxuXHRyZXR1cm5zIHBvaW50IGZvciBnaXZlbiB1XG5cdCovXG5cdGNhbGNCU3BsaW5lUG9pbnQ6IGZ1bmN0aW9uICggcCwgVSwgUCwgdSApIHtcblxuXHRcdHZhciBzcGFuID0gdGhpcy5maW5kU3BhbiggcCwgdSwgVSApO1xuXHRcdHZhciBOID0gdGhpcy5jYWxjQmFzaXNGdW5jdGlvbnMoIHNwYW4sIHUsIHAsIFUgKTtcblx0XHR2YXIgQyA9IG5ldyBWZWN0b3I0KCAwLCAwLCAwLCAwICk7XG5cblx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPD0gcDsgKysgaiApIHtcblxuXHRcdFx0dmFyIHBvaW50ID0gUFsgc3BhbiAtIHAgKyBqIF07XG5cdFx0XHR2YXIgTmogPSBOWyBqIF07XG5cdFx0XHR2YXIgd05qID0gcG9pbnQudyAqIE5qO1xuXHRcdFx0Qy54ICs9IHBvaW50LnggKiB3Tmo7XG5cdFx0XHRDLnkgKz0gcG9pbnQueSAqIHdOajtcblx0XHRcdEMueiArPSBwb2ludC56ICogd05qO1xuXHRcdFx0Qy53ICs9IHBvaW50LncgKiBOajtcblxuXHRcdH1cblxuXHRcdHJldHVybiBDO1xuXG5cdH0sXG5cblxuXHQvKlxuXHRDYWxjdWxhdGUgYmFzaXMgZnVuY3Rpb25zIGRlcml2YXRpdmVzLiBTZWUgVGhlIE5VUkJTIEJvb2ssIHBhZ2UgNzIsIGFsZ29yaXRobSBBMi4zLlxuXG5cdHNwYW4gOiBzcGFuIGluIHdoaWNoIHUgbGllc1xuXHR1ICAgIDogcGFyYW1ldHJpYyBwb2ludFxuXHRwICAgIDogZGVncmVlXG5cdG4gICAgOiBudW1iZXIgb2YgZGVyaXZhdGl2ZXMgdG8gY2FsY3VsYXRlXG5cdFUgICAgOiBrbm90IHZlY3RvclxuXG5cdHJldHVybnMgYXJyYXlbbisxXVtwKzFdIHdpdGggYmFzaXMgZnVuY3Rpb25zIGRlcml2YXRpdmVzXG5cdCovXG5cdGNhbGNCYXNpc0Z1bmN0aW9uRGVyaXZhdGl2ZXM6IGZ1bmN0aW9uICggc3BhbiwgdSwgcCwgbiwgVSApIHtcblxuXHRcdHZhciB6ZXJvQXJyID0gW107XG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDw9IHA7ICsrIGkgKVxuXHRcdFx0emVyb0FyclsgaSBdID0gMC4wO1xuXG5cdFx0dmFyIGRlcnMgPSBbXTtcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPD0gbjsgKysgaSApXG5cdFx0XHRkZXJzWyBpIF0gPSB6ZXJvQXJyLnNsaWNlKCAwICk7XG5cblx0XHR2YXIgbmR1ID0gW107XG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDw9IHA7ICsrIGkgKVxuXHRcdFx0bmR1WyBpIF0gPSB6ZXJvQXJyLnNsaWNlKCAwICk7XG5cblx0XHRuZHVbIDAgXVsgMCBdID0gMS4wO1xuXG5cdFx0dmFyIGxlZnQgPSB6ZXJvQXJyLnNsaWNlKCAwICk7XG5cdFx0dmFyIHJpZ2h0ID0gemVyb0Fyci5zbGljZSggMCApO1xuXG5cdFx0Zm9yICggdmFyIGogPSAxOyBqIDw9IHA7ICsrIGogKSB7XG5cblx0XHRcdGxlZnRbIGogXSA9IHUgLSBVWyBzcGFuICsgMSAtIGogXTtcblx0XHRcdHJpZ2h0WyBqIF0gPSBVWyBzcGFuICsgaiBdIC0gdTtcblxuXHRcdFx0dmFyIHNhdmVkID0gMC4wO1xuXG5cdFx0XHRmb3IgKCB2YXIgciA9IDA7IHIgPCBqOyArKyByICkge1xuXG5cdFx0XHRcdHZhciBydiA9IHJpZ2h0WyByICsgMSBdO1xuXHRcdFx0XHR2YXIgbHYgPSBsZWZ0WyBqIC0gciBdO1xuXHRcdFx0XHRuZHVbIGogXVsgciBdID0gcnYgKyBsdjtcblxuXHRcdFx0XHR2YXIgdGVtcCA9IG5kdVsgciBdWyBqIC0gMSBdIC8gbmR1WyBqIF1bIHIgXTtcblx0XHRcdFx0bmR1WyByIF1bIGogXSA9IHNhdmVkICsgcnYgKiB0ZW1wO1xuXHRcdFx0XHRzYXZlZCA9IGx2ICogdGVtcDtcblxuXHRcdFx0fVxuXG5cdFx0XHRuZHVbIGogXVsgaiBdID0gc2F2ZWQ7XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPD0gcDsgKysgaiApIHtcblxuXHRcdFx0ZGVyc1sgMCBdWyBqIF0gPSBuZHVbIGogXVsgcCBdO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIHIgPSAwOyByIDw9IHA7ICsrIHIgKSB7XG5cblx0XHRcdHZhciBzMSA9IDA7XG5cdFx0XHR2YXIgczIgPSAxO1xuXG5cdFx0XHR2YXIgYSA9IFtdO1xuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDw9IHA7ICsrIGkgKSB7XG5cblx0XHRcdFx0YVsgaSBdID0gemVyb0Fyci5zbGljZSggMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGFbIDAgXVsgMCBdID0gMS4wO1xuXG5cdFx0XHRmb3IgKCB2YXIgayA9IDE7IGsgPD0gbjsgKysgayApIHtcblxuXHRcdFx0XHR2YXIgZCA9IDAuMDtcblx0XHRcdFx0dmFyIHJrID0gciAtIGs7XG5cdFx0XHRcdHZhciBwayA9IHAgLSBrO1xuXG5cdFx0XHRcdGlmICggciA+PSBrICkge1xuXG5cdFx0XHRcdFx0YVsgczIgXVsgMCBdID0gYVsgczEgXVsgMCBdIC8gbmR1WyBwayArIDEgXVsgcmsgXTtcblx0XHRcdFx0XHRkID0gYVsgczIgXVsgMCBdICogbmR1WyByayBdWyBwayBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgajEgPSAoIHJrID49IC0gMSApID8gMSA6IC0gcms7XG5cdFx0XHRcdHZhciBqMiA9ICggciAtIDEgPD0gcGsgKSA/IGsgLSAxIDogcCAtIHI7XG5cblx0XHRcdFx0Zm9yICggdmFyIGogPSBqMTsgaiA8PSBqMjsgKysgaiApIHtcblxuXHRcdFx0XHRcdGFbIHMyIF1bIGogXSA9ICggYVsgczEgXVsgaiBdIC0gYVsgczEgXVsgaiAtIDEgXSApIC8gbmR1WyBwayArIDEgXVsgcmsgKyBqIF07XG5cdFx0XHRcdFx0ZCArPSBhWyBzMiBdWyBqIF0gKiBuZHVbIHJrICsgaiBdWyBwayBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHIgPD0gcGsgKSB7XG5cblx0XHRcdFx0XHRhWyBzMiBdWyBrIF0gPSAtIGFbIHMxIF1bIGsgLSAxIF0gLyBuZHVbIHBrICsgMSBdWyByIF07XG5cdFx0XHRcdFx0ZCArPSBhWyBzMiBdWyBrIF0gKiBuZHVbIHIgXVsgcGsgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVyc1sgayBdWyByIF0gPSBkO1xuXG5cdFx0XHRcdHZhciBqID0gczE7XG5cdFx0XHRcdHMxID0gczI7XG5cdFx0XHRcdHMyID0gajtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dmFyIHIgPSBwO1xuXG5cdFx0Zm9yICggdmFyIGsgPSAxOyBrIDw9IG47ICsrIGsgKSB7XG5cblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8PSBwOyArKyBqICkge1xuXG5cdFx0XHRcdGRlcnNbIGsgXVsgaiBdICo9IHI7XG5cblx0XHRcdH1cblxuXHRcdFx0ciAqPSBwIC0gaztcblxuXHRcdH1cblxuXHRcdHJldHVybiBkZXJzO1xuXG5cdH0sXG5cblxuXHQvKlxuXHRcdENhbGN1bGF0ZSBkZXJpdmF0aXZlcyBvZiBhIEItU3BsaW5lLiBTZWUgVGhlIE5VUkJTIEJvb2ssIHBhZ2UgOTMsIGFsZ29yaXRobSBBMy4yLlxuXG5cdFx0cCAgOiBkZWdyZWVcblx0XHRVICA6IGtub3QgdmVjdG9yXG5cdFx0UCAgOiBjb250cm9sIHBvaW50c1xuXHRcdHUgIDogUGFyYW1ldHJpYyBwb2ludHNcblx0XHRuZCA6IG51bWJlciBvZiBkZXJpdmF0aXZlc1xuXG5cdFx0cmV0dXJucyBhcnJheVtkKzFdIHdpdGggZGVyaXZhdGl2ZXNcblx0XHQqL1xuXHRjYWxjQlNwbGluZURlcml2YXRpdmVzOiBmdW5jdGlvbiAoIHAsIFUsIFAsIHUsIG5kICkge1xuXG5cdFx0dmFyIGR1ID0gbmQgPCBwID8gbmQgOiBwO1xuXHRcdHZhciBDSyA9IFtdO1xuXHRcdHZhciBzcGFuID0gdGhpcy5maW5kU3BhbiggcCwgdSwgVSApO1xuXHRcdHZhciBuZGVycyA9IHRoaXMuY2FsY0Jhc2lzRnVuY3Rpb25EZXJpdmF0aXZlcyggc3BhbiwgdSwgcCwgZHUsIFUgKTtcblx0XHR2YXIgUHcgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IFAubGVuZ3RoOyArKyBpICkge1xuXG5cdFx0XHR2YXIgcG9pbnQgPSBQWyBpIF0uY2xvbmUoKTtcblx0XHRcdHZhciB3ID0gcG9pbnQudztcblxuXHRcdFx0cG9pbnQueCAqPSB3O1xuXHRcdFx0cG9pbnQueSAqPSB3O1xuXHRcdFx0cG9pbnQueiAqPSB3O1xuXG5cdFx0XHRQd1sgaSBdID0gcG9pbnQ7XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgayA9IDA7IGsgPD0gZHU7ICsrIGsgKSB7XG5cblx0XHRcdHZhciBwb2ludCA9IFB3WyBzcGFuIC0gcCBdLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoIG5kZXJzWyBrIF1bIDAgXSApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDE7IGogPD0gcDsgKysgaiApIHtcblxuXHRcdFx0XHRwb2ludC5hZGQoIFB3WyBzcGFuIC0gcCArIGogXS5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKCBuZGVyc1sgayBdWyBqIF0gKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdENLWyBrIF0gPSBwb2ludDtcblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBrID0gZHUgKyAxOyBrIDw9IG5kICsgMTsgKysgayApIHtcblxuXHRcdFx0Q0tbIGsgXSA9IG5ldyBWZWN0b3I0KCAwLCAwLCAwICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gQ0s7XG5cblx0fSxcblxuXG5cdC8qXG5cdENhbGN1bGF0ZSBcIksgb3ZlciBJXCJcblxuXHRyZXR1cm5zIGshLyhpIShrLWkpISlcblx0Ki9cblx0Y2FsY0tvdmVySTogZnVuY3Rpb24gKCBrLCBpICkge1xuXG5cdFx0dmFyIG5vbSA9IDE7XG5cblx0XHRmb3IgKCB2YXIgaiA9IDI7IGogPD0gazsgKysgaiApIHtcblxuXHRcdFx0bm9tICo9IGo7XG5cblx0XHR9XG5cblx0XHR2YXIgZGVub20gPSAxO1xuXG5cdFx0Zm9yICggdmFyIGogPSAyOyBqIDw9IGk7ICsrIGogKSB7XG5cblx0XHRcdGRlbm9tICo9IGo7XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaiA9IDI7IGogPD0gayAtIGk7ICsrIGogKSB7XG5cblx0XHRcdGRlbm9tICo9IGo7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbm9tIC8gZGVub207XG5cblx0fSxcblxuXG5cdC8qXG5cdENhbGN1bGF0ZSBkZXJpdmF0aXZlcyAoMC1uZCkgb2YgcmF0aW9uYWwgY3VydmUuIFNlZSBUaGUgTlVSQlMgQm9vaywgcGFnZSAxMjcsIGFsZ29yaXRobSBBNC4yLlxuXG5cdFBkZXJzIDogcmVzdWx0IG9mIGZ1bmN0aW9uIGNhbGNCU3BsaW5lRGVyaXZhdGl2ZXNcblxuXHRyZXR1cm5zIGFycmF5IHdpdGggZGVyaXZhdGl2ZXMgZm9yIHJhdGlvbmFsIGN1cnZlLlxuXHQqL1xuXHRjYWxjUmF0aW9uYWxDdXJ2ZURlcml2YXRpdmVzOiBmdW5jdGlvbiAoIFBkZXJzICkge1xuXG5cdFx0dmFyIG5kID0gUGRlcnMubGVuZ3RoO1xuXHRcdHZhciBBZGVycyA9IFtdO1xuXHRcdHZhciB3ZGVycyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbmQ7ICsrIGkgKSB7XG5cblx0XHRcdHZhciBwb2ludCA9IFBkZXJzWyBpIF07XG5cdFx0XHRBZGVyc1sgaSBdID0gbmV3IFZlY3RvcjMoIHBvaW50LngsIHBvaW50LnksIHBvaW50LnogKTtcblx0XHRcdHdkZXJzWyBpIF0gPSBwb2ludC53O1xuXG5cdFx0fVxuXG5cdFx0dmFyIENLID0gW107XG5cblx0XHRmb3IgKCB2YXIgayA9IDA7IGsgPCBuZDsgKysgayApIHtcblxuXHRcdFx0dmFyIHYgPSBBZGVyc1sgayBdLmNsb25lKCk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMTsgaSA8PSBrOyArKyBpICkge1xuXG5cdFx0XHRcdHYuc3ViKCBDS1sgayAtIGkgXS5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKCB0aGlzLmNhbGNLb3ZlckkoIGssIGkgKSAqIHdkZXJzWyBpIF0gKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdENLWyBrIF0gPSB2LmRpdmlkZVNjYWxhciggd2RlcnNbIDAgXSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIENLO1xuXG5cdH0sXG5cblxuXHQvKlxuXHRDYWxjdWxhdGUgTlVSQlMgY3VydmUgZGVyaXZhdGl2ZXMuIFNlZSBUaGUgTlVSQlMgQm9vaywgcGFnZSAxMjcsIGFsZ29yaXRobSBBNC4yLlxuXG5cdHAgIDogZGVncmVlXG5cdFUgIDoga25vdCB2ZWN0b3Jcblx0UCAgOiBjb250cm9sIHBvaW50cyBpbiBob21vZ2VuZW91cyBzcGFjZVxuXHR1ICA6IHBhcmFtZXRyaWMgcG9pbnRzXG5cdG5kIDogbnVtYmVyIG9mIGRlcml2YXRpdmVzXG5cblx0cmV0dXJucyBhcnJheSB3aXRoIGRlcml2YXRpdmVzLlxuXHQqL1xuXHRjYWxjTlVSQlNEZXJpdmF0aXZlczogZnVuY3Rpb24gKCBwLCBVLCBQLCB1LCBuZCApIHtcblxuXHRcdHZhciBQZGVycyA9IHRoaXMuY2FsY0JTcGxpbmVEZXJpdmF0aXZlcyggcCwgVSwgUCwgdSwgbmQgKTtcblx0XHRyZXR1cm4gdGhpcy5jYWxjUmF0aW9uYWxDdXJ2ZURlcml2YXRpdmVzKCBQZGVycyApO1xuXG5cdH0sXG5cblxuXHQvKlxuXHRDYWxjdWxhdGUgcmF0aW9uYWwgQi1TcGxpbmUgc3VyZmFjZSBwb2ludC4gU2VlIFRoZSBOVVJCUyBCb29rLCBwYWdlIDEzNCwgYWxnb3JpdGhtIEE0LjMuXG5cblx0cDEsIHAyIDogZGVncmVlcyBvZiBCLVNwbGluZSBzdXJmYWNlXG5cdFUxLCBVMiA6IGtub3QgdmVjdG9yc1xuXHRQICAgICAgOiBjb250cm9sIHBvaW50cyAoeCwgeSwgeiwgdylcblx0dSwgdiAgIDogcGFyYW1ldHJpYyB2YWx1ZXNcblxuXHRyZXR1cm5zIHBvaW50IGZvciBnaXZlbiAodSwgdilcblx0Ki9cblx0Y2FsY1N1cmZhY2VQb2ludDogZnVuY3Rpb24gKCBwLCBxLCBVLCBWLCBQLCB1LCB2LCB0YXJnZXQgKSB7XG5cblx0XHR2YXIgdXNwYW4gPSB0aGlzLmZpbmRTcGFuKCBwLCB1LCBVICk7XG5cdFx0dmFyIHZzcGFuID0gdGhpcy5maW5kU3BhbiggcSwgdiwgViApO1xuXHRcdHZhciBOdSA9IHRoaXMuY2FsY0Jhc2lzRnVuY3Rpb25zKCB1c3BhbiwgdSwgcCwgVSApO1xuXHRcdHZhciBOdiA9IHRoaXMuY2FsY0Jhc2lzRnVuY3Rpb25zKCB2c3BhbiwgdiwgcSwgViApO1xuXHRcdHZhciB0ZW1wID0gW107XG5cblx0XHRmb3IgKCB2YXIgbCA9IDA7IGwgPD0gcTsgKysgbCApIHtcblxuXHRcdFx0dGVtcFsgbCBdID0gbmV3IFZlY3RvcjQoIDAsIDAsIDAsIDAgKTtcblx0XHRcdGZvciAoIHZhciBrID0gMDsgayA8PSBwOyArKyBrICkge1xuXG5cdFx0XHRcdHZhciBwb2ludCA9IFBbIHVzcGFuIC0gcCArIGsgXVsgdnNwYW4gLSBxICsgbCBdLmNsb25lKCk7XG5cdFx0XHRcdHZhciB3ID0gcG9pbnQudztcblx0XHRcdFx0cG9pbnQueCAqPSB3O1xuXHRcdFx0XHRwb2ludC55ICo9IHc7XG5cdFx0XHRcdHBvaW50LnogKj0gdztcblx0XHRcdFx0dGVtcFsgbCBdLmFkZCggcG9pbnQubXVsdGlwbHlTY2FsYXIoIE51WyBrIF0gKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR2YXIgU3cgPSBuZXcgVmVjdG9yNCggMCwgMCwgMCwgMCApO1xuXHRcdGZvciAoIHZhciBsID0gMDsgbCA8PSBxOyArKyBsICkge1xuXG5cdFx0XHRTdy5hZGQoIHRlbXBbIGwgXS5tdWx0aXBseVNjYWxhciggTnZbIGwgXSApICk7XG5cblx0XHR9XG5cblx0XHRTdy5kaXZpZGVTY2FsYXIoIFN3LncgKTtcblx0XHR0YXJnZXQuc2V0KCBTdy54LCBTdy55LCBTdy56ICk7XG5cblx0fVxuXG59O1xuXG4vKipcbiAqIE5VUkJTIGN1cnZlIG9iamVjdFxuICpcbiAqIERlcml2ZXMgZnJvbSBDdXJ2ZSwgb3ZlcnJpZGluZyBnZXRQb2ludCBhbmQgZ2V0VGFuZ2VudC5cbiAqXG4gKiBJbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiAoeCwgeSBbLCB6PTAgWywgdz0xXV0pIGNvbnRyb2wgcG9pbnRzIHdpdGggdz13ZWlnaHQuXG4gKlxuICoqL1xuXG52YXIgTlVSQlNDdXJ2ZSA9IGZ1bmN0aW9uICggZGVncmVlLCBrbm90cyAvKiBhcnJheSBvZiByZWFscyAqLywgY29udHJvbFBvaW50cyAvKiBhcnJheSBvZiBWZWN0b3IoMnwzfDQpICovLCBzdGFydEtub3QgLyogaW5kZXggaW4ga25vdHMgKi8sIGVuZEtub3QgLyogaW5kZXggaW4ga25vdHMgKi8gKSB7XG5cblx0Q3VydmUuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMuZGVncmVlID0gZGVncmVlO1xuXHR0aGlzLmtub3RzID0ga25vdHM7XG5cdHRoaXMuY29udHJvbFBvaW50cyA9IFtdO1xuXHQvLyBVc2VkIGJ5IHBlcmlvZGljIE5VUkJTIHRvIHJlbW92ZSBoaWRkZW4gc3BhbnNcblx0dGhpcy5zdGFydEtub3QgPSBzdGFydEtub3QgfHwgMDtcblx0dGhpcy5lbmRLbm90ID0gZW5kS25vdCB8fCAoIHRoaXMua25vdHMubGVuZ3RoIC0gMSApO1xuXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjb250cm9sUG9pbnRzLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdC8vIGVuc3VyZSBWZWN0b3I0IGZvciBjb250cm9sIHBvaW50c1xuXHRcdHZhciBwb2ludCA9IGNvbnRyb2xQb2ludHNbIGkgXTtcblx0XHR0aGlzLmNvbnRyb2xQb2ludHNbIGkgXSA9IG5ldyBWZWN0b3I0KCBwb2ludC54LCBwb2ludC55LCBwb2ludC56LCBwb2ludC53ICk7XG5cblx0fVxuXG59O1xuXG5cbk5VUkJTQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XG5OVVJCU0N1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE5VUkJTQ3VydmU7XG5cblxuTlVSQlNDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdHZhciBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cblx0dmFyIHUgPSB0aGlzLmtub3RzWyB0aGlzLnN0YXJ0S25vdCBdICsgdCAqICggdGhpcy5rbm90c1sgdGhpcy5lbmRLbm90IF0gLSB0aGlzLmtub3RzWyB0aGlzLnN0YXJ0S25vdCBdICk7IC8vIGxpbmVhciBtYXBwaW5nIHQtPnVcblxuXHQvLyBmb2xsb3dpbmcgcmVzdWx0cyBpbiAod3gsIHd5LCB3eiwgdykgaG9tb2dlbmVvdXMgcG9pbnRcblx0dmFyIGhwb2ludCA9IE5VUkJTVXRpbHMuY2FsY0JTcGxpbmVQb2ludCggdGhpcy5kZWdyZWUsIHRoaXMua25vdHMsIHRoaXMuY29udHJvbFBvaW50cywgdSApO1xuXG5cdGlmICggaHBvaW50LncgIT0gMS4wICkge1xuXG5cdFx0Ly8gcHJvamVjdCB0byAzRCBzcGFjZTogKHd4LCB3eSwgd3osIHcpIC0+ICh4LCB5LCB6LCAxKVxuXHRcdGhwb2ludC5kaXZpZGVTY2FsYXIoIGhwb2ludC53ICk7XG5cblx0fVxuXG5cdHJldHVybiBwb2ludC5zZXQoIGhwb2ludC54LCBocG9pbnQueSwgaHBvaW50LnogKTtcblxufTtcblxuXG5OVVJCU0N1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHR2YXIgdGFuZ2VudCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cblx0dmFyIHUgPSB0aGlzLmtub3RzWyAwIF0gKyB0ICogKCB0aGlzLmtub3RzWyB0aGlzLmtub3RzLmxlbmd0aCAtIDEgXSAtIHRoaXMua25vdHNbIDAgXSApO1xuXHR2YXIgZGVycyA9IE5VUkJTVXRpbHMuY2FsY05VUkJTRGVyaXZhdGl2ZXMoIHRoaXMuZGVncmVlLCB0aGlzLmtub3RzLCB0aGlzLmNvbnRyb2xQb2ludHMsIHUsIDEgKTtcblx0dGFuZ2VudC5jb3B5KCBkZXJzWyAxIF0gKS5ub3JtYWxpemUoKTtcblxuXHRyZXR1cm4gdGFuZ2VudDtcblxufTtcblxuLyoqXG4gKiBMb2FkZXIgbG9hZHMgRkJYIGZpbGUgYW5kIGdlbmVyYXRlcyBHcm91cCByZXByZXNlbnRpbmcgRkJYIHNjZW5lLlxuICogUmVxdWlyZXMgRkJYIGZpbGUgdG8gYmUgPj0gNy4wIGFuZCBpbiBBU0NJSSBvciA+PSA2NDAwIGluIEJpbmFyeSBmb3JtYXRcbiAqIFZlcnNpb25zIGxvd2VyIHRoYW4gdGhpcyBtYXkgbG9hZCBidXQgd2lsbCBwcm9iYWJseSBoYXZlIGVycm9yc1xuICpcbiAqIE5lZWRzIFN1cHBvcnQ6XG4gKiAgTW9ycGggbm9ybWFscyAvIGJsZW5kIHNoYXBlIG5vcm1hbHNcbiAqXG4gKiBGQlggZm9ybWF0IHJlZmVyZW5jZXM6XG4gKiBcdGh0dHBzOi8vd2lraS5ibGVuZGVyLm9yZy9pbmRleC5waHAvVXNlcjpNb250MjkvRm91bmRhdGlvbi9GQlhfRmlsZV9TdHJ1Y3R1cmVcbiAqIFx0aHR0cDovL2hlbHAuYXV0b2Rlc2suY29tL3ZpZXcvRkJYLzIwMTcvRU5VLz9ndWlkPV9fY3BwX3JlZl9pbmRleF9odG1sIChDKysgU0RLIHJlZmVyZW5jZSlcbiAqXG4gKiBcdEJpbmFyeSBmb3JtYXQgc3BlY2lmaWNhdGlvbjpcbiAqXHRcdGh0dHBzOi8vY29kZS5ibGVuZGVyLm9yZy8yMDEzLzA4L2ZieC1iaW5hcnktZmlsZS1mb3JtYXQtc3BlY2lmaWNhdGlvbi9cbiAqL1xuXG5cbnZhciBGQlhMb2FkZXIgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgZmJ4VHJlZTtcblx0dmFyIGNvbm5lY3Rpb25zO1xuXHR2YXIgc2NlbmVHcmFwaDtcblxuXHRmdW5jdGlvbiBGQlhMb2FkZXIoIG1hbmFnZXIgKSB7XG5cblx0XHRMb2FkZXIkMS5jYWxsKCB0aGlzLCBtYW5hZ2VyICk7XG5cblx0fVxuXG5cdEZCWExvYWRlci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMb2FkZXIkMS5wcm90b3R5cGUgKSwge1xuXG5cdFx0Y29uc3RydWN0b3I6IEZCWExvYWRlcixcblxuXHRcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHRcdHZhciBwYXRoID0gKCBzY29wZS5wYXRoID09PSAnJyApID8gTG9hZGVyVXRpbHMuZXh0cmFjdFVybEJhc2UoIHVybCApIDogc2NvcGUucGF0aDtcblxuXHRcdFx0dmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRcdGxvYWRlci5zZXRQYXRoKCBzY29wZS5wYXRoICk7XG5cdFx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cdFx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggc2NvcGUucmVxdWVzdEhlYWRlciApO1xuXHRcdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggc2NvcGUud2l0aENyZWRlbnRpYWxzICk7XG5cblx0XHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHRvbkxvYWQoIHNjb3BlLnBhcnNlKCBidWZmZXIsIHBhdGggKSApO1xuXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBvbkVycm9yICkge1xuXG5cdFx0XHRcdFx0XHRvbkVycm9yKCBlICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBlICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0XHR9LFxuXG5cdFx0cGFyc2U6IGZ1bmN0aW9uICggRkJYQnVmZmVyLCBwYXRoICkge1xuXG5cdFx0XHRpZiAoIGlzRmJ4Rm9ybWF0QmluYXJ5KCBGQlhCdWZmZXIgKSApIHtcblxuXHRcdFx0XHRmYnhUcmVlID0gbmV3IEJpbmFyeVBhcnNlcigpLnBhcnNlKCBGQlhCdWZmZXIgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR2YXIgRkJYVGV4dCA9IGNvbnZlcnRBcnJheUJ1ZmZlclRvU3RyaW5nKCBGQlhCdWZmZXIgKTtcblxuXHRcdFx0XHRpZiAoICEgaXNGYnhGb3JtYXRBU0NJSSggRkJYVGV4dCApICkge1xuXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuRkJYTG9hZGVyOiBVbmtub3duIGZvcm1hdC4nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZ2V0RmJ4VmVyc2lvbiggRkJYVGV4dCApIDwgNzAwMCApIHtcblxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkZCWExvYWRlcjogRkJYIHZlcnNpb24gbm90IHN1cHBvcnRlZCwgRmlsZVZlcnNpb246ICcgKyBnZXRGYnhWZXJzaW9uKCBGQlhUZXh0ICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZmJ4VHJlZSA9IG5ldyBUZXh0UGFyc2VyKCkucGFyc2UoIEZCWFRleHQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjb25zb2xlLmxvZyggZmJ4VHJlZSApO1xuXG5cdFx0XHR2YXIgdGV4dHVyZUxvYWRlciA9IG5ldyBUZXh0dXJlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKS5zZXRQYXRoKCB0aGlzLnJlc291cmNlUGF0aCB8fCBwYXRoICkuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcblxuXHRcdFx0cmV0dXJuIG5ldyBGQlhUcmVlUGFyc2VyKCB0ZXh0dXJlTG9hZGVyLCB0aGlzLm1hbmFnZXIgKS5wYXJzZSggZmJ4VHJlZSApO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvLyBQYXJzZSB0aGUgRkJYVHJlZSBvYmplY3QgcmV0dXJuZWQgYnkgdGhlIEJpbmFyeVBhcnNlciBvciBUZXh0UGFyc2VyIGFuZCByZXR1cm4gYSBHcm91cFxuXHRmdW5jdGlvbiBGQlhUcmVlUGFyc2VyKCB0ZXh0dXJlTG9hZGVyLCBtYW5hZ2VyICkge1xuXG5cdFx0dGhpcy50ZXh0dXJlTG9hZGVyID0gdGV4dHVyZUxvYWRlcjtcblx0XHR0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuXG5cdH1cblxuXHRGQlhUcmVlUGFyc2VyLnByb3RvdHlwZSA9IHtcblxuXHRcdGNvbnN0cnVjdG9yOiBGQlhUcmVlUGFyc2VyLFxuXG5cdFx0cGFyc2U6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29ubmVjdGlvbnMgPSB0aGlzLnBhcnNlQ29ubmVjdGlvbnMoKTtcblxuXHRcdFx0dmFyIGltYWdlcyA9IHRoaXMucGFyc2VJbWFnZXMoKTtcblx0XHRcdHZhciB0ZXh0dXJlcyA9IHRoaXMucGFyc2VUZXh0dXJlcyggaW1hZ2VzICk7XG5cdFx0XHR2YXIgbWF0ZXJpYWxzID0gdGhpcy5wYXJzZU1hdGVyaWFscyggdGV4dHVyZXMgKTtcblx0XHRcdHZhciBkZWZvcm1lcnMgPSB0aGlzLnBhcnNlRGVmb3JtZXJzKCk7XG5cdFx0XHR2YXIgZ2VvbWV0cnlNYXAgPSBuZXcgR2VvbWV0cnlQYXJzZXIoKS5wYXJzZSggZGVmb3JtZXJzICk7XG5cblx0XHRcdHRoaXMucGFyc2VTY2VuZSggZGVmb3JtZXJzLCBnZW9tZXRyeU1hcCwgbWF0ZXJpYWxzICk7XG5cblx0XHRcdHJldHVybiBzY2VuZUdyYXBoO1xuXG5cdFx0fSxcblxuXHRcdC8vIFBhcnNlcyBGQlhUcmVlLkNvbm5lY3Rpb25zIHdoaWNoIGhvbGRzIHBhcmVudC1jaGlsZCBjb25uZWN0aW9ucyBiZXR3ZWVuIG9iamVjdHMgKGUuZy4gbWF0ZXJpYWwgLT4gdGV4dHVyZSwgbW9kZWwtPmdlb21ldHJ5IClcblx0XHQvLyBhbmQgZGV0YWlscyB0aGUgY29ubmVjdGlvbiB0eXBlXG5cdFx0cGFyc2VDb25uZWN0aW9uczogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgY29ubmVjdGlvbk1hcCA9IG5ldyBNYXAoKTtcblxuXHRcdFx0aWYgKCAnQ29ubmVjdGlvbnMnIGluIGZieFRyZWUgKSB7XG5cblx0XHRcdFx0dmFyIHJhd0Nvbm5lY3Rpb25zID0gZmJ4VHJlZS5Db25uZWN0aW9ucy5jb25uZWN0aW9ucztcblxuXHRcdFx0XHRyYXdDb25uZWN0aW9ucy5mb3JFYWNoKCBmdW5jdGlvbiAoIHJhd0Nvbm5lY3Rpb24gKSB7XG5cblx0XHRcdFx0XHR2YXIgZnJvbUlEID0gcmF3Q29ubmVjdGlvblsgMCBdO1xuXHRcdFx0XHRcdHZhciB0b0lEID0gcmF3Q29ubmVjdGlvblsgMSBdO1xuXHRcdFx0XHRcdHZhciByZWxhdGlvbnNoaXAgPSByYXdDb25uZWN0aW9uWyAyIF07XG5cblx0XHRcdFx0XHRpZiAoICEgY29ubmVjdGlvbk1hcC5oYXMoIGZyb21JRCApICkge1xuXG5cdFx0XHRcdFx0XHRjb25uZWN0aW9uTWFwLnNldCggZnJvbUlELCB7XG5cdFx0XHRcdFx0XHRcdHBhcmVudHM6IFtdLFxuXHRcdFx0XHRcdFx0XHRjaGlsZHJlbjogW11cblx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBwYXJlbnRSZWxhdGlvbnNoaXAgPSB7IElEOiB0b0lELCByZWxhdGlvbnNoaXA6IHJlbGF0aW9uc2hpcCB9O1xuXHRcdFx0XHRcdGNvbm5lY3Rpb25NYXAuZ2V0KCBmcm9tSUQgKS5wYXJlbnRzLnB1c2goIHBhcmVudFJlbGF0aW9uc2hpcCApO1xuXG5cdFx0XHRcdFx0aWYgKCAhIGNvbm5lY3Rpb25NYXAuaGFzKCB0b0lEICkgKSB7XG5cblx0XHRcdFx0XHRcdGNvbm5lY3Rpb25NYXAuc2V0KCB0b0lELCB7XG5cdFx0XHRcdFx0XHRcdHBhcmVudHM6IFtdLFxuXHRcdFx0XHRcdFx0XHRjaGlsZHJlbjogW11cblx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBjaGlsZFJlbGF0aW9uc2hpcCA9IHsgSUQ6IGZyb21JRCwgcmVsYXRpb25zaGlwOiByZWxhdGlvbnNoaXAgfTtcblx0XHRcdFx0XHRjb25uZWN0aW9uTWFwLmdldCggdG9JRCApLmNoaWxkcmVuLnB1c2goIGNoaWxkUmVsYXRpb25zaGlwICk7XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjb25uZWN0aW9uTWFwO1xuXG5cdFx0fSxcblxuXHRcdC8vIFBhcnNlIEZCWFRyZWUuT2JqZWN0cy5WaWRlbyBmb3IgZW1iZWRkZWQgaW1hZ2UgZGF0YVxuXHRcdC8vIFRoZXNlIGltYWdlcyBhcmUgY29ubmVjdGVkIHRvIHRleHR1cmVzIGluIEZCWFRyZWUuT2JqZWN0cy5UZXh0dXJlc1xuXHRcdC8vIHZpYSBGQlhUcmVlLkNvbm5lY3Rpb25zLlxuXHRcdHBhcnNlSW1hZ2VzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBpbWFnZXMgPSB7fTtcblx0XHRcdHZhciBibG9icyA9IHt9O1xuXG5cdFx0XHRpZiAoICdWaWRlbycgaW4gZmJ4VHJlZS5PYmplY3RzICkge1xuXG5cdFx0XHRcdHZhciB2aWRlb05vZGVzID0gZmJ4VHJlZS5PYmplY3RzLlZpZGVvO1xuXG5cdFx0XHRcdGZvciAoIHZhciBub2RlSUQgaW4gdmlkZW9Ob2RlcyApIHtcblxuXHRcdFx0XHRcdHZhciB2aWRlb05vZGUgPSB2aWRlb05vZGVzWyBub2RlSUQgXTtcblxuXHRcdFx0XHRcdHZhciBpZCA9IHBhcnNlSW50KCBub2RlSUQgKTtcblxuXHRcdFx0XHRcdGltYWdlc1sgaWQgXSA9IHZpZGVvTm9kZS5SZWxhdGl2ZUZpbGVuYW1lIHx8IHZpZGVvTm9kZS5GaWxlbmFtZTtcblxuXHRcdFx0XHRcdC8vIHJhdyBpbWFnZSBkYXRhIGlzIGluIHZpZGVvTm9kZS5Db250ZW50XG5cdFx0XHRcdFx0aWYgKCAnQ29udGVudCcgaW4gdmlkZW9Ob2RlICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgYXJyYXlCdWZmZXJDb250ZW50ID0gKCB2aWRlb05vZGUuQ29udGVudCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyICkgJiYgKCB2aWRlb05vZGUuQ29udGVudC5ieXRlTGVuZ3RoID4gMCApO1xuXHRcdFx0XHRcdFx0dmFyIGJhc2U2NENvbnRlbnQgPSAoIHR5cGVvZiB2aWRlb05vZGUuQ29udGVudCA9PT0gJ3N0cmluZycgKSAmJiAoIHZpZGVvTm9kZS5Db250ZW50ICE9PSAnJyApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGFycmF5QnVmZmVyQ29udGVudCB8fCBiYXNlNjRDb250ZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBpbWFnZSA9IHRoaXMucGFyc2VJbWFnZSggdmlkZW9Ob2Rlc1sgbm9kZUlEIF0gKTtcblxuXHRcdFx0XHRcdFx0XHRibG9ic1sgdmlkZW9Ob2RlLlJlbGF0aXZlRmlsZW5hbWUgfHwgdmlkZW9Ob2RlLkZpbGVuYW1lIF0gPSBpbWFnZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCB2YXIgaWQgaW4gaW1hZ2VzICkge1xuXG5cdFx0XHRcdHZhciBmaWxlbmFtZSA9IGltYWdlc1sgaWQgXTtcblxuXHRcdFx0XHRpZiAoIGJsb2JzWyBmaWxlbmFtZSBdICE9PSB1bmRlZmluZWQgKSBpbWFnZXNbIGlkIF0gPSBibG9ic1sgZmlsZW5hbWUgXTtcblx0XHRcdFx0ZWxzZSBpbWFnZXNbIGlkIF0gPSBpbWFnZXNbIGlkIF0uc3BsaXQoICdcXFxcJyApLnBvcCgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpbWFnZXM7XG5cblx0XHR9LFxuXG5cdFx0Ly8gUGFyc2UgZW1iZWRkZWQgaW1hZ2UgZGF0YSBpbiBGQlhUcmVlLlZpZGVvLkNvbnRlbnRcblx0XHRwYXJzZUltYWdlOiBmdW5jdGlvbiAoIHZpZGVvTm9kZSApIHtcblxuXHRcdFx0dmFyIGNvbnRlbnQgPSB2aWRlb05vZGUuQ29udGVudDtcblx0XHRcdHZhciBmaWxlTmFtZSA9IHZpZGVvTm9kZS5SZWxhdGl2ZUZpbGVuYW1lIHx8IHZpZGVvTm9kZS5GaWxlbmFtZTtcblx0XHRcdHZhciBleHRlbnNpb24gPSBmaWxlTmFtZS5zbGljZSggZmlsZU5hbWUubGFzdEluZGV4T2YoICcuJyApICsgMSApLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdHZhciB0eXBlO1xuXG5cdFx0XHRzd2l0Y2ggKCBleHRlbnNpb24gKSB7XG5cblx0XHRcdFx0Y2FzZSAnYm1wJzpcblxuXHRcdFx0XHRcdHR5cGUgPSAnaW1hZ2UvYm1wJztcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdqcGcnOlxuXHRcdFx0XHRjYXNlICdqcGVnJzpcblxuXHRcdFx0XHRcdHR5cGUgPSAnaW1hZ2UvanBlZyc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAncG5nJzpcblxuXHRcdFx0XHRcdHR5cGUgPSAnaW1hZ2UvcG5nJztcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICd0aWYnOlxuXG5cdFx0XHRcdFx0dHlwZSA9ICdpbWFnZS90aWZmJztcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICd0Z2EnOlxuXG5cdFx0XHRcdFx0aWYgKCB0aGlzLm1hbmFnZXIuZ2V0SGFuZGxlciggJy50Z2EnICkgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ0ZCWExvYWRlcjogVEdBIGxvYWRlciBub3QgZm91bmQsIHNraXBwaW5nICcsIGZpbGVOYW1lICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0eXBlID0gJ2ltYWdlL3RnYSc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ0ZCWExvYWRlcjogSW1hZ2UgdHlwZSBcIicgKyBleHRlbnNpb24gKyAnXCIgaXMgbm90IHN1cHBvcnRlZC4nICk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnICkgeyAvLyBBU0NJSSBmb3JtYXRcblxuXHRcdFx0XHRyZXR1cm4gJ2RhdGE6JyArIHR5cGUgKyAnO2Jhc2U2NCwnICsgY29udGVudDtcblxuXHRcdFx0fSBlbHNlIHsgLy8gQmluYXJ5IEZvcm1hdFxuXG5cdFx0XHRcdHZhciBhcnJheSA9IG5ldyBVaW50OEFycmF5KCBjb250ZW50ICk7XG5cdFx0XHRcdHJldHVybiB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTCggbmV3IEJsb2IoIFsgYXJyYXkgXSwgeyB0eXBlOiB0eXBlIH0gKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0Ly8gUGFyc2Ugbm9kZXMgaW4gRkJYVHJlZS5PYmplY3RzLlRleHR1cmVcblx0XHQvLyBUaGVzZSBjb250YWluIGRldGFpbHMgc3VjaCBhcyBVViBzY2FsaW5nLCBjcm9wcGluZywgcm90YXRpb24gZXRjIGFuZCBhcmUgY29ubmVjdGVkXG5cdFx0Ly8gdG8gaW1hZ2VzIGluIEZCWFRyZWUuT2JqZWN0cy5WaWRlb1xuXHRcdHBhcnNlVGV4dHVyZXM6IGZ1bmN0aW9uICggaW1hZ2VzICkge1xuXG5cdFx0XHR2YXIgdGV4dHVyZU1hcCA9IG5ldyBNYXAoKTtcblxuXHRcdFx0aWYgKCAnVGV4dHVyZScgaW4gZmJ4VHJlZS5PYmplY3RzICkge1xuXG5cdFx0XHRcdHZhciB0ZXh0dXJlTm9kZXMgPSBmYnhUcmVlLk9iamVjdHMuVGV4dHVyZTtcblx0XHRcdFx0Zm9yICggdmFyIG5vZGVJRCBpbiB0ZXh0dXJlTm9kZXMgKSB7XG5cblx0XHRcdFx0XHR2YXIgdGV4dHVyZSA9IHRoaXMucGFyc2VUZXh0dXJlKCB0ZXh0dXJlTm9kZXNbIG5vZGVJRCBdLCBpbWFnZXMgKTtcblx0XHRcdFx0XHR0ZXh0dXJlTWFwLnNldCggcGFyc2VJbnQoIG5vZGVJRCApLCB0ZXh0dXJlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0ZXh0dXJlTWFwO1xuXG5cdFx0fSxcblxuXHRcdC8vIFBhcnNlIGluZGl2aWR1YWwgbm9kZSBpbiBGQlhUcmVlLk9iamVjdHMuVGV4dHVyZVxuXHRcdHBhcnNlVGV4dHVyZTogZnVuY3Rpb24gKCB0ZXh0dXJlTm9kZSwgaW1hZ2VzICkge1xuXG5cdFx0XHR2YXIgdGV4dHVyZSA9IHRoaXMubG9hZFRleHR1cmUoIHRleHR1cmVOb2RlLCBpbWFnZXMgKTtcblxuXHRcdFx0dGV4dHVyZS5JRCA9IHRleHR1cmVOb2RlLmlkO1xuXG5cdFx0XHR0ZXh0dXJlLm5hbWUgPSB0ZXh0dXJlTm9kZS5hdHRyTmFtZTtcblxuXHRcdFx0dmFyIHdyYXBNb2RlVSA9IHRleHR1cmVOb2RlLldyYXBNb2RlVTtcblx0XHRcdHZhciB3cmFwTW9kZVYgPSB0ZXh0dXJlTm9kZS5XcmFwTW9kZVY7XG5cblx0XHRcdHZhciB2YWx1ZVUgPSB3cmFwTW9kZVUgIT09IHVuZGVmaW5lZCA/IHdyYXBNb2RlVS52YWx1ZSA6IDA7XG5cdFx0XHR2YXIgdmFsdWVWID0gd3JhcE1vZGVWICE9PSB1bmRlZmluZWQgPyB3cmFwTW9kZVYudmFsdWUgOiAwO1xuXG5cdFx0XHQvLyBodHRwOi8vZG93bmxvYWQuYXV0b2Rlc2suY29tL3VzL2ZieC9TREtkb2NzL0ZCWF9TREtfSGVscC9maWxlcy9mYnhzZGtyZWYvY2xhc3Nfa19mYnhfdGV4dHVyZS5odG1sIzg4OTY0MGU2M2UyZTY4MTI1OWVhODEwNjFiODUxNDNhXG5cdFx0XHQvLyAwOiByZXBlYXQoZGVmYXVsdCksIDE6IGNsYW1wXG5cblx0XHRcdHRleHR1cmUud3JhcFMgPSB2YWx1ZVUgPT09IDAgPyBSZXBlYXRXcmFwcGluZyA6IENsYW1wVG9FZGdlV3JhcHBpbmc7XG5cdFx0XHR0ZXh0dXJlLndyYXBUID0gdmFsdWVWID09PSAwID8gUmVwZWF0V3JhcHBpbmcgOiBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuXG5cdFx0XHRpZiAoICdTY2FsaW5nJyBpbiB0ZXh0dXJlTm9kZSApIHtcblxuXHRcdFx0XHR2YXIgdmFsdWVzID0gdGV4dHVyZU5vZGUuU2NhbGluZy52YWx1ZTtcblxuXHRcdFx0XHR0ZXh0dXJlLnJlcGVhdC54ID0gdmFsdWVzWyAwIF07XG5cdFx0XHRcdHRleHR1cmUucmVwZWF0LnkgPSB2YWx1ZXNbIDEgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHRcdH0sXG5cblx0XHQvLyBsb2FkIGEgdGV4dHVyZSBzcGVjaWZpZWQgYXMgYSBibG9iIG9yIGRhdGEgVVJJLCBvciB2aWEgYW4gZXh0ZXJuYWwgVVJMIHVzaW5nIFRleHR1cmVMb2FkZXJcblx0XHRsb2FkVGV4dHVyZTogZnVuY3Rpb24gKCB0ZXh0dXJlTm9kZSwgaW1hZ2VzICkge1xuXG5cdFx0XHR2YXIgZmlsZU5hbWU7XG5cblx0XHRcdHZhciBjdXJyZW50UGF0aCA9IHRoaXMudGV4dHVyZUxvYWRlci5wYXRoO1xuXG5cdFx0XHR2YXIgY2hpbGRyZW4gPSBjb25uZWN0aW9ucy5nZXQoIHRleHR1cmVOb2RlLmlkICkuY2hpbGRyZW47XG5cblx0XHRcdGlmICggY2hpbGRyZW4gIT09IHVuZGVmaW5lZCAmJiBjaGlsZHJlbi5sZW5ndGggPiAwICYmIGltYWdlc1sgY2hpbGRyZW5bIDAgXS5JRCBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0ZmlsZU5hbWUgPSBpbWFnZXNbIGNoaWxkcmVuWyAwIF0uSUQgXTtcblxuXHRcdFx0XHRpZiAoIGZpbGVOYW1lLmluZGV4T2YoICdibG9iOicgKSA9PT0gMCB8fCBmaWxlTmFtZS5pbmRleE9mKCAnZGF0YTonICkgPT09IDAgKSB7XG5cblx0XHRcdFx0XHR0aGlzLnRleHR1cmVMb2FkZXIuc2V0UGF0aCggdW5kZWZpbmVkICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciB0ZXh0dXJlO1xuXG5cdFx0XHR2YXIgZXh0ZW5zaW9uID0gdGV4dHVyZU5vZGUuRmlsZU5hbWUuc2xpY2UoIC0gMyApLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggZXh0ZW5zaW9uID09PSAndGdhJyApIHtcblxuXHRcdFx0XHR2YXIgbG9hZGVyID0gdGhpcy5tYW5hZ2VyLmdldEhhbmRsZXIoICcudGdhJyApO1xuXG5cdFx0XHRcdGlmICggbG9hZGVyID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnRkJYTG9hZGVyOiBUR0EgbG9hZGVyIG5vdCBmb3VuZCwgY3JlYXRpbmcgcGxhY2Vob2xkZXIgdGV4dHVyZSBmb3InLCB0ZXh0dXJlTm9kZS5SZWxhdGl2ZUZpbGVuYW1lICk7XG5cdFx0XHRcdFx0dGV4dHVyZSA9IG5ldyBUZXh0dXJlKCk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRleHR1cmUgPSBsb2FkZXIubG9hZCggZmlsZU5hbWUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIGV4dGVuc2lvbiA9PT0gJ3BzZCcgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnRkJYTG9hZGVyOiBQU0QgdGV4dHVyZXMgYXJlIG5vdCBzdXBwb3J0ZWQsIGNyZWF0aW5nIHBsYWNlaG9sZGVyIHRleHR1cmUgZm9yJywgdGV4dHVyZU5vZGUuUmVsYXRpdmVGaWxlbmFtZSApO1xuXHRcdFx0XHR0ZXh0dXJlID0gbmV3IFRleHR1cmUoKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0ZXh0dXJlID0gdGhpcy50ZXh0dXJlTG9hZGVyLmxvYWQoIGZpbGVOYW1lICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy50ZXh0dXJlTG9hZGVyLnNldFBhdGgoIGN1cnJlbnRQYXRoICk7XG5cblx0XHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdFx0fSxcblxuXHRcdC8vIFBhcnNlIG5vZGVzIGluIEZCWFRyZWUuT2JqZWN0cy5NYXRlcmlhbFxuXHRcdHBhcnNlTWF0ZXJpYWxzOiBmdW5jdGlvbiAoIHRleHR1cmVNYXAgKSB7XG5cblx0XHRcdHZhciBtYXRlcmlhbE1hcCA9IG5ldyBNYXAoKTtcblxuXHRcdFx0aWYgKCAnTWF0ZXJpYWwnIGluIGZieFRyZWUuT2JqZWN0cyApIHtcblxuXHRcdFx0XHR2YXIgbWF0ZXJpYWxOb2RlcyA9IGZieFRyZWUuT2JqZWN0cy5NYXRlcmlhbDtcblxuXHRcdFx0XHRmb3IgKCB2YXIgbm9kZUlEIGluIG1hdGVyaWFsTm9kZXMgKSB7XG5cblx0XHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSB0aGlzLnBhcnNlTWF0ZXJpYWwoIG1hdGVyaWFsTm9kZXNbIG5vZGVJRCBdLCB0ZXh0dXJlTWFwICk7XG5cblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsICE9PSBudWxsICkgbWF0ZXJpYWxNYXAuc2V0KCBwYXJzZUludCggbm9kZUlEICksIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRlcmlhbE1hcDtcblxuXHRcdH0sXG5cblx0XHQvLyBQYXJzZSBzaW5nbGUgbm9kZSBpbiBGQlhUcmVlLk9iamVjdHMuTWF0ZXJpYWxcblx0XHQvLyBNYXRlcmlhbHMgYXJlIGNvbm5lY3RlZCB0byB0ZXh0dXJlIG1hcHMgaW4gRkJYVHJlZS5PYmplY3RzLlRleHR1cmVzXG5cdFx0Ly8gRkJYIGZvcm1hdCBjdXJyZW50bHkgb25seSBzdXBwb3J0cyBMYW1iZXJ0IGFuZCBQaG9uZyBzaGFkaW5nIG1vZGVsc1xuXHRcdHBhcnNlTWF0ZXJpYWw6IGZ1bmN0aW9uICggbWF0ZXJpYWxOb2RlLCB0ZXh0dXJlTWFwICkge1xuXG5cdFx0XHR2YXIgSUQgPSBtYXRlcmlhbE5vZGUuaWQ7XG5cdFx0XHR2YXIgbmFtZSA9IG1hdGVyaWFsTm9kZS5hdHRyTmFtZTtcblx0XHRcdHZhciB0eXBlID0gbWF0ZXJpYWxOb2RlLlNoYWRpbmdNb2RlbDtcblxuXHRcdFx0Ly8gQ2FzZSB3aGVyZSBGQlggd3JhcHMgc2hhZGluZyBtb2RlbCBpbiBwcm9wZXJ0eSBvYmplY3QuXG5cdFx0XHRpZiAoIHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyApIHtcblxuXHRcdFx0XHR0eXBlID0gdHlwZS52YWx1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZ25vcmUgdW51c2VkIG1hdGVyaWFscyB3aGljaCBkb24ndCBoYXZlIGFueSBjb25uZWN0aW9ucy5cblx0XHRcdGlmICggISBjb25uZWN0aW9ucy5oYXMoIElEICkgKSByZXR1cm4gbnVsbDtcblxuXHRcdFx0dmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcnNlUGFyYW1ldGVycyggbWF0ZXJpYWxOb2RlLCB0ZXh0dXJlTWFwLCBJRCApO1xuXG5cdFx0XHR2YXIgbWF0ZXJpYWw7XG5cblx0XHRcdHN3aXRjaCAoIHR5cGUudG9Mb3dlckNhc2UoKSApIHtcblxuXHRcdFx0XHRjYXNlICdwaG9uZyc6XG5cdFx0XHRcdFx0bWF0ZXJpYWwgPSBuZXcgTWVzaFBob25nTWF0ZXJpYWwoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnbGFtYmVydCc6XG5cdFx0XHRcdFx0bWF0ZXJpYWwgPSBuZXcgTWVzaExhbWJlcnRNYXRlcmlhbCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZCWExvYWRlcjogdW5rbm93biBtYXRlcmlhbCB0eXBlIFwiJXNcIi4gRGVmYXVsdGluZyB0byBNZXNoUGhvbmdNYXRlcmlhbC4nLCB0eXBlICk7XG5cdFx0XHRcdFx0bWF0ZXJpYWwgPSBuZXcgTWVzaFBob25nTWF0ZXJpYWwoKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0XHRtYXRlcmlhbC5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblx0XHRcdG1hdGVyaWFsLm5hbWUgPSBuYW1lO1xuXG5cdFx0XHRyZXR1cm4gbWF0ZXJpYWw7XG5cblx0XHR9LFxuXG5cdFx0Ly8gUGFyc2UgRkJYIG1hdGVyaWFsIGFuZCByZXR1cm4gcGFyYW1ldGVycyBzdWl0YWJsZSBmb3IgYSB0aHJlZS5qcyBtYXRlcmlhbFxuXHRcdC8vIEFsc28gcGFyc2UgdGhlIHRleHR1cmUgbWFwIGFuZCByZXR1cm4gYW55IHRleHR1cmVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgbWF0ZXJpYWxcblx0XHRwYXJzZVBhcmFtZXRlcnM6IGZ1bmN0aW9uICggbWF0ZXJpYWxOb2RlLCB0ZXh0dXJlTWFwLCBJRCApIHtcblxuXHRcdFx0dmFyIHBhcmFtZXRlcnMgPSB7fTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbE5vZGUuQnVtcEZhY3RvciApIHtcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLmJ1bXBTY2FsZSA9IG1hdGVyaWFsTm9kZS5CdW1wRmFjdG9yLnZhbHVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWxOb2RlLkRpZmZ1c2UgKSB7XG5cblx0XHRcdFx0cGFyYW1ldGVycy5jb2xvciA9IG5ldyBDb2xvcigpLmZyb21BcnJheSggbWF0ZXJpYWxOb2RlLkRpZmZ1c2UudmFsdWUgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWxOb2RlLkRpZmZ1c2VDb2xvciAmJiAoIG1hdGVyaWFsTm9kZS5EaWZmdXNlQ29sb3IudHlwZSA9PT0gJ0NvbG9yJyB8fCBtYXRlcmlhbE5vZGUuRGlmZnVzZUNvbG9yLnR5cGUgPT09ICdDb2xvclJHQicgKSApIHtcblxuXHRcdFx0XHQvLyBUaGUgYmxlbmRlciBleHBvcnRlciBleHBvcnRzIGRpZmZ1c2UgaGVyZSBpbnN0ZWFkIG9mIGluIG1hdGVyaWFsTm9kZS5EaWZmdXNlXG5cdFx0XHRcdHBhcmFtZXRlcnMuY29sb3IgPSBuZXcgQ29sb3IoKS5mcm9tQXJyYXkoIG1hdGVyaWFsTm9kZS5EaWZmdXNlQ29sb3IudmFsdWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsTm9kZS5EaXNwbGFjZW1lbnRGYWN0b3IgKSB7XG5cblx0XHRcdFx0cGFyYW1ldGVycy5kaXNwbGFjZW1lbnRTY2FsZSA9IG1hdGVyaWFsTm9kZS5EaXNwbGFjZW1lbnRGYWN0b3IudmFsdWU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbE5vZGUuRW1pc3NpdmUgKSB7XG5cblx0XHRcdFx0cGFyYW1ldGVycy5lbWlzc2l2ZSA9IG5ldyBDb2xvcigpLmZyb21BcnJheSggbWF0ZXJpYWxOb2RlLkVtaXNzaXZlLnZhbHVlICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsTm9kZS5FbWlzc2l2ZUNvbG9yICYmICggbWF0ZXJpYWxOb2RlLkVtaXNzaXZlQ29sb3IudHlwZSA9PT0gJ0NvbG9yJyB8fCBtYXRlcmlhbE5vZGUuRW1pc3NpdmVDb2xvci50eXBlID09PSAnQ29sb3JSR0InICkgKSB7XG5cblx0XHRcdFx0Ly8gVGhlIGJsZW5kZXIgZXhwb3J0ZXIgZXhwb3J0cyBlbWlzc2l2ZSBjb2xvciBoZXJlIGluc3RlYWQgb2YgaW4gbWF0ZXJpYWxOb2RlLkVtaXNzaXZlXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoKS5mcm9tQXJyYXkoIG1hdGVyaWFsTm9kZS5FbWlzc2l2ZUNvbG9yLnZhbHVlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbE5vZGUuRW1pc3NpdmVGYWN0b3IgKSB7XG5cblx0XHRcdFx0cGFyYW1ldGVycy5lbWlzc2l2ZUludGVuc2l0eSA9IHBhcnNlRmxvYXQoIG1hdGVyaWFsTm9kZS5FbWlzc2l2ZUZhY3Rvci52YWx1ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWxOb2RlLk9wYWNpdHkgKSB7XG5cblx0XHRcdFx0cGFyYW1ldGVycy5vcGFjaXR5ID0gcGFyc2VGbG9hdCggbWF0ZXJpYWxOb2RlLk9wYWNpdHkudmFsdWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHBhcmFtZXRlcnMub3BhY2l0eSA8IDEuMCApIHtcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsTm9kZS5SZWZsZWN0aW9uRmFjdG9yICkge1xuXG5cdFx0XHRcdHBhcmFtZXRlcnMucmVmbGVjdGl2aXR5ID0gbWF0ZXJpYWxOb2RlLlJlZmxlY3Rpb25GYWN0b3IudmFsdWU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbE5vZGUuU2hpbmluZXNzICkge1xuXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2hpbmluZXNzID0gbWF0ZXJpYWxOb2RlLlNoaW5pbmVzcy52YWx1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsTm9kZS5TcGVjdWxhciApIHtcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFyID0gbmV3IENvbG9yKCkuZnJvbUFycmF5KCBtYXRlcmlhbE5vZGUuU3BlY3VsYXIudmFsdWUgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWxOb2RlLlNwZWN1bGFyQ29sb3IgJiYgbWF0ZXJpYWxOb2RlLlNwZWN1bGFyQ29sb3IudHlwZSA9PT0gJ0NvbG9yJyApIHtcblxuXHRcdFx0XHQvLyBUaGUgYmxlbmRlciBleHBvcnRlciBleHBvcnRzIHNwZWN1bGFyIGNvbG9yIGhlcmUgaW5zdGVhZCBvZiBpbiBtYXRlcmlhbE5vZGUuU3BlY3VsYXJcblx0XHRcdFx0cGFyYW1ldGVycy5zcGVjdWxhciA9IG5ldyBDb2xvcigpLmZyb21BcnJheSggbWF0ZXJpYWxOb2RlLlNwZWN1bGFyQ29sb3IudmFsdWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXHRcdFx0Y29ubmVjdGlvbnMuZ2V0KCBJRCApLmNoaWxkcmVuLmZvckVhY2goIGZ1bmN0aW9uICggY2hpbGQgKSB7XG5cblx0XHRcdFx0dmFyIHR5cGUgPSBjaGlsZC5yZWxhdGlvbnNoaXA7XG5cblx0XHRcdFx0c3dpdGNoICggdHlwZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ0J1bXAnOlxuXHRcdFx0XHRcdFx0cGFyYW1ldGVycy5idW1wTWFwID0gc2NvcGUuZ2V0VGV4dHVyZSggdGV4dHVyZU1hcCwgY2hpbGQuSUQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnTWF5YXxURVhfYW9fbWFwJzpcblx0XHRcdFx0XHRcdHBhcmFtZXRlcnMuYW9NYXAgPSBzY29wZS5nZXRUZXh0dXJlKCB0ZXh0dXJlTWFwLCBjaGlsZC5JRCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdEaWZmdXNlQ29sb3InOlxuXHRcdFx0XHRcdGNhc2UgJ01heWF8VEVYX2NvbG9yX21hcCc6XG5cdFx0XHRcdFx0XHRwYXJhbWV0ZXJzLm1hcCA9IHNjb3BlLmdldFRleHR1cmUoIHRleHR1cmVNYXAsIGNoaWxkLklEICk7XG5cdFx0XHRcdFx0XHRwYXJhbWV0ZXJzLm1hcC5lbmNvZGluZyA9IHNSR0JFbmNvZGluZztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnRGlzcGxhY2VtZW50Q29sb3InOlxuXHRcdFx0XHRcdFx0cGFyYW1ldGVycy5kaXNwbGFjZW1lbnRNYXAgPSBzY29wZS5nZXRUZXh0dXJlKCB0ZXh0dXJlTWFwLCBjaGlsZC5JRCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdFbWlzc2l2ZUNvbG9yJzpcblx0XHRcdFx0XHRcdHBhcmFtZXRlcnMuZW1pc3NpdmVNYXAgPSBzY29wZS5nZXRUZXh0dXJlKCB0ZXh0dXJlTWFwLCBjaGlsZC5JRCApO1xuXHRcdFx0XHRcdFx0cGFyYW1ldGVycy5lbWlzc2l2ZU1hcC5lbmNvZGluZyA9IHNSR0JFbmNvZGluZztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnTm9ybWFsTWFwJzpcblx0XHRcdFx0XHRjYXNlICdNYXlhfFRFWF9ub3JtYWxfbWFwJzpcblx0XHRcdFx0XHRcdHBhcmFtZXRlcnMubm9ybWFsTWFwID0gc2NvcGUuZ2V0VGV4dHVyZSggdGV4dHVyZU1hcCwgY2hpbGQuSUQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnUmVmbGVjdGlvbkNvbG9yJzpcblx0XHRcdFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID0gc2NvcGUuZ2V0VGV4dHVyZSggdGV4dHVyZU1hcCwgY2hpbGQuSUQgKTtcblx0XHRcdFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwLm1hcHBpbmcgPSBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZztcblx0XHRcdFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwLmVuY29kaW5nID0gc1JHQkVuY29kaW5nO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdTcGVjdWxhckNvbG9yJzpcblx0XHRcdFx0XHRcdHBhcmFtZXRlcnMuc3BlY3VsYXJNYXAgPSBzY29wZS5nZXRUZXh0dXJlKCB0ZXh0dXJlTWFwLCBjaGlsZC5JRCApO1xuXHRcdFx0XHRcdFx0cGFyYW1ldGVycy5zcGVjdWxhck1hcC5lbmNvZGluZyA9IHNSR0JFbmNvZGluZztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnVHJhbnNwYXJlbnRDb2xvcic6XG5cdFx0XHRcdFx0Y2FzZSAnVHJhbnNwYXJlbmN5RmFjdG9yJzpcblx0XHRcdFx0XHRcdHBhcmFtZXRlcnMuYWxwaGFNYXAgPSBzY29wZS5nZXRUZXh0dXJlKCB0ZXh0dXJlTWFwLCBjaGlsZC5JRCApO1xuXHRcdFx0XHRcdFx0cGFyYW1ldGVycy50cmFuc3BhcmVudCA9IHRydWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0FtYmllbnRDb2xvcic6XG5cdFx0XHRcdFx0Y2FzZSAnU2hpbmluZXNzRXhwb25lbnQnOiAvLyBBS0EgZ2xvc3NpbmVzcyBtYXBcblx0XHRcdFx0XHRjYXNlICdTcGVjdWxhckZhY3Rvcic6IC8vIEFLQSBzcGVjdWxhckxldmVsXG5cdFx0XHRcdFx0Y2FzZSAnVmVjdG9yRGlzcGxhY2VtZW50Q29sb3InOiAvLyBOT1RFOiBTZWVtcyB0byBiZSBhIGNvcHkgb2YgRGlzcGxhY2VtZW50Q29sb3Jcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRkJYTG9hZGVyOiAlcyBtYXAgaXMgbm90IHN1cHBvcnRlZCBpbiB0aHJlZS5qcywgc2tpcHBpbmcgdGV4dHVyZS4nLCB0eXBlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0cmV0dXJuIHBhcmFtZXRlcnM7XG5cblx0XHR9LFxuXG5cdFx0Ly8gZ2V0IGEgdGV4dHVyZSBmcm9tIHRoZSB0ZXh0dXJlTWFwIGZvciB1c2UgYnkgYSBtYXRlcmlhbC5cblx0XHRnZXRUZXh0dXJlOiBmdW5jdGlvbiAoIHRleHR1cmVNYXAsIGlkICkge1xuXG5cdFx0XHQvLyBpZiB0aGUgdGV4dHVyZSBpcyBhIGxheWVyZWQgdGV4dHVyZSwganVzdCB1c2UgdGhlIGZpcnN0IGxheWVyIGFuZCBpc3N1ZSBhIHdhcm5pbmdcblx0XHRcdGlmICggJ0xheWVyZWRUZXh0dXJlJyBpbiBmYnhUcmVlLk9iamVjdHMgJiYgaWQgaW4gZmJ4VHJlZS5PYmplY3RzLkxheWVyZWRUZXh0dXJlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZCWExvYWRlcjogbGF5ZXJlZCB0ZXh0dXJlcyBhcmUgbm90IHN1cHBvcnRlZCBpbiB0aHJlZS5qcy4gRGlzY2FyZGluZyBhbGwgYnV0IGZpcnN0IGxheWVyLicgKTtcblx0XHRcdFx0aWQgPSBjb25uZWN0aW9ucy5nZXQoIGlkICkuY2hpbGRyZW5bIDAgXS5JRDtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGV4dHVyZU1hcC5nZXQoIGlkICk7XG5cblx0XHR9LFxuXG5cdFx0Ly8gUGFyc2Ugbm9kZXMgaW4gRkJYVHJlZS5PYmplY3RzLkRlZm9ybWVyXG5cdFx0Ly8gRGVmb3JtZXIgbm9kZSBjYW4gY29udGFpbiBza2lubmluZyBvciBWZXJ0ZXggQ2FjaGUgYW5pbWF0aW9uIGRhdGEsIGhvd2V2ZXIgb25seSBza2lubmluZyBpcyBzdXBwb3J0ZWQgaGVyZVxuXHRcdC8vIEdlbmVyYXRlcyBtYXAgb2YgU2tlbGV0b24tbGlrZSBvYmplY3RzIGZvciB1c2UgbGF0ZXIgd2hlbiBnZW5lcmF0aW5nIGFuZCBiaW5kaW5nIHNrZWxldG9ucy5cblx0XHRwYXJzZURlZm9ybWVyczogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgc2tlbGV0b25zID0ge307XG5cdFx0XHR2YXIgbW9ycGhUYXJnZXRzID0ge307XG5cblx0XHRcdGlmICggJ0RlZm9ybWVyJyBpbiBmYnhUcmVlLk9iamVjdHMgKSB7XG5cblx0XHRcdFx0dmFyIERlZm9ybWVyTm9kZXMgPSBmYnhUcmVlLk9iamVjdHMuRGVmb3JtZXI7XG5cblx0XHRcdFx0Zm9yICggdmFyIG5vZGVJRCBpbiBEZWZvcm1lck5vZGVzICkge1xuXG5cdFx0XHRcdFx0dmFyIGRlZm9ybWVyTm9kZSA9IERlZm9ybWVyTm9kZXNbIG5vZGVJRCBdO1xuXG5cdFx0XHRcdFx0dmFyIHJlbGF0aW9uc2hpcHMgPSBjb25uZWN0aW9ucy5nZXQoIHBhcnNlSW50KCBub2RlSUQgKSApO1xuXG5cdFx0XHRcdFx0aWYgKCBkZWZvcm1lck5vZGUuYXR0clR5cGUgPT09ICdTa2luJyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHNrZWxldG9uID0gdGhpcy5wYXJzZVNrZWxldG9uKCByZWxhdGlvbnNoaXBzLCBEZWZvcm1lck5vZGVzICk7XG5cdFx0XHRcdFx0XHRza2VsZXRvbi5JRCA9IG5vZGVJRDtcblxuXHRcdFx0XHRcdFx0aWYgKCByZWxhdGlvbnNoaXBzLnBhcmVudHMubGVuZ3RoID4gMSApIGNvbnNvbGUud2FybiggJ1RIUkVFLkZCWExvYWRlcjogc2tlbGV0b24gYXR0YWNoZWQgdG8gbW9yZSB0aGFuIG9uZSBnZW9tZXRyeSBpcyBub3Qgc3VwcG9ydGVkLicgKTtcblx0XHRcdFx0XHRcdHNrZWxldG9uLmdlb21ldHJ5SUQgPSByZWxhdGlvbnNoaXBzLnBhcmVudHNbIDAgXS5JRDtcblxuXHRcdFx0XHRcdFx0c2tlbGV0b25zWyBub2RlSUQgXSA9IHNrZWxldG9uO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggZGVmb3JtZXJOb2RlLmF0dHJUeXBlID09PSAnQmxlbmRTaGFwZScgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBtb3JwaFRhcmdldCA9IHtcblx0XHRcdFx0XHRcdFx0aWQ6IG5vZGVJRCxcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdG1vcnBoVGFyZ2V0LnJhd1RhcmdldHMgPSB0aGlzLnBhcnNlTW9ycGhUYXJnZXRzKCByZWxhdGlvbnNoaXBzLCBEZWZvcm1lck5vZGVzICk7XG5cdFx0XHRcdFx0XHRtb3JwaFRhcmdldC5pZCA9IG5vZGVJRDtcblxuXHRcdFx0XHRcdFx0aWYgKCByZWxhdGlvbnNoaXBzLnBhcmVudHMubGVuZ3RoID4gMSApIGNvbnNvbGUud2FybiggJ1RIUkVFLkZCWExvYWRlcjogbW9ycGggdGFyZ2V0IGF0dGFjaGVkIHRvIG1vcmUgdGhhbiBvbmUgZ2VvbWV0cnkgaXMgbm90IHN1cHBvcnRlZC4nICk7XG5cblx0XHRcdFx0XHRcdG1vcnBoVGFyZ2V0c1sgbm9kZUlEIF0gPSBtb3JwaFRhcmdldDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtcblxuXHRcdFx0XHRza2VsZXRvbnM6IHNrZWxldG9ucyxcblx0XHRcdFx0bW9ycGhUYXJnZXRzOiBtb3JwaFRhcmdldHMsXG5cblx0XHRcdH07XG5cblx0XHR9LFxuXG5cdFx0Ly8gUGFyc2Ugc2luZ2xlIG5vZGVzIGluIEZCWFRyZWUuT2JqZWN0cy5EZWZvcm1lclxuXHRcdC8vIFRoZSB0b3AgbGV2ZWwgc2tlbGV0b24gbm9kZSBoYXMgdHlwZSAnU2tpbicgYW5kIHN1YiBub2RlcyBoYXZlIHR5cGUgJ0NsdXN0ZXInXG5cdFx0Ly8gRWFjaCBza2luIG5vZGUgcmVwcmVzZW50cyBhIHNrZWxldG9uIGFuZCBlYWNoIGNsdXN0ZXIgbm9kZSByZXByZXNlbnRzIGEgYm9uZVxuXHRcdHBhcnNlU2tlbGV0b246IGZ1bmN0aW9uICggcmVsYXRpb25zaGlwcywgZGVmb3JtZXJOb2RlcyApIHtcblxuXHRcdFx0dmFyIHJhd0JvbmVzID0gW107XG5cblx0XHRcdHJlbGF0aW9uc2hpcHMuY2hpbGRyZW4uZm9yRWFjaCggZnVuY3Rpb24gKCBjaGlsZCApIHtcblxuXHRcdFx0XHR2YXIgYm9uZU5vZGUgPSBkZWZvcm1lck5vZGVzWyBjaGlsZC5JRCBdO1xuXG5cdFx0XHRcdGlmICggYm9uZU5vZGUuYXR0clR5cGUgIT09ICdDbHVzdGVyJyApIHJldHVybjtcblxuXHRcdFx0XHR2YXIgcmF3Qm9uZSA9IHtcblxuXHRcdFx0XHRcdElEOiBjaGlsZC5JRCxcblx0XHRcdFx0XHRpbmRpY2VzOiBbXSxcblx0XHRcdFx0XHR3ZWlnaHRzOiBbXSxcblx0XHRcdFx0XHR0cmFuc2Zvcm1MaW5rOiBuZXcgTWF0cml4NCgpLmZyb21BcnJheSggYm9uZU5vZGUuVHJhbnNmb3JtTGluay5hICksXG5cdFx0XHRcdFx0Ly8gdHJhbnNmb3JtOiBuZXcgTWF0cml4NCgpLmZyb21BcnJheSggYm9uZU5vZGUuVHJhbnNmb3JtLmEgKSxcblx0XHRcdFx0XHQvLyBsaW5rTW9kZTogYm9uZU5vZGUuTW9kZSxcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGlmICggJ0luZGV4ZXMnIGluIGJvbmVOb2RlICkge1xuXG5cdFx0XHRcdFx0cmF3Qm9uZS5pbmRpY2VzID0gYm9uZU5vZGUuSW5kZXhlcy5hO1xuXHRcdFx0XHRcdHJhd0JvbmUud2VpZ2h0cyA9IGJvbmVOb2RlLldlaWdodHMuYTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmF3Qm9uZXMucHVzaCggcmF3Qm9uZSApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHJldHVybiB7XG5cblx0XHRcdFx0cmF3Qm9uZXM6IHJhd0JvbmVzLFxuXHRcdFx0XHRib25lczogW11cblxuXHRcdFx0fTtcblxuXHRcdH0sXG5cblx0XHQvLyBUaGUgdG9wIGxldmVsIG1vcnBoIGRlZm9ybWVyIG5vZGUgaGFzIHR5cGUgXCJCbGVuZFNoYXBlXCIgYW5kIHN1YiBub2RlcyBoYXZlIHR5cGUgXCJCbGVuZFNoYXBlQ2hhbm5lbFwiXG5cdFx0cGFyc2VNb3JwaFRhcmdldHM6IGZ1bmN0aW9uICggcmVsYXRpb25zaGlwcywgZGVmb3JtZXJOb2RlcyApIHtcblxuXHRcdFx0dmFyIHJhd01vcnBoVGFyZ2V0cyA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCByZWxhdGlvbnNoaXBzLmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSByZWxhdGlvbnNoaXBzLmNoaWxkcmVuWyBpIF07XG5cblx0XHRcdFx0dmFyIG1vcnBoVGFyZ2V0Tm9kZSA9IGRlZm9ybWVyTm9kZXNbIGNoaWxkLklEIF07XG5cblx0XHRcdFx0dmFyIHJhd01vcnBoVGFyZ2V0ID0ge1xuXG5cdFx0XHRcdFx0bmFtZTogbW9ycGhUYXJnZXROb2RlLmF0dHJOYW1lLFxuXHRcdFx0XHRcdGluaXRpYWxXZWlnaHQ6IG1vcnBoVGFyZ2V0Tm9kZS5EZWZvcm1QZXJjZW50LFxuXHRcdFx0XHRcdGlkOiBtb3JwaFRhcmdldE5vZGUuaWQsXG5cdFx0XHRcdFx0ZnVsbFdlaWdodHM6IG1vcnBoVGFyZ2V0Tm9kZS5GdWxsV2VpZ2h0cy5hXG5cblx0XHRcdFx0fTtcblxuXHRcdFx0XHRpZiAoIG1vcnBoVGFyZ2V0Tm9kZS5hdHRyVHlwZSAhPT0gJ0JsZW5kU2hhcGVDaGFubmVsJyApIHJldHVybjtcblxuXHRcdFx0XHRyYXdNb3JwaFRhcmdldC5nZW9JRCA9IGNvbm5lY3Rpb25zLmdldCggcGFyc2VJbnQoIGNoaWxkLklEICkgKS5jaGlsZHJlbi5maWx0ZXIoIGZ1bmN0aW9uICggY2hpbGQgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gY2hpbGQucmVsYXRpb25zaGlwID09PSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0fSApWyAwIF0uSUQ7XG5cblx0XHRcdFx0cmF3TW9ycGhUYXJnZXRzLnB1c2goIHJhd01vcnBoVGFyZ2V0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJhd01vcnBoVGFyZ2V0cztcblxuXHRcdH0sXG5cblx0XHQvLyBjcmVhdGUgdGhlIG1haW4gR3JvdXAoKSB0byBiZSByZXR1cm5lZCBieSB0aGUgbG9hZGVyXG5cdFx0cGFyc2VTY2VuZTogZnVuY3Rpb24gKCBkZWZvcm1lcnMsIGdlb21ldHJ5TWFwLCBtYXRlcmlhbE1hcCApIHtcblxuXHRcdFx0c2NlbmVHcmFwaCA9IG5ldyBHcm91cCgpO1xuXG5cdFx0XHR2YXIgbW9kZWxNYXAgPSB0aGlzLnBhcnNlTW9kZWxzKCBkZWZvcm1lcnMuc2tlbGV0b25zLCBnZW9tZXRyeU1hcCwgbWF0ZXJpYWxNYXAgKTtcblxuXHRcdFx0dmFyIG1vZGVsTm9kZXMgPSBmYnhUcmVlLk9iamVjdHMuTW9kZWw7XG5cblx0XHRcdHZhciBzY29wZSA9IHRoaXM7XG5cdFx0XHRtb2RlbE1hcC5mb3JFYWNoKCBmdW5jdGlvbiAoIG1vZGVsICkge1xuXG5cdFx0XHRcdHZhciBtb2RlbE5vZGUgPSBtb2RlbE5vZGVzWyBtb2RlbC5JRCBdO1xuXHRcdFx0XHRzY29wZS5zZXRMb29rQXRQcm9wZXJ0aWVzKCBtb2RlbCwgbW9kZWxOb2RlICk7XG5cblx0XHRcdFx0dmFyIHBhcmVudENvbm5lY3Rpb25zID0gY29ubmVjdGlvbnMuZ2V0KCBtb2RlbC5JRCApLnBhcmVudHM7XG5cblx0XHRcdFx0cGFyZW50Q29ubmVjdGlvbnMuZm9yRWFjaCggZnVuY3Rpb24gKCBjb25uZWN0aW9uICkge1xuXG5cdFx0XHRcdFx0dmFyIHBhcmVudCA9IG1vZGVsTWFwLmdldCggY29ubmVjdGlvbi5JRCApO1xuXHRcdFx0XHRcdGlmICggcGFyZW50ICE9PSB1bmRlZmluZWQgKSBwYXJlbnQuYWRkKCBtb2RlbCApO1xuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRpZiAoIG1vZGVsLnBhcmVudCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdHNjZW5lR3JhcGguYWRkKCBtb2RlbCApO1xuXG5cdFx0XHRcdH1cblxuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHRoaXMuYmluZFNrZWxldG9uKCBkZWZvcm1lcnMuc2tlbGV0b25zLCBnZW9tZXRyeU1hcCwgbW9kZWxNYXAgKTtcblxuXHRcdFx0dGhpcy5jcmVhdGVBbWJpZW50TGlnaHQoKTtcblxuXHRcdFx0dGhpcy5zZXR1cE1vcnBoTWF0ZXJpYWxzKCk7XG5cblx0XHRcdHNjZW5lR3JhcGgudHJhdmVyc2UoIGZ1bmN0aW9uICggbm9kZSApIHtcblxuXHRcdFx0XHRpZiAoIG5vZGUudXNlckRhdGEudHJhbnNmb3JtRGF0YSApIHtcblxuXHRcdFx0XHRcdGlmICggbm9kZS5wYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdG5vZGUudXNlckRhdGEudHJhbnNmb3JtRGF0YS5wYXJlbnRNYXRyaXggPSBub2RlLnBhcmVudC5tYXRyaXg7XG5cdFx0XHRcdFx0XHRub2RlLnVzZXJEYXRhLnRyYW5zZm9ybURhdGEucGFyZW50TWF0cml4V29ybGQgPSBub2RlLnBhcmVudC5tYXRyaXhXb3JsZDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciB0cmFuc2Zvcm0gPSBnZW5lcmF0ZVRyYW5zZm9ybSggbm9kZS51c2VyRGF0YS50cmFuc2Zvcm1EYXRhICk7XG5cblx0XHRcdFx0XHRub2RlLmFwcGx5TWF0cml4NCggdHJhbnNmb3JtICk7XG5cdFx0XHRcdFx0bm9kZS51cGRhdGVXb3JsZE1hdHJpeCgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0XHR2YXIgYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25QYXJzZXIoKS5wYXJzZSgpO1xuXG5cdFx0XHQvLyBpZiBhbGwgdGhlIG1vZGVscyB3aGVyZSBhbHJlYWR5IGNvbWJpbmVkIGluIGEgc2luZ2xlIGdyb3VwLCBqdXN0IHJldHVybiB0aGF0XG5cdFx0XHRpZiAoIHNjZW5lR3JhcGguY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIHNjZW5lR3JhcGguY2hpbGRyZW5bIDAgXS5pc0dyb3VwICkge1xuXG5cdFx0XHRcdHNjZW5lR3JhcGguY2hpbGRyZW5bIDAgXS5hbmltYXRpb25zID0gYW5pbWF0aW9ucztcblx0XHRcdFx0c2NlbmVHcmFwaCA9IHNjZW5lR3JhcGguY2hpbGRyZW5bIDAgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzY2VuZUdyYXBoLmFuaW1hdGlvbnMgPSBhbmltYXRpb25zO1xuXG5cdFx0fSxcblxuXHRcdC8vIHBhcnNlIG5vZGVzIGluIEZCWFRyZWUuT2JqZWN0cy5Nb2RlbFxuXHRcdHBhcnNlTW9kZWxzOiBmdW5jdGlvbiAoIHNrZWxldG9ucywgZ2VvbWV0cnlNYXAsIG1hdGVyaWFsTWFwICkge1xuXG5cdFx0XHR2YXIgbW9kZWxNYXAgPSBuZXcgTWFwKCk7XG5cdFx0XHR2YXIgbW9kZWxOb2RlcyA9IGZieFRyZWUuT2JqZWN0cy5Nb2RlbDtcblxuXHRcdFx0Zm9yICggdmFyIG5vZGVJRCBpbiBtb2RlbE5vZGVzICkge1xuXG5cdFx0XHRcdHZhciBpZCA9IHBhcnNlSW50KCBub2RlSUQgKTtcblx0XHRcdFx0dmFyIG5vZGUgPSBtb2RlbE5vZGVzWyBub2RlSUQgXTtcblx0XHRcdFx0dmFyIHJlbGF0aW9uc2hpcHMgPSBjb25uZWN0aW9ucy5nZXQoIGlkICk7XG5cblx0XHRcdFx0dmFyIG1vZGVsID0gdGhpcy5idWlsZFNrZWxldG9uKCByZWxhdGlvbnNoaXBzLCBza2VsZXRvbnMsIGlkLCBub2RlLmF0dHJOYW1lICk7XG5cblx0XHRcdFx0aWYgKCAhIG1vZGVsICkge1xuXG5cdFx0XHRcdFx0c3dpdGNoICggbm9kZS5hdHRyVHlwZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnQ2FtZXJhJzpcblx0XHRcdFx0XHRcdFx0bW9kZWwgPSB0aGlzLmNyZWF0ZUNhbWVyYSggcmVsYXRpb25zaGlwcyApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ0xpZ2h0Jzpcblx0XHRcdFx0XHRcdFx0bW9kZWwgPSB0aGlzLmNyZWF0ZUxpZ2h0KCByZWxhdGlvbnNoaXBzICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnTWVzaCc6XG5cdFx0XHRcdFx0XHRcdG1vZGVsID0gdGhpcy5jcmVhdGVNZXNoKCByZWxhdGlvbnNoaXBzLCBnZW9tZXRyeU1hcCwgbWF0ZXJpYWxNYXAgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdOdXJic0N1cnZlJzpcblx0XHRcdFx0XHRcdFx0bW9kZWwgPSB0aGlzLmNyZWF0ZUN1cnZlKCByZWxhdGlvbnNoaXBzLCBnZW9tZXRyeU1hcCApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ0xpbWJOb2RlJzpcblx0XHRcdFx0XHRcdGNhc2UgJ1Jvb3QnOlxuXHRcdFx0XHRcdFx0XHRtb2RlbCA9IG5ldyBCb25lKCk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnTnVsbCc6XG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRtb2RlbCA9IG5ldyBHcm91cCgpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG1vZGVsLm5hbWUgPSBub2RlLmF0dHJOYW1lID8gUHJvcGVydHlCaW5kaW5nLnNhbml0aXplTm9kZU5hbWUoIG5vZGUuYXR0ck5hbWUgKSA6ICcnO1xuXG5cdFx0XHRcdFx0bW9kZWwuSUQgPSBpZDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5nZXRUcmFuc2Zvcm1EYXRhKCBtb2RlbCwgbm9kZSApO1xuXHRcdFx0XHRtb2RlbE1hcC5zZXQoIGlkLCBtb2RlbCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtb2RlbE1hcDtcblxuXHRcdH0sXG5cblx0XHRidWlsZFNrZWxldG9uOiBmdW5jdGlvbiAoIHJlbGF0aW9uc2hpcHMsIHNrZWxldG9ucywgaWQsIG5hbWUgKSB7XG5cblx0XHRcdHZhciBib25lID0gbnVsbDtcblxuXHRcdFx0cmVsYXRpb25zaGlwcy5wYXJlbnRzLmZvckVhY2goIGZ1bmN0aW9uICggcGFyZW50ICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBJRCBpbiBza2VsZXRvbnMgKSB7XG5cblx0XHRcdFx0XHR2YXIgc2tlbGV0b24gPSBza2VsZXRvbnNbIElEIF07XG5cblx0XHRcdFx0XHRza2VsZXRvbi5yYXdCb25lcy5mb3JFYWNoKCBmdW5jdGlvbiAoIHJhd0JvbmUsIGkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggcmF3Qm9uZS5JRCA9PT0gcGFyZW50LklEICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBzdWJCb25lID0gYm9uZTtcblx0XHRcdFx0XHRcdFx0Ym9uZSA9IG5ldyBCb25lKCk7XG5cblx0XHRcdFx0XHRcdFx0Ym9uZS5tYXRyaXhXb3JsZC5jb3B5KCByYXdCb25lLnRyYW5zZm9ybUxpbmsgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBzZXQgbmFtZSBhbmQgaWQgaGVyZSAtIG90aGVyd2lzZSBpbiBjYXNlcyB3aGVyZSBcInN1YkJvbmVcIiBpcyBjcmVhdGVkIGl0IHdpbGwgbm90IGhhdmUgYSBuYW1lIC8gaWRcblxuXHRcdFx0XHRcdFx0XHRib25lLm5hbWUgPSBuYW1lID8gUHJvcGVydHlCaW5kaW5nLnNhbml0aXplTm9kZU5hbWUoIG5hbWUgKSA6ICcnO1xuXHRcdFx0XHRcdFx0XHRib25lLklEID0gaWQ7XG5cblx0XHRcdFx0XHRcdFx0c2tlbGV0b24uYm9uZXNbIGkgXSA9IGJvbmU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSW4gY2FzZXMgd2hlcmUgYSBib25lIGlzIHNoYXJlZCBiZXR3ZWVuIG11bHRpcGxlIG1lc2hlc1xuXHRcdFx0XHRcdFx0XHQvLyBkdXBsaWNhdGUgdGhlIGJvbmUgaGVyZSBhbmQgYW5kIGl0IGFzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IGJvbmVcblx0XHRcdFx0XHRcdFx0aWYgKCBzdWJCb25lICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ym9uZS5hZGQoIHN1YkJvbmUgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0cmV0dXJuIGJvbmU7XG5cblx0XHR9LFxuXG5cdFx0Ly8gY3JlYXRlIGEgUGVyc3BlY3RpdmVDYW1lcmEgb3IgT3J0aG9ncmFwaGljQ2FtZXJhXG5cdFx0Y3JlYXRlQ2FtZXJhOiBmdW5jdGlvbiAoIHJlbGF0aW9uc2hpcHMgKSB7XG5cblx0XHRcdHZhciBtb2RlbDtcblx0XHRcdHZhciBjYW1lcmFBdHRyaWJ1dGU7XG5cblx0XHRcdHJlbGF0aW9uc2hpcHMuY2hpbGRyZW4uZm9yRWFjaCggZnVuY3Rpb24gKCBjaGlsZCApIHtcblxuXHRcdFx0XHR2YXIgYXR0ciA9IGZieFRyZWUuT2JqZWN0cy5Ob2RlQXR0cmlidXRlWyBjaGlsZC5JRCBdO1xuXG5cdFx0XHRcdGlmICggYXR0ciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y2FtZXJhQXR0cmlidXRlID0gYXR0cjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0aWYgKCBjYW1lcmFBdHRyaWJ1dGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRtb2RlbCA9IG5ldyBPYmplY3QzRCgpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHZhciB0eXBlID0gMDtcblx0XHRcdFx0aWYgKCBjYW1lcmFBdHRyaWJ1dGUuQ2FtZXJhUHJvamVjdGlvblR5cGUgIT09IHVuZGVmaW5lZCAmJiBjYW1lcmFBdHRyaWJ1dGUuQ2FtZXJhUHJvamVjdGlvblR5cGUudmFsdWUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHR0eXBlID0gMTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG5lYXJDbGlwcGluZ1BsYW5lID0gMTtcblx0XHRcdFx0aWYgKCBjYW1lcmFBdHRyaWJ1dGUuTmVhclBsYW5lICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRuZWFyQ2xpcHBpbmdQbGFuZSA9IGNhbWVyYUF0dHJpYnV0ZS5OZWFyUGxhbmUudmFsdWUgLyAxMDAwO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgZmFyQ2xpcHBpbmdQbGFuZSA9IDEwMDA7XG5cdFx0XHRcdGlmICggY2FtZXJhQXR0cmlidXRlLkZhclBsYW5lICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRmYXJDbGlwcGluZ1BsYW5lID0gY2FtZXJhQXR0cmlidXRlLkZhclBsYW5lLnZhbHVlIC8gMTAwMDtcblxuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHR2YXIgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcblx0XHRcdFx0dmFyIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcblxuXHRcdFx0XHRpZiAoIGNhbWVyYUF0dHJpYnV0ZS5Bc3BlY3RXaWR0aCAhPT0gdW5kZWZpbmVkICYmIGNhbWVyYUF0dHJpYnV0ZS5Bc3BlY3RIZWlnaHQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHdpZHRoID0gY2FtZXJhQXR0cmlidXRlLkFzcGVjdFdpZHRoLnZhbHVlO1xuXHRcdFx0XHRcdGhlaWdodCA9IGNhbWVyYUF0dHJpYnV0ZS5Bc3BlY3RIZWlnaHQudmFsdWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBhc3BlY3QgPSB3aWR0aCAvIGhlaWdodDtcblxuXHRcdFx0XHR2YXIgZm92ID0gNDU7XG5cdFx0XHRcdGlmICggY2FtZXJhQXR0cmlidXRlLkZpZWxkT2ZWaWV3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRmb3YgPSBjYW1lcmFBdHRyaWJ1dGUuRmllbGRPZlZpZXcudmFsdWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBmb2NhbExlbmd0aCA9IGNhbWVyYUF0dHJpYnV0ZS5Gb2NhbExlbmd0aCA/IGNhbWVyYUF0dHJpYnV0ZS5Gb2NhbExlbmd0aC52YWx1ZSA6IG51bGw7XG5cblx0XHRcdFx0c3dpdGNoICggdHlwZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgMDogLy8gUGVyc3BlY3RpdmVcblx0XHRcdFx0XHRcdG1vZGVsID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhckNsaXBwaW5nUGxhbmUsIGZhckNsaXBwaW5nUGxhbmUgKTtcblx0XHRcdFx0XHRcdGlmICggZm9jYWxMZW5ndGggIT09IG51bGwgKSBtb2RlbC5zZXRGb2NhbExlbmd0aCggZm9jYWxMZW5ndGggKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAxOiAvLyBPcnRob2dyYXBoaWNcblx0XHRcdFx0XHRcdG1vZGVsID0gbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYSggLSB3aWR0aCAvIDIsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMiwgLSBoZWlnaHQgLyAyLCBuZWFyQ2xpcHBpbmdQbGFuZSwgZmFyQ2xpcHBpbmdQbGFuZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRkJYTG9hZGVyOiBVbmtub3duIGNhbWVyYSB0eXBlICcgKyB0eXBlICsgJy4nICk7XG5cdFx0XHRcdFx0XHRtb2RlbCA9IG5ldyBPYmplY3QzRCgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtb2RlbDtcblxuXHRcdH0sXG5cblx0XHQvLyBDcmVhdGUgYSBEaXJlY3Rpb25hbExpZ2h0LCBQb2ludExpZ2h0IG9yIFNwb3RMaWdodFxuXHRcdGNyZWF0ZUxpZ2h0OiBmdW5jdGlvbiAoIHJlbGF0aW9uc2hpcHMgKSB7XG5cblx0XHRcdHZhciBtb2RlbDtcblx0XHRcdHZhciBsaWdodEF0dHJpYnV0ZTtcblxuXHRcdFx0cmVsYXRpb25zaGlwcy5jaGlsZHJlbi5mb3JFYWNoKCBmdW5jdGlvbiAoIGNoaWxkICkge1xuXG5cdFx0XHRcdHZhciBhdHRyID0gZmJ4VHJlZS5PYmplY3RzLk5vZGVBdHRyaWJ1dGVbIGNoaWxkLklEIF07XG5cblx0XHRcdFx0aWYgKCBhdHRyICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRsaWdodEF0dHJpYnV0ZSA9IGF0dHI7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cblx0XHRcdGlmICggbGlnaHRBdHRyaWJ1dGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRtb2RlbCA9IG5ldyBPYmplY3QzRCgpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHZhciB0eXBlO1xuXG5cdFx0XHRcdC8vIExpZ2h0VHlwZSBjYW4gYmUgdW5kZWZpbmVkIGZvciBQb2ludCBsaWdodHNcblx0XHRcdFx0aWYgKCBsaWdodEF0dHJpYnV0ZS5MaWdodFR5cGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHR5cGUgPSAwO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0eXBlID0gbGlnaHRBdHRyaWJ1dGUuTGlnaHRUeXBlLnZhbHVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgY29sb3IgPSAweGZmZmZmZjtcblxuXHRcdFx0XHRpZiAoIGxpZ2h0QXR0cmlidXRlLkNvbG9yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb2xvciA9IG5ldyBDb2xvcigpLmZyb21BcnJheSggbGlnaHRBdHRyaWJ1dGUuQ29sb3IudmFsdWUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGludGVuc2l0eSA9ICggbGlnaHRBdHRyaWJ1dGUuSW50ZW5zaXR5ID09PSB1bmRlZmluZWQgKSA/IDEgOiBsaWdodEF0dHJpYnV0ZS5JbnRlbnNpdHkudmFsdWUgLyAxMDA7XG5cblx0XHRcdFx0Ly8gbGlnaHQgZGlzYWJsZWRcblx0XHRcdFx0aWYgKCBsaWdodEF0dHJpYnV0ZS5DYXN0TGlnaHRPbk9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGxpZ2h0QXR0cmlidXRlLkNhc3RMaWdodE9uT2JqZWN0LnZhbHVlID09PSAwICkge1xuXG5cdFx0XHRcdFx0aW50ZW5zaXR5ID0gMDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGRpc3RhbmNlID0gMDtcblx0XHRcdFx0aWYgKCBsaWdodEF0dHJpYnV0ZS5GYXJBdHRlbnVhdGlvbkVuZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0aWYgKCBsaWdodEF0dHJpYnV0ZS5FbmFibGVGYXJBdHRlbnVhdGlvbiAhPT0gdW5kZWZpbmVkICYmIGxpZ2h0QXR0cmlidXRlLkVuYWJsZUZhckF0dGVudWF0aW9uLnZhbHVlID09PSAwICkge1xuXG5cdFx0XHRcdFx0XHRkaXN0YW5jZSA9IDA7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRkaXN0YW5jZSA9IGxpZ2h0QXR0cmlidXRlLkZhckF0dGVudWF0aW9uRW5kLnZhbHVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUT0RPOiBjb3VsZCB0aGlzIGJlIGNhbGN1bGF0ZWQgbGluZWFybHkgZnJvbSBGYXJBdHRlbnVhdGlvblN0YXJ0IHRvIEZhckF0dGVudWF0aW9uRW5kP1xuXHRcdFx0XHR2YXIgZGVjYXkgPSAxO1xuXG5cdFx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRcdFx0XHRjYXNlIDA6IC8vIFBvaW50XG5cdFx0XHRcdFx0XHRtb2RlbCA9IG5ldyBQb2ludExpZ2h0KCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgZGVjYXkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAxOiAvLyBEaXJlY3Rpb25hbFxuXHRcdFx0XHRcdFx0bW9kZWwgPSBuZXcgRGlyZWN0aW9uYWxMaWdodCggY29sb3IsIGludGVuc2l0eSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIDI6IC8vIFNwb3Rcblx0XHRcdFx0XHRcdHZhciBhbmdsZSA9IE1hdGguUEkgLyAzO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGxpZ2h0QXR0cmlidXRlLklubmVyQW5nbGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRhbmdsZSA9IE1hdGhVdGlscy5kZWdUb1JhZCggbGlnaHRBdHRyaWJ1dGUuSW5uZXJBbmdsZS52YWx1ZSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHZhciBwZW51bWJyYSA9IDA7XG5cdFx0XHRcdFx0XHRpZiAoIGxpZ2h0QXR0cmlidXRlLk91dGVyQW5nbGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiB0aGlzIGlzIG5vdCBjb3JyZWN0IC0gRkJYIGNhbGN1bGF0ZXMgb3V0ZXIgYW5kIGlubmVyIGFuZ2xlIGluIGRlZ3JlZXNcblx0XHRcdFx0XHRcdFx0Ly8gd2l0aCBPdXRlckFuZ2xlID4gSW5uZXJBbmdsZSAmJiBPdXRlckFuZ2xlIDw9IE1hdGguUElcblx0XHRcdFx0XHRcdFx0Ly8gd2hpbGUgdGhyZWUuanMgdXNlcyBhIHBlbnVtYnJhIGJldHdlZW4gKDAsIDEpIHRvIGF0dGVudWF0ZSB0aGUgaW5uZXIgYW5nbGVcblx0XHRcdFx0XHRcdFx0cGVudW1icmEgPSBNYXRoVXRpbHMuZGVnVG9SYWQoIGxpZ2h0QXR0cmlidXRlLk91dGVyQW5nbGUudmFsdWUgKTtcblx0XHRcdFx0XHRcdFx0cGVudW1icmEgPSBNYXRoLm1heCggcGVudW1icmEsIDEgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRtb2RlbCA9IG5ldyBTcG90TGlnaHQoIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlLCBhbmdsZSwgcGVudW1icmEsIGRlY2F5ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5GQlhMb2FkZXI6IFVua25vd24gbGlnaHQgdHlwZSAnICsgbGlnaHRBdHRyaWJ1dGUuTGlnaHRUeXBlLnZhbHVlICsgJywgZGVmYXVsdGluZyB0byBhIFBvaW50TGlnaHQuJyApO1xuXHRcdFx0XHRcdFx0bW9kZWwgPSBuZXcgUG9pbnRMaWdodCggY29sb3IsIGludGVuc2l0eSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbGlnaHRBdHRyaWJ1dGUuQ2FzdFNoYWRvd3MgIT09IHVuZGVmaW5lZCAmJiBsaWdodEF0dHJpYnV0ZS5DYXN0U2hhZG93cy52YWx1ZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdG1vZGVsLmNhc3RTaGFkb3cgPSB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbW9kZWw7XG5cblx0XHR9LFxuXG5cdFx0Y3JlYXRlTWVzaDogZnVuY3Rpb24gKCByZWxhdGlvbnNoaXBzLCBnZW9tZXRyeU1hcCwgbWF0ZXJpYWxNYXAgKSB7XG5cblx0XHRcdHZhciBtb2RlbDtcblx0XHRcdHZhciBnZW9tZXRyeSA9IG51bGw7XG5cdFx0XHR2YXIgbWF0ZXJpYWwgPSBudWxsO1xuXHRcdFx0dmFyIG1hdGVyaWFscyA9IFtdO1xuXG5cdFx0XHQvLyBnZXQgZ2VvbWV0cnkgYW5kIG1hdGVyaWFscyhzKSBmcm9tIGNvbm5lY3Rpb25zXG5cdFx0XHRyZWxhdGlvbnNoaXBzLmNoaWxkcmVuLmZvckVhY2goIGZ1bmN0aW9uICggY2hpbGQgKSB7XG5cblx0XHRcdFx0aWYgKCBnZW9tZXRyeU1hcC5oYXMoIGNoaWxkLklEICkgKSB7XG5cblx0XHRcdFx0XHRnZW9tZXRyeSA9IGdlb21ldHJ5TWFwLmdldCggY2hpbGQuSUQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbE1hcC5oYXMoIGNoaWxkLklEICkgKSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbHMucHVzaCggbWF0ZXJpYWxNYXAuZ2V0KCBjaGlsZC5JRCApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cblx0XHRcdGlmICggbWF0ZXJpYWxzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdFx0bWF0ZXJpYWwgPSBtYXRlcmlhbHM7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFscy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsID0gbWF0ZXJpYWxzWyAwIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bWF0ZXJpYWwgPSBuZXcgTWVzaFBob25nTWF0ZXJpYWwoIHsgY29sb3I6IDB4Y2NjY2NjIH0gKTtcblx0XHRcdFx0bWF0ZXJpYWxzLnB1c2goIG1hdGVyaWFsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAnY29sb3InIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0bWF0ZXJpYWxzLmZvckVhY2goIGZ1bmN0aW9uICggbWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0cnVlO1xuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LkZCWF9EZWZvcm1lciApIHtcblxuXHRcdFx0XHRtYXRlcmlhbHMuZm9yRWFjaCggZnVuY3Rpb24gKCBtYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsLnNraW5uaW5nID0gdHJ1ZTtcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0bW9kZWwgPSBuZXcgU2tpbm5lZE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXHRcdFx0XHRtb2RlbC5ub3JtYWxpemVTa2luV2VpZ2h0cygpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG1vZGVsID0gbmV3IE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtb2RlbDtcblxuXHRcdH0sXG5cblx0XHRjcmVhdGVDdXJ2ZTogZnVuY3Rpb24gKCByZWxhdGlvbnNoaXBzLCBnZW9tZXRyeU1hcCApIHtcblxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gcmVsYXRpb25zaGlwcy5jaGlsZHJlbi5yZWR1Y2UoIGZ1bmN0aW9uICggZ2VvLCBjaGlsZCApIHtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5TWFwLmhhcyggY2hpbGQuSUQgKSApIGdlbyA9IGdlb21ldHJ5TWFwLmdldCggY2hpbGQuSUQgKTtcblxuXHRcdFx0XHRyZXR1cm4gZ2VvO1xuXG5cdFx0XHR9LCBudWxsICk7XG5cblx0XHRcdC8vIEZCWCBkb2VzIG5vdCBsaXN0IG1hdGVyaWFscyBmb3IgTnVyYnMgbGluZXMsIHNvIHdlJ2xsIGp1c3QgcHV0IG91ciBvd24gaW4gaGVyZS5cblx0XHRcdHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHgzMzAwZmYsIGxpbmV3aWR0aDogMSB9ICk7XG5cdFx0XHRyZXR1cm4gbmV3IExpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0fSxcblxuXHRcdC8vIHBhcnNlIHRoZSBtb2RlbCBub2RlIGZvciB0cmFuc2Zvcm0gZGF0YVxuXHRcdGdldFRyYW5zZm9ybURhdGE6IGZ1bmN0aW9uICggbW9kZWwsIG1vZGVsTm9kZSApIHtcblxuXHRcdFx0dmFyIHRyYW5zZm9ybURhdGEgPSB7fTtcblxuXHRcdFx0aWYgKCAnSW5oZXJpdFR5cGUnIGluIG1vZGVsTm9kZSApIHRyYW5zZm9ybURhdGEuaW5oZXJpdFR5cGUgPSBwYXJzZUludCggbW9kZWxOb2RlLkluaGVyaXRUeXBlLnZhbHVlICk7XG5cblx0XHRcdGlmICggJ1JvdGF0aW9uT3JkZXInIGluIG1vZGVsTm9kZSApIHRyYW5zZm9ybURhdGEuZXVsZXJPcmRlciA9IGdldEV1bGVyT3JkZXIoIG1vZGVsTm9kZS5Sb3RhdGlvbk9yZGVyLnZhbHVlICk7XG5cdFx0XHRlbHNlIHRyYW5zZm9ybURhdGEuZXVsZXJPcmRlciA9ICdaWVgnO1xuXG5cdFx0XHRpZiAoICdMY2xfVHJhbnNsYXRpb24nIGluIG1vZGVsTm9kZSApIHRyYW5zZm9ybURhdGEudHJhbnNsYXRpb24gPSBtb2RlbE5vZGUuTGNsX1RyYW5zbGF0aW9uLnZhbHVlO1xuXG5cdFx0XHRpZiAoICdQcmVSb3RhdGlvbicgaW4gbW9kZWxOb2RlICkgdHJhbnNmb3JtRGF0YS5wcmVSb3RhdGlvbiA9IG1vZGVsTm9kZS5QcmVSb3RhdGlvbi52YWx1ZTtcblx0XHRcdGlmICggJ0xjbF9Sb3RhdGlvbicgaW4gbW9kZWxOb2RlICkgdHJhbnNmb3JtRGF0YS5yb3RhdGlvbiA9IG1vZGVsTm9kZS5MY2xfUm90YXRpb24udmFsdWU7XG5cdFx0XHRpZiAoICdQb3N0Um90YXRpb24nIGluIG1vZGVsTm9kZSApIHRyYW5zZm9ybURhdGEucG9zdFJvdGF0aW9uID0gbW9kZWxOb2RlLlBvc3RSb3RhdGlvbi52YWx1ZTtcblxuXHRcdFx0aWYgKCAnTGNsX1NjYWxpbmcnIGluIG1vZGVsTm9kZSApIHRyYW5zZm9ybURhdGEuc2NhbGUgPSBtb2RlbE5vZGUuTGNsX1NjYWxpbmcudmFsdWU7XG5cblx0XHRcdGlmICggJ1NjYWxpbmdPZmZzZXQnIGluIG1vZGVsTm9kZSApIHRyYW5zZm9ybURhdGEuc2NhbGluZ09mZnNldCA9IG1vZGVsTm9kZS5TY2FsaW5nT2Zmc2V0LnZhbHVlO1xuXHRcdFx0aWYgKCAnU2NhbGluZ1Bpdm90JyBpbiBtb2RlbE5vZGUgKSB0cmFuc2Zvcm1EYXRhLnNjYWxpbmdQaXZvdCA9IG1vZGVsTm9kZS5TY2FsaW5nUGl2b3QudmFsdWU7XG5cblx0XHRcdGlmICggJ1JvdGF0aW9uT2Zmc2V0JyBpbiBtb2RlbE5vZGUgKSB0cmFuc2Zvcm1EYXRhLnJvdGF0aW9uT2Zmc2V0ID0gbW9kZWxOb2RlLlJvdGF0aW9uT2Zmc2V0LnZhbHVlO1xuXHRcdFx0aWYgKCAnUm90YXRpb25QaXZvdCcgaW4gbW9kZWxOb2RlICkgdHJhbnNmb3JtRGF0YS5yb3RhdGlvblBpdm90ID0gbW9kZWxOb2RlLlJvdGF0aW9uUGl2b3QudmFsdWU7XG5cblx0XHRcdG1vZGVsLnVzZXJEYXRhLnRyYW5zZm9ybURhdGEgPSB0cmFuc2Zvcm1EYXRhO1xuXG5cdFx0fSxcblxuXHRcdHNldExvb2tBdFByb3BlcnRpZXM6IGZ1bmN0aW9uICggbW9kZWwsIG1vZGVsTm9kZSApIHtcblxuXHRcdFx0aWYgKCAnTG9va0F0UHJvcGVydHknIGluIG1vZGVsTm9kZSApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGRyZW4gPSBjb25uZWN0aW9ucy5nZXQoIG1vZGVsLklEICkuY2hpbGRyZW47XG5cblx0XHRcdFx0Y2hpbGRyZW4uZm9yRWFjaCggZnVuY3Rpb24gKCBjaGlsZCApIHtcblxuXHRcdFx0XHRcdGlmICggY2hpbGQucmVsYXRpb25zaGlwID09PSAnTG9va0F0UHJvcGVydHknICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgbG9va0F0VGFyZ2V0ID0gZmJ4VHJlZS5PYmplY3RzLk1vZGVsWyBjaGlsZC5JRCBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoICdMY2xfVHJhbnNsYXRpb24nIGluIGxvb2tBdFRhcmdldCApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgcG9zID0gbG9va0F0VGFyZ2V0LkxjbF9UcmFuc2xhdGlvbi52YWx1ZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBEaXJlY3Rpb25hbExpZ2h0LCBTcG90TGlnaHRcblx0XHRcdFx0XHRcdFx0aWYgKCBtb2RlbC50YXJnZXQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdG1vZGVsLnRhcmdldC5wb3NpdGlvbi5mcm9tQXJyYXkoIHBvcyApO1xuXHRcdFx0XHRcdFx0XHRcdHNjZW5lR3JhcGguYWRkKCBtb2RlbC50YXJnZXQgKTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgeyAvLyBDYW1lcmFzIGFuZCBvdGhlciBPYmplY3QzRHNcblxuXHRcdFx0XHRcdFx0XHRcdG1vZGVsLmxvb2tBdCggbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoIHBvcyApICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0YmluZFNrZWxldG9uOiBmdW5jdGlvbiAoIHNrZWxldG9ucywgZ2VvbWV0cnlNYXAsIG1vZGVsTWFwICkge1xuXG5cdFx0XHR2YXIgYmluZE1hdHJpY2VzID0gdGhpcy5wYXJzZVBvc2VOb2RlcygpO1xuXG5cdFx0XHRmb3IgKCB2YXIgSUQgaW4gc2tlbGV0b25zICkge1xuXG5cdFx0XHRcdHZhciBza2VsZXRvbiA9IHNrZWxldG9uc1sgSUQgXTtcblxuXHRcdFx0XHR2YXIgcGFyZW50cyA9IGNvbm5lY3Rpb25zLmdldCggcGFyc2VJbnQoIHNrZWxldG9uLklEICkgKS5wYXJlbnRzO1xuXG5cdFx0XHRcdHBhcmVudHMuZm9yRWFjaCggZnVuY3Rpb24gKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5TWFwLmhhcyggcGFyZW50LklEICkgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBnZW9JRCA9IHBhcmVudC5JRDtcblx0XHRcdFx0XHRcdHZhciBnZW9SZWxhdGlvbnNoaXBzID0gY29ubmVjdGlvbnMuZ2V0KCBnZW9JRCApO1xuXG5cdFx0XHRcdFx0XHRnZW9SZWxhdGlvbnNoaXBzLnBhcmVudHMuZm9yRWFjaCggZnVuY3Rpb24gKCBnZW9Db25uUGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggbW9kZWxNYXAuaGFzKCBnZW9Db25uUGFyZW50LklEICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR2YXIgbW9kZWwgPSBtb2RlbE1hcC5nZXQoIGdlb0Nvbm5QYXJlbnQuSUQgKTtcblxuXHRcdFx0XHRcdFx0XHRcdG1vZGVsLmJpbmQoIG5ldyBTa2VsZXRvbiggc2tlbGV0b24uYm9uZXMgKSwgYmluZE1hdHJpY2VzWyBnZW9Db25uUGFyZW50LklEIF0gKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRwYXJzZVBvc2VOb2RlczogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgYmluZE1hdHJpY2VzID0ge307XG5cblx0XHRcdGlmICggJ1Bvc2UnIGluIGZieFRyZWUuT2JqZWN0cyApIHtcblxuXHRcdFx0XHR2YXIgQmluZFBvc2VOb2RlID0gZmJ4VHJlZS5PYmplY3RzLlBvc2U7XG5cblx0XHRcdFx0Zm9yICggdmFyIG5vZGVJRCBpbiBCaW5kUG9zZU5vZGUgKSB7XG5cblx0XHRcdFx0XHRpZiAoIEJpbmRQb3NlTm9kZVsgbm9kZUlEIF0uYXR0clR5cGUgPT09ICdCaW5kUG9zZScgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBwb3NlTm9kZXMgPSBCaW5kUG9zZU5vZGVbIG5vZGVJRCBdLlBvc2VOb2RlO1xuXG5cdFx0XHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHBvc2VOb2RlcyApICkge1xuXG5cdFx0XHRcdFx0XHRcdHBvc2VOb2Rlcy5mb3JFYWNoKCBmdW5jdGlvbiAoIHBvc2VOb2RlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0YmluZE1hdHJpY2VzWyBwb3NlTm9kZS5Ob2RlIF0gPSBuZXcgTWF0cml4NCgpLmZyb21BcnJheSggcG9zZU5vZGUuTWF0cml4LmEgKTtcblxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0YmluZE1hdHJpY2VzWyBwb3NlTm9kZXMuTm9kZSBdID0gbmV3IE1hdHJpeDQoKS5mcm9tQXJyYXkoIHBvc2VOb2Rlcy5NYXRyaXguYSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBiaW5kTWF0cmljZXM7XG5cblx0XHR9LFxuXG5cdFx0Ly8gUGFyc2UgYW1iaWVudCBjb2xvciBpbiBGQlhUcmVlLkdsb2JhbFNldHRpbmdzIC0gaWYgaXQncyBub3Qgc2V0IHRvIGJsYWNrIChkZWZhdWx0KSwgY3JlYXRlIGFuIGFtYmllbnQgbGlnaHRcblx0XHRjcmVhdGVBbWJpZW50TGlnaHQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0aWYgKCAnR2xvYmFsU2V0dGluZ3MnIGluIGZieFRyZWUgJiYgJ0FtYmllbnRDb2xvcicgaW4gZmJ4VHJlZS5HbG9iYWxTZXR0aW5ncyApIHtcblxuXHRcdFx0XHR2YXIgYW1iaWVudENvbG9yID0gZmJ4VHJlZS5HbG9iYWxTZXR0aW5ncy5BbWJpZW50Q29sb3IudmFsdWU7XG5cdFx0XHRcdHZhciByID0gYW1iaWVudENvbG9yWyAwIF07XG5cdFx0XHRcdHZhciBnID0gYW1iaWVudENvbG9yWyAxIF07XG5cdFx0XHRcdHZhciBiID0gYW1iaWVudENvbG9yWyAyIF07XG5cblx0XHRcdFx0aWYgKCByICE9PSAwIHx8IGcgIT09IDAgfHwgYiAhPT0gMCApIHtcblxuXHRcdFx0XHRcdHZhciBjb2xvciA9IG5ldyBDb2xvciggciwgZywgYiApO1xuXHRcdFx0XHRcdHNjZW5lR3JhcGguYWRkKCBuZXcgQW1iaWVudExpZ2h0KCBjb2xvciwgMSApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0c2V0dXBNb3JwaE1hdGVyaWFsczogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXHRcdFx0c2NlbmVHcmFwaC50cmF2ZXJzZSggZnVuY3Rpb24gKCBjaGlsZCApIHtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLmlzTWVzaCApIHtcblxuXHRcdFx0XHRcdGlmICggY2hpbGQuZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uICYmIGNoaWxkLmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbi5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggY2hpbGQubWF0ZXJpYWwgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRjaGlsZC5tYXRlcmlhbC5mb3JFYWNoKCBmdW5jdGlvbiAoIG1hdGVyaWFsLCBpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0c2NvcGUuc2V0dXBNb3JwaE1hdGVyaWFsKCBjaGlsZCwgbWF0ZXJpYWwsIGkgKTtcblxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0c2NvcGUuc2V0dXBNb3JwaE1hdGVyaWFsKCBjaGlsZCwgY2hpbGQubWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0fSxcblxuXHRcdHNldHVwTW9ycGhNYXRlcmlhbDogZnVuY3Rpb24gKCBjaGlsZCwgbWF0ZXJpYWwsIGluZGV4ICkge1xuXG5cdFx0XHR2YXIgdXVpZCA9IGNoaWxkLnV1aWQ7XG5cdFx0XHR2YXIgbWF0VXVpZCA9IG1hdGVyaWFsLnV1aWQ7XG5cblx0XHRcdC8vIGlmIGEgZ2VvbWV0cnkgaGFzIG1vcnBoIHRhcmdldHMsIGl0IGNhbm5vdCBzaGFyZSB0aGUgbWF0ZXJpYWwgd2l0aCBvdGhlciBnZW9tZXRyaWVzXG5cdFx0XHR2YXIgc2hhcmVkTWF0ID0gZmFsc2U7XG5cblx0XHRcdHNjZW5lR3JhcGgudHJhdmVyc2UoIGZ1bmN0aW9uICggbm9kZSApIHtcblxuXHRcdFx0XHRpZiAoIG5vZGUuaXNNZXNoICkge1xuXG5cdFx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBub2RlLm1hdGVyaWFsICkgKSB7XG5cblx0XHRcdFx0XHRcdG5vZGUubWF0ZXJpYWwuZm9yRWFjaCggZnVuY3Rpb24gKCBtYXQgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBtYXQudXVpZCA9PT0gbWF0VXVpZCAmJiBub2RlLnV1aWQgIT09IHV1aWQgKSBzaGFyZWRNYXQgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBub2RlLm1hdGVyaWFsLnV1aWQgPT09IG1hdFV1aWQgJiYgbm9kZS51dWlkICE9PSB1dWlkICkgc2hhcmVkTWF0ID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0aWYgKCBzaGFyZWRNYXQgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0dmFyIGNsb25lZE1hdCA9IG1hdGVyaWFsLmNsb25lKCk7XG5cdFx0XHRcdGNsb25lZE1hdC5tb3JwaFRhcmdldHMgPSB0cnVlO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPT09IHVuZGVmaW5lZCApIGNoaWxkLm1hdGVyaWFsID0gY2xvbmVkTWF0O1xuXHRcdFx0XHRlbHNlIGNoaWxkLm1hdGVyaWFsWyBpbmRleCBdID0gY2xvbmVkTWF0O1xuXG5cdFx0XHR9IGVsc2UgbWF0ZXJpYWwubW9ycGhUYXJnZXRzID0gdHJ1ZTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdC8vIHBhcnNlIEdlb21ldHJ5IGRhdGEgZnJvbSBGQlhUcmVlIGFuZCByZXR1cm4gbWFwIG9mIEJ1ZmZlckdlb21ldHJpZXNcblx0ZnVuY3Rpb24gR2VvbWV0cnlQYXJzZXIoKSB7fVxuXG5cdEdlb21ldHJ5UGFyc2VyLnByb3RvdHlwZSA9IHtcblxuXHRcdGNvbnN0cnVjdG9yOiBHZW9tZXRyeVBhcnNlcixcblxuXHRcdC8vIFBhcnNlIG5vZGVzIGluIEZCWFRyZWUuT2JqZWN0cy5HZW9tZXRyeVxuXHRcdHBhcnNlOiBmdW5jdGlvbiAoIGRlZm9ybWVycyApIHtcblxuXHRcdFx0dmFyIGdlb21ldHJ5TWFwID0gbmV3IE1hcCgpO1xuXG5cdFx0XHRpZiAoICdHZW9tZXRyeScgaW4gZmJ4VHJlZS5PYmplY3RzICkge1xuXG5cdFx0XHRcdHZhciBnZW9Ob2RlcyA9IGZieFRyZWUuT2JqZWN0cy5HZW9tZXRyeTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgbm9kZUlEIGluIGdlb05vZGVzICkge1xuXG5cdFx0XHRcdFx0dmFyIHJlbGF0aW9uc2hpcHMgPSBjb25uZWN0aW9ucy5nZXQoIHBhcnNlSW50KCBub2RlSUQgKSApO1xuXHRcdFx0XHRcdHZhciBnZW8gPSB0aGlzLnBhcnNlR2VvbWV0cnkoIHJlbGF0aW9uc2hpcHMsIGdlb05vZGVzWyBub2RlSUQgXSwgZGVmb3JtZXJzICk7XG5cblx0XHRcdFx0XHRnZW9tZXRyeU1hcC5zZXQoIHBhcnNlSW50KCBub2RlSUQgKSwgZ2VvICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBnZW9tZXRyeU1hcDtcblxuXHRcdH0sXG5cblx0XHQvLyBQYXJzZSBzaW5nbGUgbm9kZSBpbiBGQlhUcmVlLk9iamVjdHMuR2VvbWV0cnlcblx0XHRwYXJzZUdlb21ldHJ5OiBmdW5jdGlvbiAoIHJlbGF0aW9uc2hpcHMsIGdlb05vZGUsIGRlZm9ybWVycyApIHtcblxuXHRcdFx0c3dpdGNoICggZ2VvTm9kZS5hdHRyVHlwZSApIHtcblxuXHRcdFx0XHRjYXNlICdNZXNoJzpcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5wYXJzZU1lc2hHZW9tZXRyeSggcmVsYXRpb25zaGlwcywgZ2VvTm9kZSwgZGVmb3JtZXJzICk7XG5cblx0XHRcdFx0Y2FzZSAnTnVyYnNDdXJ2ZSc6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMucGFyc2VOdXJic0dlb21ldHJ5KCBnZW9Ob2RlICk7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblxuXHRcdC8vIFBhcnNlIHNpbmdsZSBub2RlIG1lc2ggZ2VvbWV0cnkgaW4gRkJYVHJlZS5PYmplY3RzLkdlb21ldHJ5XG5cdFx0cGFyc2VNZXNoR2VvbWV0cnk6IGZ1bmN0aW9uICggcmVsYXRpb25zaGlwcywgZ2VvTm9kZSwgZGVmb3JtZXJzICkge1xuXG5cdFx0XHR2YXIgc2tlbGV0b25zID0gZGVmb3JtZXJzLnNrZWxldG9ucztcblx0XHRcdHZhciBtb3JwaFRhcmdldHMgPSBbXTtcblxuXHRcdFx0dmFyIG1vZGVsTm9kZXMgPSByZWxhdGlvbnNoaXBzLnBhcmVudHMubWFwKCBmdW5jdGlvbiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRyZXR1cm4gZmJ4VHJlZS5PYmplY3RzLk1vZGVsWyBwYXJlbnQuSUQgXTtcblxuXHRcdFx0fSApO1xuXG5cdFx0XHQvLyBkb24ndCBjcmVhdGUgZ2VvbWV0cnkgaWYgaXQgaXMgbm90IGFzc29jaWF0ZWQgd2l0aCBhbnkgbW9kZWxzXG5cdFx0XHRpZiAoIG1vZGVsTm9kZXMubGVuZ3RoID09PSAwICkgcmV0dXJuO1xuXG5cdFx0XHR2YXIgc2tlbGV0b24gPSByZWxhdGlvbnNoaXBzLmNoaWxkcmVuLnJlZHVjZSggZnVuY3Rpb24gKCBza2VsZXRvbiwgY2hpbGQgKSB7XG5cblx0XHRcdFx0aWYgKCBza2VsZXRvbnNbIGNoaWxkLklEIF0gIT09IHVuZGVmaW5lZCApIHNrZWxldG9uID0gc2tlbGV0b25zWyBjaGlsZC5JRCBdO1xuXG5cdFx0XHRcdHJldHVybiBza2VsZXRvbjtcblxuXHRcdFx0fSwgbnVsbCApO1xuXG5cdFx0XHRyZWxhdGlvbnNoaXBzLmNoaWxkcmVuLmZvckVhY2goIGZ1bmN0aW9uICggY2hpbGQgKSB7XG5cblx0XHRcdFx0aWYgKCBkZWZvcm1lcnMubW9ycGhUYXJnZXRzWyBjaGlsZC5JRCBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRtb3JwaFRhcmdldHMucHVzaCggZGVmb3JtZXJzLm1vcnBoVGFyZ2V0c1sgY2hpbGQuSUQgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0XHQvLyBBc3N1bWUgb25lIG1vZGVsIGFuZCBnZXQgdGhlIHByZVJvdGF0aW9uIGZyb20gdGhhdFxuXHRcdFx0Ly8gaWYgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSBtb2RlbCBhc3NvY2lhdGVkIHdpdGggdGhlIGdlb21ldHJ5IHRoaXMgbWF5IGNhdXNlIHByb2JsZW1zXG5cdFx0XHR2YXIgbW9kZWxOb2RlID0gbW9kZWxOb2Rlc1sgMCBdO1xuXG5cdFx0XHR2YXIgdHJhbnNmb3JtRGF0YSA9IHt9O1xuXG5cdFx0XHRpZiAoICdSb3RhdGlvbk9yZGVyJyBpbiBtb2RlbE5vZGUgKSB0cmFuc2Zvcm1EYXRhLmV1bGVyT3JkZXIgPSBnZXRFdWxlck9yZGVyKCBtb2RlbE5vZGUuUm90YXRpb25PcmRlci52YWx1ZSApO1xuXHRcdFx0aWYgKCAnSW5oZXJpdFR5cGUnIGluIG1vZGVsTm9kZSApIHRyYW5zZm9ybURhdGEuaW5oZXJpdFR5cGUgPSBwYXJzZUludCggbW9kZWxOb2RlLkluaGVyaXRUeXBlLnZhbHVlICk7XG5cblx0XHRcdGlmICggJ0dlb21ldHJpY1RyYW5zbGF0aW9uJyBpbiBtb2RlbE5vZGUgKSB0cmFuc2Zvcm1EYXRhLnRyYW5zbGF0aW9uID0gbW9kZWxOb2RlLkdlb21ldHJpY1RyYW5zbGF0aW9uLnZhbHVlO1xuXHRcdFx0aWYgKCAnR2VvbWV0cmljUm90YXRpb24nIGluIG1vZGVsTm9kZSApIHRyYW5zZm9ybURhdGEucm90YXRpb24gPSBtb2RlbE5vZGUuR2VvbWV0cmljUm90YXRpb24udmFsdWU7XG5cdFx0XHRpZiAoICdHZW9tZXRyaWNTY2FsaW5nJyBpbiBtb2RlbE5vZGUgKSB0cmFuc2Zvcm1EYXRhLnNjYWxlID0gbW9kZWxOb2RlLkdlb21ldHJpY1NjYWxpbmcudmFsdWU7XG5cblx0XHRcdHZhciB0cmFuc2Zvcm0gPSBnZW5lcmF0ZVRyYW5zZm9ybSggdHJhbnNmb3JtRGF0YSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZW5HZW9tZXRyeSggZ2VvTm9kZSwgc2tlbGV0b24sIG1vcnBoVGFyZ2V0cywgdHJhbnNmb3JtICk7XG5cblx0XHR9LFxuXG5cdFx0Ly8gR2VuZXJhdGUgYSBCdWZmZXJHZW9tZXRyeSBmcm9tIGEgbm9kZSBpbiBGQlhUcmVlLk9iamVjdHMuR2VvbWV0cnlcblx0XHRnZW5HZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9Ob2RlLCBza2VsZXRvbiwgbW9ycGhUYXJnZXRzLCBwcmVUcmFuc2Zvcm0gKSB7XG5cblx0XHRcdHZhciBnZW8gPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRcdGlmICggZ2VvTm9kZS5hdHRyTmFtZSApIGdlby5uYW1lID0gZ2VvTm9kZS5hdHRyTmFtZTtcblxuXHRcdFx0dmFyIGdlb0luZm8gPSB0aGlzLnBhcnNlR2VvTm9kZSggZ2VvTm9kZSwgc2tlbGV0b24gKTtcblx0XHRcdHZhciBidWZmZXJzID0gdGhpcy5nZW5CdWZmZXJzKCBnZW9JbmZvICk7XG5cblx0XHRcdHZhciBwb3NpdGlvbkF0dHJpYnV0ZSA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBidWZmZXJzLnZlcnRleCwgMyApO1xuXG5cdFx0XHRwb3NpdGlvbkF0dHJpYnV0ZS5hcHBseU1hdHJpeDQoIHByZVRyYW5zZm9ybSApO1xuXG5cdFx0XHRnZW8uc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbkF0dHJpYnV0ZSApO1xuXG5cdFx0XHRpZiAoIGJ1ZmZlcnMuY29sb3JzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0Z2VvLnNldEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGJ1ZmZlcnMuY29sb3JzLCAzICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNrZWxldG9uICkge1xuXG5cdFx0XHRcdGdlby5zZXRBdHRyaWJ1dGUoICdza2luSW5kZXgnLCBuZXcgVWludDE2QnVmZmVyQXR0cmlidXRlKCBidWZmZXJzLndlaWdodHNJbmRpY2VzLCA0ICkgKTtcblxuXHRcdFx0XHRnZW8uc2V0QXR0cmlidXRlKCAnc2tpbldlaWdodCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBidWZmZXJzLnZlcnRleFdlaWdodHMsIDQgKSApO1xuXG5cdFx0XHRcdC8vIHVzZWQgbGF0ZXIgdG8gYmluZCB0aGUgc2tlbGV0b24gdG8gdGhlIG1vZGVsXG5cdFx0XHRcdGdlby5GQlhfRGVmb3JtZXIgPSBza2VsZXRvbjtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1ZmZlcnMubm9ybWFsLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0dmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBNYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBwcmVUcmFuc2Zvcm0gKTtcblxuXHRcdFx0XHR2YXIgbm9ybWFsQXR0cmlidXRlID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGJ1ZmZlcnMubm9ybWFsLCAzICk7XG5cdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZS5hcHBseU5vcm1hbE1hdHJpeCggbm9ybWFsTWF0cml4ICk7XG5cblx0XHRcdFx0Z2VvLnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5vcm1hbEF0dHJpYnV0ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGJ1ZmZlcnMudXZzLmZvckVhY2goIGZ1bmN0aW9uICggdXZCdWZmZXIsIGkgKSB7XG5cblx0XHRcdFx0Ly8gc3Vic2VxdWVudCB1diBidWZmZXJzIGFyZSBjYWxsZWQgJ3V2MScsICd1djInLCAuLi5cblx0XHRcdFx0dmFyIG5hbWUgPSAndXYnICsgKCBpICsgMSApLnRvU3RyaW5nKCk7XG5cblx0XHRcdFx0Ly8gdGhlIGZpcnN0IHV2IGJ1ZmZlciBpcyBqdXN0IGNhbGxlZCAndXYnXG5cdFx0XHRcdGlmICggaSA9PT0gMCApIHtcblxuXHRcdFx0XHRcdG5hbWUgPSAndXYnO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRnZW8uc2V0QXR0cmlidXRlKCBuYW1lLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggYnVmZmVycy51dnNbIGkgXSwgMiApICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0aWYgKCBnZW9JbmZvLm1hdGVyaWFsICYmIGdlb0luZm8ubWF0ZXJpYWwubWFwcGluZ1R5cGUgIT09ICdBbGxTYW1lJyApIHtcblxuXHRcdFx0XHQvLyBDb252ZXJ0IHRoZSBtYXRlcmlhbCBpbmRpY2VzIG9mIGVhY2ggdmVydGV4IGludG8gcmVuZGVyaW5nIGdyb3VwcyBvbiB0aGUgZ2VvbWV0cnkuXG5cdFx0XHRcdHZhciBwcmV2TWF0ZXJpYWxJbmRleCA9IGJ1ZmZlcnMubWF0ZXJpYWxJbmRleFsgMCBdO1xuXHRcdFx0XHR2YXIgc3RhcnRJbmRleCA9IDA7XG5cblx0XHRcdFx0YnVmZmVycy5tYXRlcmlhbEluZGV4LmZvckVhY2goIGZ1bmN0aW9uICggY3VycmVudEluZGV4LCBpICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjdXJyZW50SW5kZXggIT09IHByZXZNYXRlcmlhbEluZGV4ICkge1xuXG5cdFx0XHRcdFx0XHRnZW8uYWRkR3JvdXAoIHN0YXJ0SW5kZXgsIGkgLSBzdGFydEluZGV4LCBwcmV2TWF0ZXJpYWxJbmRleCApO1xuXG5cdFx0XHRcdFx0XHRwcmV2TWF0ZXJpYWxJbmRleCA9IGN1cnJlbnRJbmRleDtcblx0XHRcdFx0XHRcdHN0YXJ0SW5kZXggPSBpO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHQvLyB0aGUgbG9vcCBhYm92ZSBkb2Vzbid0IGFkZCB0aGUgbGFzdCBncm91cCwgZG8gdGhhdCBoZXJlLlxuXHRcdFx0XHRpZiAoIGdlby5ncm91cHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdHZhciBsYXN0R3JvdXAgPSBnZW8uZ3JvdXBzWyBnZW8uZ3JvdXBzLmxlbmd0aCAtIDEgXTtcblx0XHRcdFx0XHR2YXIgbGFzdEluZGV4ID0gbGFzdEdyb3VwLnN0YXJ0ICsgbGFzdEdyb3VwLmNvdW50O1xuXG5cdFx0XHRcdFx0aWYgKCBsYXN0SW5kZXggIT09IGJ1ZmZlcnMubWF0ZXJpYWxJbmRleC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHRcdGdlby5hZGRHcm91cCggbGFzdEluZGV4LCBidWZmZXJzLm1hdGVyaWFsSW5kZXgubGVuZ3RoIC0gbGFzdEluZGV4LCBwcmV2TWF0ZXJpYWxJbmRleCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjYXNlIHdoZXJlIHRoZXJlIGFyZSBtdWx0aXBsZSBtYXRlcmlhbHMgYnV0IHRoZSB3aG9sZSBnZW9tZXRyeSBpcyBvbmx5XG5cdFx0XHRcdC8vIHVzaW5nIG9uZSBvZiB0aGVtXG5cdFx0XHRcdGlmICggZ2VvLmdyb3Vwcy5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdFx0XHRnZW8uYWRkR3JvdXAoIDAsIGJ1ZmZlcnMubWF0ZXJpYWxJbmRleC5sZW5ndGgsIGJ1ZmZlcnMubWF0ZXJpYWxJbmRleFsgMCBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuYWRkTW9ycGhUYXJnZXRzKCBnZW8sIGdlb05vZGUsIG1vcnBoVGFyZ2V0cywgcHJlVHJhbnNmb3JtICk7XG5cblx0XHRcdHJldHVybiBnZW87XG5cblx0XHR9LFxuXG5cdFx0cGFyc2VHZW9Ob2RlOiBmdW5jdGlvbiAoIGdlb05vZGUsIHNrZWxldG9uICkge1xuXG5cdFx0XHR2YXIgZ2VvSW5mbyA9IHt9O1xuXG5cdFx0XHRnZW9JbmZvLnZlcnRleFBvc2l0aW9ucyA9ICggZ2VvTm9kZS5WZXJ0aWNlcyAhPT0gdW5kZWZpbmVkICkgPyBnZW9Ob2RlLlZlcnRpY2VzLmEgOiBbXTtcblx0XHRcdGdlb0luZm8udmVydGV4SW5kaWNlcyA9ICggZ2VvTm9kZS5Qb2x5Z29uVmVydGV4SW5kZXggIT09IHVuZGVmaW5lZCApID8gZ2VvTm9kZS5Qb2x5Z29uVmVydGV4SW5kZXguYSA6IFtdO1xuXG5cdFx0XHRpZiAoIGdlb05vZGUuTGF5ZXJFbGVtZW50Q29sb3IgKSB7XG5cblx0XHRcdFx0Z2VvSW5mby5jb2xvciA9IHRoaXMucGFyc2VWZXJ0ZXhDb2xvcnMoIGdlb05vZGUuTGF5ZXJFbGVtZW50Q29sb3JbIDAgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZ2VvTm9kZS5MYXllckVsZW1lbnRNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRnZW9JbmZvLm1hdGVyaWFsID0gdGhpcy5wYXJzZU1hdGVyaWFsSW5kaWNlcyggZ2VvTm9kZS5MYXllckVsZW1lbnRNYXRlcmlhbFsgMCBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBnZW9Ob2RlLkxheWVyRWxlbWVudE5vcm1hbCApIHtcblxuXHRcdFx0XHRnZW9JbmZvLm5vcm1hbCA9IHRoaXMucGFyc2VOb3JtYWxzKCBnZW9Ob2RlLkxheWVyRWxlbWVudE5vcm1hbFsgMCBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBnZW9Ob2RlLkxheWVyRWxlbWVudFVWICkge1xuXG5cdFx0XHRcdGdlb0luZm8udXYgPSBbXTtcblxuXHRcdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRcdHdoaWxlICggZ2VvTm9kZS5MYXllckVsZW1lbnRVVlsgaSBdICkge1xuXG5cdFx0XHRcdFx0aWYgKCBnZW9Ob2RlLkxheWVyRWxlbWVudFVWWyBpIF0uVVYgKSB7XG5cblx0XHRcdFx0XHRcdGdlb0luZm8udXYucHVzaCggdGhpcy5wYXJzZVVWcyggZ2VvTm9kZS5MYXllckVsZW1lbnRVVlsgaSBdICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGkgKys7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGdlb0luZm8ud2VpZ2h0VGFibGUgPSB7fTtcblxuXHRcdFx0aWYgKCBza2VsZXRvbiAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRnZW9JbmZvLnNrZWxldG9uID0gc2tlbGV0b247XG5cblx0XHRcdFx0c2tlbGV0b24ucmF3Qm9uZXMuZm9yRWFjaCggZnVuY3Rpb24gKCByYXdCb25lLCBpICkge1xuXG5cdFx0XHRcdFx0Ly8gbG9vcCBvdmVyIHRoZSBib25lJ3MgdmVydGV4IGluZGljZXMgYW5kIHdlaWdodHNcblx0XHRcdFx0XHRyYXdCb25lLmluZGljZXMuZm9yRWFjaCggZnVuY3Rpb24gKCBpbmRleCwgaiApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBnZW9JbmZvLndlaWdodFRhYmxlWyBpbmRleCBdID09PSB1bmRlZmluZWQgKSBnZW9JbmZvLndlaWdodFRhYmxlWyBpbmRleCBdID0gW107XG5cblx0XHRcdFx0XHRcdGdlb0luZm8ud2VpZ2h0VGFibGVbIGluZGV4IF0ucHVzaCgge1xuXG5cdFx0XHRcdFx0XHRcdGlkOiBpLFxuXHRcdFx0XHRcdFx0XHR3ZWlnaHQ6IHJhd0JvbmUud2VpZ2h0c1sgaiBdLFxuXG5cdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBnZW9JbmZvO1xuXG5cdFx0fSxcblxuXHRcdGdlbkJ1ZmZlcnM6IGZ1bmN0aW9uICggZ2VvSW5mbyApIHtcblxuXHRcdFx0dmFyIGJ1ZmZlcnMgPSB7XG5cdFx0XHRcdHZlcnRleDogW10sXG5cdFx0XHRcdG5vcm1hbDogW10sXG5cdFx0XHRcdGNvbG9yczogW10sXG5cdFx0XHRcdHV2czogW10sXG5cdFx0XHRcdG1hdGVyaWFsSW5kZXg6IFtdLFxuXHRcdFx0XHR2ZXJ0ZXhXZWlnaHRzOiBbXSxcblx0XHRcdFx0d2VpZ2h0c0luZGljZXM6IFtdLFxuXHRcdFx0fTtcblxuXHRcdFx0dmFyIHBvbHlnb25JbmRleCA9IDA7XG5cdFx0XHR2YXIgZmFjZUxlbmd0aCA9IDA7XG5cdFx0XHR2YXIgZGlzcGxheWVkV2VpZ2h0c1dhcm5pbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gdGhlc2Ugd2lsbCBob2xkIGRhdGEgZm9yIGEgc2luZ2xlIGZhY2Vcblx0XHRcdHZhciBmYWNlUG9zaXRpb25JbmRleGVzID0gW107XG5cdFx0XHR2YXIgZmFjZU5vcm1hbHMgPSBbXTtcblx0XHRcdHZhciBmYWNlQ29sb3JzID0gW107XG5cdFx0XHR2YXIgZmFjZVVWcyA9IFtdO1xuXHRcdFx0dmFyIGZhY2VXZWlnaHRzID0gW107XG5cdFx0XHR2YXIgZmFjZVdlaWdodEluZGljZXMgPSBbXTtcblxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcblx0XHRcdGdlb0luZm8udmVydGV4SW5kaWNlcy5mb3JFYWNoKCBmdW5jdGlvbiAoIHZlcnRleEluZGV4LCBwb2x5Z29uVmVydGV4SW5kZXggKSB7XG5cblx0XHRcdFx0dmFyIGVuZE9mRmFjZSA9IGZhbHNlO1xuXG5cdFx0XHRcdC8vIEZhY2UgaW5kZXggYW5kIHZlcnRleCBpbmRleCBhcnJheXMgYXJlIGNvbWJpbmVkIGluIGEgc2luZ2xlIGFycmF5XG5cdFx0XHRcdC8vIEEgY3ViZSB3aXRoIHF1YWQgZmFjZXMgbG9va3MgbGlrZSB0aGlzOlxuXHRcdFx0XHQvLyBQb2x5Z29uVmVydGV4SW5kZXg6ICoyNCB7XG5cdFx0XHRcdC8vICBhOiAwLCAxLCAzLCAtMywgMiwgMywgNSwgLTUsIDQsIDUsIDcsIC03LCA2LCA3LCAxLCAtMSwgMSwgNywgNSwgLTQsIDYsIDAsIDIsIC01XG5cdFx0XHRcdC8vICB9XG5cdFx0XHRcdC8vIE5lZ2F0aXZlIG51bWJlcnMgbWFyayB0aGUgZW5kIG9mIGEgZmFjZSAtIGZpcnN0IGZhY2UgaGVyZSBpcyAwLCAxLCAzLCAtM1xuXHRcdFx0XHQvLyB0byBmaW5kIGluZGV4IG9mIGxhc3QgdmVydGV4IGJpdCBzaGlmdCB0aGUgaW5kZXg6IF4gLSAxXG5cdFx0XHRcdGlmICggdmVydGV4SW5kZXggPCAwICkge1xuXG5cdFx0XHRcdFx0dmVydGV4SW5kZXggPSB2ZXJ0ZXhJbmRleCBeIC0gMTsgLy8gZXF1aXZhbGVudCB0byAoIHggKiAtMSApIC0gMVxuXHRcdFx0XHRcdGVuZE9mRmFjZSA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB3ZWlnaHRJbmRpY2VzID0gW107XG5cdFx0XHRcdHZhciB3ZWlnaHRzID0gW107XG5cblx0XHRcdFx0ZmFjZVBvc2l0aW9uSW5kZXhlcy5wdXNoKCB2ZXJ0ZXhJbmRleCAqIDMsIHZlcnRleEluZGV4ICogMyArIDEsIHZlcnRleEluZGV4ICogMyArIDIgKTtcblxuXHRcdFx0XHRpZiAoIGdlb0luZm8uY29sb3IgKSB7XG5cblx0XHRcdFx0XHR2YXIgZGF0YSA9IGdldERhdGEoIHBvbHlnb25WZXJ0ZXhJbmRleCwgcG9seWdvbkluZGV4LCB2ZXJ0ZXhJbmRleCwgZ2VvSW5mby5jb2xvciApO1xuXG5cdFx0XHRcdFx0ZmFjZUNvbG9ycy5wdXNoKCBkYXRhWyAwIF0sIGRhdGFbIDEgXSwgZGF0YVsgMiBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZ2VvSW5mby5za2VsZXRvbiApIHtcblxuXHRcdFx0XHRcdGlmICggZ2VvSW5mby53ZWlnaHRUYWJsZVsgdmVydGV4SW5kZXggXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRnZW9JbmZvLndlaWdodFRhYmxlWyB2ZXJ0ZXhJbmRleCBdLmZvckVhY2goIGZ1bmN0aW9uICggd3QgKSB7XG5cblx0XHRcdFx0XHRcdFx0d2VpZ2h0cy5wdXNoKCB3dC53ZWlnaHQgKTtcblx0XHRcdFx0XHRcdFx0d2VpZ2h0SW5kaWNlcy5wdXNoKCB3dC5pZCApO1xuXG5cdFx0XHRcdFx0XHR9ICk7XG5cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggd2VpZ2h0cy5sZW5ndGggPiA0ICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoICEgZGlzcGxheWVkV2VpZ2h0c1dhcm5pbmcgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRkJYTG9hZGVyOiBWZXJ0ZXggaGFzIG1vcmUgdGhhbiA0IHNraW5uaW5nIHdlaWdodHMgYXNzaWduZWQgdG8gdmVydGV4LiBEZWxldGluZyBhZGRpdGlvbmFsIHdlaWdodHMuJyApO1xuXHRcdFx0XHRcdFx0XHRkaXNwbGF5ZWRXZWlnaHRzV2FybmluZyA9IHRydWU7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dmFyIHdJbmRleCA9IFsgMCwgMCwgMCwgMCBdO1xuXHRcdFx0XHRcdFx0dmFyIFdlaWdodCA9IFsgMCwgMCwgMCwgMCBdO1xuXG5cdFx0XHRcdFx0XHR3ZWlnaHRzLmZvckVhY2goIGZ1bmN0aW9uICggd2VpZ2h0LCB3ZWlnaHRJbmRleCApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgY3VycmVudFdlaWdodCA9IHdlaWdodDtcblx0XHRcdFx0XHRcdFx0dmFyIGN1cnJlbnRJbmRleCA9IHdlaWdodEluZGljZXNbIHdlaWdodEluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0V2VpZ2h0LmZvckVhY2goIGZ1bmN0aW9uICggY29tcGFyZWRXZWlnaHQsIGNvbXBhcmVkV2VpZ2h0SW5kZXgsIGNvbXBhcmVkV2VpZ2h0QXJyYXkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGN1cnJlbnRXZWlnaHQgPiBjb21wYXJlZFdlaWdodCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGFyZWRXZWlnaHRBcnJheVsgY29tcGFyZWRXZWlnaHRJbmRleCBdID0gY3VycmVudFdlaWdodDtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRXZWlnaHQgPSBjb21wYXJlZFdlaWdodDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHRtcCA9IHdJbmRleFsgY29tcGFyZWRXZWlnaHRJbmRleCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0d0luZGV4WyBjb21wYXJlZFdlaWdodEluZGV4IF0gPSBjdXJyZW50SW5kZXg7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50SW5kZXggPSB0bXA7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHRcdHdlaWdodEluZGljZXMgPSB3SW5kZXg7XG5cdFx0XHRcdFx0XHR3ZWlnaHRzID0gV2VpZ2h0O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gaWYgdGhlIHdlaWdodCBhcnJheSBpcyBzaG9ydGVyIHRoYW4gNCBwYWQgd2l0aCAwc1xuXHRcdFx0XHRcdHdoaWxlICggd2VpZ2h0cy5sZW5ndGggPCA0ICkge1xuXG5cdFx0XHRcdFx0XHR3ZWlnaHRzLnB1c2goIDAgKTtcblx0XHRcdFx0XHRcdHdlaWdodEluZGljZXMucHVzaCggMCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNDsgKysgaSApIHtcblxuXHRcdFx0XHRcdFx0ZmFjZVdlaWdodHMucHVzaCggd2VpZ2h0c1sgaSBdICk7XG5cdFx0XHRcdFx0XHRmYWNlV2VpZ2h0SW5kaWNlcy5wdXNoKCB3ZWlnaHRJbmRpY2VzWyBpIF0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBnZW9JbmZvLm5vcm1hbCApIHtcblxuXHRcdFx0XHRcdHZhciBkYXRhID0gZ2V0RGF0YSggcG9seWdvblZlcnRleEluZGV4LCBwb2x5Z29uSW5kZXgsIHZlcnRleEluZGV4LCBnZW9JbmZvLm5vcm1hbCApO1xuXG5cdFx0XHRcdFx0ZmFjZU5vcm1hbHMucHVzaCggZGF0YVsgMCBdLCBkYXRhWyAxIF0sIGRhdGFbIDIgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGdlb0luZm8ubWF0ZXJpYWwgJiYgZ2VvSW5mby5tYXRlcmlhbC5tYXBwaW5nVHlwZSAhPT0gJ0FsbFNhbWUnICkge1xuXG5cdFx0XHRcdFx0dmFyIG1hdGVyaWFsSW5kZXggPSBnZXREYXRhKCBwb2x5Z29uVmVydGV4SW5kZXgsIHBvbHlnb25JbmRleCwgdmVydGV4SW5kZXgsIGdlb0luZm8ubWF0ZXJpYWwgKVsgMCBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGdlb0luZm8udXYgKSB7XG5cblx0XHRcdFx0XHRnZW9JbmZvLnV2LmZvckVhY2goIGZ1bmN0aW9uICggdXYsIGkgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBkYXRhID0gZ2V0RGF0YSggcG9seWdvblZlcnRleEluZGV4LCBwb2x5Z29uSW5kZXgsIHZlcnRleEluZGV4LCB1diApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGZhY2VVVnNbIGkgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdGZhY2VVVnNbIGkgXSA9IFtdO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGZhY2VVVnNbIGkgXS5wdXNoKCBkYXRhWyAwIF0gKTtcblx0XHRcdFx0XHRcdGZhY2VVVnNbIGkgXS5wdXNoKCBkYXRhWyAxIF0gKTtcblxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZmFjZUxlbmd0aCArKztcblxuXHRcdFx0XHRpZiAoIGVuZE9mRmFjZSApIHtcblxuXHRcdFx0XHRcdHNjb3BlLmdlbkZhY2UoIGJ1ZmZlcnMsIGdlb0luZm8sIGZhY2VQb3NpdGlvbkluZGV4ZXMsIG1hdGVyaWFsSW5kZXgsIGZhY2VOb3JtYWxzLCBmYWNlQ29sb3JzLCBmYWNlVVZzLCBmYWNlV2VpZ2h0cywgZmFjZVdlaWdodEluZGljZXMsIGZhY2VMZW5ndGggKTtcblxuXHRcdFx0XHRcdHBvbHlnb25JbmRleCArKztcblx0XHRcdFx0XHRmYWNlTGVuZ3RoID0gMDtcblxuXHRcdFx0XHRcdC8vIHJlc2V0IGFycmF5cyBmb3IgdGhlIG5leHQgZmFjZVxuXHRcdFx0XHRcdGZhY2VQb3NpdGlvbkluZGV4ZXMgPSBbXTtcblx0XHRcdFx0XHRmYWNlTm9ybWFscyA9IFtdO1xuXHRcdFx0XHRcdGZhY2VDb2xvcnMgPSBbXTtcblx0XHRcdFx0XHRmYWNlVVZzID0gW107XG5cdFx0XHRcdFx0ZmFjZVdlaWdodHMgPSBbXTtcblx0XHRcdFx0XHRmYWNlV2VpZ2h0SW5kaWNlcyA9IFtdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0XHRyZXR1cm4gYnVmZmVycztcblxuXHRcdH0sXG5cblx0XHQvLyBHZW5lcmF0ZSBkYXRhIGZvciBhIHNpbmdsZSBmYWNlIGluIGEgZ2VvbWV0cnkuIElmIHRoZSBmYWNlIGlzIGEgcXVhZCB0aGVuIHNwbGl0IGl0IGludG8gMiB0cmlzXG5cdFx0Z2VuRmFjZTogZnVuY3Rpb24gKCBidWZmZXJzLCBnZW9JbmZvLCBmYWNlUG9zaXRpb25JbmRleGVzLCBtYXRlcmlhbEluZGV4LCBmYWNlTm9ybWFscywgZmFjZUNvbG9ycywgZmFjZVVWcywgZmFjZVdlaWdodHMsIGZhY2VXZWlnaHRJbmRpY2VzLCBmYWNlTGVuZ3RoICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDI7IGkgPCBmYWNlTGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGJ1ZmZlcnMudmVydGV4LnB1c2goIGdlb0luZm8udmVydGV4UG9zaXRpb25zWyBmYWNlUG9zaXRpb25JbmRleGVzWyAwIF0gXSApO1xuXHRcdFx0XHRidWZmZXJzLnZlcnRleC5wdXNoKCBnZW9JbmZvLnZlcnRleFBvc2l0aW9uc1sgZmFjZVBvc2l0aW9uSW5kZXhlc1sgMSBdIF0gKTtcblx0XHRcdFx0YnVmZmVycy52ZXJ0ZXgucHVzaCggZ2VvSW5mby52ZXJ0ZXhQb3NpdGlvbnNbIGZhY2VQb3NpdGlvbkluZGV4ZXNbIDIgXSBdICk7XG5cblx0XHRcdFx0YnVmZmVycy52ZXJ0ZXgucHVzaCggZ2VvSW5mby52ZXJ0ZXhQb3NpdGlvbnNbIGZhY2VQb3NpdGlvbkluZGV4ZXNbICggaSAtIDEgKSAqIDMgXSBdICk7XG5cdFx0XHRcdGJ1ZmZlcnMudmVydGV4LnB1c2goIGdlb0luZm8udmVydGV4UG9zaXRpb25zWyBmYWNlUG9zaXRpb25JbmRleGVzWyAoIGkgLSAxICkgKiAzICsgMSBdIF0gKTtcblx0XHRcdFx0YnVmZmVycy52ZXJ0ZXgucHVzaCggZ2VvSW5mby52ZXJ0ZXhQb3NpdGlvbnNbIGZhY2VQb3NpdGlvbkluZGV4ZXNbICggaSAtIDEgKSAqIDMgKyAyIF0gXSApO1xuXG5cdFx0XHRcdGJ1ZmZlcnMudmVydGV4LnB1c2goIGdlb0luZm8udmVydGV4UG9zaXRpb25zWyBmYWNlUG9zaXRpb25JbmRleGVzWyBpICogMyBdIF0gKTtcblx0XHRcdFx0YnVmZmVycy52ZXJ0ZXgucHVzaCggZ2VvSW5mby52ZXJ0ZXhQb3NpdGlvbnNbIGZhY2VQb3NpdGlvbkluZGV4ZXNbIGkgKiAzICsgMSBdIF0gKTtcblx0XHRcdFx0YnVmZmVycy52ZXJ0ZXgucHVzaCggZ2VvSW5mby52ZXJ0ZXhQb3NpdGlvbnNbIGZhY2VQb3NpdGlvbkluZGV4ZXNbIGkgKiAzICsgMiBdIF0gKTtcblxuXHRcdFx0XHRpZiAoIGdlb0luZm8uc2tlbGV0b24gKSB7XG5cblx0XHRcdFx0XHRidWZmZXJzLnZlcnRleFdlaWdodHMucHVzaCggZmFjZVdlaWdodHNbIDAgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMudmVydGV4V2VpZ2h0cy5wdXNoKCBmYWNlV2VpZ2h0c1sgMSBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy52ZXJ0ZXhXZWlnaHRzLnB1c2goIGZhY2VXZWlnaHRzWyAyIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLnZlcnRleFdlaWdodHMucHVzaCggZmFjZVdlaWdodHNbIDMgXSApO1xuXG5cdFx0XHRcdFx0YnVmZmVycy52ZXJ0ZXhXZWlnaHRzLnB1c2goIGZhY2VXZWlnaHRzWyAoIGkgLSAxICkgKiA0IF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLnZlcnRleFdlaWdodHMucHVzaCggZmFjZVdlaWdodHNbICggaSAtIDEgKSAqIDQgKyAxIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLnZlcnRleFdlaWdodHMucHVzaCggZmFjZVdlaWdodHNbICggaSAtIDEgKSAqIDQgKyAyIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLnZlcnRleFdlaWdodHMucHVzaCggZmFjZVdlaWdodHNbICggaSAtIDEgKSAqIDQgKyAzIF0gKTtcblxuXHRcdFx0XHRcdGJ1ZmZlcnMudmVydGV4V2VpZ2h0cy5wdXNoKCBmYWNlV2VpZ2h0c1sgaSAqIDQgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMudmVydGV4V2VpZ2h0cy5wdXNoKCBmYWNlV2VpZ2h0c1sgaSAqIDQgKyAxIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLnZlcnRleFdlaWdodHMucHVzaCggZmFjZVdlaWdodHNbIGkgKiA0ICsgMiBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy52ZXJ0ZXhXZWlnaHRzLnB1c2goIGZhY2VXZWlnaHRzWyBpICogNCArIDMgXSApO1xuXG5cdFx0XHRcdFx0YnVmZmVycy53ZWlnaHRzSW5kaWNlcy5wdXNoKCBmYWNlV2VpZ2h0SW5kaWNlc1sgMCBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy53ZWlnaHRzSW5kaWNlcy5wdXNoKCBmYWNlV2VpZ2h0SW5kaWNlc1sgMSBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy53ZWlnaHRzSW5kaWNlcy5wdXNoKCBmYWNlV2VpZ2h0SW5kaWNlc1sgMiBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy53ZWlnaHRzSW5kaWNlcy5wdXNoKCBmYWNlV2VpZ2h0SW5kaWNlc1sgMyBdICk7XG5cblx0XHRcdFx0XHRidWZmZXJzLndlaWdodHNJbmRpY2VzLnB1c2goIGZhY2VXZWlnaHRJbmRpY2VzWyAoIGkgLSAxICkgKiA0IF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLndlaWdodHNJbmRpY2VzLnB1c2goIGZhY2VXZWlnaHRJbmRpY2VzWyAoIGkgLSAxICkgKiA0ICsgMSBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy53ZWlnaHRzSW5kaWNlcy5wdXNoKCBmYWNlV2VpZ2h0SW5kaWNlc1sgKCBpIC0gMSApICogNCArIDIgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMud2VpZ2h0c0luZGljZXMucHVzaCggZmFjZVdlaWdodEluZGljZXNbICggaSAtIDEgKSAqIDQgKyAzIF0gKTtcblxuXHRcdFx0XHRcdGJ1ZmZlcnMud2VpZ2h0c0luZGljZXMucHVzaCggZmFjZVdlaWdodEluZGljZXNbIGkgKiA0IF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLndlaWdodHNJbmRpY2VzLnB1c2goIGZhY2VXZWlnaHRJbmRpY2VzWyBpICogNCArIDEgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMud2VpZ2h0c0luZGljZXMucHVzaCggZmFjZVdlaWdodEluZGljZXNbIGkgKiA0ICsgMiBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy53ZWlnaHRzSW5kaWNlcy5wdXNoKCBmYWNlV2VpZ2h0SW5kaWNlc1sgaSAqIDQgKyAzIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBnZW9JbmZvLmNvbG9yICkge1xuXG5cdFx0XHRcdFx0YnVmZmVycy5jb2xvcnMucHVzaCggZmFjZUNvbG9yc1sgMCBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy5jb2xvcnMucHVzaCggZmFjZUNvbG9yc1sgMSBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy5jb2xvcnMucHVzaCggZmFjZUNvbG9yc1sgMiBdICk7XG5cblx0XHRcdFx0XHRidWZmZXJzLmNvbG9ycy5wdXNoKCBmYWNlQ29sb3JzWyAoIGkgLSAxICkgKiAzIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLmNvbG9ycy5wdXNoKCBmYWNlQ29sb3JzWyAoIGkgLSAxICkgKiAzICsgMSBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy5jb2xvcnMucHVzaCggZmFjZUNvbG9yc1sgKCBpIC0gMSApICogMyArIDIgXSApO1xuXG5cdFx0XHRcdFx0YnVmZmVycy5jb2xvcnMucHVzaCggZmFjZUNvbG9yc1sgaSAqIDMgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMuY29sb3JzLnB1c2goIGZhY2VDb2xvcnNbIGkgKiAzICsgMSBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy5jb2xvcnMucHVzaCggZmFjZUNvbG9yc1sgaSAqIDMgKyAyIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBnZW9JbmZvLm1hdGVyaWFsICYmIGdlb0luZm8ubWF0ZXJpYWwubWFwcGluZ1R5cGUgIT09ICdBbGxTYW1lJyApIHtcblxuXHRcdFx0XHRcdGJ1ZmZlcnMubWF0ZXJpYWxJbmRleC5wdXNoKCBtYXRlcmlhbEluZGV4ICk7XG5cdFx0XHRcdFx0YnVmZmVycy5tYXRlcmlhbEluZGV4LnB1c2goIG1hdGVyaWFsSW5kZXggKTtcblx0XHRcdFx0XHRidWZmZXJzLm1hdGVyaWFsSW5kZXgucHVzaCggbWF0ZXJpYWxJbmRleCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGdlb0luZm8ubm9ybWFsICkge1xuXG5cdFx0XHRcdFx0YnVmZmVycy5ub3JtYWwucHVzaCggZmFjZU5vcm1hbHNbIDAgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMubm9ybWFsLnB1c2goIGZhY2VOb3JtYWxzWyAxIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLm5vcm1hbC5wdXNoKCBmYWNlTm9ybWFsc1sgMiBdICk7XG5cblx0XHRcdFx0XHRidWZmZXJzLm5vcm1hbC5wdXNoKCBmYWNlTm9ybWFsc1sgKCBpIC0gMSApICogMyBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy5ub3JtYWwucHVzaCggZmFjZU5vcm1hbHNbICggaSAtIDEgKSAqIDMgKyAxIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLm5vcm1hbC5wdXNoKCBmYWNlTm9ybWFsc1sgKCBpIC0gMSApICogMyArIDIgXSApO1xuXG5cdFx0XHRcdFx0YnVmZmVycy5ub3JtYWwucHVzaCggZmFjZU5vcm1hbHNbIGkgKiAzIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLm5vcm1hbC5wdXNoKCBmYWNlTm9ybWFsc1sgaSAqIDMgKyAxIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLm5vcm1hbC5wdXNoKCBmYWNlTm9ybWFsc1sgaSAqIDMgKyAyIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBnZW9JbmZvLnV2ICkge1xuXG5cdFx0XHRcdFx0Z2VvSW5mby51di5mb3JFYWNoKCBmdW5jdGlvbiAoIHV2LCBqICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGJ1ZmZlcnMudXZzWyBqIF0gPT09IHVuZGVmaW5lZCApIGJ1ZmZlcnMudXZzWyBqIF0gPSBbXTtcblxuXHRcdFx0XHRcdFx0YnVmZmVycy51dnNbIGogXS5wdXNoKCBmYWNlVVZzWyBqIF1bIDAgXSApO1xuXHRcdFx0XHRcdFx0YnVmZmVycy51dnNbIGogXS5wdXNoKCBmYWNlVVZzWyBqIF1bIDEgXSApO1xuXG5cdFx0XHRcdFx0XHRidWZmZXJzLnV2c1sgaiBdLnB1c2goIGZhY2VVVnNbIGogXVsgKCBpIC0gMSApICogMiBdICk7XG5cdFx0XHRcdFx0XHRidWZmZXJzLnV2c1sgaiBdLnB1c2goIGZhY2VVVnNbIGogXVsgKCBpIC0gMSApICogMiArIDEgXSApO1xuXG5cdFx0XHRcdFx0XHRidWZmZXJzLnV2c1sgaiBdLnB1c2goIGZhY2VVVnNbIGogXVsgaSAqIDIgXSApO1xuXHRcdFx0XHRcdFx0YnVmZmVycy51dnNbIGogXS5wdXNoKCBmYWNlVVZzWyBqIF1bIGkgKiAyICsgMSBdICk7XG5cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0YWRkTW9ycGhUYXJnZXRzOiBmdW5jdGlvbiAoIHBhcmVudEdlbywgcGFyZW50R2VvTm9kZSwgbW9ycGhUYXJnZXRzLCBwcmVUcmFuc2Zvcm0gKSB7XG5cblx0XHRcdGlmICggbW9ycGhUYXJnZXRzLmxlbmd0aCA9PT0gMCApIHJldHVybjtcblxuXHRcdFx0cGFyZW50R2VvLm1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gdHJ1ZTtcblxuXHRcdFx0cGFyZW50R2VvLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiA9IFtdO1xuXHRcdFx0Ly8gcGFyZW50R2VvLm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgPSBbXTsgLy8gbm90IGltcGxlbWVudGVkXG5cblx0XHRcdHZhciBzY29wZSA9IHRoaXM7XG5cdFx0XHRtb3JwaFRhcmdldHMuZm9yRWFjaCggZnVuY3Rpb24gKCBtb3JwaFRhcmdldCApIHtcblxuXHRcdFx0XHRtb3JwaFRhcmdldC5yYXdUYXJnZXRzLmZvckVhY2goIGZ1bmN0aW9uICggcmF3VGFyZ2V0ICkge1xuXG5cdFx0XHRcdFx0dmFyIG1vcnBoR2VvTm9kZSA9IGZieFRyZWUuT2JqZWN0cy5HZW9tZXRyeVsgcmF3VGFyZ2V0Lmdlb0lEIF07XG5cblx0XHRcdFx0XHRpZiAoIG1vcnBoR2VvTm9kZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRzY29wZS5nZW5Nb3JwaEdlb21ldHJ5KCBwYXJlbnRHZW8sIHBhcmVudEdlb05vZGUsIG1vcnBoR2VvTm9kZSwgcHJlVHJhbnNmb3JtLCByYXdUYXJnZXQubmFtZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fSxcblxuXHRcdC8vIGEgbW9ycGggZ2VvbWV0cnkgbm9kZSBpcyBzaW1pbGFyIHRvIGEgc3RhbmRhcmQgIG5vZGUsIGFuZCB0aGUgbm9kZSBpcyBhbHNvIGNvbnRhaW5lZFxuXHRcdC8vIGluIEZCWFRyZWUuT2JqZWN0cy5HZW9tZXRyeSwgaG93ZXZlciBpdCBjYW4gb25seSBoYXZlIGF0dHJpYnV0ZXMgZm9yIHBvc2l0aW9uLCBub3JtYWxcblx0XHQvLyBhbmQgYSBzcGVjaWFsIGF0dHJpYnV0ZSBJbmRleCBkZWZpbmluZyB3aGljaCB2ZXJ0aWNlcyBvZiB0aGUgb3JpZ2luYWwgZ2VvbWV0cnkgYXJlIGFmZmVjdGVkXG5cdFx0Ly8gTm9ybWFsIGFuZCBwb3NpdGlvbiBhdHRyaWJ1dGVzIG9ubHkgaGF2ZSBkYXRhIGZvciB0aGUgdmVydGljZXMgdGhhdCBhcmUgYWZmZWN0ZWQgYnkgdGhlIG1vcnBoXG5cdFx0Z2VuTW9ycGhHZW9tZXRyeTogZnVuY3Rpb24gKCBwYXJlbnRHZW8sIHBhcmVudEdlb05vZGUsIG1vcnBoR2VvTm9kZSwgcHJlVHJhbnNmb3JtLCBuYW1lICkge1xuXG5cdFx0XHR2YXIgdmVydGV4SW5kaWNlcyA9ICggcGFyZW50R2VvTm9kZS5Qb2x5Z29uVmVydGV4SW5kZXggIT09IHVuZGVmaW5lZCApID8gcGFyZW50R2VvTm9kZS5Qb2x5Z29uVmVydGV4SW5kZXguYSA6IFtdO1xuXG5cdFx0XHR2YXIgbW9ycGhQb3NpdGlvbnNTcGFyc2UgPSAoIG1vcnBoR2VvTm9kZS5WZXJ0aWNlcyAhPT0gdW5kZWZpbmVkICkgPyBtb3JwaEdlb05vZGUuVmVydGljZXMuYSA6IFtdO1xuXHRcdFx0dmFyIGluZGljZXMgPSAoIG1vcnBoR2VvTm9kZS5JbmRleGVzICE9PSB1bmRlZmluZWQgKSA/IG1vcnBoR2VvTm9kZS5JbmRleGVzLmEgOiBbXTtcblxuXHRcdFx0dmFyIGxlbmd0aCA9IHBhcmVudEdlby5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50ICogMztcblx0XHRcdHZhciBtb3JwaFBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoIGxlbmd0aCApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgbW9ycGhJbmRleCA9IGluZGljZXNbIGkgXSAqIDM7XG5cblx0XHRcdFx0bW9ycGhQb3NpdGlvbnNbIG1vcnBoSW5kZXggXSA9IG1vcnBoUG9zaXRpb25zU3BhcnNlWyBpICogMyBdO1xuXHRcdFx0XHRtb3JwaFBvc2l0aW9uc1sgbW9ycGhJbmRleCArIDEgXSA9IG1vcnBoUG9zaXRpb25zU3BhcnNlWyBpICogMyArIDEgXTtcblx0XHRcdFx0bW9ycGhQb3NpdGlvbnNbIG1vcnBoSW5kZXggKyAyIF0gPSBtb3JwaFBvc2l0aW9uc1NwYXJzZVsgaSAqIDMgKyAyIF07XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gVE9ETzogYWRkIG1vcnBoIG5vcm1hbCBzdXBwb3J0XG5cdFx0XHR2YXIgbW9ycGhHZW9JbmZvID0ge1xuXHRcdFx0XHR2ZXJ0ZXhJbmRpY2VzOiB2ZXJ0ZXhJbmRpY2VzLFxuXHRcdFx0XHR2ZXJ0ZXhQb3NpdGlvbnM6IG1vcnBoUG9zaXRpb25zLFxuXG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgbW9ycGhCdWZmZXJzID0gdGhpcy5nZW5CdWZmZXJzKCBtb3JwaEdlb0luZm8gKTtcblxuXHRcdFx0dmFyIHBvc2l0aW9uQXR0cmlidXRlID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG1vcnBoQnVmZmVycy52ZXJ0ZXgsIDMgKTtcblx0XHRcdHBvc2l0aW9uQXR0cmlidXRlLm5hbWUgPSBuYW1lIHx8IG1vcnBoR2VvTm9kZS5hdHRyTmFtZTtcblxuXHRcdFx0cG9zaXRpb25BdHRyaWJ1dGUuYXBwbHlNYXRyaXg0KCBwcmVUcmFuc2Zvcm0gKTtcblxuXHRcdFx0cGFyZW50R2VvLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbi5wdXNoKCBwb3NpdGlvbkF0dHJpYnV0ZSApO1xuXG5cdFx0fSxcblxuXHRcdC8vIFBhcnNlIG5vcm1hbCBmcm9tIEZCWFRyZWUuT2JqZWN0cy5HZW9tZXRyeS5MYXllckVsZW1lbnROb3JtYWwgaWYgaXQgZXhpc3RzXG5cdFx0cGFyc2VOb3JtYWxzOiBmdW5jdGlvbiAoIE5vcm1hbE5vZGUgKSB7XG5cblx0XHRcdHZhciBtYXBwaW5nVHlwZSA9IE5vcm1hbE5vZGUuTWFwcGluZ0luZm9ybWF0aW9uVHlwZTtcblx0XHRcdHZhciByZWZlcmVuY2VUeXBlID0gTm9ybWFsTm9kZS5SZWZlcmVuY2VJbmZvcm1hdGlvblR5cGU7XG5cdFx0XHR2YXIgYnVmZmVyID0gTm9ybWFsTm9kZS5Ob3JtYWxzLmE7XG5cdFx0XHR2YXIgaW5kZXhCdWZmZXIgPSBbXTtcblx0XHRcdGlmICggcmVmZXJlbmNlVHlwZSA9PT0gJ0luZGV4VG9EaXJlY3QnICkge1xuXG5cdFx0XHRcdGlmICggJ05vcm1hbEluZGV4JyBpbiBOb3JtYWxOb2RlICkge1xuXG5cdFx0XHRcdFx0aW5kZXhCdWZmZXIgPSBOb3JtYWxOb2RlLk5vcm1hbEluZGV4LmE7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggJ05vcm1hbHNJbmRleCcgaW4gTm9ybWFsTm9kZSApIHtcblxuXHRcdFx0XHRcdGluZGV4QnVmZmVyID0gTm9ybWFsTm9kZS5Ob3JtYWxzSW5kZXguYTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YVNpemU6IDMsXG5cdFx0XHRcdGJ1ZmZlcjogYnVmZmVyLFxuXHRcdFx0XHRpbmRpY2VzOiBpbmRleEJ1ZmZlcixcblx0XHRcdFx0bWFwcGluZ1R5cGU6IG1hcHBpbmdUeXBlLFxuXHRcdFx0XHRyZWZlcmVuY2VUeXBlOiByZWZlcmVuY2VUeXBlXG5cdFx0XHR9O1xuXG5cdFx0fSxcblxuXHRcdC8vIFBhcnNlIFVWcyBmcm9tIEZCWFRyZWUuT2JqZWN0cy5HZW9tZXRyeS5MYXllckVsZW1lbnRVViBpZiBpdCBleGlzdHNcblx0XHRwYXJzZVVWczogZnVuY3Rpb24gKCBVVk5vZGUgKSB7XG5cblx0XHRcdHZhciBtYXBwaW5nVHlwZSA9IFVWTm9kZS5NYXBwaW5nSW5mb3JtYXRpb25UeXBlO1xuXHRcdFx0dmFyIHJlZmVyZW5jZVR5cGUgPSBVVk5vZGUuUmVmZXJlbmNlSW5mb3JtYXRpb25UeXBlO1xuXHRcdFx0dmFyIGJ1ZmZlciA9IFVWTm9kZS5VVi5hO1xuXHRcdFx0dmFyIGluZGV4QnVmZmVyID0gW107XG5cdFx0XHRpZiAoIHJlZmVyZW5jZVR5cGUgPT09ICdJbmRleFRvRGlyZWN0JyApIHtcblxuXHRcdFx0XHRpbmRleEJ1ZmZlciA9IFVWTm9kZS5VVkluZGV4LmE7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YVNpemU6IDIsXG5cdFx0XHRcdGJ1ZmZlcjogYnVmZmVyLFxuXHRcdFx0XHRpbmRpY2VzOiBpbmRleEJ1ZmZlcixcblx0XHRcdFx0bWFwcGluZ1R5cGU6IG1hcHBpbmdUeXBlLFxuXHRcdFx0XHRyZWZlcmVuY2VUeXBlOiByZWZlcmVuY2VUeXBlXG5cdFx0XHR9O1xuXG5cdFx0fSxcblxuXHRcdC8vIFBhcnNlIFZlcnRleCBDb2xvcnMgZnJvbSBGQlhUcmVlLk9iamVjdHMuR2VvbWV0cnkuTGF5ZXJFbGVtZW50Q29sb3IgaWYgaXQgZXhpc3RzXG5cdFx0cGFyc2VWZXJ0ZXhDb2xvcnM6IGZ1bmN0aW9uICggQ29sb3JOb2RlICkge1xuXG5cdFx0XHR2YXIgbWFwcGluZ1R5cGUgPSBDb2xvck5vZGUuTWFwcGluZ0luZm9ybWF0aW9uVHlwZTtcblx0XHRcdHZhciByZWZlcmVuY2VUeXBlID0gQ29sb3JOb2RlLlJlZmVyZW5jZUluZm9ybWF0aW9uVHlwZTtcblx0XHRcdHZhciBidWZmZXIgPSBDb2xvck5vZGUuQ29sb3JzLmE7XG5cdFx0XHR2YXIgaW5kZXhCdWZmZXIgPSBbXTtcblx0XHRcdGlmICggcmVmZXJlbmNlVHlwZSA9PT0gJ0luZGV4VG9EaXJlY3QnICkge1xuXG5cdFx0XHRcdGluZGV4QnVmZmVyID0gQ29sb3JOb2RlLkNvbG9ySW5kZXguYTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhU2l6ZTogNCxcblx0XHRcdFx0YnVmZmVyOiBidWZmZXIsXG5cdFx0XHRcdGluZGljZXM6IGluZGV4QnVmZmVyLFxuXHRcdFx0XHRtYXBwaW5nVHlwZTogbWFwcGluZ1R5cGUsXG5cdFx0XHRcdHJlZmVyZW5jZVR5cGU6IHJlZmVyZW5jZVR5cGVcblx0XHRcdH07XG5cblx0XHR9LFxuXG5cdFx0Ly8gUGFyc2UgbWFwcGluZyBhbmQgbWF0ZXJpYWwgZGF0YSBpbiBGQlhUcmVlLk9iamVjdHMuR2VvbWV0cnkuTGF5ZXJFbGVtZW50TWF0ZXJpYWwgaWYgaXQgZXhpc3RzXG5cdFx0cGFyc2VNYXRlcmlhbEluZGljZXM6IGZ1bmN0aW9uICggTWF0ZXJpYWxOb2RlICkge1xuXG5cdFx0XHR2YXIgbWFwcGluZ1R5cGUgPSBNYXRlcmlhbE5vZGUuTWFwcGluZ0luZm9ybWF0aW9uVHlwZTtcblx0XHRcdHZhciByZWZlcmVuY2VUeXBlID0gTWF0ZXJpYWxOb2RlLlJlZmVyZW5jZUluZm9ybWF0aW9uVHlwZTtcblxuXHRcdFx0aWYgKCBtYXBwaW5nVHlwZSA9PT0gJ05vTWFwcGluZ0luZm9ybWF0aW9uJyApIHtcblxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGRhdGFTaXplOiAxLFxuXHRcdFx0XHRcdGJ1ZmZlcjogWyAwIF0sXG5cdFx0XHRcdFx0aW5kaWNlczogWyAwIF0sXG5cdFx0XHRcdFx0bWFwcGluZ1R5cGU6ICdBbGxTYW1lJyxcblx0XHRcdFx0XHRyZWZlcmVuY2VUeXBlOiByZWZlcmVuY2VUeXBlXG5cdFx0XHRcdH07XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIG1hdGVyaWFsSW5kZXhCdWZmZXIgPSBNYXRlcmlhbE5vZGUuTWF0ZXJpYWxzLmE7XG5cblx0XHRcdC8vIFNpbmNlIG1hdGVyaWFscyBhcmUgc3RvcmVkIGFzIGluZGljZXMsIHRoZXJlJ3MgYSBiaXQgb2YgYSBtaXNtYXRjaCBiZXR3ZWVuIEZCWCBhbmQgd2hhdFxuXHRcdFx0Ly8gd2UgZXhwZWN0LlNvIHdlIGNyZWF0ZSBhbiBpbnRlcm1lZGlhdGUgYnVmZmVyIHRoYXQgcG9pbnRzIHRvIHRoZSBpbmRleCBpbiB0aGUgYnVmZmVyLFxuXHRcdFx0Ly8gZm9yIGNvbmZvcm1pbmcgd2l0aCB0aGUgb3RoZXIgZnVuY3Rpb25zIHdlJ3ZlIHdyaXR0ZW4gZm9yIG90aGVyIGRhdGEuXG5cdFx0XHR2YXIgbWF0ZXJpYWxJbmRpY2VzID0gW107XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG1hdGVyaWFsSW5kZXhCdWZmZXIubGVuZ3RoOyArKyBpICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsSW5kaWNlcy5wdXNoKCBpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YVNpemU6IDEsXG5cdFx0XHRcdGJ1ZmZlcjogbWF0ZXJpYWxJbmRleEJ1ZmZlcixcblx0XHRcdFx0aW5kaWNlczogbWF0ZXJpYWxJbmRpY2VzLFxuXHRcdFx0XHRtYXBwaW5nVHlwZTogbWFwcGluZ1R5cGUsXG5cdFx0XHRcdHJlZmVyZW5jZVR5cGU6IHJlZmVyZW5jZVR5cGVcblx0XHRcdH07XG5cblx0XHR9LFxuXG5cdFx0Ly8gR2VuZXJhdGUgYSBOdXJiR2VvbWV0cnkgZnJvbSBhIG5vZGUgaW4gRkJYVHJlZS5PYmplY3RzLkdlb21ldHJ5XG5cdFx0cGFyc2VOdXJic0dlb21ldHJ5OiBmdW5jdGlvbiAoIGdlb05vZGUgKSB7XG5cblx0XHRcdGlmICggTlVSQlNDdXJ2ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5GQlhMb2FkZXI6IFRoZSBsb2FkZXIgcmVsaWVzIG9uIE5VUkJTQ3VydmUgZm9yIGFueSBudXJicyBwcmVzZW50IGluIHRoZSBtb2RlbC4gTnVyYnMgd2lsbCBzaG93IHVwIGFzIGVtcHR5IGdlb21ldHJ5LicgKTtcblx0XHRcdFx0cmV0dXJuIG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBvcmRlciA9IHBhcnNlSW50KCBnZW9Ob2RlLk9yZGVyICk7XG5cblx0XHRcdGlmICggaXNOYU4oIG9yZGVyICkgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkZCWExvYWRlcjogSW52YWxpZCBPcmRlciAlcyBnaXZlbiBmb3IgZ2VvbWV0cnkgSUQ6ICVzJywgZ2VvTm9kZS5PcmRlciwgZ2VvTm9kZS5pZCApO1xuXHRcdFx0XHRyZXR1cm4gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGRlZ3JlZSA9IG9yZGVyIC0gMTtcblxuXHRcdFx0dmFyIGtub3RzID0gZ2VvTm9kZS5Lbm90VmVjdG9yLmE7XG5cdFx0XHR2YXIgY29udHJvbFBvaW50cyA9IFtdO1xuXHRcdFx0dmFyIHBvaW50c1ZhbHVlcyA9IGdlb05vZGUuUG9pbnRzLmE7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHBvaW50c1ZhbHVlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDQgKSB7XG5cblx0XHRcdFx0Y29udHJvbFBvaW50cy5wdXNoKCBuZXcgVmVjdG9yNCgpLmZyb21BcnJheSggcG9pbnRzVmFsdWVzLCBpICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgc3RhcnRLbm90LCBlbmRLbm90O1xuXG5cdFx0XHRpZiAoIGdlb05vZGUuRm9ybSA9PT0gJ0Nsb3NlZCcgKSB7XG5cblx0XHRcdFx0Y29udHJvbFBvaW50cy5wdXNoKCBjb250cm9sUG9pbnRzWyAwIF0gKTtcblxuXHRcdFx0fSBlbHNlIGlmICggZ2VvTm9kZS5Gb3JtID09PSAnUGVyaW9kaWMnICkge1xuXG5cdFx0XHRcdHN0YXJ0S25vdCA9IGRlZ3JlZTtcblx0XHRcdFx0ZW5kS25vdCA9IGtub3RzLmxlbmd0aCAtIDEgLSBzdGFydEtub3Q7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZGVncmVlOyArKyBpICkge1xuXG5cdFx0XHRcdFx0Y29udHJvbFBvaW50cy5wdXNoKCBjb250cm9sUG9pbnRzWyBpIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGN1cnZlID0gbmV3IE5VUkJTQ3VydmUoIGRlZ3JlZSwga25vdHMsIGNvbnRyb2xQb2ludHMsIHN0YXJ0S25vdCwgZW5kS25vdCApO1xuXHRcdFx0dmFyIHZlcnRpY2VzID0gY3VydmUuZ2V0UG9pbnRzKCBjb250cm9sUG9pbnRzLmxlbmd0aCAqIDcgKTtcblxuXHRcdFx0dmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRpY2VzLmxlbmd0aCAqIDMgKTtcblxuXHRcdFx0dmVydGljZXMuZm9yRWFjaCggZnVuY3Rpb24gKCB2ZXJ0ZXgsIGkgKSB7XG5cblx0XHRcdFx0dmVydGV4LnRvQXJyYXkoIHBvc2l0aW9ucywgaSAqIDMgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCAzICkgKTtcblxuXHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0fSxcblxuXHR9O1xuXG5cdC8vIHBhcnNlIGFuaW1hdGlvbiBkYXRhIGZyb20gRkJYVHJlZVxuXHRmdW5jdGlvbiBBbmltYXRpb25QYXJzZXIoKSB7fVxuXG5cdEFuaW1hdGlvblBhcnNlci5wcm90b3R5cGUgPSB7XG5cblx0XHRjb25zdHJ1Y3RvcjogQW5pbWF0aW9uUGFyc2VyLFxuXG5cdFx0Ly8gdGFrZSByYXcgYW5pbWF0aW9uIGNsaXBzIGFuZCB0dXJuIHRoZW0gaW50byB0aHJlZS5qcyBhbmltYXRpb24gY2xpcHNcblx0XHRwYXJzZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgYW5pbWF0aW9uQ2xpcHMgPSBbXTtcblxuXHRcdFx0dmFyIHJhd0NsaXBzID0gdGhpcy5wYXJzZUNsaXBzKCk7XG5cblx0XHRcdGlmICggcmF3Q2xpcHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIga2V5IGluIHJhd0NsaXBzICkge1xuXG5cdFx0XHRcdFx0dmFyIHJhd0NsaXAgPSByYXdDbGlwc1sga2V5IF07XG5cblx0XHRcdFx0XHR2YXIgY2xpcCA9IHRoaXMuYWRkQ2xpcCggcmF3Q2xpcCApO1xuXG5cdFx0XHRcdFx0YW5pbWF0aW9uQ2xpcHMucHVzaCggY2xpcCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYW5pbWF0aW9uQ2xpcHM7XG5cblx0XHR9LFxuXG5cdFx0cGFyc2VDbGlwczogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQvLyBzaW5jZSB0aGUgYWN0dWFsIHRyYW5zZm9ybWF0aW9uIGRhdGEgaXMgc3RvcmVkIGluIEZCWFRyZWUuT2JqZWN0cy5BbmltYXRpb25DdXJ2ZSxcblx0XHRcdC8vIGlmIHRoaXMgaXMgdW5kZWZpbmVkIHdlIGNhbiBzYWZlbHkgYXNzdW1lIHRoZXJlIGFyZSBubyBhbmltYXRpb25zXG5cdFx0XHRpZiAoIGZieFRyZWUuT2JqZWN0cy5BbmltYXRpb25DdXJ2ZSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIHVuZGVmaW5lZDtcblxuXHRcdFx0dmFyIGN1cnZlTm9kZXNNYXAgPSB0aGlzLnBhcnNlQW5pbWF0aW9uQ3VydmVOb2RlcygpO1xuXG5cdFx0XHR0aGlzLnBhcnNlQW5pbWF0aW9uQ3VydmVzKCBjdXJ2ZU5vZGVzTWFwICk7XG5cblx0XHRcdHZhciBsYXllcnNNYXAgPSB0aGlzLnBhcnNlQW5pbWF0aW9uTGF5ZXJzKCBjdXJ2ZU5vZGVzTWFwICk7XG5cdFx0XHR2YXIgcmF3Q2xpcHMgPSB0aGlzLnBhcnNlQW5pbVN0YWNrcyggbGF5ZXJzTWFwICk7XG5cblx0XHRcdHJldHVybiByYXdDbGlwcztcblxuXHRcdH0sXG5cblx0XHQvLyBwYXJzZSBub2RlcyBpbiBGQlhUcmVlLk9iamVjdHMuQW5pbWF0aW9uQ3VydmVOb2RlXG5cdFx0Ly8gZWFjaCBBbmltYXRpb25DdXJ2ZU5vZGUgaG9sZHMgZGF0YSBmb3IgYW4gYW5pbWF0aW9uIHRyYW5zZm9ybSBmb3IgYSBtb2RlbCAoZS5nLiBsZWZ0IGFybSByb3RhdGlvbiApXG5cdFx0Ly8gYW5kIGlzIHJlZmVyZW5jZWQgYnkgYW4gQW5pbWF0aW9uTGF5ZXJcblx0XHRwYXJzZUFuaW1hdGlvbkN1cnZlTm9kZXM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHJhd0N1cnZlTm9kZXMgPSBmYnhUcmVlLk9iamVjdHMuQW5pbWF0aW9uQ3VydmVOb2RlO1xuXG5cdFx0XHR2YXIgY3VydmVOb2Rlc01hcCA9IG5ldyBNYXAoKTtcblxuXHRcdFx0Zm9yICggdmFyIG5vZGVJRCBpbiByYXdDdXJ2ZU5vZGVzICkge1xuXG5cdFx0XHRcdHZhciByYXdDdXJ2ZU5vZGUgPSByYXdDdXJ2ZU5vZGVzWyBub2RlSUQgXTtcblxuXHRcdFx0XHRpZiAoIHJhd0N1cnZlTm9kZS5hdHRyTmFtZS5tYXRjaCggL1N8UnxUfERlZm9ybVBlcmNlbnQvICkgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHR2YXIgY3VydmVOb2RlID0ge1xuXG5cdFx0XHRcdFx0XHRpZDogcmF3Q3VydmVOb2RlLmlkLFxuXHRcdFx0XHRcdFx0YXR0cjogcmF3Q3VydmVOb2RlLmF0dHJOYW1lLFxuXHRcdFx0XHRcdFx0Y3VydmVzOiB7fSxcblxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRjdXJ2ZU5vZGVzTWFwLnNldCggY3VydmVOb2RlLmlkLCBjdXJ2ZU5vZGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGN1cnZlTm9kZXNNYXA7XG5cblx0XHR9LFxuXG5cdFx0Ly8gcGFyc2Ugbm9kZXMgaW4gRkJYVHJlZS5PYmplY3RzLkFuaW1hdGlvbkN1cnZlIGFuZCBjb25uZWN0IHRoZW0gdXAgdG9cblx0XHQvLyBwcmV2aW91c2x5IHBhcnNlZCBBbmltYXRpb25DdXJ2ZU5vZGVzLiBFYWNoIEFuaW1hdGlvbkN1cnZlIGhvbGRzIGRhdGEgZm9yIGEgc2luZ2xlIGFuaW1hdGVkXG5cdFx0Ly8gYXhpcyAoIGUuZy4gdGltZXMgYW5kIHZhbHVlcyBvZiB4IHJvdGF0aW9uKVxuXHRcdHBhcnNlQW5pbWF0aW9uQ3VydmVzOiBmdW5jdGlvbiAoIGN1cnZlTm9kZXNNYXAgKSB7XG5cblx0XHRcdHZhciByYXdDdXJ2ZXMgPSBmYnhUcmVlLk9iamVjdHMuQW5pbWF0aW9uQ3VydmU7XG5cblx0XHRcdC8vIFRPRE86IE1hbnkgdmFsdWVzIGFyZSBpZGVudGljYWwgdXAgdG8gcm91bmRvZmYgZXJyb3IsIGJ1dCB3b24ndCBiZSBvcHRpbWlzZWRcblx0XHRcdC8vIGUuZy4gcG9zaXRpb24gdGltZXM6IFswLCAwLjQsIDAuIDhdXG5cdFx0XHQvLyBwb3NpdGlvbiB2YWx1ZXM6IFs3LjIzNTM4MzM1MDIzNDc3ZS03LCA5My42NzUxODYxNTcyMjY1NiwgLTAuOTk4MjY5NTU3OTUyODgwOSwgNy4yMzUzODMzNTAyMzQ3N2UtNywgOTMuNjc1MTg2MTU3MjI2NTYsIC0wLjk5ODI2OTU1Nzk1Mjg4MDksIDcuMjM1Mzg0NDg3MTAzMTQ3ZS03LCA5My42NzUyMDkwNDU0MTAxNiwgLTAuOTk4MjY5NTU3OTUyODgwOV1cblx0XHRcdC8vIGNsZWFybHksIHRoaXMgc2hvdWxkIGJlIG9wdGltaXNlZCB0b1xuXHRcdFx0Ly8gdGltZXM6IFswXSwgcG9zaXRpb25zIFs3LjIzNTM4MzM1MDIzNDc3ZS03LCA5My42NzUxODYxNTcyMjY1NiwgLTAuOTk4MjY5NTU3OTUyODgwOV1cblx0XHRcdC8vIHRoaXMgc2hvd3MgdXAgaW4gbmVhcmx5IGV2ZXJ5IEZCWCBmaWxlLCBhbmQgZ2VuZXJhbGx5IHRpbWUgYXJyYXkgaXMgbGVuZ3RoID4gMTAwXG5cblx0XHRcdGZvciAoIHZhciBub2RlSUQgaW4gcmF3Q3VydmVzICkge1xuXG5cdFx0XHRcdHZhciBhbmltYXRpb25DdXJ2ZSA9IHtcblxuXHRcdFx0XHRcdGlkOiByYXdDdXJ2ZXNbIG5vZGVJRCBdLmlkLFxuXHRcdFx0XHRcdHRpbWVzOiByYXdDdXJ2ZXNbIG5vZGVJRCBdLktleVRpbWUuYS5tYXAoIGNvbnZlcnRGQlhUaW1lVG9TZWNvbmRzICksXG5cdFx0XHRcdFx0dmFsdWVzOiByYXdDdXJ2ZXNbIG5vZGVJRCBdLktleVZhbHVlRmxvYXQuYSxcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHZhciByZWxhdGlvbnNoaXBzID0gY29ubmVjdGlvbnMuZ2V0KCBhbmltYXRpb25DdXJ2ZS5pZCApO1xuXG5cdFx0XHRcdGlmICggcmVsYXRpb25zaGlwcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0dmFyIGFuaW1hdGlvbkN1cnZlSUQgPSByZWxhdGlvbnNoaXBzLnBhcmVudHNbIDAgXS5JRDtcblx0XHRcdFx0XHR2YXIgYW5pbWF0aW9uQ3VydmVSZWxhdGlvbnNoaXAgPSByZWxhdGlvbnNoaXBzLnBhcmVudHNbIDAgXS5yZWxhdGlvbnNoaXA7XG5cblx0XHRcdFx0XHRpZiAoIGFuaW1hdGlvbkN1cnZlUmVsYXRpb25zaGlwLm1hdGNoKCAvWC8gKSApIHtcblxuXHRcdFx0XHRcdFx0Y3VydmVOb2Rlc01hcC5nZXQoIGFuaW1hdGlvbkN1cnZlSUQgKS5jdXJ2ZXNbICd4JyBdID0gYW5pbWF0aW9uQ3VydmU7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhbmltYXRpb25DdXJ2ZVJlbGF0aW9uc2hpcC5tYXRjaCggL1kvICkgKSB7XG5cblx0XHRcdFx0XHRcdGN1cnZlTm9kZXNNYXAuZ2V0KCBhbmltYXRpb25DdXJ2ZUlEICkuY3VydmVzWyAneScgXSA9IGFuaW1hdGlvbkN1cnZlO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggYW5pbWF0aW9uQ3VydmVSZWxhdGlvbnNoaXAubWF0Y2goIC9aLyApICkge1xuXG5cdFx0XHRcdFx0XHRjdXJ2ZU5vZGVzTWFwLmdldCggYW5pbWF0aW9uQ3VydmVJRCApLmN1cnZlc1sgJ3onIF0gPSBhbmltYXRpb25DdXJ2ZTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFuaW1hdGlvbkN1cnZlUmVsYXRpb25zaGlwLm1hdGNoKCAvZHxEZWZvcm1QZXJjZW50LyApICYmIGN1cnZlTm9kZXNNYXAuaGFzKCBhbmltYXRpb25DdXJ2ZUlEICkgKSB7XG5cblx0XHRcdFx0XHRcdGN1cnZlTm9kZXNNYXAuZ2V0KCBhbmltYXRpb25DdXJ2ZUlEICkuY3VydmVzWyAnbW9ycGgnIF0gPSBhbmltYXRpb25DdXJ2ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHQvLyBwYXJzZSBub2RlcyBpbiBGQlhUcmVlLk9iamVjdHMuQW5pbWF0aW9uTGF5ZXIuIEVhY2ggbGF5ZXJzIGhvbGRzIHJlZmVyZW5jZXNcblx0XHQvLyB0byB2YXJpb3VzIEFuaW1hdGlvbkN1cnZlTm9kZXMgYW5kIGlzIHJlZmVyZW5jZWQgYnkgYW4gQW5pbWF0aW9uU3RhY2sgbm9kZVxuXHRcdC8vIG5vdGU6IHRoZW9yZXRpY2FsbHkgYSBzdGFjayBjYW4gaGF2ZSBtdWx0aXBsZSBsYXllcnMsIGhvd2V2ZXIgaW4gcHJhY3RpY2UgdGhlcmUgYWx3YXlzIHNlZW1zIHRvIGJlIG9uZSBwZXIgc3RhY2tcblx0XHRwYXJzZUFuaW1hdGlvbkxheWVyczogZnVuY3Rpb24gKCBjdXJ2ZU5vZGVzTWFwICkge1xuXG5cdFx0XHR2YXIgcmF3TGF5ZXJzID0gZmJ4VHJlZS5PYmplY3RzLkFuaW1hdGlvbkxheWVyO1xuXG5cdFx0XHR2YXIgbGF5ZXJzTWFwID0gbmV3IE1hcCgpO1xuXG5cdFx0XHRmb3IgKCB2YXIgbm9kZUlEIGluIHJhd0xheWVycyApIHtcblxuXHRcdFx0XHR2YXIgbGF5ZXJDdXJ2ZU5vZGVzID0gW107XG5cblx0XHRcdFx0dmFyIGNvbm5lY3Rpb24gPSBjb25uZWN0aW9ucy5nZXQoIHBhcnNlSW50KCBub2RlSUQgKSApO1xuXG5cdFx0XHRcdGlmICggY29ubmVjdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Ly8gYWxsIHRoZSBhbmltYXRpb25DdXJ2ZU5vZGVzIHVzZWQgaW4gdGhlIGxheWVyXG5cdFx0XHRcdFx0dmFyIGNoaWxkcmVuID0gY29ubmVjdGlvbi5jaGlsZHJlbjtcblxuXHRcdFx0XHRcdGNoaWxkcmVuLmZvckVhY2goIGZ1bmN0aW9uICggY2hpbGQsIGkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggY3VydmVOb2Rlc01hcC5oYXMoIGNoaWxkLklEICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIGN1cnZlTm9kZSA9IGN1cnZlTm9kZXNNYXAuZ2V0KCBjaGlsZC5JRCApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGNoZWNrIHRoYXQgdGhlIGN1cnZlcyBhcmUgZGVmaW5lZCBmb3IgYXQgbGVhc3Qgb25lIGF4aXMsIG90aGVyd2lzZSBpZ25vcmUgdGhlIGN1cnZlTm9kZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGN1cnZlTm9kZS5jdXJ2ZXMueCAhPT0gdW5kZWZpbmVkIHx8IGN1cnZlTm9kZS5jdXJ2ZXMueSAhPT0gdW5kZWZpbmVkIHx8IGN1cnZlTm9kZS5jdXJ2ZXMueiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBsYXllckN1cnZlTm9kZXNbIGkgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgbW9kZWxJRCA9IGNvbm5lY3Rpb25zLmdldCggY2hpbGQuSUQgKS5wYXJlbnRzLmZpbHRlciggZnVuY3Rpb24gKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHBhcmVudC5yZWxhdGlvbnNoaXAgIT09IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0fSApWyAwIF0uSUQ7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggbW9kZWxJRCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhciByYXdNb2RlbCA9IGZieFRyZWUuT2JqZWN0cy5Nb2RlbFsgbW9kZWxJRC50b1N0cmluZygpIF07XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCByYXdNb2RlbCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRkJYTG9hZGVyOiBFbmNvdW50ZXJlZCBhIHVudXNlZCBjdXJ2ZS4nLCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIG5vZGUgPSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtb2RlbE5hbWU6IHJhd01vZGVsLmF0dHJOYW1lID8gUHJvcGVydHlCaW5kaW5nLnNhbml0aXplTm9kZU5hbWUoIHJhd01vZGVsLmF0dHJOYW1lICkgOiAnJyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRJRDogcmF3TW9kZWwuaWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aW5pdGlhbFBvc2l0aW9uOiBbIDAsIDAsIDAgXSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpbml0aWFsUm90YXRpb246IFsgMCwgMCwgMCBdLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGluaXRpYWxTY2FsZTogWyAxLCAxLCAxIF0sXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzY2VuZUdyYXBoLnRyYXZlcnNlKCBmdW5jdGlvbiAoIGNoaWxkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBjaGlsZC5JRCA9PT0gcmF3TW9kZWwuaWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUudHJhbnNmb3JtID0gY2hpbGQubWF0cml4O1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGNoaWxkLnVzZXJEYXRhLnRyYW5zZm9ybURhdGEgKSBub2RlLmV1bGVyT3JkZXIgPSBjaGlsZC51c2VyRGF0YS50cmFuc2Zvcm1EYXRhLmV1bGVyT3JkZXI7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggISBub2RlLnRyYW5zZm9ybSApIG5vZGUudHJhbnNmb3JtID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBpZiB0aGUgYW5pbWF0ZWQgbW9kZWwgaXMgcHJlIHJvdGF0ZWQsIHdlJ2xsIGhhdmUgdG8gYXBwbHkgdGhlIHByZSByb3RhdGlvbnMgdG8gZXZlcnlcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5pbWF0aW9uIHZhbHVlIGFzIHdlbGxcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAnUHJlUm90YXRpb24nIGluIHJhd01vZGVsICkgbm9kZS5wcmVSb3RhdGlvbiA9IHJhd01vZGVsLlByZVJvdGF0aW9uLnZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoICdQb3N0Um90YXRpb24nIGluIHJhd01vZGVsICkgbm9kZS5wb3N0Um90YXRpb24gPSByYXdNb2RlbC5Qb3N0Um90YXRpb24udmFsdWU7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0bGF5ZXJDdXJ2ZU5vZGVzWyBpIF0gPSBub2RlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGxheWVyQ3VydmVOb2Rlc1sgaSBdICkgbGF5ZXJDdXJ2ZU5vZGVzWyBpIF1bIGN1cnZlTm9kZS5hdHRyIF0gPSBjdXJ2ZU5vZGU7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY3VydmVOb2RlLmN1cnZlcy5tb3JwaCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBsYXllckN1cnZlTm9kZXNbIGkgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgZGVmb3JtZXJJRCA9IGNvbm5lY3Rpb25zLmdldCggY2hpbGQuSUQgKS5wYXJlbnRzLmZpbHRlciggZnVuY3Rpb24gKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHBhcmVudC5yZWxhdGlvbnNoaXAgIT09IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0fSApWyAwIF0uSUQ7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHZhciBtb3JwaGVySUQgPSBjb25uZWN0aW9ucy5nZXQoIGRlZm9ybWVySUQgKS5wYXJlbnRzWyAwIF0uSUQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgZ2VvSUQgPSBjb25uZWN0aW9ucy5nZXQoIG1vcnBoZXJJRCApLnBhcmVudHNbIDAgXS5JRDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gYXNzdW1pbmcgZ2VvbWV0cnkgaXMgbm90IHVzZWQgaW4gbW9yZSB0aGFuIG9uZSBtb2RlbFxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIG1vZGVsSUQgPSBjb25uZWN0aW9ucy5nZXQoIGdlb0lEICkucGFyZW50c1sgMCBdLklEO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmF3TW9kZWwgPSBmYnhUcmVlLk9iamVjdHMuTW9kZWxbIG1vZGVsSUQgXTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIG5vZGUgPSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0bW9kZWxOYW1lOiByYXdNb2RlbC5hdHRyTmFtZSA/IFByb3BlcnR5QmluZGluZy5zYW5pdGl6ZU5vZGVOYW1lKCByYXdNb2RlbC5hdHRyTmFtZSApIDogJycsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG1vcnBoTmFtZTogZmJ4VHJlZS5PYmplY3RzLkRlZm9ybWVyWyBkZWZvcm1lcklEIF0uYXR0ck5hbWUsXG5cblx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0XHRcdGxheWVyQ3VydmVOb2Rlc1sgaSBdID0gbm9kZTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdGxheWVyQ3VydmVOb2Rlc1sgaSBdWyBjdXJ2ZU5vZGUuYXR0ciBdID0gY3VydmVOb2RlO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0bGF5ZXJzTWFwLnNldCggcGFyc2VJbnQoIG5vZGVJRCApLCBsYXllckN1cnZlTm9kZXMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGxheWVyc01hcDtcblxuXHRcdH0sXG5cblx0XHQvLyBwYXJzZSBub2RlcyBpbiBGQlhUcmVlLk9iamVjdHMuQW5pbWF0aW9uU3RhY2suIFRoZXNlIGFyZSB0aGUgdG9wIGxldmVsIG5vZGUgaW4gdGhlIGFuaW1hdGlvblxuXHRcdC8vIGhpZXJhcmNoeS4gRWFjaCBTdGFjayBub2RlIHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgYSBBbmltYXRpb25DbGlwXG5cdFx0cGFyc2VBbmltU3RhY2tzOiBmdW5jdGlvbiAoIGxheWVyc01hcCApIHtcblxuXHRcdFx0dmFyIHJhd1N0YWNrcyA9IGZieFRyZWUuT2JqZWN0cy5BbmltYXRpb25TdGFjaztcblxuXHRcdFx0Ly8gY29ubmVjdCB0aGUgc3RhY2tzIChjbGlwcykgdXAgdG8gdGhlIGxheWVyc1xuXHRcdFx0dmFyIHJhd0NsaXBzID0ge307XG5cblx0XHRcdGZvciAoIHZhciBub2RlSUQgaW4gcmF3U3RhY2tzICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZHJlbiA9IGNvbm5lY3Rpb25zLmdldCggcGFyc2VJbnQoIG5vZGVJRCApICkuY2hpbGRyZW47XG5cblx0XHRcdFx0aWYgKCBjaGlsZHJlbi5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRcdFx0Ly8gaXQgc2VlbXMgbGlrZSBzdGFja3Mgd2lsbCBhbHdheXMgYmUgYXNzb2NpYXRlZCB3aXRoIGEgc2luZ2xlIGxheWVyLiBCdXQganVzdCBpbiBjYXNlIHRoZXJlIGFyZSBmaWxlc1xuXHRcdFx0XHRcdC8vIHdoZXJlIHRoZXJlIGFyZSBtdWx0aXBsZSBsYXllcnMgcGVyIHN0YWNrLCB3ZSdsbCBkaXNwbGF5IGEgd2FybmluZ1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZCWExvYWRlcjogRW5jb3VudGVyZWQgYW4gYW5pbWF0aW9uIHN0YWNrIHdpdGggbXVsdGlwbGUgbGF5ZXJzLCB0aGlzIGlzIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkLiBJZ25vcmluZyBzdWJzZXF1ZW50IGxheWVycy4nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBsYXllciA9IGxheWVyc01hcC5nZXQoIGNoaWxkcmVuWyAwIF0uSUQgKTtcblxuXHRcdFx0XHRyYXdDbGlwc1sgbm9kZUlEIF0gPSB7XG5cblx0XHRcdFx0XHRuYW1lOiByYXdTdGFja3NbIG5vZGVJRCBdLmF0dHJOYW1lLFxuXHRcdFx0XHRcdGxheWVyOiBsYXllcixcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByYXdDbGlwcztcblxuXHRcdH0sXG5cblx0XHRhZGRDbGlwOiBmdW5jdGlvbiAoIHJhd0NsaXAgKSB7XG5cblx0XHRcdHZhciB0cmFja3MgPSBbXTtcblxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcblx0XHRcdHJhd0NsaXAubGF5ZXIuZm9yRWFjaCggZnVuY3Rpb24gKCByYXdUcmFja3MgKSB7XG5cblx0XHRcdFx0dHJhY2tzID0gdHJhY2tzLmNvbmNhdCggc2NvcGUuZ2VuZXJhdGVUcmFja3MoIHJhd1RyYWNrcyApICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0cmV0dXJuIG5ldyBBbmltYXRpb25DbGlwKCByYXdDbGlwLm5hbWUsIC0gMSwgdHJhY2tzICk7XG5cblx0XHR9LFxuXG5cdFx0Z2VuZXJhdGVUcmFja3M6IGZ1bmN0aW9uICggcmF3VHJhY2tzICkge1xuXG5cdFx0XHR2YXIgdHJhY2tzID0gW107XG5cblx0XHRcdHZhciBpbml0aWFsUG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0dmFyIGluaXRpYWxSb3RhdGlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cdFx0XHR2YXIgaW5pdGlhbFNjYWxlID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0aWYgKCByYXdUcmFja3MudHJhbnNmb3JtICkgcmF3VHJhY2tzLnRyYW5zZm9ybS5kZWNvbXBvc2UoIGluaXRpYWxQb3NpdGlvbiwgaW5pdGlhbFJvdGF0aW9uLCBpbml0aWFsU2NhbGUgKTtcblxuXHRcdFx0aW5pdGlhbFBvc2l0aW9uID0gaW5pdGlhbFBvc2l0aW9uLnRvQXJyYXkoKTtcblx0XHRcdGluaXRpYWxSb3RhdGlvbiA9IG5ldyBFdWxlcigpLnNldEZyb21RdWF0ZXJuaW9uKCBpbml0aWFsUm90YXRpb24sIHJhd1RyYWNrcy5ldWxlck9yZGVyICkudG9BcnJheSgpO1xuXHRcdFx0aW5pdGlhbFNjYWxlID0gaW5pdGlhbFNjYWxlLnRvQXJyYXkoKTtcblxuXHRcdFx0aWYgKCByYXdUcmFja3MuVCAhPT0gdW5kZWZpbmVkICYmIE9iamVjdC5rZXlzKCByYXdUcmFja3MuVC5jdXJ2ZXMgKS5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdHZhciBwb3NpdGlvblRyYWNrID0gdGhpcy5nZW5lcmF0ZVZlY3RvclRyYWNrKCByYXdUcmFja3MubW9kZWxOYW1lLCByYXdUcmFja3MuVC5jdXJ2ZXMsIGluaXRpYWxQb3NpdGlvbiwgJ3Bvc2l0aW9uJyApO1xuXHRcdFx0XHRpZiAoIHBvc2l0aW9uVHJhY2sgIT09IHVuZGVmaW5lZCApIHRyYWNrcy5wdXNoKCBwb3NpdGlvblRyYWNrICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCByYXdUcmFja3MuUiAhPT0gdW5kZWZpbmVkICYmIE9iamVjdC5rZXlzKCByYXdUcmFja3MuUi5jdXJ2ZXMgKS5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdHZhciByb3RhdGlvblRyYWNrID0gdGhpcy5nZW5lcmF0ZVJvdGF0aW9uVHJhY2soIHJhd1RyYWNrcy5tb2RlbE5hbWUsIHJhd1RyYWNrcy5SLmN1cnZlcywgaW5pdGlhbFJvdGF0aW9uLCByYXdUcmFja3MucHJlUm90YXRpb24sIHJhd1RyYWNrcy5wb3N0Um90YXRpb24sIHJhd1RyYWNrcy5ldWxlck9yZGVyICk7XG5cdFx0XHRcdGlmICggcm90YXRpb25UcmFjayAhPT0gdW5kZWZpbmVkICkgdHJhY2tzLnB1c2goIHJvdGF0aW9uVHJhY2sgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHJhd1RyYWNrcy5TICE9PSB1bmRlZmluZWQgJiYgT2JqZWN0LmtleXMoIHJhd1RyYWNrcy5TLmN1cnZlcyApLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0dmFyIHNjYWxlVHJhY2sgPSB0aGlzLmdlbmVyYXRlVmVjdG9yVHJhY2soIHJhd1RyYWNrcy5tb2RlbE5hbWUsIHJhd1RyYWNrcy5TLmN1cnZlcywgaW5pdGlhbFNjYWxlLCAnc2NhbGUnICk7XG5cdFx0XHRcdGlmICggc2NhbGVUcmFjayAhPT0gdW5kZWZpbmVkICkgdHJhY2tzLnB1c2goIHNjYWxlVHJhY2sgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHJhd1RyYWNrcy5EZWZvcm1QZXJjZW50ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dmFyIG1vcnBoVHJhY2sgPSB0aGlzLmdlbmVyYXRlTW9ycGhUcmFjayggcmF3VHJhY2tzICk7XG5cdFx0XHRcdGlmICggbW9ycGhUcmFjayAhPT0gdW5kZWZpbmVkICkgdHJhY2tzLnB1c2goIG1vcnBoVHJhY2sgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJhY2tzO1xuXG5cdFx0fSxcblxuXHRcdGdlbmVyYXRlVmVjdG9yVHJhY2s6IGZ1bmN0aW9uICggbW9kZWxOYW1lLCBjdXJ2ZXMsIGluaXRpYWxWYWx1ZSwgdHlwZSApIHtcblxuXHRcdFx0dmFyIHRpbWVzID0gdGhpcy5nZXRUaW1lc0ZvckFsbEF4ZXMoIGN1cnZlcyApO1xuXHRcdFx0dmFyIHZhbHVlcyA9IHRoaXMuZ2V0S2V5ZnJhbWVUcmFja1ZhbHVlcyggdGltZXMsIGN1cnZlcywgaW5pdGlhbFZhbHVlICk7XG5cblx0XHRcdHJldHVybiBuZXcgVmVjdG9yS2V5ZnJhbWVUcmFjayggbW9kZWxOYW1lICsgJy4nICsgdHlwZSwgdGltZXMsIHZhbHVlcyApO1xuXG5cdFx0fSxcblxuXHRcdGdlbmVyYXRlUm90YXRpb25UcmFjazogZnVuY3Rpb24gKCBtb2RlbE5hbWUsIGN1cnZlcywgaW5pdGlhbFZhbHVlLCBwcmVSb3RhdGlvbiwgcG9zdFJvdGF0aW9uLCBldWxlck9yZGVyICkge1xuXG5cdFx0XHRpZiAoIGN1cnZlcy54ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGhpcy5pbnRlcnBvbGF0ZVJvdGF0aW9ucyggY3VydmVzLnggKTtcblx0XHRcdFx0Y3VydmVzLngudmFsdWVzID0gY3VydmVzLngudmFsdWVzLm1hcCggTWF0aFV0aWxzLmRlZ1RvUmFkICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBjdXJ2ZXMueSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRoaXMuaW50ZXJwb2xhdGVSb3RhdGlvbnMoIGN1cnZlcy55ICk7XG5cdFx0XHRcdGN1cnZlcy55LnZhbHVlcyA9IGN1cnZlcy55LnZhbHVlcy5tYXAoIE1hdGhVdGlscy5kZWdUb1JhZCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggY3VydmVzLnogIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0aGlzLmludGVycG9sYXRlUm90YXRpb25zKCBjdXJ2ZXMueiApO1xuXHRcdFx0XHRjdXJ2ZXMuei52YWx1ZXMgPSBjdXJ2ZXMuei52YWx1ZXMubWFwKCBNYXRoVXRpbHMuZGVnVG9SYWQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdGltZXMgPSB0aGlzLmdldFRpbWVzRm9yQWxsQXhlcyggY3VydmVzICk7XG5cdFx0XHR2YXIgdmFsdWVzID0gdGhpcy5nZXRLZXlmcmFtZVRyYWNrVmFsdWVzKCB0aW1lcywgY3VydmVzLCBpbml0aWFsVmFsdWUgKTtcblxuXHRcdFx0aWYgKCBwcmVSb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHByZVJvdGF0aW9uID0gcHJlUm90YXRpb24ubWFwKCBNYXRoVXRpbHMuZGVnVG9SYWQgKTtcblx0XHRcdFx0cHJlUm90YXRpb24ucHVzaCggZXVsZXJPcmRlciApO1xuXG5cdFx0XHRcdHByZVJvdGF0aW9uID0gbmV3IEV1bGVyKCkuZnJvbUFycmF5KCBwcmVSb3RhdGlvbiApO1xuXHRcdFx0XHRwcmVSb3RhdGlvbiA9IG5ldyBRdWF0ZXJuaW9uKCkuc2V0RnJvbUV1bGVyKCBwcmVSb3RhdGlvbiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcG9zdFJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cG9zdFJvdGF0aW9uID0gcG9zdFJvdGF0aW9uLm1hcCggTWF0aFV0aWxzLmRlZ1RvUmFkICk7XG5cdFx0XHRcdHBvc3RSb3RhdGlvbi5wdXNoKCBldWxlck9yZGVyICk7XG5cblx0XHRcdFx0cG9zdFJvdGF0aW9uID0gbmV3IEV1bGVyKCkuZnJvbUFycmF5KCBwb3N0Um90YXRpb24gKTtcblx0XHRcdFx0cG9zdFJvdGF0aW9uID0gbmV3IFF1YXRlcm5pb24oKS5zZXRGcm9tRXVsZXIoIHBvc3RSb3RhdGlvbiApLmludmVydCgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblx0XHRcdHZhciBldWxlciA9IG5ldyBFdWxlcigpO1xuXG5cdFx0XHR2YXIgcXVhdGVybmlvblZhbHVlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0ZXVsZXIuc2V0KCB2YWx1ZXNbIGkgXSwgdmFsdWVzWyBpICsgMSBdLCB2YWx1ZXNbIGkgKyAyIF0sIGV1bGVyT3JkZXIgKTtcblxuXHRcdFx0XHRxdWF0ZXJuaW9uLnNldEZyb21FdWxlciggZXVsZXIgKTtcblxuXHRcdFx0XHRpZiAoIHByZVJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSBxdWF0ZXJuaW9uLnByZW11bHRpcGx5KCBwcmVSb3RhdGlvbiApO1xuXHRcdFx0XHRpZiAoIHBvc3RSb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkgcXVhdGVybmlvbi5tdWx0aXBseSggcG9zdFJvdGF0aW9uICk7XG5cblx0XHRcdFx0cXVhdGVybmlvbi50b0FycmF5KCBxdWF0ZXJuaW9uVmFsdWVzLCAoIGkgLyAzICkgKiA0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayggbW9kZWxOYW1lICsgJy5xdWF0ZXJuaW9uJywgdGltZXMsIHF1YXRlcm5pb25WYWx1ZXMgKTtcblxuXHRcdH0sXG5cblx0XHRnZW5lcmF0ZU1vcnBoVHJhY2s6IGZ1bmN0aW9uICggcmF3VHJhY2tzICkge1xuXG5cdFx0XHR2YXIgY3VydmVzID0gcmF3VHJhY2tzLkRlZm9ybVBlcmNlbnQuY3VydmVzLm1vcnBoO1xuXHRcdFx0dmFyIHZhbHVlcyA9IGN1cnZlcy52YWx1ZXMubWFwKCBmdW5jdGlvbiAoIHZhbCApIHtcblxuXHRcdFx0XHRyZXR1cm4gdmFsIC8gMTAwO1xuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHZhciBtb3JwaE51bSA9IHNjZW5lR3JhcGguZ2V0T2JqZWN0QnlOYW1lKCByYXdUcmFja3MubW9kZWxOYW1lICkubW9ycGhUYXJnZXREaWN0aW9uYXJ5WyByYXdUcmFja3MubW9ycGhOYW1lIF07XG5cblx0XHRcdHJldHVybiBuZXcgTnVtYmVyS2V5ZnJhbWVUcmFjayggcmF3VHJhY2tzLm1vZGVsTmFtZSArICcubW9ycGhUYXJnZXRJbmZsdWVuY2VzWycgKyBtb3JwaE51bSArICddJywgY3VydmVzLnRpbWVzLCB2YWx1ZXMgKTtcblxuXHRcdH0sXG5cblx0XHQvLyBGb3IgYWxsIGFuaW1hdGVkIG9iamVjdHMsIHRpbWVzIGFyZSBkZWZpbmVkIHNlcGFyYXRlbHkgZm9yIGVhY2ggYXhpc1xuXHRcdC8vIEhlcmUgd2UnbGwgY29tYmluZSB0aGUgdGltZXMgaW50byBvbmUgc29ydGVkIGFycmF5IHdpdGhvdXQgZHVwbGljYXRlc1xuXHRcdGdldFRpbWVzRm9yQWxsQXhlczogZnVuY3Rpb24gKCBjdXJ2ZXMgKSB7XG5cblx0XHRcdHZhciB0aW1lcyA9IFtdO1xuXG5cdFx0XHQvLyBmaXJzdCBqb2luIHRvZ2V0aGVyIHRoZSB0aW1lcyBmb3IgZWFjaCBheGlzLCBpZiBkZWZpbmVkXG5cdFx0XHRpZiAoIGN1cnZlcy54ICE9PSB1bmRlZmluZWQgKSB0aW1lcyA9IHRpbWVzLmNvbmNhdCggY3VydmVzLngudGltZXMgKTtcblx0XHRcdGlmICggY3VydmVzLnkgIT09IHVuZGVmaW5lZCApIHRpbWVzID0gdGltZXMuY29uY2F0KCBjdXJ2ZXMueS50aW1lcyApO1xuXHRcdFx0aWYgKCBjdXJ2ZXMueiAhPT0gdW5kZWZpbmVkICkgdGltZXMgPSB0aW1lcy5jb25jYXQoIGN1cnZlcy56LnRpbWVzICk7XG5cblx0XHRcdC8vIHRoZW4gc29ydCB0aGVtXG5cdFx0XHR0aW1lcyA9IHRpbWVzLnNvcnQoIGZ1bmN0aW9uICggYSwgYiApIHtcblxuXHRcdFx0XHRyZXR1cm4gYSAtIGI7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0Ly8gYW5kIHJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoIHRpbWVzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdFx0dmFyIHRhcmdldEluZGV4ID0gMTtcblx0XHRcdFx0dmFyIGxhc3RWYWx1ZSA9IHRpbWVzWyAwIF07XG5cdFx0XHRcdGZvciAoIHZhciBpID0gMTsgaSA8IHRpbWVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBjdXJyZW50VmFsdWUgPSB0aW1lc1sgaSBdO1xuXHRcdFx0XHRcdGlmICggY3VycmVudFZhbHVlICE9PSBsYXN0VmFsdWUgKSB7XG5cblx0XHRcdFx0XHRcdHRpbWVzWyB0YXJnZXRJbmRleCBdID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHRcdFx0bGFzdFZhbHVlID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHRcdFx0dGFyZ2V0SW5kZXggKys7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRpbWVzID0gdGltZXMuc2xpY2UoIDAsIHRhcmdldEluZGV4ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRpbWVzO1xuXG5cdFx0fSxcblxuXHRcdGdldEtleWZyYW1lVHJhY2tWYWx1ZXM6IGZ1bmN0aW9uICggdGltZXMsIGN1cnZlcywgaW5pdGlhbFZhbHVlICkge1xuXG5cdFx0XHR2YXIgcHJldlZhbHVlID0gaW5pdGlhbFZhbHVlO1xuXG5cdFx0XHR2YXIgdmFsdWVzID0gW107XG5cblx0XHRcdHZhciB4SW5kZXggPSAtIDE7XG5cdFx0XHR2YXIgeUluZGV4ID0gLSAxO1xuXHRcdFx0dmFyIHpJbmRleCA9IC0gMTtcblxuXHRcdFx0dGltZXMuZm9yRWFjaCggZnVuY3Rpb24gKCB0aW1lICkge1xuXG5cdFx0XHRcdGlmICggY3VydmVzLnggKSB4SW5kZXggPSBjdXJ2ZXMueC50aW1lcy5pbmRleE9mKCB0aW1lICk7XG5cdFx0XHRcdGlmICggY3VydmVzLnkgKSB5SW5kZXggPSBjdXJ2ZXMueS50aW1lcy5pbmRleE9mKCB0aW1lICk7XG5cdFx0XHRcdGlmICggY3VydmVzLnogKSB6SW5kZXggPSBjdXJ2ZXMuei50aW1lcy5pbmRleE9mKCB0aW1lICk7XG5cblx0XHRcdFx0Ly8gaWYgdGhlcmUgaXMgYW4geCB2YWx1ZSBkZWZpbmVkIGZvciB0aGlzIGZyYW1lLCB1c2UgdGhhdFxuXHRcdFx0XHRpZiAoIHhJbmRleCAhPT0gLSAxICkge1xuXG5cdFx0XHRcdFx0dmFyIHhWYWx1ZSA9IGN1cnZlcy54LnZhbHVlc1sgeEluZGV4IF07XG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goIHhWYWx1ZSApO1xuXHRcdFx0XHRcdHByZXZWYWx1ZVsgMCBdID0geFZhbHVlO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBvdGhlcndpc2UgdXNlIHRoZSB4IHZhbHVlIGZyb20gdGhlIHByZXZpb3VzIGZyYW1lXG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goIHByZXZWYWx1ZVsgMCBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggeUluZGV4ICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0XHR2YXIgeVZhbHVlID0gY3VydmVzLnkudmFsdWVzWyB5SW5kZXggXTtcblx0XHRcdFx0XHR2YWx1ZXMucHVzaCggeVZhbHVlICk7XG5cdFx0XHRcdFx0cHJldlZhbHVlWyAxIF0gPSB5VmFsdWU7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKCBwcmV2VmFsdWVbIDEgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHpJbmRleCAhPT0gLSAxICkge1xuXG5cdFx0XHRcdFx0dmFyIHpWYWx1ZSA9IGN1cnZlcy56LnZhbHVlc1sgekluZGV4IF07XG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goIHpWYWx1ZSApO1xuXHRcdFx0XHRcdHByZXZWYWx1ZVsgMiBdID0gelZhbHVlO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR2YWx1ZXMucHVzaCggcHJldlZhbHVlWyAyIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0cmV0dXJuIHZhbHVlcztcblxuXHRcdH0sXG5cblx0XHQvLyBSb3RhdGlvbnMgYXJlIGRlZmluZWQgYXMgRXVsZXIgYW5nbGVzIHdoaWNoIGNhbiBoYXZlIHZhbHVlcyAgb2YgYW55IHNpemVcblx0XHQvLyBUaGVzZSB3aWxsIGJlIGNvbnZlcnRlZCB0byBxdWF0ZXJuaW9ucyB3aGljaCBkb24ndCBzdXBwb3J0IHZhbHVlcyBncmVhdGVyIHRoYW5cblx0XHQvLyBQSSwgc28gd2UnbGwgaW50ZXJwb2xhdGUgbGFyZ2Ugcm90YXRpb25zXG5cdFx0aW50ZXJwb2xhdGVSb3RhdGlvbnM6IGZ1bmN0aW9uICggY3VydmUgKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMTsgaSA8IGN1cnZlLnZhbHVlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGluaXRpYWxWYWx1ZSA9IGN1cnZlLnZhbHVlc1sgaSAtIDEgXTtcblx0XHRcdFx0dmFyIHZhbHVlc1NwYW4gPSBjdXJ2ZS52YWx1ZXNbIGkgXSAtIGluaXRpYWxWYWx1ZTtcblxuXHRcdFx0XHR2YXIgYWJzb2x1dGVTcGFuID0gTWF0aC5hYnMoIHZhbHVlc1NwYW4gKTtcblxuXHRcdFx0XHRpZiAoIGFic29sdXRlU3BhbiA+PSAxODAgKSB7XG5cblx0XHRcdFx0XHR2YXIgbnVtU3ViSW50ZXJ2YWxzID0gYWJzb2x1dGVTcGFuIC8gMTgwO1xuXG5cdFx0XHRcdFx0dmFyIHN0ZXAgPSB2YWx1ZXNTcGFuIC8gbnVtU3ViSW50ZXJ2YWxzO1xuXHRcdFx0XHRcdHZhciBuZXh0VmFsdWUgPSBpbml0aWFsVmFsdWUgKyBzdGVwO1xuXG5cdFx0XHRcdFx0dmFyIGluaXRpYWxUaW1lID0gY3VydmUudGltZXNbIGkgLSAxIF07XG5cdFx0XHRcdFx0dmFyIHRpbWVTcGFuID0gY3VydmUudGltZXNbIGkgXSAtIGluaXRpYWxUaW1lO1xuXHRcdFx0XHRcdHZhciBpbnRlcnZhbCA9IHRpbWVTcGFuIC8gbnVtU3ViSW50ZXJ2YWxzO1xuXHRcdFx0XHRcdHZhciBuZXh0VGltZSA9IGluaXRpYWxUaW1lICsgaW50ZXJ2YWw7XG5cblx0XHRcdFx0XHR2YXIgaW50ZXJwb2xhdGVkVGltZXMgPSBbXTtcblx0XHRcdFx0XHR2YXIgaW50ZXJwb2xhdGVkVmFsdWVzID0gW107XG5cblx0XHRcdFx0XHR3aGlsZSAoIG5leHRUaW1lIDwgY3VydmUudGltZXNbIGkgXSApIHtcblxuXHRcdFx0XHRcdFx0aW50ZXJwb2xhdGVkVGltZXMucHVzaCggbmV4dFRpbWUgKTtcblx0XHRcdFx0XHRcdG5leHRUaW1lICs9IGludGVydmFsO1xuXG5cdFx0XHRcdFx0XHRpbnRlcnBvbGF0ZWRWYWx1ZXMucHVzaCggbmV4dFZhbHVlICk7XG5cdFx0XHRcdFx0XHRuZXh0VmFsdWUgKz0gc3RlcDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGN1cnZlLnRpbWVzID0gaW5qZWN0KCBjdXJ2ZS50aW1lcywgaSwgaW50ZXJwb2xhdGVkVGltZXMgKTtcblx0XHRcdFx0XHRjdXJ2ZS52YWx1ZXMgPSBpbmplY3QoIGN1cnZlLnZhbHVlcywgaSwgaW50ZXJwb2xhdGVkVmFsdWVzICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdH07XG5cblx0Ly8gcGFyc2UgYW4gRkJYIGZpbGUgaW4gQVNDSUkgZm9ybWF0XG5cdGZ1bmN0aW9uIFRleHRQYXJzZXIoKSB7fVxuXG5cdFRleHRQYXJzZXIucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IFRleHRQYXJzZXIsXG5cblx0XHRnZXRQcmV2Tm9kZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5ub2RlU3RhY2tbIHRoaXMuY3VycmVudEluZGVudCAtIDIgXTtcblxuXHRcdH0sXG5cblx0XHRnZXRDdXJyZW50Tm9kZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5ub2RlU3RhY2tbIHRoaXMuY3VycmVudEluZGVudCAtIDEgXTtcblxuXHRcdH0sXG5cblx0XHRnZXRDdXJyZW50UHJvcDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5jdXJyZW50UHJvcDtcblxuXHRcdH0sXG5cblx0XHRwdXNoU3RhY2s6IGZ1bmN0aW9uICggbm9kZSApIHtcblxuXHRcdFx0dGhpcy5ub2RlU3RhY2sucHVzaCggbm9kZSApO1xuXHRcdFx0dGhpcy5jdXJyZW50SW5kZW50ICs9IDE7XG5cblx0XHR9LFxuXG5cdFx0cG9wU3RhY2s6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5ub2RlU3RhY2sucG9wKCk7XG5cdFx0XHR0aGlzLmN1cnJlbnRJbmRlbnQgLT0gMTtcblxuXHRcdH0sXG5cblx0XHRzZXRDdXJyZW50UHJvcDogZnVuY3Rpb24gKCB2YWwsIG5hbWUgKSB7XG5cblx0XHRcdHRoaXMuY3VycmVudFByb3AgPSB2YWw7XG5cdFx0XHR0aGlzLmN1cnJlbnRQcm9wTmFtZSA9IG5hbWU7XG5cblx0XHR9LFxuXG5cdFx0cGFyc2U6IGZ1bmN0aW9uICggdGV4dCApIHtcblxuXHRcdFx0dGhpcy5jdXJyZW50SW5kZW50ID0gMDtcblxuXHRcdFx0dGhpcy5hbGxOb2RlcyA9IG5ldyBGQlhUcmVlKCk7XG5cdFx0XHR0aGlzLm5vZGVTdGFjayA9IFtdO1xuXHRcdFx0dGhpcy5jdXJyZW50UHJvcCA9IFtdO1xuXHRcdFx0dGhpcy5jdXJyZW50UHJvcE5hbWUgPSAnJztcblxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdFx0dmFyIHNwbGl0ID0gdGV4dC5zcGxpdCggL1tcXHJcXG5dKy8gKTtcblxuXHRcdFx0c3BsaXQuZm9yRWFjaCggZnVuY3Rpb24gKCBsaW5lLCBpICkge1xuXG5cdFx0XHRcdHZhciBtYXRjaENvbW1lbnQgPSBsaW5lLm1hdGNoKCAvXltcXHNcXHRdKjsvICk7XG5cdFx0XHRcdHZhciBtYXRjaEVtcHR5ID0gbGluZS5tYXRjaCggL15bXFxzXFx0XSokLyApO1xuXG5cdFx0XHRcdGlmICggbWF0Y2hDb21tZW50IHx8IG1hdGNoRW1wdHkgKSByZXR1cm47XG5cblx0XHRcdFx0dmFyIG1hdGNoQmVnaW5uaW5nID0gbGluZS5tYXRjaCggJ15cXFxcdHsnICsgc2NvcGUuY3VycmVudEluZGVudCArICd9KFxcXFx3Kyk6KC4qKXsnLCAnJyApO1xuXHRcdFx0XHR2YXIgbWF0Y2hQcm9wZXJ0eSA9IGxpbmUubWF0Y2goICdeXFxcXHR7JyArICggc2NvcGUuY3VycmVudEluZGVudCApICsgJ30oXFxcXHcrKTpbXFxcXHNcXFxcdFxcXFxyXFxcXG5dKC4qKScgKTtcblx0XHRcdFx0dmFyIG1hdGNoRW5kID0gbGluZS5tYXRjaCggJ15cXFxcdHsnICsgKCBzY29wZS5jdXJyZW50SW5kZW50IC0gMSApICsgJ319JyApO1xuXG5cdFx0XHRcdGlmICggbWF0Y2hCZWdpbm5pbmcgKSB7XG5cblx0XHRcdFx0XHRzY29wZS5wYXJzZU5vZGVCZWdpbiggbGluZSwgbWF0Y2hCZWdpbm5pbmcgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFByb3BlcnR5ICkge1xuXG5cdFx0XHRcdFx0c2NvcGUucGFyc2VOb2RlUHJvcGVydHkoIGxpbmUsIG1hdGNoUHJvcGVydHksIHNwbGl0WyArKyBpIF0gKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaEVuZCApIHtcblxuXHRcdFx0XHRcdHNjb3BlLnBvcFN0YWNrKCk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbGluZS5tYXRjaCggL15bXlxcc1xcdH1dLyApICkge1xuXG5cdFx0XHRcdFx0Ly8gbGFyZ2UgYXJyYXlzIGFyZSBzcGxpdCBvdmVyIG11bHRpcGxlIGxpbmVzIHRlcm1pbmF0ZWQgd2l0aCBhICcsJyBjaGFyYWN0ZXJcblx0XHRcdFx0XHQvLyBpZiB0aGlzIGlzIGVuY291bnRlcmVkIHRoZSBsaW5lIG5lZWRzIHRvIGJlIGpvaW5lZCB0byB0aGUgcHJldmlvdXMgbGluZVxuXHRcdFx0XHRcdHNjb3BlLnBhcnNlTm9kZVByb3BlcnR5Q29udGludWVkKCBsaW5lICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHJldHVybiB0aGlzLmFsbE5vZGVzO1xuXG5cdFx0fSxcblxuXHRcdHBhcnNlTm9kZUJlZ2luOiBmdW5jdGlvbiAoIGxpbmUsIHByb3BlcnR5ICkge1xuXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBwcm9wZXJ0eVsgMSBdLnRyaW0oKS5yZXBsYWNlKCAvXlwiLywgJycgKS5yZXBsYWNlKCAvXCIkLywgJycgKTtcblxuXHRcdFx0dmFyIG5vZGVBdHRycyA9IHByb3BlcnR5WyAyIF0uc3BsaXQoICcsJyApLm1hcCggZnVuY3Rpb24gKCBhdHRyICkge1xuXG5cdFx0XHRcdHJldHVybiBhdHRyLnRyaW0oKS5yZXBsYWNlKCAvXlwiLywgJycgKS5yZXBsYWNlKCAvXCIkLywgJycgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0XHR2YXIgbm9kZSA9IHsgbmFtZTogbm9kZU5hbWUgfTtcblx0XHRcdHZhciBhdHRycyA9IHRoaXMucGFyc2VOb2RlQXR0ciggbm9kZUF0dHJzICk7XG5cblx0XHRcdHZhciBjdXJyZW50Tm9kZSA9IHRoaXMuZ2V0Q3VycmVudE5vZGUoKTtcblxuXHRcdFx0Ly8gYSB0b3Agbm9kZVxuXHRcdFx0aWYgKCB0aGlzLmN1cnJlbnRJbmRlbnQgPT09IDAgKSB7XG5cblx0XHRcdFx0dGhpcy5hbGxOb2Rlcy5hZGQoIG5vZGVOYW1lLCBub2RlICk7XG5cblx0XHRcdH0gZWxzZSB7IC8vIGEgc3Vibm9kZVxuXG5cdFx0XHRcdC8vIGlmIHRoZSBzdWJub2RlIGFscmVhZHkgZXhpc3RzLCBhcHBlbmQgaXRcblx0XHRcdFx0aWYgKCBub2RlTmFtZSBpbiBjdXJyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdC8vIHNwZWNpYWwgY2FzZSBQb3NlIG5lZWRzIFBvc2VOb2RlcyBhcyBhbiBhcnJheVxuXHRcdFx0XHRcdGlmICggbm9kZU5hbWUgPT09ICdQb3NlTm9kZScgKSB7XG5cblx0XHRcdFx0XHRcdGN1cnJlbnROb2RlLlBvc2VOb2RlLnB1c2goIG5vZGUgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1cnJlbnROb2RlWyBub2RlTmFtZSBdLmlkICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdGN1cnJlbnROb2RlWyBub2RlTmFtZSBdID0ge307XG5cdFx0XHRcdFx0XHRjdXJyZW50Tm9kZVsgbm9kZU5hbWUgXVsgY3VycmVudE5vZGVbIG5vZGVOYW1lIF0uaWQgXSA9IGN1cnJlbnROb2RlWyBub2RlTmFtZSBdO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBhdHRycy5pZCAhPT0gJycgKSBjdXJyZW50Tm9kZVsgbm9kZU5hbWUgXVsgYXR0cnMuaWQgXSA9IG5vZGU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIGF0dHJzLmlkID09PSAnbnVtYmVyJyApIHtcblxuXHRcdFx0XHRcdGN1cnJlbnROb2RlWyBub2RlTmFtZSBdID0ge307XG5cdFx0XHRcdFx0Y3VycmVudE5vZGVbIG5vZGVOYW1lIF1bIGF0dHJzLmlkIF0gPSBub2RlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG5vZGVOYW1lICE9PSAnUHJvcGVydGllczcwJyApIHtcblxuXHRcdFx0XHRcdGlmICggbm9kZU5hbWUgPT09ICdQb3NlTm9kZScgKVx0Y3VycmVudE5vZGVbIG5vZGVOYW1lIF0gPSBbIG5vZGUgXTtcblx0XHRcdFx0XHRlbHNlIGN1cnJlbnROb2RlWyBub2RlTmFtZSBdID0gbm9kZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0eXBlb2YgYXR0cnMuaWQgPT09ICdudW1iZXInICkgbm9kZS5pZCA9IGF0dHJzLmlkO1xuXHRcdFx0aWYgKCBhdHRycy5uYW1lICE9PSAnJyApIG5vZGUuYXR0ck5hbWUgPSBhdHRycy5uYW1lO1xuXHRcdFx0aWYgKCBhdHRycy50eXBlICE9PSAnJyApIG5vZGUuYXR0clR5cGUgPSBhdHRycy50eXBlO1xuXG5cdFx0XHR0aGlzLnB1c2hTdGFjayggbm9kZSApO1xuXG5cdFx0fSxcblxuXHRcdHBhcnNlTm9kZUF0dHI6IGZ1bmN0aW9uICggYXR0cnMgKSB7XG5cblx0XHRcdHZhciBpZCA9IGF0dHJzWyAwIF07XG5cblx0XHRcdGlmICggYXR0cnNbIDAgXSAhPT0gJycgKSB7XG5cblx0XHRcdFx0aWQgPSBwYXJzZUludCggYXR0cnNbIDAgXSApO1xuXG5cdFx0XHRcdGlmICggaXNOYU4oIGlkICkgKSB7XG5cblx0XHRcdFx0XHRpZCA9IGF0dHJzWyAwIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBuYW1lID0gJycsIHR5cGUgPSAnJztcblxuXHRcdFx0aWYgKCBhdHRycy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRcdG5hbWUgPSBhdHRyc1sgMSBdLnJlcGxhY2UoIC9eKFxcdyspOjovLCAnJyApO1xuXHRcdFx0XHR0eXBlID0gYXR0cnNbIDIgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4geyBpZDogaWQsIG5hbWU6IG5hbWUsIHR5cGU6IHR5cGUgfTtcblxuXHRcdH0sXG5cblx0XHRwYXJzZU5vZGVQcm9wZXJ0eTogZnVuY3Rpb24gKCBsaW5lLCBwcm9wZXJ0eSwgY29udGVudExpbmUgKSB7XG5cblx0XHRcdHZhciBwcm9wTmFtZSA9IHByb3BlcnR5WyAxIF0ucmVwbGFjZSggL15cIi8sICcnICkucmVwbGFjZSggL1wiJC8sICcnICkudHJpbSgpO1xuXHRcdFx0dmFyIHByb3BWYWx1ZSA9IHByb3BlcnR5WyAyIF0ucmVwbGFjZSggL15cIi8sICcnICkucmVwbGFjZSggL1wiJC8sICcnICkudHJpbSgpO1xuXG5cdFx0XHQvLyBmb3Igc3BlY2lhbCBjYXNlOiBiYXNlNjQgaW1hZ2UgZGF0YSBmb2xsb3dzIFwiQ29udGVudDogLFwiIGxpbmVcblx0XHRcdC8vXHRDb250ZW50OiAsXG5cdFx0XHQvL1x0IFwiLzlqLzRSRGFSWGhwWmdBQVRVMEEuLi5cIlxuXHRcdFx0aWYgKCBwcm9wTmFtZSA9PT0gJ0NvbnRlbnQnICYmIHByb3BWYWx1ZSA9PT0gJywnICkge1xuXG5cdFx0XHRcdHByb3BWYWx1ZSA9IGNvbnRlbnRMaW5lLnJlcGxhY2UoIC9cIi9nLCAnJyApLnJlcGxhY2UoIC8sJC8sICcnICkudHJpbSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBjdXJyZW50Tm9kZSA9IHRoaXMuZ2V0Q3VycmVudE5vZGUoKTtcblx0XHRcdHZhciBwYXJlbnROYW1lID0gY3VycmVudE5vZGUubmFtZTtcblxuXHRcdFx0aWYgKCBwYXJlbnROYW1lID09PSAnUHJvcGVydGllczcwJyApIHtcblxuXHRcdFx0XHR0aGlzLnBhcnNlTm9kZVNwZWNpYWxQcm9wZXJ0eSggbGluZSwgcHJvcE5hbWUsIHByb3BWYWx1ZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29ubmVjdGlvbnNcblx0XHRcdGlmICggcHJvcE5hbWUgPT09ICdDJyApIHtcblxuXHRcdFx0XHR2YXIgY29ublByb3BzID0gcHJvcFZhbHVlLnNwbGl0KCAnLCcgKS5zbGljZSggMSApO1xuXHRcdFx0XHR2YXIgZnJvbSA9IHBhcnNlSW50KCBjb25uUHJvcHNbIDAgXSApO1xuXHRcdFx0XHR2YXIgdG8gPSBwYXJzZUludCggY29ublByb3BzWyAxIF0gKTtcblxuXHRcdFx0XHR2YXIgcmVzdCA9IHByb3BWYWx1ZS5zcGxpdCggJywnICkuc2xpY2UoIDMgKTtcblxuXHRcdFx0XHRyZXN0ID0gcmVzdC5tYXAoIGZ1bmN0aW9uICggZWxlbSApIHtcblxuXHRcdFx0XHRcdHJldHVybiBlbGVtLnRyaW0oKS5yZXBsYWNlKCAvXlwiLywgJycgKTtcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0cHJvcE5hbWUgPSAnY29ubmVjdGlvbnMnO1xuXHRcdFx0XHRwcm9wVmFsdWUgPSBbIGZyb20sIHRvIF07XG5cdFx0XHRcdGFwcGVuZCggcHJvcFZhbHVlLCByZXN0ICk7XG5cblx0XHRcdFx0aWYgKCBjdXJyZW50Tm9kZVsgcHJvcE5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y3VycmVudE5vZGVbIHByb3BOYW1lIF0gPSBbXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gTm9kZVxuXHRcdFx0aWYgKCBwcm9wTmFtZSA9PT0gJ05vZGUnICkgY3VycmVudE5vZGUuaWQgPSBwcm9wVmFsdWU7XG5cblx0XHRcdC8vIGNvbm5lY3Rpb25zXG5cdFx0XHRpZiAoIHByb3BOYW1lIGluIGN1cnJlbnROb2RlICYmIEFycmF5LmlzQXJyYXkoIGN1cnJlbnROb2RlWyBwcm9wTmFtZSBdICkgKSB7XG5cblx0XHRcdFx0Y3VycmVudE5vZGVbIHByb3BOYW1lIF0ucHVzaCggcHJvcFZhbHVlICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKCBwcm9wTmFtZSAhPT0gJ2EnICkgY3VycmVudE5vZGVbIHByb3BOYW1lIF0gPSBwcm9wVmFsdWU7XG5cdFx0XHRcdGVsc2UgY3VycmVudE5vZGUuYSA9IHByb3BWYWx1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNldEN1cnJlbnRQcm9wKCBjdXJyZW50Tm9kZSwgcHJvcE5hbWUgKTtcblxuXHRcdFx0Ly8gY29udmVydCBzdHJpbmcgdG8gYXJyYXksIHVubGVzcyBpdCBlbmRzIGluICcsJyBpbiB3aGljaCBjYXNlIG1vcmUgd2lsbCBiZSBhZGRlZCB0byBpdFxuXHRcdFx0aWYgKCBwcm9wTmFtZSA9PT0gJ2EnICYmIHByb3BWYWx1ZS5zbGljZSggLSAxICkgIT09ICcsJyApIHtcblxuXHRcdFx0XHRjdXJyZW50Tm9kZS5hID0gcGFyc2VOdW1iZXJBcnJheSggcHJvcFZhbHVlICk7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRwYXJzZU5vZGVQcm9wZXJ0eUNvbnRpbnVlZDogZnVuY3Rpb24gKCBsaW5lICkge1xuXG5cdFx0XHR2YXIgY3VycmVudE5vZGUgPSB0aGlzLmdldEN1cnJlbnROb2RlKCk7XG5cblx0XHRcdGN1cnJlbnROb2RlLmEgKz0gbGluZTtcblxuXHRcdFx0Ly8gaWYgdGhlIGxpbmUgZG9lc24ndCBlbmQgaW4gJywnIHdlIGhhdmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBwcm9wZXJ0eSB2YWx1ZVxuXHRcdFx0Ly8gc28gY29udmVydCB0aGUgc3RyaW5nIHRvIGFuIGFycmF5XG5cdFx0XHRpZiAoIGxpbmUuc2xpY2UoIC0gMSApICE9PSAnLCcgKSB7XG5cblx0XHRcdFx0Y3VycmVudE5vZGUuYSA9IHBhcnNlTnVtYmVyQXJyYXkoIGN1cnJlbnROb2RlLmEgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdC8vIHBhcnNlIFwiUHJvcGVydHk3MFwiXG5cdFx0cGFyc2VOb2RlU3BlY2lhbFByb3BlcnR5OiBmdW5jdGlvbiAoIGxpbmUsIHByb3BOYW1lLCBwcm9wVmFsdWUgKSB7XG5cblx0XHRcdC8vIHNwbGl0IHRoaXNcblx0XHRcdC8vIFA6IFwiTGNsIFNjYWxpbmdcIiwgXCJMY2wgU2NhbGluZ1wiLCBcIlwiLCBcIkFcIiwxLDEsMVxuXHRcdFx0Ly8gaW50byBhcnJheSBsaWtlIGJlbG93XG5cdFx0XHQvLyBbXCJMY2wgU2NhbGluZ1wiLCBcIkxjbCBTY2FsaW5nXCIsIFwiXCIsIFwiQVwiLCBcIjEsMSwxXCIgXVxuXHRcdFx0dmFyIHByb3BzID0gcHJvcFZhbHVlLnNwbGl0KCAnXCIsJyApLm1hcCggZnVuY3Rpb24gKCBwcm9wICkge1xuXG5cdFx0XHRcdHJldHVybiBwcm9wLnRyaW0oKS5yZXBsYWNlKCAvXlxcXCIvLCAnJyApLnJlcGxhY2UoIC9cXHMvLCAnXycgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0XHR2YXIgaW5uZXJQcm9wTmFtZSA9IHByb3BzWyAwIF07XG5cdFx0XHR2YXIgaW5uZXJQcm9wVHlwZTEgPSBwcm9wc1sgMSBdO1xuXHRcdFx0dmFyIGlubmVyUHJvcFR5cGUyID0gcHJvcHNbIDIgXTtcblx0XHRcdHZhciBpbm5lclByb3BGbGFnID0gcHJvcHNbIDMgXTtcblx0XHRcdHZhciBpbm5lclByb3BWYWx1ZSA9IHByb3BzWyA0IF07XG5cblx0XHRcdC8vIGNhc3QgdmFsdWVzIHdoZXJlIG5lZWRlZCwgb3RoZXJ3aXNlIGxlYXZlIGFzIHN0cmluZ3Ncblx0XHRcdHN3aXRjaCAoIGlubmVyUHJvcFR5cGUxICkge1xuXG5cdFx0XHRcdGNhc2UgJ2ludCc6XG5cdFx0XHRcdGNhc2UgJ2VudW0nOlxuXHRcdFx0XHRjYXNlICdib29sJzpcblx0XHRcdFx0Y2FzZSAnVUxvbmdMb25nJzpcblx0XHRcdFx0Y2FzZSAnZG91YmxlJzpcblx0XHRcdFx0Y2FzZSAnTnVtYmVyJzpcblx0XHRcdFx0Y2FzZSAnRmllbGRPZlZpZXcnOlxuXHRcdFx0XHRcdGlubmVyUHJvcFZhbHVlID0gcGFyc2VGbG9hdCggaW5uZXJQcm9wVmFsdWUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdDb2xvcic6XG5cdFx0XHRcdGNhc2UgJ0NvbG9yUkdCJzpcblx0XHRcdFx0Y2FzZSAnVmVjdG9yM0QnOlxuXHRcdFx0XHRjYXNlICdMY2xfVHJhbnNsYXRpb24nOlxuXHRcdFx0XHRjYXNlICdMY2xfUm90YXRpb24nOlxuXHRcdFx0XHRjYXNlICdMY2xfU2NhbGluZyc6XG5cdFx0XHRcdFx0aW5uZXJQcm9wVmFsdWUgPSBwYXJzZU51bWJlckFycmF5KCBpbm5lclByb3BWYWx1ZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIENBVVRJT046IHRoZXNlIHByb3BzIG11c3QgYXBwZW5kIHRvIHBhcmVudCdzIHBhcmVudFxuXHRcdFx0dGhpcy5nZXRQcmV2Tm9kZSgpWyBpbm5lclByb3BOYW1lIF0gPSB7XG5cblx0XHRcdFx0J3R5cGUnOiBpbm5lclByb3BUeXBlMSxcblx0XHRcdFx0J3R5cGUyJzogaW5uZXJQcm9wVHlwZTIsXG5cdFx0XHRcdCdmbGFnJzogaW5uZXJQcm9wRmxhZyxcblx0XHRcdFx0J3ZhbHVlJzogaW5uZXJQcm9wVmFsdWVcblxuXHRcdFx0fTtcblxuXHRcdFx0dGhpcy5zZXRDdXJyZW50UHJvcCggdGhpcy5nZXRQcmV2Tm9kZSgpLCBpbm5lclByb3BOYW1lICk7XG5cblx0XHR9LFxuXG5cdH07XG5cblx0Ly8gUGFyc2UgYW4gRkJYIGZpbGUgaW4gQmluYXJ5IGZvcm1hdFxuXHRmdW5jdGlvbiBCaW5hcnlQYXJzZXIoKSB7fVxuXG5cdEJpbmFyeVBhcnNlci5wcm90b3R5cGUgPSB7XG5cblx0XHRjb25zdHJ1Y3RvcjogQmluYXJ5UGFyc2VyLFxuXG5cdFx0cGFyc2U6IGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG5cdFx0XHR2YXIgcmVhZGVyID0gbmV3IEJpbmFyeVJlYWRlciggYnVmZmVyICk7XG5cdFx0XHRyZWFkZXIuc2tpcCggMjMgKTsgLy8gc2tpcCBtYWdpYyAyMyBieXRlc1xuXG5cdFx0XHR2YXIgdmVyc2lvbiA9IHJlYWRlci5nZXRVaW50MzIoKTtcblxuXHRcdFx0aWYgKCB2ZXJzaW9uIDwgNjQwMCApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5GQlhMb2FkZXI6IEZCWCB2ZXJzaW9uIG5vdCBzdXBwb3J0ZWQsIEZpbGVWZXJzaW9uOiAnICsgdmVyc2lvbiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBhbGxOb2RlcyA9IG5ldyBGQlhUcmVlKCk7XG5cblx0XHRcdHdoaWxlICggISB0aGlzLmVuZE9mQ29udGVudCggcmVhZGVyICkgKSB7XG5cblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLnBhcnNlTm9kZSggcmVhZGVyLCB2ZXJzaW9uICk7XG5cdFx0XHRcdGlmICggbm9kZSAhPT0gbnVsbCApIGFsbE5vZGVzLmFkZCggbm9kZS5uYW1lLCBub2RlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGFsbE5vZGVzO1xuXG5cdFx0fSxcblxuXHRcdC8vIENoZWNrIGlmIHJlYWRlciBoYXMgcmVhY2hlZCB0aGUgZW5kIG9mIGNvbnRlbnQuXG5cdFx0ZW5kT2ZDb250ZW50OiBmdW5jdGlvbiAoIHJlYWRlciApIHtcblxuXHRcdFx0Ly8gZm9vdGVyIHNpemU6IDE2MGJ5dGVzICsgMTYtYnl0ZSBhbGlnbm1lbnQgcGFkZGluZ1xuXHRcdFx0Ly8gLSAxNmJ5dGVzOiBtYWdpY1xuXHRcdFx0Ly8gLSBwYWRkaW5nIHRpbCAxNi1ieXRlIGFsaWdubWVudCAoYXQgbGVhc3QgMWJ5dGU/KVxuXHRcdFx0Ly9cdChzZWVtcyBsaWtlIHNvbWUgZXhwb3J0ZXJzIGVtYmVkIGZpeGVkIDE1IG9yIDE2Ynl0ZXM/KVxuXHRcdFx0Ly8gLSA0Ynl0ZXM6IG1hZ2ljXG5cdFx0XHQvLyAtIDRieXRlczogdmVyc2lvblxuXHRcdFx0Ly8gLSAxMjBieXRlczogemVyb1xuXHRcdFx0Ly8gLSAxNmJ5dGVzOiBtYWdpY1xuXHRcdFx0aWYgKCByZWFkZXIuc2l6ZSgpICUgMTYgPT09IDAgKSB7XG5cblx0XHRcdFx0cmV0dXJuICggKCByZWFkZXIuZ2V0T2Zmc2V0KCkgKyAxNjAgKyAxNiApICYgfiAweGYgKSA+PSByZWFkZXIuc2l6ZSgpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiByZWFkZXIuZ2V0T2Zmc2V0KCkgKyAxNjAgKyAxNiA+PSByZWFkZXIuc2l6ZSgpO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0Ly8gcmVjdXJzaXZlbHkgcGFyc2Ugbm9kZXMgdW50aWwgdGhlIGVuZCBvZiB0aGUgZmlsZSBpcyByZWFjaGVkXG5cdFx0cGFyc2VOb2RlOiBmdW5jdGlvbiAoIHJlYWRlciwgdmVyc2lvbiApIHtcblxuXHRcdFx0dmFyIG5vZGUgPSB7fTtcblxuXHRcdFx0Ly8gVGhlIGZpcnN0IHRocmVlIGRhdGEgc2l6ZXMgZGVwZW5kcyBvbiB2ZXJzaW9uLlxuXHRcdFx0dmFyIGVuZE9mZnNldCA9ICggdmVyc2lvbiA+PSA3NTAwICkgPyByZWFkZXIuZ2V0VWludDY0KCkgOiByZWFkZXIuZ2V0VWludDMyKCk7XG5cdFx0XHR2YXIgbnVtUHJvcGVydGllcyA9ICggdmVyc2lvbiA+PSA3NTAwICkgPyByZWFkZXIuZ2V0VWludDY0KCkgOiByZWFkZXIuZ2V0VWludDMyKCk7XG5cblx0XHRcdCggdmVyc2lvbiA+PSA3NTAwICkgPyByZWFkZXIuZ2V0VWludDY0KCkgOiByZWFkZXIuZ2V0VWludDMyKCk7IC8vIHRoZSByZXR1cm5lZCBwcm9wZXJ0eUxpc3RMZW4gaXMgbm90IHVzZWRcblxuXHRcdFx0dmFyIG5hbWVMZW4gPSByZWFkZXIuZ2V0VWludDgoKTtcblx0XHRcdHZhciBuYW1lID0gcmVhZGVyLmdldFN0cmluZyggbmFtZUxlbiApO1xuXG5cdFx0XHQvLyBSZWdhcmRzIHRoaXMgbm9kZSBhcyBOVUxMLXJlY29yZCBpZiBlbmRPZmZzZXQgaXMgemVyb1xuXHRcdFx0aWYgKCBlbmRPZmZzZXQgPT09IDAgKSByZXR1cm4gbnVsbDtcblxuXHRcdFx0dmFyIHByb3BlcnR5TGlzdCA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBudW1Qcm9wZXJ0aWVzOyBpICsrICkge1xuXG5cdFx0XHRcdHByb3BlcnR5TGlzdC5wdXNoKCB0aGlzLnBhcnNlUHJvcGVydHkoIHJlYWRlciApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVnYXJkcyB0aGUgZmlyc3QgdGhyZWUgZWxlbWVudHMgaW4gcHJvcGVydHlMaXN0IGFzIGlkLCBhdHRyTmFtZSwgYW5kIGF0dHJUeXBlXG5cdFx0XHR2YXIgaWQgPSBwcm9wZXJ0eUxpc3QubGVuZ3RoID4gMCA/IHByb3BlcnR5TGlzdFsgMCBdIDogJyc7XG5cdFx0XHR2YXIgYXR0ck5hbWUgPSBwcm9wZXJ0eUxpc3QubGVuZ3RoID4gMSA/IHByb3BlcnR5TGlzdFsgMSBdIDogJyc7XG5cdFx0XHR2YXIgYXR0clR5cGUgPSBwcm9wZXJ0eUxpc3QubGVuZ3RoID4gMiA/IHByb3BlcnR5TGlzdFsgMiBdIDogJyc7XG5cblx0XHRcdC8vIGNoZWNrIGlmIHRoaXMgbm9kZSByZXByZXNlbnRzIGp1c3QgYSBzaW5nbGUgcHJvcGVydHlcblx0XHRcdC8vIGxpa2UgKG5hbWUsIDApIHNldCBvciAobmFtZTIsIFswLCAxLCAyXSkgc2V0IG9mIHtuYW1lOiAwLCBuYW1lMjogWzAsIDEsIDJdfVxuXHRcdFx0bm9kZS5zaW5nbGVQcm9wZXJ0eSA9ICggbnVtUHJvcGVydGllcyA9PT0gMSAmJiByZWFkZXIuZ2V0T2Zmc2V0KCkgPT09IGVuZE9mZnNldCApID8gdHJ1ZSA6IGZhbHNlO1xuXG5cdFx0XHR3aGlsZSAoIGVuZE9mZnNldCA+IHJlYWRlci5nZXRPZmZzZXQoKSApIHtcblxuXHRcdFx0XHR2YXIgc3ViTm9kZSA9IHRoaXMucGFyc2VOb2RlKCByZWFkZXIsIHZlcnNpb24gKTtcblxuXHRcdFx0XHRpZiAoIHN1Yk5vZGUgIT09IG51bGwgKSB0aGlzLnBhcnNlU3ViTm9kZSggbmFtZSwgbm9kZSwgc3ViTm9kZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdG5vZGUucHJvcGVydHlMaXN0ID0gcHJvcGVydHlMaXN0OyAvLyByYXcgcHJvcGVydHkgbGlzdCB1c2VkIGJ5IHBhcmVudFxuXG5cdFx0XHRpZiAoIHR5cGVvZiBpZCA9PT0gJ251bWJlcicgKSBub2RlLmlkID0gaWQ7XG5cdFx0XHRpZiAoIGF0dHJOYW1lICE9PSAnJyApIG5vZGUuYXR0ck5hbWUgPSBhdHRyTmFtZTtcblx0XHRcdGlmICggYXR0clR5cGUgIT09ICcnICkgbm9kZS5hdHRyVHlwZSA9IGF0dHJUeXBlO1xuXHRcdFx0aWYgKCBuYW1lICE9PSAnJyApIG5vZGUubmFtZSA9IG5hbWU7XG5cblx0XHRcdHJldHVybiBub2RlO1xuXG5cdFx0fSxcblxuXHRcdHBhcnNlU3ViTm9kZTogZnVuY3Rpb24gKCBuYW1lLCBub2RlLCBzdWJOb2RlICkge1xuXG5cdFx0XHQvLyBzcGVjaWFsIGNhc2U6IGNoaWxkIG5vZGUgaXMgc2luZ2xlIHByb3BlcnR5XG5cdFx0XHRpZiAoIHN1Yk5vZGUuc2luZ2xlUHJvcGVydHkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0dmFyIHZhbHVlID0gc3ViTm9kZS5wcm9wZXJ0eUxpc3RbIDAgXTtcblxuXHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cblx0XHRcdFx0XHRub2RlWyBzdWJOb2RlLm5hbWUgXSA9IHN1Yk5vZGU7XG5cblx0XHRcdFx0XHRzdWJOb2RlLmEgPSB2YWx1ZTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0bm9kZVsgc3ViTm9kZS5uYW1lIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIG5hbWUgPT09ICdDb25uZWN0aW9ucycgJiYgc3ViTm9kZS5uYW1lID09PSAnQycgKSB7XG5cblx0XHRcdFx0dmFyIGFycmF5ID0gW107XG5cblx0XHRcdFx0c3ViTm9kZS5wcm9wZXJ0eUxpc3QuZm9yRWFjaCggZnVuY3Rpb24gKCBwcm9wZXJ0eSwgaSApIHtcblxuXHRcdFx0XHRcdC8vIGZpcnN0IENvbm5lY3Rpb24gaXMgRkJYIHR5cGUgKE9PLCBPUCwgZXRjLikuIFdlJ2xsIGRpc2NhcmQgdGhlc2Vcblx0XHRcdFx0XHRpZiAoIGkgIT09IDAgKSBhcnJheS5wdXNoKCBwcm9wZXJ0eSApO1xuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRpZiAoIG5vZGUuY29ubmVjdGlvbnMgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdG5vZGUuY29ubmVjdGlvbnMgPSBbXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bm9kZS5jb25uZWN0aW9ucy5wdXNoKCBhcnJheSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBzdWJOb2RlLm5hbWUgPT09ICdQcm9wZXJ0aWVzNzAnICkge1xuXG5cdFx0XHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMoIHN1Yk5vZGUgKTtcblxuXHRcdFx0XHRrZXlzLmZvckVhY2goIGZ1bmN0aW9uICgga2V5ICkge1xuXG5cdFx0XHRcdFx0bm9kZVsga2V5IF0gPSBzdWJOb2RlWyBrZXkgXTtcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG5hbWUgPT09ICdQcm9wZXJ0aWVzNzAnICYmIHN1Yk5vZGUubmFtZSA9PT0gJ1AnICkge1xuXG5cdFx0XHRcdHZhciBpbm5lclByb3BOYW1lID0gc3ViTm9kZS5wcm9wZXJ0eUxpc3RbIDAgXTtcblx0XHRcdFx0dmFyIGlubmVyUHJvcFR5cGUxID0gc3ViTm9kZS5wcm9wZXJ0eUxpc3RbIDEgXTtcblx0XHRcdFx0dmFyIGlubmVyUHJvcFR5cGUyID0gc3ViTm9kZS5wcm9wZXJ0eUxpc3RbIDIgXTtcblx0XHRcdFx0dmFyIGlubmVyUHJvcEZsYWcgPSBzdWJOb2RlLnByb3BlcnR5TGlzdFsgMyBdO1xuXHRcdFx0XHR2YXIgaW5uZXJQcm9wVmFsdWU7XG5cblx0XHRcdFx0aWYgKCBpbm5lclByb3BOYW1lLmluZGV4T2YoICdMY2wgJyApID09PSAwICkgaW5uZXJQcm9wTmFtZSA9IGlubmVyUHJvcE5hbWUucmVwbGFjZSggJ0xjbCAnLCAnTGNsXycgKTtcblx0XHRcdFx0aWYgKCBpbm5lclByb3BUeXBlMS5pbmRleE9mKCAnTGNsICcgKSA9PT0gMCApIGlubmVyUHJvcFR5cGUxID0gaW5uZXJQcm9wVHlwZTEucmVwbGFjZSggJ0xjbCAnLCAnTGNsXycgKTtcblxuXHRcdFx0XHRpZiAoIGlubmVyUHJvcFR5cGUxID09PSAnQ29sb3InIHx8IGlubmVyUHJvcFR5cGUxID09PSAnQ29sb3JSR0InIHx8IGlubmVyUHJvcFR5cGUxID09PSAnVmVjdG9yJyB8fCBpbm5lclByb3BUeXBlMSA9PT0gJ1ZlY3RvcjNEJyB8fCBpbm5lclByb3BUeXBlMS5pbmRleE9mKCAnTGNsXycgKSA9PT0gMCApIHtcblxuXHRcdFx0XHRcdGlubmVyUHJvcFZhbHVlID0gW1xuXHRcdFx0XHRcdFx0c3ViTm9kZS5wcm9wZXJ0eUxpc3RbIDQgXSxcblx0XHRcdFx0XHRcdHN1Yk5vZGUucHJvcGVydHlMaXN0WyA1IF0sXG5cdFx0XHRcdFx0XHRzdWJOb2RlLnByb3BlcnR5TGlzdFsgNiBdXG5cdFx0XHRcdFx0XTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aW5uZXJQcm9wVmFsdWUgPSBzdWJOb2RlLnByb3BlcnR5TGlzdFsgNCBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB0aGlzIHdpbGwgYmUgY29waWVkIHRvIHBhcmVudCwgc2VlIGFib3ZlXG5cdFx0XHRcdG5vZGVbIGlubmVyUHJvcE5hbWUgXSA9IHtcblxuXHRcdFx0XHRcdCd0eXBlJzogaW5uZXJQcm9wVHlwZTEsXG5cdFx0XHRcdFx0J3R5cGUyJzogaW5uZXJQcm9wVHlwZTIsXG5cdFx0XHRcdFx0J2ZsYWcnOiBpbm5lclByb3BGbGFnLFxuXHRcdFx0XHRcdCd2YWx1ZSc6IGlubmVyUHJvcFZhbHVlXG5cblx0XHRcdFx0fTtcblxuXHRcdFx0fSBlbHNlIGlmICggbm9kZVsgc3ViTm9kZS5uYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRpZiAoIHR5cGVvZiBzdWJOb2RlLmlkID09PSAnbnVtYmVyJyApIHtcblxuXHRcdFx0XHRcdG5vZGVbIHN1Yk5vZGUubmFtZSBdID0ge307XG5cdFx0XHRcdFx0bm9kZVsgc3ViTm9kZS5uYW1lIF1bIHN1Yk5vZGUuaWQgXSA9IHN1Yk5vZGU7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdG5vZGVbIHN1Yk5vZGUubmFtZSBdID0gc3ViTm9kZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKCBzdWJOb2RlLm5hbWUgPT09ICdQb3NlTm9kZScgKSB7XG5cblx0XHRcdFx0XHRpZiAoICEgQXJyYXkuaXNBcnJheSggbm9kZVsgc3ViTm9kZS5uYW1lIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0bm9kZVsgc3ViTm9kZS5uYW1lIF0gPSBbIG5vZGVbIHN1Yk5vZGUubmFtZSBdIF07XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRub2RlWyBzdWJOb2RlLm5hbWUgXS5wdXNoKCBzdWJOb2RlICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbm9kZVsgc3ViTm9kZS5uYW1lIF1bIHN1Yk5vZGUuaWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0bm9kZVsgc3ViTm9kZS5uYW1lIF1bIHN1Yk5vZGUuaWQgXSA9IHN1Yk5vZGU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0cGFyc2VQcm9wZXJ0eTogZnVuY3Rpb24gKCByZWFkZXIgKSB7XG5cblx0XHRcdHZhciB0eXBlID0gcmVhZGVyLmdldFN0cmluZyggMSApO1xuXG5cdFx0XHRzd2l0Y2ggKCB0eXBlICkge1xuXG5cdFx0XHRcdGNhc2UgJ0MnOlxuXHRcdFx0XHRcdHJldHVybiByZWFkZXIuZ2V0Qm9vbGVhbigpO1xuXG5cdFx0XHRcdGNhc2UgJ0QnOlxuXHRcdFx0XHRcdHJldHVybiByZWFkZXIuZ2V0RmxvYXQ2NCgpO1xuXG5cdFx0XHRcdGNhc2UgJ0YnOlxuXHRcdFx0XHRcdHJldHVybiByZWFkZXIuZ2V0RmxvYXQzMigpO1xuXG5cdFx0XHRcdGNhc2UgJ0knOlxuXHRcdFx0XHRcdHJldHVybiByZWFkZXIuZ2V0SW50MzIoKTtcblxuXHRcdFx0XHRjYXNlICdMJzpcblx0XHRcdFx0XHRyZXR1cm4gcmVhZGVyLmdldEludDY0KCk7XG5cblx0XHRcdFx0Y2FzZSAnUic6XG5cdFx0XHRcdFx0dmFyIGxlbmd0aCA9IHJlYWRlci5nZXRVaW50MzIoKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVhZGVyLmdldEFycmF5QnVmZmVyKCBsZW5ndGggKTtcblxuXHRcdFx0XHRjYXNlICdTJzpcblx0XHRcdFx0XHR2YXIgbGVuZ3RoID0gcmVhZGVyLmdldFVpbnQzMigpO1xuXHRcdFx0XHRcdHJldHVybiByZWFkZXIuZ2V0U3RyaW5nKCBsZW5ndGggKTtcblxuXHRcdFx0XHRjYXNlICdZJzpcblx0XHRcdFx0XHRyZXR1cm4gcmVhZGVyLmdldEludDE2KCk7XG5cblx0XHRcdFx0Y2FzZSAnYic6XG5cdFx0XHRcdGNhc2UgJ2MnOlxuXHRcdFx0XHRjYXNlICdkJzpcblx0XHRcdFx0Y2FzZSAnZic6XG5cdFx0XHRcdGNhc2UgJ2knOlxuXHRcdFx0XHRjYXNlICdsJzpcblxuXHRcdFx0XHRcdHZhciBhcnJheUxlbmd0aCA9IHJlYWRlci5nZXRVaW50MzIoKTtcblx0XHRcdFx0XHR2YXIgZW5jb2RpbmcgPSByZWFkZXIuZ2V0VWludDMyKCk7IC8vIDA6IG5vbi1jb21wcmVzc2VkLCAxOiBjb21wcmVzc2VkXG5cdFx0XHRcdFx0dmFyIGNvbXByZXNzZWRMZW5ndGggPSByZWFkZXIuZ2V0VWludDMyKCk7XG5cblx0XHRcdFx0XHRpZiAoIGVuY29kaW5nID09PSAwICkge1xuXG5cdFx0XHRcdFx0XHRzd2l0Y2ggKCB0eXBlICkge1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2InOlxuXHRcdFx0XHRcdFx0XHRjYXNlICdjJzpcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVhZGVyLmdldEJvb2xlYW5BcnJheSggYXJyYXlMZW5ndGggKTtcblxuXHRcdFx0XHRcdFx0XHRjYXNlICdkJzpcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVhZGVyLmdldEZsb2F0NjRBcnJheSggYXJyYXlMZW5ndGggKTtcblxuXHRcdFx0XHRcdFx0XHRjYXNlICdmJzpcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVhZGVyLmdldEZsb2F0MzJBcnJheSggYXJyYXlMZW5ndGggKTtcblxuXHRcdFx0XHRcdFx0XHRjYXNlICdpJzpcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVhZGVyLmdldEludDMyQXJyYXkoIGFycmF5TGVuZ3RoICk7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAnbCc6XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlYWRlci5nZXRJbnQ2NEFycmF5KCBhcnJheUxlbmd0aCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHR5cGVvZiBmZmxhdGUgPT09ICd1bmRlZmluZWQnICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuRkJYTG9hZGVyOiBFeHRlcm5hbCBsaWJyYXJ5IGZmbGF0ZS5taW4uanMgcmVxdWlyZWQuJyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIGRhdGEgPSBKciggbmV3IFVpbnQ4QXJyYXkoIHJlYWRlci5nZXRBcnJheUJ1ZmZlciggY29tcHJlc3NlZExlbmd0aCApICkgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXHRcdFx0XHRcdHZhciByZWFkZXIyID0gbmV3IEJpbmFyeVJlYWRlciggZGF0YS5idWZmZXIgKTtcblxuXHRcdFx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2InOlxuXHRcdFx0XHRcdFx0Y2FzZSAnYyc6XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZWFkZXIyLmdldEJvb2xlYW5BcnJheSggYXJyYXlMZW5ndGggKTtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnZCc6XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZWFkZXIyLmdldEZsb2F0NjRBcnJheSggYXJyYXlMZW5ndGggKTtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnZic6XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZWFkZXIyLmdldEZsb2F0MzJBcnJheSggYXJyYXlMZW5ndGggKTtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnaSc6XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZWFkZXIyLmdldEludDMyQXJyYXkoIGFycmF5TGVuZ3RoICk7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2wnOlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVhZGVyMi5nZXRJbnQ2NEFycmF5KCBhcnJheUxlbmd0aCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuRkJYTG9hZGVyOiBVbmtub3duIHByb3BlcnR5IHR5cGUgJyArIHR5cGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gQmluYXJ5UmVhZGVyKCBidWZmZXIsIGxpdHRsZUVuZGlhbiApIHtcblxuXHRcdHRoaXMuZHYgPSBuZXcgRGF0YVZpZXcoIGJ1ZmZlciApO1xuXHRcdHRoaXMub2Zmc2V0ID0gMDtcblx0XHR0aGlzLmxpdHRsZUVuZGlhbiA9ICggbGl0dGxlRW5kaWFuICE9PSB1bmRlZmluZWQgKSA/IGxpdHRsZUVuZGlhbiA6IHRydWU7XG5cblx0fVxuXG5cdEJpbmFyeVJlYWRlci5wcm90b3R5cGUgPSB7XG5cblx0XHRjb25zdHJ1Y3RvcjogQmluYXJ5UmVhZGVyLFxuXG5cdFx0Z2V0T2Zmc2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLm9mZnNldDtcblxuXHRcdH0sXG5cblx0XHRzaXplOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmR2LmJ1ZmZlci5ieXRlTGVuZ3RoO1xuXG5cdFx0fSxcblxuXHRcdHNraXA6IGZ1bmN0aW9uICggbGVuZ3RoICkge1xuXG5cdFx0XHR0aGlzLm9mZnNldCArPSBsZW5ndGg7XG5cblx0XHR9LFxuXG5cdFx0Ly8gc2VlbXMgbGlrZSB0cnVlL2ZhbHNlIHJlcHJlc2VudGF0aW9uIGRlcGVuZHMgb24gZXhwb3J0ZXIuXG5cdFx0Ly8gdHJ1ZTogMSBvciAnWScoPTB4NTkpLCBmYWxzZTogMCBvciAnVCcoPTB4NTQpXG5cdFx0Ly8gdGhlbiBzZWVzIExTQi5cblx0XHRnZXRCb29sZWFuOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0VWludDgoKSAmIDEgKSA9PT0gMTtcblxuXHRcdH0sXG5cblx0XHRnZXRCb29sZWFuQXJyYXk6IGZ1bmN0aW9uICggc2l6ZSApIHtcblxuXHRcdFx0dmFyIGEgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSArKyApIHtcblxuXHRcdFx0XHRhLnB1c2goIHRoaXMuZ2V0Qm9vbGVhbigpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGE7XG5cblx0XHR9LFxuXG5cdFx0Z2V0VWludDg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHZhbHVlID0gdGhpcy5kdi5nZXRVaW50OCggdGhpcy5vZmZzZXQgKTtcblx0XHRcdHRoaXMub2Zmc2V0ICs9IDE7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHR9LFxuXG5cdFx0Z2V0SW50MTY6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHZhbHVlID0gdGhpcy5kdi5nZXRJbnQxNiggdGhpcy5vZmZzZXQsIHRoaXMubGl0dGxlRW5kaWFuICk7XG5cdFx0XHR0aGlzLm9mZnNldCArPSAyO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0fSxcblxuXHRcdGdldEludDMyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuZHYuZ2V0SW50MzIoIHRoaXMub2Zmc2V0LCB0aGlzLmxpdHRsZUVuZGlhbiApO1xuXHRcdFx0dGhpcy5vZmZzZXQgKz0gNDtcblx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdH0sXG5cblx0XHRnZXRJbnQzMkFycmF5OiBmdW5jdGlvbiAoIHNpemUgKSB7XG5cblx0XHRcdHZhciBhID0gW107XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHNpemU7IGkgKysgKSB7XG5cblx0XHRcdFx0YS5wdXNoKCB0aGlzLmdldEludDMyKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYTtcblxuXHRcdH0sXG5cblx0XHRnZXRVaW50MzI6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHZhbHVlID0gdGhpcy5kdi5nZXRVaW50MzIoIHRoaXMub2Zmc2V0LCB0aGlzLmxpdHRsZUVuZGlhbiApO1xuXHRcdFx0dGhpcy5vZmZzZXQgKz0gNDtcblx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdH0sXG5cblx0XHQvLyBKYXZhU2NyaXB0IGRvZXNuJ3Qgc3VwcG9ydCA2NC1iaXQgaW50ZWdlciBzbyBjYWxjdWxhdGUgdGhpcyBoZXJlXG5cdFx0Ly8gMSA8PCAzMiB3aWxsIHJldHVybiAxIHNvIHVzaW5nIG11bHRpcGx5IG9wZXJhdGlvbiBpbnN0ZWFkIGhlcmUuXG5cdFx0Ly8gVGhlcmUncyBhIHBvc3NpYmlsaXR5IHRoYXQgdGhpcyBtZXRob2QgcmV0dXJucyB3cm9uZyB2YWx1ZSBpZiB0aGUgdmFsdWVcblx0XHQvLyBpcyBvdXQgb2YgdGhlIHJhbmdlIGJldHdlZW4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgYW5kIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSLlxuXHRcdC8vIFRPRE86IHNhZmVseSBoYW5kbGUgNjQtYml0IGludGVnZXJcblx0XHRnZXRJbnQ2NDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgbG93LCBoaWdoO1xuXG5cdFx0XHRpZiAoIHRoaXMubGl0dGxlRW5kaWFuICkge1xuXG5cdFx0XHRcdGxvdyA9IHRoaXMuZ2V0VWludDMyKCk7XG5cdFx0XHRcdGhpZ2ggPSB0aGlzLmdldFVpbnQzMigpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGhpZ2ggPSB0aGlzLmdldFVpbnQzMigpO1xuXHRcdFx0XHRsb3cgPSB0aGlzLmdldFVpbnQzMigpO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGNhbGN1bGF0ZSBuZWdhdGl2ZSB2YWx1ZVxuXHRcdFx0aWYgKCBoaWdoICYgMHg4MDAwMDAwMCApIHtcblxuXHRcdFx0XHRoaWdoID0gfiBoaWdoICYgMHhGRkZGRkZGRjtcblx0XHRcdFx0bG93ID0gfiBsb3cgJiAweEZGRkZGRkZGO1xuXG5cdFx0XHRcdGlmICggbG93ID09PSAweEZGRkZGRkZGICkgaGlnaCA9ICggaGlnaCArIDEgKSAmIDB4RkZGRkZGRkY7XG5cblx0XHRcdFx0bG93ID0gKCBsb3cgKyAxICkgJiAweEZGRkZGRkZGO1xuXG5cdFx0XHRcdHJldHVybiAtICggaGlnaCAqIDB4MTAwMDAwMDAwICsgbG93ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGhpZ2ggKiAweDEwMDAwMDAwMCArIGxvdztcblxuXHRcdH0sXG5cblx0XHRnZXRJbnQ2NEFycmF5OiBmdW5jdGlvbiAoIHNpemUgKSB7XG5cblx0XHRcdHZhciBhID0gW107XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHNpemU7IGkgKysgKSB7XG5cblx0XHRcdFx0YS5wdXNoKCB0aGlzLmdldEludDY0KCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYTtcblxuXHRcdH0sXG5cblx0XHQvLyBOb3RlOiBzZWUgZ2V0SW50NjQoKSBjb21tZW50XG5cdFx0Z2V0VWludDY0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBsb3csIGhpZ2g7XG5cblx0XHRcdGlmICggdGhpcy5saXR0bGVFbmRpYW4gKSB7XG5cblx0XHRcdFx0bG93ID0gdGhpcy5nZXRVaW50MzIoKTtcblx0XHRcdFx0aGlnaCA9IHRoaXMuZ2V0VWludDMyKCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aGlnaCA9IHRoaXMuZ2V0VWludDMyKCk7XG5cdFx0XHRcdGxvdyA9IHRoaXMuZ2V0VWludDMyKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGhpZ2ggKiAweDEwMDAwMDAwMCArIGxvdztcblxuXHRcdH0sXG5cblx0XHRnZXRGbG9hdDMyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuZHYuZ2V0RmxvYXQzMiggdGhpcy5vZmZzZXQsIHRoaXMubGl0dGxlRW5kaWFuICk7XG5cdFx0XHR0aGlzLm9mZnNldCArPSA0O1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0fSxcblxuXHRcdGdldEZsb2F0MzJBcnJheTogZnVuY3Rpb24gKCBzaXplICkge1xuXG5cdFx0XHR2YXIgYSA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBzaXplOyBpICsrICkge1xuXG5cdFx0XHRcdGEucHVzaCggdGhpcy5nZXRGbG9hdDMyKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYTtcblxuXHRcdH0sXG5cblx0XHRnZXRGbG9hdDY0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuZHYuZ2V0RmxvYXQ2NCggdGhpcy5vZmZzZXQsIHRoaXMubGl0dGxlRW5kaWFuICk7XG5cdFx0XHR0aGlzLm9mZnNldCArPSA4O1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0fSxcblxuXHRcdGdldEZsb2F0NjRBcnJheTogZnVuY3Rpb24gKCBzaXplICkge1xuXG5cdFx0XHR2YXIgYSA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBzaXplOyBpICsrICkge1xuXG5cdFx0XHRcdGEucHVzaCggdGhpcy5nZXRGbG9hdDY0KCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYTtcblxuXHRcdH0sXG5cblx0XHRnZXRBcnJheUJ1ZmZlcjogZnVuY3Rpb24gKCBzaXplICkge1xuXG5cdFx0XHR2YXIgdmFsdWUgPSB0aGlzLmR2LmJ1ZmZlci5zbGljZSggdGhpcy5vZmZzZXQsIHRoaXMub2Zmc2V0ICsgc2l6ZSApO1xuXHRcdFx0dGhpcy5vZmZzZXQgKz0gc2l6ZTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdH0sXG5cblx0XHRnZXRTdHJpbmc6IGZ1bmN0aW9uICggc2l6ZSApIHtcblxuXHRcdFx0Ly8gbm90ZTogc2FmYXJpIDkgZG9lc24ndCBzdXBwb3J0IFVpbnQ4QXJyYXkuaW5kZXhPZjsgY3JlYXRlIGludGVybWVkaWF0ZSBhcnJheSBpbnN0ZWFkXG5cdFx0XHR2YXIgYSA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBzaXplOyBpICsrICkge1xuXG5cdFx0XHRcdGFbIGkgXSA9IHRoaXMuZ2V0VWludDgoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbnVsbEJ5dGUgPSBhLmluZGV4T2YoIDAgKTtcblx0XHRcdGlmICggbnVsbEJ5dGUgPj0gMCApIGEgPSBhLnNsaWNlKCAwLCBudWxsQnl0ZSApO1xuXG5cdFx0XHRyZXR1cm4gTG9hZGVyVXRpbHMuZGVjb2RlVGV4dCggbmV3IFVpbnQ4QXJyYXkoIGEgKSApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gRkJYVHJlZSBob2xkcyBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBGQlggZGF0YSwgcmV0dXJuZWQgYnkgdGhlIFRleHRQYXJzZXIgKCBGQlggQVNDSUkgZm9ybWF0KVxuXHQvLyBhbmQgQmluYXJ5UGFyc2VyKCBGQlggQmluYXJ5IGZvcm1hdClcblx0ZnVuY3Rpb24gRkJYVHJlZSgpIHt9XG5cblx0RkJYVHJlZS5wcm90b3R5cGUgPSB7XG5cblx0XHRjb25zdHJ1Y3RvcjogRkJYVHJlZSxcblxuXHRcdGFkZDogZnVuY3Rpb24gKCBrZXksIHZhbCApIHtcblxuXHRcdFx0dGhpc1sga2V5IF0gPSB2YWw7XG5cblx0XHR9LFxuXG5cdH07XG5cblx0Ly8gKioqKioqKioqKioqKiogVVRJTElUWSBGVU5DVElPTlMgKioqKioqKioqKioqKipcblxuXHRmdW5jdGlvbiBpc0ZieEZvcm1hdEJpbmFyeSggYnVmZmVyICkge1xuXG5cdFx0dmFyIENPUlJFQ1QgPSAnS2F5ZGFyYSBGQlggQmluYXJ5ICBcXDAnO1xuXG5cdFx0cmV0dXJuIGJ1ZmZlci5ieXRlTGVuZ3RoID49IENPUlJFQ1QubGVuZ3RoICYmIENPUlJFQ1QgPT09IGNvbnZlcnRBcnJheUJ1ZmZlclRvU3RyaW5nKCBidWZmZXIsIDAsIENPUlJFQ1QubGVuZ3RoICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGlzRmJ4Rm9ybWF0QVNDSUkoIHRleHQgKSB7XG5cblx0XHR2YXIgQ09SUkVDVCA9IFsgJ0snLCAnYScsICd5JywgJ2QnLCAnYScsICdyJywgJ2EnLCAnXFxcXCcsICdGJywgJ0InLCAnWCcsICdcXFxcJywgJ0InLCAnaScsICduJywgJ2EnLCAncicsICd5JywgJ1xcXFwnLCAnXFxcXCcgXTtcblxuXHRcdHZhciBjdXJzb3IgPSAwO1xuXG5cdFx0ZnVuY3Rpb24gcmVhZCggb2Zmc2V0ICkge1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gdGV4dFsgb2Zmc2V0IC0gMSBdO1xuXHRcdFx0dGV4dCA9IHRleHQuc2xpY2UoIGN1cnNvciArIG9mZnNldCApO1xuXHRcdFx0Y3Vyc29yICsrO1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IENPUlJFQ1QubGVuZ3RoOyArKyBpICkge1xuXG5cdFx0XHR2YXIgbnVtID0gcmVhZCggMSApO1xuXHRcdFx0aWYgKCBudW0gPT09IENPUlJFQ1RbIGkgXSApIHtcblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRGYnhWZXJzaW9uKCB0ZXh0ICkge1xuXG5cdFx0dmFyIHZlcnNpb25SZWdFeHAgPSAvRkJYVmVyc2lvbjogKFxcZCspLztcblx0XHR2YXIgbWF0Y2ggPSB0ZXh0Lm1hdGNoKCB2ZXJzaW9uUmVnRXhwICk7XG5cblx0XHRpZiAoIG1hdGNoICkge1xuXG5cdFx0XHR2YXIgdmVyc2lvbiA9IHBhcnNlSW50KCBtYXRjaFsgMSBdICk7XG5cdFx0XHRyZXR1cm4gdmVyc2lvbjtcblxuXHRcdH1cblxuXHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkZCWExvYWRlcjogQ2Fubm90IGZpbmQgdGhlIHZlcnNpb24gbnVtYmVyIGZvciB0aGUgZmlsZSBnaXZlbi4nICk7XG5cblx0fVxuXG5cdC8vIENvbnZlcnRzIEZCWCB0aWNrcyBpbnRvIHJlYWwgdGltZSBzZWNvbmRzLlxuXHRmdW5jdGlvbiBjb252ZXJ0RkJYVGltZVRvU2Vjb25kcyggdGltZSApIHtcblxuXHRcdHJldHVybiB0aW1lIC8gNDYxODYxNTgwMDA7XG5cblx0fVxuXG5cdHZhciBkYXRhQXJyYXkgPSBbXTtcblxuXHQvLyBleHRyYWN0cyB0aGUgZGF0YSBmcm9tIHRoZSBjb3JyZWN0IHBvc2l0aW9uIGluIHRoZSBGQlggYXJyYXkgYmFzZWQgb24gaW5kZXhpbmcgdHlwZVxuXHRmdW5jdGlvbiBnZXREYXRhKCBwb2x5Z29uVmVydGV4SW5kZXgsIHBvbHlnb25JbmRleCwgdmVydGV4SW5kZXgsIGluZm9PYmplY3QgKSB7XG5cblx0XHR2YXIgaW5kZXg7XG5cblx0XHRzd2l0Y2ggKCBpbmZvT2JqZWN0Lm1hcHBpbmdUeXBlICkge1xuXG5cdFx0XHRjYXNlICdCeVBvbHlnb25WZXJ0ZXgnIDpcblx0XHRcdFx0aW5kZXggPSBwb2x5Z29uVmVydGV4SW5kZXg7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnQnlQb2x5Z29uJyA6XG5cdFx0XHRcdGluZGV4ID0gcG9seWdvbkluZGV4O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ0J5VmVydGljZScgOlxuXHRcdFx0XHRpbmRleCA9IHZlcnRleEluZGV4O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ0FsbFNhbWUnIDpcblx0XHRcdFx0aW5kZXggPSBpbmZvT2JqZWN0LmluZGljZXNbIDAgXTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0IDpcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRkJYTG9hZGVyOiB1bmtub3duIGF0dHJpYnV0ZSBtYXBwaW5nIHR5cGUgJyArIGluZm9PYmplY3QubWFwcGluZ1R5cGUgKTtcblxuXHRcdH1cblxuXHRcdGlmICggaW5mb09iamVjdC5yZWZlcmVuY2VUeXBlID09PSAnSW5kZXhUb0RpcmVjdCcgKSBpbmRleCA9IGluZm9PYmplY3QuaW5kaWNlc1sgaW5kZXggXTtcblxuXHRcdHZhciBmcm9tID0gaW5kZXggKiBpbmZvT2JqZWN0LmRhdGFTaXplO1xuXHRcdHZhciB0byA9IGZyb20gKyBpbmZvT2JqZWN0LmRhdGFTaXplO1xuXG5cdFx0cmV0dXJuIHNsaWNlKCBkYXRhQXJyYXksIGluZm9PYmplY3QuYnVmZmVyLCBmcm9tLCB0byApO1xuXG5cdH1cblxuXHR2YXIgdGVtcEV1bGVyID0gbmV3IEV1bGVyKCk7XG5cdHZhciB0ZW1wVmVjID0gbmV3IFZlY3RvcjMoKTtcblxuXHQvLyBnZW5lcmF0ZSB0cmFuc2Zvcm1hdGlvbiBmcm9tIEZCWCB0cmFuc2Zvcm0gZGF0YVxuXHQvLyByZWY6IGh0dHBzOi8vaGVscC5hdXRvZGVzay5jb20vdmlldy9GQlgvMjAxNy9FTlUvP2d1aWQ9X19maWxlc19HVUlEXzEwQ0RENjNDXzc5QzFfNEYyRF9CQjI4X0FEMkJFNjVBMDJFRF9odG1cblx0Ly8gcmVmOiBodHRwOi8vZG9jcy5hdXRvZGVzay5jb20vRkJYLzIwMTQvRU5VL0ZCWC1TREstRG9jdW1lbnRhdGlvbi9pbmRleC5odG1sP3VybD1jcHBfcmVmL190cmFuc2Zvcm1hdGlvbnNfMm1haW5fOGN4eC1leGFtcGxlLmh0bWwsdG9waWNOdW1iZXI9Y3BwX3JlZl9fdHJhbnNmb3JtYXRpb25zXzJtYWluXzhjeHhfZXhhbXBsZV9odG1sZmMxMGExZTEtYjE4ZC00ZTcyLTlkYzAtNzBkMGYxOTU5ZjVlXG5cdGZ1bmN0aW9uIGdlbmVyYXRlVHJhbnNmb3JtKCB0cmFuc2Zvcm1EYXRhICkge1xuXG5cdFx0dmFyIGxUcmFuc2xhdGlvbk0gPSBuZXcgTWF0cml4NCgpO1xuXHRcdHZhciBsUHJlUm90YXRpb25NID0gbmV3IE1hdHJpeDQoKTtcblx0XHR2YXIgbFJvdGF0aW9uTSA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0dmFyIGxQb3N0Um90YXRpb25NID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdHZhciBsU2NhbGluZ00gPSBuZXcgTWF0cml4NCgpO1xuXHRcdHZhciBsU2NhbGluZ1Bpdm90TSA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0dmFyIGxTY2FsaW5nT2Zmc2V0TSA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0dmFyIGxSb3RhdGlvbk9mZnNldE0gPSBuZXcgTWF0cml4NCgpO1xuXHRcdHZhciBsUm90YXRpb25QaXZvdE0gPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0dmFyIGxQYXJlbnRHWCA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0dmFyIGxQYXJlbnRMWCA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0dmFyIGxHbG9iYWxUID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdHZhciBpbmhlcml0VHlwZSA9ICggdHJhbnNmb3JtRGF0YS5pbmhlcml0VHlwZSApID8gdHJhbnNmb3JtRGF0YS5pbmhlcml0VHlwZSA6IDA7XG5cblx0XHRpZiAoIHRyYW5zZm9ybURhdGEudHJhbnNsYXRpb24gKSBsVHJhbnNsYXRpb25NLnNldFBvc2l0aW9uKCB0ZW1wVmVjLmZyb21BcnJheSggdHJhbnNmb3JtRGF0YS50cmFuc2xhdGlvbiApICk7XG5cblx0XHRpZiAoIHRyYW5zZm9ybURhdGEucHJlUm90YXRpb24gKSB7XG5cblx0XHRcdHZhciBhcnJheSA9IHRyYW5zZm9ybURhdGEucHJlUm90YXRpb24ubWFwKCBNYXRoVXRpbHMuZGVnVG9SYWQgKTtcblx0XHRcdGFycmF5LnB1c2goIHRyYW5zZm9ybURhdGEuZXVsZXJPcmRlciApO1xuXHRcdFx0bFByZVJvdGF0aW9uTS5tYWtlUm90YXRpb25Gcm9tRXVsZXIoIHRlbXBFdWxlci5mcm9tQXJyYXkoIGFycmF5ICkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdHJhbnNmb3JtRGF0YS5yb3RhdGlvbiApIHtcblxuXHRcdFx0dmFyIGFycmF5ID0gdHJhbnNmb3JtRGF0YS5yb3RhdGlvbi5tYXAoIE1hdGhVdGlscy5kZWdUb1JhZCApO1xuXHRcdFx0YXJyYXkucHVzaCggdHJhbnNmb3JtRGF0YS5ldWxlck9yZGVyICk7XG5cdFx0XHRsUm90YXRpb25NLm1ha2VSb3RhdGlvbkZyb21FdWxlciggdGVtcEV1bGVyLmZyb21BcnJheSggYXJyYXkgKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0cmFuc2Zvcm1EYXRhLnBvc3RSb3RhdGlvbiApIHtcblxuXHRcdFx0dmFyIGFycmF5ID0gdHJhbnNmb3JtRGF0YS5wb3N0Um90YXRpb24ubWFwKCBNYXRoVXRpbHMuZGVnVG9SYWQgKTtcblx0XHRcdGFycmF5LnB1c2goIHRyYW5zZm9ybURhdGEuZXVsZXJPcmRlciApO1xuXHRcdFx0bFBvc3RSb3RhdGlvbk0ubWFrZVJvdGF0aW9uRnJvbUV1bGVyKCB0ZW1wRXVsZXIuZnJvbUFycmF5KCBhcnJheSApICk7XG5cdFx0XHRsUG9zdFJvdGF0aW9uTS5pbnZlcnQoKTtcblxuXHRcdH1cblxuXHRcdGlmICggdHJhbnNmb3JtRGF0YS5zY2FsZSApIGxTY2FsaW5nTS5zY2FsZSggdGVtcFZlYy5mcm9tQXJyYXkoIHRyYW5zZm9ybURhdGEuc2NhbGUgKSApO1xuXG5cdFx0Ly8gUGl2b3RzIGFuZCBvZmZzZXRzXG5cdFx0aWYgKCB0cmFuc2Zvcm1EYXRhLnNjYWxpbmdPZmZzZXQgKSBsU2NhbGluZ09mZnNldE0uc2V0UG9zaXRpb24oIHRlbXBWZWMuZnJvbUFycmF5KCB0cmFuc2Zvcm1EYXRhLnNjYWxpbmdPZmZzZXQgKSApO1xuXHRcdGlmICggdHJhbnNmb3JtRGF0YS5zY2FsaW5nUGl2b3QgKSBsU2NhbGluZ1Bpdm90TS5zZXRQb3NpdGlvbiggdGVtcFZlYy5mcm9tQXJyYXkoIHRyYW5zZm9ybURhdGEuc2NhbGluZ1Bpdm90ICkgKTtcblx0XHRpZiAoIHRyYW5zZm9ybURhdGEucm90YXRpb25PZmZzZXQgKSBsUm90YXRpb25PZmZzZXRNLnNldFBvc2l0aW9uKCB0ZW1wVmVjLmZyb21BcnJheSggdHJhbnNmb3JtRGF0YS5yb3RhdGlvbk9mZnNldCApICk7XG5cdFx0aWYgKCB0cmFuc2Zvcm1EYXRhLnJvdGF0aW9uUGl2b3QgKSBsUm90YXRpb25QaXZvdE0uc2V0UG9zaXRpb24oIHRlbXBWZWMuZnJvbUFycmF5KCB0cmFuc2Zvcm1EYXRhLnJvdGF0aW9uUGl2b3QgKSApO1xuXG5cdFx0Ly8gcGFyZW50IHRyYW5zZm9ybVxuXHRcdGlmICggdHJhbnNmb3JtRGF0YS5wYXJlbnRNYXRyaXhXb3JsZCApIHtcblxuXHRcdFx0bFBhcmVudExYLmNvcHkoIHRyYW5zZm9ybURhdGEucGFyZW50TWF0cml4ICk7XG5cdFx0XHRsUGFyZW50R1guY29weSggdHJhbnNmb3JtRGF0YS5wYXJlbnRNYXRyaXhXb3JsZCApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGxMUk0gPSBuZXcgTWF0cml4NCgpLmNvcHkoIGxQcmVSb3RhdGlvbk0gKS5tdWx0aXBseSggbFJvdGF0aW9uTSApLm11bHRpcGx5KCBsUG9zdFJvdGF0aW9uTSApO1xuXHRcdC8vIEdsb2JhbCBSb3RhdGlvblxuXHRcdHZhciBsUGFyZW50R1JNID0gbmV3IE1hdHJpeDQoKTtcblx0XHRsUGFyZW50R1JNLmV4dHJhY3RSb3RhdGlvbiggbFBhcmVudEdYICk7XG5cblx0XHQvLyBHbG9iYWwgU2hlYXIqU2NhbGluZ1xuXHRcdHZhciBsUGFyZW50VE0gPSBuZXcgTWF0cml4NCgpO1xuXHRcdGxQYXJlbnRUTS5jb3B5UG9zaXRpb24oIGxQYXJlbnRHWCApO1xuXG5cdFx0dmFyIGxQYXJlbnRHU00gPSBuZXcgTWF0cml4NCgpO1xuXHRcdHZhciBsUGFyZW50R1JTTSA9IG5ldyBNYXRyaXg0KCkuY29weSggbFBhcmVudFRNICkuaW52ZXJ0KCkubXVsdGlwbHkoIGxQYXJlbnRHWCApO1xuXHRcdGxQYXJlbnRHU00uY29weSggbFBhcmVudEdSTSApLmludmVydCgpLm11bHRpcGx5KCBsUGFyZW50R1JTTSApO1xuXHRcdHZhciBsTFNNID0gbFNjYWxpbmdNO1xuXG5cdFx0dmFyIGxHbG9iYWxSUyA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHRpZiAoIGluaGVyaXRUeXBlID09PSAwICkge1xuXG5cdFx0XHRsR2xvYmFsUlMuY29weSggbFBhcmVudEdSTSApLm11bHRpcGx5KCBsTFJNICkubXVsdGlwbHkoIGxQYXJlbnRHU00gKS5tdWx0aXBseSggbExTTSApO1xuXG5cdFx0fSBlbHNlIGlmICggaW5oZXJpdFR5cGUgPT09IDEgKSB7XG5cblx0XHRcdGxHbG9iYWxSUy5jb3B5KCBsUGFyZW50R1JNICkubXVsdGlwbHkoIGxQYXJlbnRHU00gKS5tdWx0aXBseSggbExSTSApLm11bHRpcGx5KCBsTFNNICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR2YXIgbFBhcmVudExTTSA9IG5ldyBNYXRyaXg0KCkuc2NhbGUoIG5ldyBWZWN0b3IzKCkuc2V0RnJvbU1hdHJpeFNjYWxlKCBsUGFyZW50TFggKSApO1xuXHRcdFx0dmFyIGxQYXJlbnRMU01faW52ID0gbmV3IE1hdHJpeDQoKS5jb3B5KCBsUGFyZW50TFNNICkuaW52ZXJ0KCk7XG5cdFx0XHR2YXIgbFBhcmVudEdTTV9ub0xvY2FsID0gbmV3IE1hdHJpeDQoKS5jb3B5KCBsUGFyZW50R1NNICkubXVsdGlwbHkoIGxQYXJlbnRMU01faW52ICk7XG5cblx0XHRcdGxHbG9iYWxSUy5jb3B5KCBsUGFyZW50R1JNICkubXVsdGlwbHkoIGxMUk0gKS5tdWx0aXBseSggbFBhcmVudEdTTV9ub0xvY2FsICkubXVsdGlwbHkoIGxMU00gKTtcblxuXHRcdH1cblxuXHRcdHZhciBsUm90YXRpb25QaXZvdE1faW52ID0gbmV3IE1hdHJpeDQoKTtcblx0XHRsUm90YXRpb25QaXZvdE1faW52LmNvcHkoIGxSb3RhdGlvblBpdm90TSApLmludmVydCgpO1xuXHRcdHZhciBsU2NhbGluZ1Bpdm90TV9pbnYgPSBuZXcgTWF0cml4NCgpO1xuXHRcdGxTY2FsaW5nUGl2b3RNX2ludi5jb3B5KCBsU2NhbGluZ1Bpdm90TSApLmludmVydCgpO1xuXHRcdC8vIENhbGN1bGF0ZSB0aGUgbG9jYWwgdHJhbnNmb3JtIG1hdHJpeFxuXHRcdHZhciBsVHJhbnNmb3JtID0gbmV3IE1hdHJpeDQoKTtcblx0XHRsVHJhbnNmb3JtLmNvcHkoIGxUcmFuc2xhdGlvbk0gKS5tdWx0aXBseSggbFJvdGF0aW9uT2Zmc2V0TSApLm11bHRpcGx5KCBsUm90YXRpb25QaXZvdE0gKS5tdWx0aXBseSggbFByZVJvdGF0aW9uTSApLm11bHRpcGx5KCBsUm90YXRpb25NICkubXVsdGlwbHkoIGxQb3N0Um90YXRpb25NICkubXVsdGlwbHkoIGxSb3RhdGlvblBpdm90TV9pbnYgKS5tdWx0aXBseSggbFNjYWxpbmdPZmZzZXRNICkubXVsdGlwbHkoIGxTY2FsaW5nUGl2b3RNICkubXVsdGlwbHkoIGxTY2FsaW5nTSApLm11bHRpcGx5KCBsU2NhbGluZ1Bpdm90TV9pbnYgKTtcblxuXHRcdHZhciBsTG9jYWxUV2l0aEFsbFBpdm90QW5kT2Zmc2V0SW5mbyA9IG5ldyBNYXRyaXg0KCkuY29weVBvc2l0aW9uKCBsVHJhbnNmb3JtICk7XG5cblx0XHR2YXIgbEdsb2JhbFRyYW5zbGF0aW9uID0gbmV3IE1hdHJpeDQoKS5jb3B5KCBsUGFyZW50R1ggKS5tdWx0aXBseSggbExvY2FsVFdpdGhBbGxQaXZvdEFuZE9mZnNldEluZm8gKTtcblx0XHRsR2xvYmFsVC5jb3B5UG9zaXRpb24oIGxHbG9iYWxUcmFuc2xhdGlvbiApO1xuXG5cdFx0bFRyYW5zZm9ybSA9IG5ldyBNYXRyaXg0KCkuY29weSggbEdsb2JhbFQgKS5tdWx0aXBseSggbEdsb2JhbFJTICk7XG5cblx0XHQvLyBmcm9tIGdsb2JhbCB0byBsb2NhbFxuXHRcdGxUcmFuc2Zvcm0ucHJlbXVsdGlwbHkoIGxQYXJlbnRHWC5pbnZlcnQoKSApO1xuXG5cdFx0cmV0dXJuIGxUcmFuc2Zvcm07XG5cblx0fVxuXG5cdC8vIFJldHVybnMgdGhlIHRocmVlLmpzIGludHJpbnNpYyBFdWxlciBvcmRlciBjb3JyZXNwb25kaW5nIHRvIEZCWCBleHRyaW5zaWMgRXVsZXIgb3JkZXJcblx0Ly8gcmVmOiBodHRwOi8vaGVscC5hdXRvZGVzay5jb20vdmlldy9GQlgvMjAxNy9FTlUvP2d1aWQ9X19jcHBfcmVmX2NsYXNzX2ZieF9ldWxlcl9odG1sXG5cdGZ1bmN0aW9uIGdldEV1bGVyT3JkZXIoIG9yZGVyICkge1xuXG5cdFx0b3JkZXIgPSBvcmRlciB8fCAwO1xuXG5cdFx0dmFyIGVudW1zID0gW1xuXHRcdFx0J1pZWCcsIC8vIC0+IFhZWiBleHRyaW5zaWNcblx0XHRcdCdZWlgnLCAvLyAtPiBYWlkgZXh0cmluc2ljXG5cdFx0XHQnWFpZJywgLy8gLT4gWVpYIGV4dHJpbnNpY1xuXHRcdFx0J1pYWScsIC8vIC0+IFlYWiBleHRyaW5zaWNcblx0XHRcdCdZWFonLCAvLyAtPiBaWFkgZXh0cmluc2ljXG5cdFx0XHQnWFlaJywgLy8gLT4gWllYIGV4dHJpbnNpY1xuXHRcdFx0Ly8nU3BoZXJpY1hZWicsIC8vIG5vdCBwb3NzaWJsZSB0byBzdXBwb3J0XG5cdFx0XTtcblxuXHRcdGlmICggb3JkZXIgPT09IDYgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZCWExvYWRlcjogdW5zdXBwb3J0ZWQgRXVsZXIgT3JkZXI6IFNwaGVyaWNhbCBYWVouIEFuaW1hdGlvbnMgYW5kIHJvdGF0aW9ucyBtYXkgYmUgaW5jb3JyZWN0LicgKTtcblx0XHRcdHJldHVybiBlbnVtc1sgMCBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVudW1zWyBvcmRlciBdO1xuXG5cdH1cblxuXHQvLyBQYXJzZXMgY29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgbnVtYmVycyBhbmQgcmV0dXJucyB0aGVtIGFuIGFycmF5LlxuXHQvLyBVc2VkIGludGVybmFsbHkgYnkgdGhlIFRleHRQYXJzZXJcblx0ZnVuY3Rpb24gcGFyc2VOdW1iZXJBcnJheSggdmFsdWUgKSB7XG5cblx0XHR2YXIgYXJyYXkgPSB2YWx1ZS5zcGxpdCggJywnICkubWFwKCBmdW5jdGlvbiAoIHZhbCApIHtcblxuXHRcdFx0cmV0dXJuIHBhcnNlRmxvYXQoIHZhbCApO1xuXG5cdFx0fSApO1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBjb252ZXJ0QXJyYXlCdWZmZXJUb1N0cmluZyggYnVmZmVyLCBmcm9tLCB0byApIHtcblxuXHRcdGlmICggZnJvbSA9PT0gdW5kZWZpbmVkICkgZnJvbSA9IDA7XG5cdFx0aWYgKCB0byA9PT0gdW5kZWZpbmVkICkgdG8gPSBidWZmZXIuYnl0ZUxlbmd0aDtcblxuXHRcdHJldHVybiBMb2FkZXJVdGlscy5kZWNvZGVUZXh0KCBuZXcgVWludDhBcnJheSggYnVmZmVyLCBmcm9tLCB0byApICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGFwcGVuZCggYSwgYiApIHtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaiA9IGEubGVuZ3RoLCBsID0gYi5sZW5ndGg7IGkgPCBsOyBpICsrLCBqICsrICkge1xuXG5cdFx0XHRhWyBqIF0gPSBiWyBpIF07XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNsaWNlKCBhLCBiLCBmcm9tLCB0byApIHtcblxuXHRcdGZvciAoIHZhciBpID0gZnJvbSwgaiA9IDA7IGkgPCB0bzsgaSArKywgaiArKyApIHtcblxuXHRcdFx0YVsgaiBdID0gYlsgaSBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGE7XG5cblx0fVxuXG5cdC8vIGluamVjdCBhcnJheSBhMiBpbnRvIGFycmF5IGExIGF0IGluZGV4XG5cdGZ1bmN0aW9uIGluamVjdCggYTEsIGluZGV4LCBhMiApIHtcblxuXHRcdHJldHVybiBhMS5zbGljZSggMCwgaW5kZXggKS5jb25jYXQoIGEyICkuY29uY2F0KCBhMS5zbGljZSggaW5kZXggKSApO1xuXG5cdH1cblxuXHRyZXR1cm4gRkJYTG9hZGVyO1xuXG59ICkoKTtcblxudmFyIFNWR0xvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuXHRMb2FkZXIkMS5jYWxsKCB0aGlzLCBtYW5hZ2VyICk7XG5cblx0Ly8gRGVmYXVsdCBkb3RzIHBlciBpbmNoXG5cdHRoaXMuZGVmYXVsdERQSSA9IDkwO1xuXG5cdC8vIEFjY2VwdGVkIHVuaXRzOiAnbW0nLCAnY20nLCAnaW4nLCAncHQnLCAncGMnLCAncHgnXG5cdHRoaXMuZGVmYXVsdFVuaXQgPSAncHgnO1xuXG59O1xuXG5TVkdMb2FkZXIucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTG9hZGVyJDEucHJvdG90eXBlICksIHtcblxuXHRjb25zdHJ1Y3RvcjogU1ZHTG9hZGVyLFxuXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XG5cdFx0bG9hZGVyLnNldFBhdGgoIHNjb3BlLnBhdGggKTtcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggc2NvcGUucmVxdWVzdEhlYWRlciApO1xuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHNjb3BlLndpdGhDcmVkZW50aWFscyApO1xuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcblxuXHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRvbkxvYWQoIHNjb3BlLnBhcnNlKCB0ZXh0ICkgKTtcblxuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICkge1xuXG5cdFx0XHRcdFx0b25FcnJvciggZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdH0sXG5cblx0cGFyc2U6IGZ1bmN0aW9uICggdGV4dCApIHtcblxuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHRmdW5jdGlvbiBwYXJzZU5vZGUoIG5vZGUsIHN0eWxlICkge1xuXG5cdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgIT09IDEgKSByZXR1cm47XG5cblx0XHRcdHZhciB0cmFuc2Zvcm0gPSBnZXROb2RlVHJhbnNmb3JtKCBub2RlICk7XG5cblx0XHRcdHZhciB0cmF2ZXJzZUNoaWxkTm9kZXMgPSB0cnVlO1xuXG5cdFx0XHR2YXIgcGF0aCA9IG51bGw7XG5cblx0XHRcdHN3aXRjaCAoIG5vZGUubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnc3ZnJzpcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdzdHlsZSc6XG5cdFx0XHRcdFx0cGFyc2VDU1NTdHlsZXNoZWV0KCBub2RlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnZyc6XG5cdFx0XHRcdFx0c3R5bGUgPSBwYXJzZVN0eWxlKCBub2RlLCBzdHlsZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3BhdGgnOlxuXHRcdFx0XHRcdHN0eWxlID0gcGFyc2VTdHlsZSggbm9kZSwgc3R5bGUgKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUuaGFzQXR0cmlidXRlKCAnZCcgKSApIHBhdGggPSBwYXJzZVBhdGhOb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAncmVjdCc6XG5cdFx0XHRcdFx0c3R5bGUgPSBwYXJzZVN0eWxlKCBub2RlLCBzdHlsZSApO1xuXHRcdFx0XHRcdHBhdGggPSBwYXJzZVJlY3ROb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAncG9seWdvbic6XG5cdFx0XHRcdFx0c3R5bGUgPSBwYXJzZVN0eWxlKCBub2RlLCBzdHlsZSApO1xuXHRcdFx0XHRcdHBhdGggPSBwYXJzZVBvbHlnb25Ob2RlKCBub2RlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAncG9seWxpbmUnOlxuXHRcdFx0XHRcdHN0eWxlID0gcGFyc2VTdHlsZSggbm9kZSwgc3R5bGUgKTtcblx0XHRcdFx0XHRwYXRoID0gcGFyc2VQb2x5bGluZU5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdjaXJjbGUnOlxuXHRcdFx0XHRcdHN0eWxlID0gcGFyc2VTdHlsZSggbm9kZSwgc3R5bGUgKTtcblx0XHRcdFx0XHRwYXRoID0gcGFyc2VDaXJjbGVOb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnZWxsaXBzZSc6XG5cdFx0XHRcdFx0c3R5bGUgPSBwYXJzZVN0eWxlKCBub2RlLCBzdHlsZSApO1xuXHRcdFx0XHRcdHBhdGggPSBwYXJzZUVsbGlwc2VOb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbGluZSc6XG5cdFx0XHRcdFx0c3R5bGUgPSBwYXJzZVN0eWxlKCBub2RlLCBzdHlsZSApO1xuXHRcdFx0XHRcdHBhdGggPSBwYXJzZUxpbmVOb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnZGVmcyc6XG5cdFx0XHRcdFx0dHJhdmVyc2VDaGlsZE5vZGVzID0gZmFsc2U7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAndXNlJzpcblx0XHRcdFx0XHRzdHlsZSA9IHBhcnNlU3R5bGUoIG5vZGUsIHN0eWxlICk7XG5cdFx0XHRcdFx0dmFyIHVzZWROb2RlSWQgPSBub2RlLmhyZWYuYmFzZVZhbC5zdWJzdHJpbmcoIDEgKTtcblx0XHRcdFx0XHR2YXIgdXNlZE5vZGUgPSBub2RlLnZpZXdwb3J0RWxlbWVudC5nZXRFbGVtZW50QnlJZCggdXNlZE5vZGVJZCApO1xuXHRcdFx0XHRcdGlmICggdXNlZE5vZGUgKSB7XG5cblx0XHRcdFx0XHRcdHBhcnNlTm9kZSggdXNlZE5vZGUsIHN0eWxlICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdTVkdMb2FkZXI6IFxcJ3VzZSBub2RlXFwnIHJlZmVyZW5jZXMgbm9uLWV4aXN0ZW50IG5vZGUgaWQ6ICcgKyB1c2VkTm9kZUlkICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyggbm9kZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcGF0aCApIHtcblxuXHRcdFx0XHRpZiAoIHN0eWxlLmZpbGwgIT09IHVuZGVmaW5lZCAmJiBzdHlsZS5maWxsICE9PSAnbm9uZScgKSB7XG5cblx0XHRcdFx0XHRwYXRoLmNvbG9yLnNldFN0eWxlKCBzdHlsZS5maWxsICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRyYW5zZm9ybVBhdGgoIHBhdGgsIGN1cnJlbnRUcmFuc2Zvcm0gKTtcblxuXHRcdFx0XHRwYXRocy5wdXNoKCBwYXRoICk7XG5cblx0XHRcdFx0cGF0aC51c2VyRGF0YSA9IHsgbm9kZTogbm9kZSwgc3R5bGU6IHN0eWxlIH07XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0cmF2ZXJzZUNoaWxkTm9kZXMgKSB7XG5cblx0XHRcdFx0dmFyIG5vZGVzID0gbm9kZS5jaGlsZE5vZGVzO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHBhcnNlTm9kZSggbm9kZXNbIGkgXSwgc3R5bGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0cmFuc2Zvcm0gKSB7XG5cblx0XHRcdFx0dHJhbnNmb3JtU3RhY2sucG9wKCk7XG5cblx0XHRcdFx0aWYgKCB0cmFuc2Zvcm1TdGFjay5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0Y3VycmVudFRyYW5zZm9ybS5jb3B5KCB0cmFuc2Zvcm1TdGFja1sgdHJhbnNmb3JtU3RhY2subGVuZ3RoIC0gMSBdICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGN1cnJlbnRUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlUGF0aE5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdHZhciBwYXRoID0gbmV3IFNoYXBlUGF0aCgpO1xuXG5cdFx0XHR2YXIgcG9pbnQgPSBuZXcgVmVjdG9yMigpO1xuXHRcdFx0dmFyIGNvbnRyb2wgPSBuZXcgVmVjdG9yMigpO1xuXG5cdFx0XHR2YXIgZmlyc3RQb2ludCA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0XHR2YXIgaXNGaXJzdFBvaW50ID0gdHJ1ZTtcblx0XHRcdHZhciBkb1NldEZpcnN0UG9pbnQgPSBmYWxzZTtcblxuXHRcdFx0dmFyIGQgPSBub2RlLmdldEF0dHJpYnV0ZSggJ2QnICk7XG5cblx0XHRcdC8vIGNvbnNvbGUubG9nKCBkICk7XG5cblx0XHRcdHZhciBjb21tYW5kcyA9IGQubWF0Y2goIC9bYS1kZi16XVteYS1kZi16XSovaWcgKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY29tbWFuZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY29tbWFuZCA9IGNvbW1hbmRzWyBpIF07XG5cblx0XHRcdFx0dmFyIHR5cGUgPSBjb21tYW5kLmNoYXJBdCggMCApO1xuXHRcdFx0XHR2YXIgZGF0YSA9IGNvbW1hbmQuc3Vic3RyKCAxICkudHJpbSgpO1xuXG5cdFx0XHRcdGlmICggaXNGaXJzdFBvaW50ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0ZG9TZXRGaXJzdFBvaW50ID0gdHJ1ZTtcblx0XHRcdFx0XHRpc0ZpcnN0UG9pbnQgPSBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3dpdGNoICggdHlwZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ00nOlxuXHRcdFx0XHRcdFx0dmFyIG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gMiApIHtcblxuXHRcdFx0XHRcdFx0XHRwb2ludC54ID0gbnVtYmVyc1sgaiArIDAgXTtcblx0XHRcdFx0XHRcdFx0cG9pbnQueSA9IG51bWJlcnNbIGogKyAxIF07XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueCA9IHBvaW50Lng7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IHBvaW50Lnk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0cGF0aC5tb3ZlVG8oIHBvaW50LngsIHBvaW50LnkgKTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0cGF0aC5saW5lVG8oIHBvaW50LngsIHBvaW50LnkgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0gnOlxuXHRcdFx0XHRcdFx0dmFyIG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRwb2ludC54ID0gbnVtYmVyc1sgaiBdO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBwb2ludC54O1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSBwb2ludC55O1xuXHRcdFx0XHRcdFx0XHRwYXRoLmxpbmVUbyggcG9pbnQueCwgcG9pbnQueSApO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUgKSBmaXJzdFBvaW50LmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdWJzpcblx0XHRcdFx0XHRcdHZhciBudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0cG9pbnQueSA9IG51bWJlcnNbIGogXTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gcG9pbnQueDtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gcG9pbnQueTtcblx0XHRcdFx0XHRcdFx0cGF0aC5saW5lVG8oIHBvaW50LngsIHBvaW50LnkgKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnTCc6XG5cdFx0XHRcdFx0XHR2YXIgbnVtYmVycyA9IHBhcnNlRmxvYXRzKCBkYXRhICk7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDIgKSB7XG5cblx0XHRcdFx0XHRcdFx0cG9pbnQueCA9IG51bWJlcnNbIGogKyAwIF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgPSBudW1iZXJzWyBqICsgMSBdO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBwb2ludC54O1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSBwb2ludC55O1xuXHRcdFx0XHRcdFx0XHRwYXRoLmxpbmVUbyggcG9pbnQueCwgcG9pbnQueSApO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUgKSBmaXJzdFBvaW50LmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdDJzpcblx0XHRcdFx0XHRcdHZhciBudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gNiApIHtcblxuXHRcdFx0XHRcdFx0XHRwYXRoLmJlemllckN1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdFx0bnVtYmVyc1sgaiArIDAgXSxcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgMSBdLFxuXHRcdFx0XHRcdFx0XHRcdG51bWJlcnNbIGogKyAyIF0sXG5cdFx0XHRcdFx0XHRcdFx0bnVtYmVyc1sgaiArIDMgXSxcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgNCBdLFxuXHRcdFx0XHRcdFx0XHRcdG51bWJlcnNbIGogKyA1IF1cblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gbnVtYmVyc1sgaiArIDIgXTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gbnVtYmVyc1sgaiArIDMgXTtcblx0XHRcdFx0XHRcdFx0cG9pbnQueCA9IG51bWJlcnNbIGogKyA0IF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgPSBudW1iZXJzWyBqICsgNSBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUgKSBmaXJzdFBvaW50LmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdTJzpcblx0XHRcdFx0XHRcdHZhciBudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHRwYXRoLmJlemllckN1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdFx0Z2V0UmVmbGVjdGlvbiggcG9pbnQueCwgY29udHJvbC54ICksXG5cdFx0XHRcdFx0XHRcdFx0Z2V0UmVmbGVjdGlvbiggcG9pbnQueSwgY29udHJvbC55ICksXG5cdFx0XHRcdFx0XHRcdFx0bnVtYmVyc1sgaiArIDAgXSxcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgMSBdLFxuXHRcdFx0XHRcdFx0XHRcdG51bWJlcnNbIGogKyAyIF0sXG5cdFx0XHRcdFx0XHRcdFx0bnVtYmVyc1sgaiArIDMgXVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBudW1iZXJzWyBqICsgMCBdO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSBudW1iZXJzWyBqICsgMSBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC54ID0gbnVtYmVyc1sgaiArIDIgXTtcblx0XHRcdFx0XHRcdFx0cG9pbnQueSA9IG51bWJlcnNbIGogKyAzIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1EnOlxuXHRcdFx0XHRcdFx0dmFyIG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdHBhdGgucXVhZHJhdGljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgMCBdLFxuXHRcdFx0XHRcdFx0XHRcdG51bWJlcnNbIGogKyAxIF0sXG5cdFx0XHRcdFx0XHRcdFx0bnVtYmVyc1sgaiArIDIgXSxcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgMyBdXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueCA9IG51bWJlcnNbIGogKyAwIF07XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IG51bWJlcnNbIGogKyAxIF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnggPSBudW1iZXJzWyBqICsgMiBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC55ID0gbnVtYmVyc1sgaiArIDMgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnVCc6XG5cdFx0XHRcdFx0XHR2YXIgbnVtYmVycyA9IHBhcnNlRmxvYXRzKCBkYXRhICk7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDIgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHJ4ID0gZ2V0UmVmbGVjdGlvbiggcG9pbnQueCwgY29udHJvbC54ICk7XG5cdFx0XHRcdFx0XHRcdHZhciByeSA9IGdldFJlZmxlY3Rpb24oIHBvaW50LnksIGNvbnRyb2wueSApO1xuXHRcdFx0XHRcdFx0XHRwYXRoLnF1YWRyYXRpY0N1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdFx0cngsXG5cdFx0XHRcdFx0XHRcdFx0cnksXG5cdFx0XHRcdFx0XHRcdFx0bnVtYmVyc1sgaiArIDAgXSxcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgMSBdXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueCA9IHJ4O1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSByeTtcblx0XHRcdFx0XHRcdFx0cG9pbnQueCA9IG51bWJlcnNbIGogKyAwIF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgPSBudW1iZXJzWyBqICsgMSBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUgKSBmaXJzdFBvaW50LmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdBJzpcblx0XHRcdFx0XHRcdHZhciBudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gNyApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBza2lwIGNvbW1hbmQgaWYgc3RhcnQgcG9pbnQgPT0gZW5kIHBvaW50XG5cdFx0XHRcdFx0XHRcdGlmICggbnVtYmVyc1sgaiArIDUgXSA9PSBwb2ludC54ICYmIG51bWJlcnNbIGogKyA2IF0gPT0gcG9pbnQueSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0XHRcdHZhciBzdGFydCA9IHBvaW50LmNsb25lKCk7XG5cdFx0XHRcdFx0XHRcdHBvaW50LnggPSBudW1iZXJzWyBqICsgNSBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC55ID0gbnVtYmVyc1sgaiArIDYgXTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gcG9pbnQueDtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gcG9pbnQueTtcblx0XHRcdFx0XHRcdFx0cGFyc2VBcmNDb21tYW5kKFxuXHRcdFx0XHRcdFx0XHRcdHBhdGgsIG51bWJlcnNbIGogXSwgbnVtYmVyc1sgaiArIDEgXSwgbnVtYmVyc1sgaiArIDIgXSwgbnVtYmVyc1sgaiArIDMgXSwgbnVtYmVyc1sgaiArIDQgXSwgc3RhcnQsIHBvaW50XG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ20nOlxuXHRcdFx0XHRcdFx0dmFyIG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSAyICkge1xuXG5cdFx0XHRcdFx0XHRcdHBvaW50LnggKz0gbnVtYmVyc1sgaiArIDAgXTtcblx0XHRcdFx0XHRcdFx0cG9pbnQueSArPSBudW1iZXJzWyBqICsgMSBdO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBwb2ludC54O1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSBwb2ludC55O1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHBhdGgubW92ZVRvKCBwb2ludC54LCBwb2ludC55ICk7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdHBhdGgubGluZVRvKCBwb2ludC54LCBwb2ludC55ICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUgKSBmaXJzdFBvaW50LmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdoJzpcblx0XHRcdFx0XHRcdHZhciBudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0cG9pbnQueCArPSBudW1iZXJzWyBqIF07XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueCA9IHBvaW50Lng7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IHBvaW50Lnk7XG5cdFx0XHRcdFx0XHRcdHBhdGgubGluZVRvKCBwb2ludC54LCBwb2ludC55ICk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3YnOlxuXHRcdFx0XHRcdFx0dmFyIG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRwb2ludC55ICs9IG51bWJlcnNbIGogXTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gcG9pbnQueDtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gcG9pbnQueTtcblx0XHRcdFx0XHRcdFx0cGF0aC5saW5lVG8oIHBvaW50LngsIHBvaW50LnkgKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnbCc6XG5cdFx0XHRcdFx0XHR2YXIgbnVtYmVycyA9IHBhcnNlRmxvYXRzKCBkYXRhICk7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDIgKSB7XG5cblx0XHRcdFx0XHRcdFx0cG9pbnQueCArPSBudW1iZXJzWyBqICsgMCBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC55ICs9IG51bWJlcnNbIGogKyAxIF07XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueCA9IHBvaW50Lng7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IHBvaW50Lnk7XG5cdFx0XHRcdFx0XHRcdHBhdGgubGluZVRvKCBwb2ludC54LCBwb2ludC55ICk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2MnOlxuXHRcdFx0XHRcdFx0dmFyIG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSA2ICkge1xuXG5cdFx0XHRcdFx0XHRcdHBhdGguYmV6aWVyQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0XHRwb2ludC54ICsgbnVtYmVyc1sgaiArIDAgXSxcblx0XHRcdFx0XHRcdFx0XHRwb2ludC55ICsgbnVtYmVyc1sgaiArIDEgXSxcblx0XHRcdFx0XHRcdFx0XHRwb2ludC54ICsgbnVtYmVyc1sgaiArIDIgXSxcblx0XHRcdFx0XHRcdFx0XHRwb2ludC55ICsgbnVtYmVyc1sgaiArIDMgXSxcblx0XHRcdFx0XHRcdFx0XHRwb2ludC54ICsgbnVtYmVyc1sgaiArIDQgXSxcblx0XHRcdFx0XHRcdFx0XHRwb2ludC55ICsgbnVtYmVyc1sgaiArIDUgXVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBwb2ludC54ICsgbnVtYmVyc1sgaiArIDIgXTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gcG9pbnQueSArIG51bWJlcnNbIGogKyAzIF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnggKz0gbnVtYmVyc1sgaiArIDQgXTtcblx0XHRcdFx0XHRcdFx0cG9pbnQueSArPSBudW1iZXJzWyBqICsgNSBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUgKSBmaXJzdFBvaW50LmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdzJzpcblx0XHRcdFx0XHRcdHZhciBudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHRwYXRoLmJlemllckN1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdFx0Z2V0UmVmbGVjdGlvbiggcG9pbnQueCwgY29udHJvbC54ICksXG5cdFx0XHRcdFx0XHRcdFx0Z2V0UmVmbGVjdGlvbiggcG9pbnQueSwgY29udHJvbC55ICksXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueCArIG51bWJlcnNbIGogKyAwIF0sXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueSArIG51bWJlcnNbIGogKyAxIF0sXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueCArIG51bWJlcnNbIGogKyAyIF0sXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueSArIG51bWJlcnNbIGogKyAzIF1cblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gcG9pbnQueCArIG51bWJlcnNbIGogKyAwIF07XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IHBvaW50LnkgKyBudW1iZXJzWyBqICsgMSBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC54ICs9IG51bWJlcnNbIGogKyAyIF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgKz0gbnVtYmVyc1sgaiArIDMgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAncSc6XG5cdFx0XHRcdFx0XHR2YXIgbnVtYmVycyA9IHBhcnNlRmxvYXRzKCBkYXRhICk7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0cGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKFxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnggKyBudW1iZXJzWyBqICsgMCBdLFxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnkgKyBudW1iZXJzWyBqICsgMSBdLFxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnggKyBudW1iZXJzWyBqICsgMiBdLFxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnkgKyBudW1iZXJzWyBqICsgMyBdXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueCA9IHBvaW50LnggKyBudW1iZXJzWyBqICsgMCBdO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSBwb2ludC55ICsgbnVtYmVyc1sgaiArIDEgXTtcblx0XHRcdFx0XHRcdFx0cG9pbnQueCArPSBudW1iZXJzWyBqICsgMiBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC55ICs9IG51bWJlcnNbIGogKyAzIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3QnOlxuXHRcdFx0XHRcdFx0dmFyIG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSAyICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciByeCA9IGdldFJlZmxlY3Rpb24oIHBvaW50LngsIGNvbnRyb2wueCApO1xuXHRcdFx0XHRcdFx0XHR2YXIgcnkgPSBnZXRSZWZsZWN0aW9uKCBwb2ludC55LCBjb250cm9sLnkgKTtcblx0XHRcdFx0XHRcdFx0cGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKFxuXHRcdFx0XHRcdFx0XHRcdHJ4LFxuXHRcdFx0XHRcdFx0XHRcdHJ5LFxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnggKyBudW1iZXJzWyBqICsgMCBdLFxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnkgKyBudW1iZXJzWyBqICsgMSBdXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueCA9IHJ4O1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSByeTtcblx0XHRcdFx0XHRcdFx0cG9pbnQueCA9IHBvaW50LnggKyBudW1iZXJzWyBqICsgMCBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC55ID0gcG9pbnQueSArIG51bWJlcnNbIGogKyAxIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2EnOlxuXHRcdFx0XHRcdFx0dmFyIG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSA3ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIHNraXAgY29tbWFuZCBpZiBubyBkaXNwbGFjZW1lbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBudW1iZXJzWyBqICsgNSBdID09IDAgJiYgbnVtYmVyc1sgaiArIDYgXSA9PSAwICkgY29udGludWU7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHN0YXJ0ID0gcG9pbnQuY2xvbmUoKTtcblx0XHRcdFx0XHRcdFx0cG9pbnQueCArPSBudW1iZXJzWyBqICsgNSBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC55ICs9IG51bWJlcnNbIGogKyA2IF07XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueCA9IHBvaW50Lng7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IHBvaW50Lnk7XG5cdFx0XHRcdFx0XHRcdHBhcnNlQXJjQ29tbWFuZChcblx0XHRcdFx0XHRcdFx0XHRwYXRoLCBudW1iZXJzWyBqIF0sIG51bWJlcnNbIGogKyAxIF0sIG51bWJlcnNbIGogKyAyIF0sIG51bWJlcnNbIGogKyAzIF0sIG51bWJlcnNbIGogKyA0IF0sIHN0YXJ0LCBwb2ludFxuXHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUgKSBmaXJzdFBvaW50LmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdaJzpcblx0XHRcdFx0XHRjYXNlICd6Jzpcblx0XHRcdFx0XHRcdHBhdGguY3VycmVudFBhdGguYXV0b0Nsb3NlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0aWYgKCBwYXRoLmN1cnJlbnRQYXRoLmN1cnZlcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFJlc2V0IHBvaW50IHRvIGJlZ2lubmluZyBvZiBQYXRoXG5cdFx0XHRcdFx0XHRcdHBvaW50LmNvcHkoIGZpcnN0UG9pbnQgKTtcblx0XHRcdFx0XHRcdFx0cGF0aC5jdXJyZW50UGF0aC5jdXJyZW50UG9pbnQuY29weSggcG9pbnQgKTtcblx0XHRcdFx0XHRcdFx0aXNGaXJzdFBvaW50ID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oIGNvbW1hbmQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY29uc29sZS5sb2coIHR5cGUsIHBhcnNlRmxvYXRzKCBkYXRhICksIHBhcnNlRmxvYXRzKCBkYXRhICkubGVuZ3RoICApXG5cblx0XHRcdFx0ZG9TZXRGaXJzdFBvaW50ID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHBhdGg7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUNTU1N0eWxlc2hlZXQoIG5vZGUgKSB7XG5cblx0XHRcdGlmICggISBub2RlLnNoZWV0IHx8ICEgbm9kZS5zaGVldC5jc3NSdWxlcyB8fCAhIG5vZGUuc2hlZXQuY3NzUnVsZXMubGVuZ3RoICkgcmV0dXJuO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBub2RlLnNoZWV0LmNzc1J1bGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgc3R5bGVzaGVldCA9IG5vZGUuc2hlZXQuY3NzUnVsZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIHN0eWxlc2hlZXQudHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHZhciBzZWxlY3Rvckxpc3QgPSBzdHlsZXNoZWV0LnNlbGVjdG9yVGV4dFxuXHRcdFx0XHRcdC5zcGxpdCggLywvZ20gKVxuXHRcdFx0XHRcdC5maWx0ZXIoIEJvb2xlYW4gKVxuXHRcdFx0XHRcdC5tYXAoIGkgPT4gaS50cmltKCkgKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBzZWxlY3Rvckxpc3QubGVuZ3RoOyBqICsrICkge1xuXG5cdFx0XHRcdFx0c3R5bGVzaGVldHNbIHNlbGVjdG9yTGlzdFsgaiBdIF0gPSBPYmplY3QuYXNzaWduKFxuXHRcdFx0XHRcdFx0c3R5bGVzaGVldHNbIHNlbGVjdG9yTGlzdFsgaiBdIF0gfHwge30sXG5cdFx0XHRcdFx0XHRzdHlsZXNoZWV0LnN0eWxlXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcvaW1wbG5vdGUuaHRtbCNBcmNJbXBsZW1lbnRhdGlvbk5vdGVzXG5cdFx0ICogaHR0cHM6Ly9tb3J0b3JheS5jb20vMjAxNy8wMi8xNi9yZW5kZXJpbmctYW4tc3ZnLWVsbGlwdGljYWwtYXJjLWFzLWJlemllci1jdXJ2ZXMvIEFwcGVuZGl4OiBFbmRwb2ludCB0byBjZW50ZXIgYXJjIGNvbnZlcnNpb25cblx0XHQgKiBGcm9tXG5cdFx0ICogcnggcnkgeC1heGlzLXJvdGF0aW9uIGxhcmdlLWFyYy1mbGFnIHN3ZWVwLWZsYWcgeCB5XG5cdFx0ICogVG9cblx0XHQgKiBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvblxuXHRcdCAqL1xuXG5cdFx0ZnVuY3Rpb24gcGFyc2VBcmNDb21tYW5kKCBwYXRoLCByeCwgcnksIHhfYXhpc19yb3RhdGlvbiwgbGFyZ2VfYXJjX2ZsYWcsIHN3ZWVwX2ZsYWcsIHN0YXJ0LCBlbmQgKSB7XG5cblx0XHRcdGlmICggcnggPT0gMCB8fCByeSA9PSAwICkge1xuXG5cdFx0XHRcdC8vIGRyYXcgYSBsaW5lIGlmIGVpdGhlciBvZiB0aGUgcmFkaWkgPT0gMFxuXHRcdFx0XHRwYXRoLmxpbmVUbyggZW5kLngsIGVuZC55ICk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0XHR4X2F4aXNfcm90YXRpb24gPSB4X2F4aXNfcm90YXRpb24gKiBNYXRoLlBJIC8gMTgwO1xuXG5cdFx0XHQvLyBFbnN1cmUgcmFkaWkgYXJlIHBvc2l0aXZlXG5cdFx0XHRyeCA9IE1hdGguYWJzKCByeCApO1xuXHRcdFx0cnkgPSBNYXRoLmFicyggcnkgKTtcblxuXHRcdFx0Ly8gQ29tcHV0ZSAoeDEnLCB5MScpXG5cdFx0XHR2YXIgZHgyID0gKCBzdGFydC54IC0gZW5kLnggKSAvIDIuMDtcblx0XHRcdHZhciBkeTIgPSAoIHN0YXJ0LnkgLSBlbmQueSApIC8gMi4wO1xuXHRcdFx0dmFyIHgxcCA9IE1hdGguY29zKCB4X2F4aXNfcm90YXRpb24gKSAqIGR4MiArIE1hdGguc2luKCB4X2F4aXNfcm90YXRpb24gKSAqIGR5Mjtcblx0XHRcdHZhciB5MXAgPSAtIE1hdGguc2luKCB4X2F4aXNfcm90YXRpb24gKSAqIGR4MiArIE1hdGguY29zKCB4X2F4aXNfcm90YXRpb24gKSAqIGR5MjtcblxuXHRcdFx0Ly8gQ29tcHV0ZSAoY3gnLCBjeScpXG5cdFx0XHR2YXIgcnhzID0gcnggKiByeDtcblx0XHRcdHZhciByeXMgPSByeSAqIHJ5O1xuXHRcdFx0dmFyIHgxcHMgPSB4MXAgKiB4MXA7XG5cdFx0XHR2YXIgeTFwcyA9IHkxcCAqIHkxcDtcblxuXHRcdFx0Ly8gRW5zdXJlIHJhZGlpIGFyZSBsYXJnZSBlbm91Z2hcblx0XHRcdHZhciBjciA9IHgxcHMgLyByeHMgKyB5MXBzIC8gcnlzO1xuXG5cdFx0XHRpZiAoIGNyID4gMSApIHtcblxuXHRcdFx0XHQvLyBzY2FsZSB1cCByeCxyeSBlcXVhbGx5IHNvIGNyID09IDFcblx0XHRcdFx0dmFyIHMgPSBNYXRoLnNxcnQoIGNyICk7XG5cdFx0XHRcdHJ4ID0gcyAqIHJ4O1xuXHRcdFx0XHRyeSA9IHMgKiByeTtcblx0XHRcdFx0cnhzID0gcnggKiByeDtcblx0XHRcdFx0cnlzID0gcnkgKiByeTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZHEgPSAoIHJ4cyAqIHkxcHMgKyByeXMgKiB4MXBzICk7XG5cdFx0XHR2YXIgcHEgPSAoIHJ4cyAqIHJ5cyAtIGRxICkgLyBkcTtcblx0XHRcdHZhciBxID0gTWF0aC5zcXJ0KCBNYXRoLm1heCggMCwgcHEgKSApO1xuXHRcdFx0aWYgKCBsYXJnZV9hcmNfZmxhZyA9PT0gc3dlZXBfZmxhZyApIHEgPSAtIHE7XG5cdFx0XHR2YXIgY3hwID0gcSAqIHJ4ICogeTFwIC8gcnk7XG5cdFx0XHR2YXIgY3lwID0gLSBxICogcnkgKiB4MXAgLyByeDtcblxuXHRcdFx0Ly8gU3RlcCAzOiBDb21wdXRlIChjeCwgY3kpIGZyb20gKGN4JywgY3knKVxuXHRcdFx0dmFyIGN4ID0gTWF0aC5jb3MoIHhfYXhpc19yb3RhdGlvbiApICogY3hwIC0gTWF0aC5zaW4oIHhfYXhpc19yb3RhdGlvbiApICogY3lwICsgKCBzdGFydC54ICsgZW5kLnggKSAvIDI7XG5cdFx0XHR2YXIgY3kgPSBNYXRoLnNpbiggeF9heGlzX3JvdGF0aW9uICkgKiBjeHAgKyBNYXRoLmNvcyggeF9heGlzX3JvdGF0aW9uICkgKiBjeXAgKyAoIHN0YXJ0LnkgKyBlbmQueSApIC8gMjtcblxuXHRcdFx0Ly8gU3RlcCA0OiBDb21wdXRlIM64MSBhbmQgzpTOuFxuXHRcdFx0dmFyIHRoZXRhID0gc3ZnQW5nbGUoIDEsIDAsICggeDFwIC0gY3hwICkgLyByeCwgKCB5MXAgLSBjeXAgKSAvIHJ5ICk7XG5cdFx0XHR2YXIgZGVsdGEgPSBzdmdBbmdsZSggKCB4MXAgLSBjeHAgKSAvIHJ4LCAoIHkxcCAtIGN5cCApIC8gcnksICggLSB4MXAgLSBjeHAgKSAvIHJ4LCAoIC0geTFwIC0gY3lwICkgLyByeSApICUgKCBNYXRoLlBJICogMiApO1xuXG5cdFx0XHRwYXRoLmN1cnJlbnRQYXRoLmFic2VsbGlwc2UoIGN4LCBjeSwgcngsIHJ5LCB0aGV0YSwgdGhldGEgKyBkZWx0YSwgc3dlZXBfZmxhZyA9PT0gMCwgeF9heGlzX3JvdGF0aW9uICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzdmdBbmdsZSggdXgsIHV5LCB2eCwgdnkgKSB7XG5cblx0XHRcdHZhciBkb3QgPSB1eCAqIHZ4ICsgdXkgKiB2eTtcblx0XHRcdHZhciBsZW4gPSBNYXRoLnNxcnQoIHV4ICogdXggKyB1eSAqIHV5ICkgKiBNYXRoLnNxcnQoIHZ4ICogdnggKyB2eSAqIHZ5ICk7XG5cdFx0XHR2YXIgYW5nID0gTWF0aC5hY29zKCBNYXRoLm1heCggLSAxLCBNYXRoLm1pbiggMSwgZG90IC8gbGVuICkgKSApOyAvLyBmbG9hdGluZyBwb2ludCBwcmVjaXNpb24sIHNsaWdodGx5IG92ZXIgdmFsdWVzIGFwcGVhclxuXHRcdFx0aWYgKCAoIHV4ICogdnkgLSB1eSAqIHZ4ICkgPCAwICkgYW5nID0gLSBhbmc7XG5cdFx0XHRyZXR1cm4gYW5nO1xuXG5cdFx0fVxuXG5cdFx0Lypcblx0XHQqIEFjY29yZGluZyB0byBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI1JlY3RFbGVtZW50UlhBdHRyaWJ1dGVcblx0XHQqIHJvdW5kZWQgY29ybmVyIHNob3VsZCBiZSByZW5kZXJlZCB0byBlbGxpcHRpY2FsIGFyYywgYnV0IGJlemllciBjdXJ2ZSBkb2VzIHRoZSBqb2Igd2VsbCBlbm91Z2hcblx0XHQqL1xuXHRcdGZ1bmN0aW9uIHBhcnNlUmVjdE5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdHZhciB4ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICd4JyApIHx8IDAgKTtcblx0XHRcdHZhciB5ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICd5JyApIHx8IDAgKTtcblx0XHRcdHZhciByeCA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAncngnICkgfHwgMCApO1xuXHRcdFx0dmFyIHJ5ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICdyeScgKSB8fCAwICk7XG5cdFx0XHR2YXIgdyA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAnd2lkdGgnICkgKTtcblx0XHRcdHZhciBoID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICdoZWlnaHQnICkgKTtcblxuXHRcdFx0dmFyIHBhdGggPSBuZXcgU2hhcGVQYXRoKCk7XG5cdFx0XHRwYXRoLm1vdmVUbyggeCArIDIgKiByeCwgeSApO1xuXHRcdFx0cGF0aC5saW5lVG8oIHggKyB3IC0gMiAqIHJ4LCB5ICk7XG5cdFx0XHRpZiAoIHJ4ICE9PSAwIHx8IHJ5ICE9PSAwICkgcGF0aC5iZXppZXJDdXJ2ZVRvKCB4ICsgdywgeSwgeCArIHcsIHksIHggKyB3LCB5ICsgMiAqIHJ5ICk7XG5cdFx0XHRwYXRoLmxpbmVUbyggeCArIHcsIHkgKyBoIC0gMiAqIHJ5ICk7XG5cdFx0XHRpZiAoIHJ4ICE9PSAwIHx8IHJ5ICE9PSAwICkgcGF0aC5iZXppZXJDdXJ2ZVRvKCB4ICsgdywgeSArIGgsIHggKyB3LCB5ICsgaCwgeCArIHcgLSAyICogcngsIHkgKyBoICk7XG5cdFx0XHRwYXRoLmxpbmVUbyggeCArIDIgKiByeCwgeSArIGggKTtcblxuXHRcdFx0aWYgKCByeCAhPT0gMCB8fCByeSAhPT0gMCApIHtcblxuXHRcdFx0XHRwYXRoLmJlemllckN1cnZlVG8oIHgsIHkgKyBoLCB4LCB5ICsgaCwgeCwgeSArIGggLSAyICogcnkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRwYXRoLmxpbmVUbyggeCwgeSArIDIgKiByeSApO1xuXG5cdFx0XHRpZiAoIHJ4ICE9PSAwIHx8IHJ5ICE9PSAwICkge1xuXG5cdFx0XHRcdHBhdGguYmV6aWVyQ3VydmVUbyggeCwgeSwgeCwgeSwgeCArIDIgKiByeCwgeSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwYXRoO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VQb2x5Z29uTm9kZSggbm9kZSApIHtcblxuXHRcdFx0ZnVuY3Rpb24gaXRlcmF0b3IoIG1hdGNoLCBhLCBiICkge1xuXG5cdFx0XHRcdHZhciB4ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggYSApO1xuXHRcdFx0XHR2YXIgeSA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIGIgKTtcblxuXHRcdFx0XHRpZiAoIGluZGV4ID09PSAwICkge1xuXG5cdFx0XHRcdFx0cGF0aC5tb3ZlVG8oIHgsIHkgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cGF0aC5saW5lVG8oIHgsIHkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aW5kZXggKys7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHJlZ2V4ID0gLygtP1tcXGRcXC4/XSspWyx8XFxzXSgtP1tcXGRcXC4/XSspL2c7XG5cblx0XHRcdHZhciBwYXRoID0gbmV3IFNoYXBlUGF0aCgpO1xuXG5cdFx0XHR2YXIgaW5kZXggPSAwO1xuXG5cdFx0XHRub2RlLmdldEF0dHJpYnV0ZSggJ3BvaW50cycgKS5yZXBsYWNlKCByZWdleCwgaXRlcmF0b3IgKTtcblxuXHRcdFx0cGF0aC5jdXJyZW50UGF0aC5hdXRvQ2xvc2UgPSB0cnVlO1xuXG5cdFx0XHRyZXR1cm4gcGF0aDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlUG9seWxpbmVOb2RlKCBub2RlICkge1xuXG5cdFx0XHRmdW5jdGlvbiBpdGVyYXRvciggbWF0Y2gsIGEsIGIgKSB7XG5cblx0XHRcdFx0dmFyIHggPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBhICk7XG5cdFx0XHRcdHZhciB5ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggYiApO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPT09IDAgKSB7XG5cblx0XHRcdFx0XHRwYXRoLm1vdmVUbyggeCwgeSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRwYXRoLmxpbmVUbyggeCwgeSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpbmRleCArKztcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcmVnZXggPSAvKC0/W1xcZFxcLj9dKylbLHxcXHNdKC0/W1xcZFxcLj9dKykvZztcblxuXHRcdFx0dmFyIHBhdGggPSBuZXcgU2hhcGVQYXRoKCk7XG5cblx0XHRcdHZhciBpbmRleCA9IDA7XG5cblx0XHRcdG5vZGUuZ2V0QXR0cmlidXRlKCAncG9pbnRzJyApLnJlcGxhY2UoIHJlZ2V4LCBpdGVyYXRvciApO1xuXG5cdFx0XHRwYXRoLmN1cnJlbnRQYXRoLmF1dG9DbG9zZSA9IGZhbHNlO1xuXG5cdFx0XHRyZXR1cm4gcGF0aDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlQ2lyY2xlTm9kZSggbm9kZSApIHtcblxuXHRcdFx0dmFyIHggPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ2N4JyApICk7XG5cdFx0XHR2YXIgeSA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAnY3knICkgKTtcblx0XHRcdHZhciByID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICdyJyApICk7XG5cblx0XHRcdHZhciBzdWJwYXRoID0gbmV3IFBhdGgoKTtcblx0XHRcdHN1YnBhdGguYWJzYXJjKCB4LCB5LCByLCAwLCBNYXRoLlBJICogMiApO1xuXG5cdFx0XHR2YXIgcGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcblx0XHRcdHBhdGguc3ViUGF0aHMucHVzaCggc3VicGF0aCApO1xuXG5cdFx0XHRyZXR1cm4gcGF0aDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlRWxsaXBzZU5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdHZhciB4ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICdjeCcgKSApO1xuXHRcdFx0dmFyIHkgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ2N5JyApICk7XG5cdFx0XHR2YXIgcnggPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ3J4JyApICk7XG5cdFx0XHR2YXIgcnkgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ3J5JyApICk7XG5cblx0XHRcdHZhciBzdWJwYXRoID0gbmV3IFBhdGgoKTtcblx0XHRcdHN1YnBhdGguYWJzZWxsaXBzZSggeCwgeSwgcngsIHJ5LCAwLCBNYXRoLlBJICogMiApO1xuXG5cdFx0XHR2YXIgcGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcblx0XHRcdHBhdGguc3ViUGF0aHMucHVzaCggc3VicGF0aCApO1xuXG5cdFx0XHRyZXR1cm4gcGF0aDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlTGluZU5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdHZhciB4MSA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAneDEnICkgKTtcblx0XHRcdHZhciB5MSA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAneTEnICkgKTtcblx0XHRcdHZhciB4MiA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAneDInICkgKTtcblx0XHRcdHZhciB5MiA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAneTInICkgKTtcblxuXHRcdFx0dmFyIHBhdGggPSBuZXcgU2hhcGVQYXRoKCk7XG5cdFx0XHRwYXRoLm1vdmVUbyggeDEsIHkxICk7XG5cdFx0XHRwYXRoLmxpbmVUbyggeDIsIHkyICk7XG5cdFx0XHRwYXRoLmN1cnJlbnRQYXRoLmF1dG9DbG9zZSA9IGZhbHNlO1xuXG5cdFx0XHRyZXR1cm4gcGF0aDtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRmdW5jdGlvbiBwYXJzZVN0eWxlKCBub2RlLCBzdHlsZSApIHtcblxuXHRcdFx0c3R5bGUgPSBPYmplY3QuYXNzaWduKCB7fSwgc3R5bGUgKTsgLy8gY2xvbmUgc3R5bGVcblxuXHRcdFx0dmFyIHN0eWxlc2hlZXRTdHlsZXMgPSB7fTtcblxuXHRcdFx0aWYgKCBub2RlLmhhc0F0dHJpYnV0ZSggJ2NsYXNzJyApICkge1xuXG5cdFx0XHRcdHZhciBjbGFzc1NlbGVjdG9ycyA9IG5vZGUuZ2V0QXR0cmlidXRlKCAnY2xhc3MnIClcblx0XHRcdFx0XHQuc3BsaXQoIC9cXHMvIClcblx0XHRcdFx0XHQuZmlsdGVyKCBCb29sZWFuIClcblx0XHRcdFx0XHQubWFwKCBpID0+IGkudHJpbSgpICk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgY2xhc3NTZWxlY3RvcnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0c3R5bGVzaGVldFN0eWxlcyA9IE9iamVjdC5hc3NpZ24oIHN0eWxlc2hlZXRTdHlsZXMsIHN0eWxlc2hlZXRzWyAnLicgKyBjbGFzc1NlbGVjdG9yc1sgaSBdIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBub2RlLmhhc0F0dHJpYnV0ZSggJ2lkJyApICkge1xuXG5cdFx0XHRcdHN0eWxlc2hlZXRTdHlsZXMgPSBPYmplY3QuYXNzaWduKCBzdHlsZXNoZWV0U3R5bGVzLCBzdHlsZXNoZWV0c1sgJyMnICsgbm9kZS5nZXRBdHRyaWJ1dGUoICdpZCcgKSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYWRkU3R5bGUoIHN2Z05hbWUsIGpzTmFtZSwgYWRqdXN0RnVuY3Rpb24gKSB7XG5cblx0XHRcdFx0aWYgKCBhZGp1c3RGdW5jdGlvbiA9PT0gdW5kZWZpbmVkICkgYWRqdXN0RnVuY3Rpb24gPSBmdW5jdGlvbiBjb3B5KCB2ICkge1xuXG5cdFx0XHRcdFx0aWYgKCB2LnN0YXJ0c1dpdGgoICd1cmwnICkgKSBjb25zb2xlLndhcm4oICdTVkdMb2FkZXI6IHVybCBhY2Nlc3MgaW4gYXR0cmlidXRlcyBpcyBub3QgaW1wbGVtZW50ZWQuJyApO1xuXG5cdFx0XHRcdFx0cmV0dXJuIHY7XG5cblx0XHRcdFx0fTtcblxuXHRcdFx0XHRpZiAoIG5vZGUuaGFzQXR0cmlidXRlKCBzdmdOYW1lICkgKSBzdHlsZVsganNOYW1lIF0gPSBhZGp1c3RGdW5jdGlvbiggbm9kZS5nZXRBdHRyaWJ1dGUoIHN2Z05hbWUgKSApO1xuXHRcdFx0XHRpZiAoIHN0eWxlc2hlZXRTdHlsZXNbIHN2Z05hbWUgXSApIHN0eWxlWyBqc05hbWUgXSA9IGFkanVzdEZ1bmN0aW9uKCBzdHlsZXNoZWV0U3R5bGVzWyBzdmdOYW1lIF0gKTtcblx0XHRcdFx0aWYgKCBub2RlLnN0eWxlICYmIG5vZGUuc3R5bGVbIHN2Z05hbWUgXSAhPT0gJycgKSBzdHlsZVsganNOYW1lIF0gPSBhZGp1c3RGdW5jdGlvbiggbm9kZS5zdHlsZVsgc3ZnTmFtZSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gY2xhbXAoIHYgKSB7XG5cblx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KCAwLCBNYXRoLm1pbiggMSwgcGFyc2VGbG9hdFdpdGhVbml0cyggdiApICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBwb3NpdGl2ZSggdiApIHtcblxuXHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoIDAsIHBhcnNlRmxvYXRXaXRoVW5pdHMoIHYgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGFkZFN0eWxlKCAnZmlsbCcsICdmaWxsJyApO1xuXHRcdFx0YWRkU3R5bGUoICdmaWxsLW9wYWNpdHknLCAnZmlsbE9wYWNpdHknLCBjbGFtcCApO1xuXHRcdFx0YWRkU3R5bGUoICdvcGFjaXR5JywgJ29wYWNpdHknLCBjbGFtcCApO1xuXHRcdFx0YWRkU3R5bGUoICdzdHJva2UnLCAnc3Ryb2tlJyApO1xuXHRcdFx0YWRkU3R5bGUoICdzdHJva2Utb3BhY2l0eScsICdzdHJva2VPcGFjaXR5JywgY2xhbXAgKTtcblx0XHRcdGFkZFN0eWxlKCAnc3Ryb2tlLXdpZHRoJywgJ3N0cm9rZVdpZHRoJywgcG9zaXRpdmUgKTtcblx0XHRcdGFkZFN0eWxlKCAnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cm9rZUxpbmVKb2luJyApO1xuXHRcdFx0YWRkU3R5bGUoICdzdHJva2UtbGluZWNhcCcsICdzdHJva2VMaW5lQ2FwJyApO1xuXHRcdFx0YWRkU3R5bGUoICdzdHJva2UtbWl0ZXJsaW1pdCcsICdzdHJva2VNaXRlckxpbWl0JywgcG9zaXRpdmUgKTtcblx0XHRcdGFkZFN0eWxlKCAndmlzaWJpbGl0eScsICd2aXNpYmlsaXR5JyApO1xuXG5cdFx0XHRyZXR1cm4gc3R5bGU7XG5cblx0XHR9XG5cblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9pbXBsbm90ZS5odG1sI1BhdGhFbGVtZW50SW1wbGVtZW50YXRpb25Ob3Rlc1xuXG5cdFx0ZnVuY3Rpb24gZ2V0UmVmbGVjdGlvbiggYSwgYiApIHtcblxuXHRcdFx0cmV0dXJuIGEgLSAoIGIgLSBhICk7XG5cblx0XHR9XG5cblx0XHQvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9wcHZnL3N2Zy1udW1iZXJzIChNSVQgTGljZW5zZSlcblxuXHRcdGZ1bmN0aW9uIHBhcnNlRmxvYXRzKCBpbnB1dCApIHtcblxuXHRcdFx0aWYgKCB0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdJbnZhbGlkIGlucHV0OiAnICsgdHlwZW9mIGlucHV0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hhcmFjdGVyIGdyb3Vwc1xuXHRcdFx0dmFyIFJFID0ge1xuXHRcdFx0XHRTRVBBUkFUT1I6IC9bIFxcdFxcclxcblxcLC5cXC0rXS8sXG5cdFx0XHRcdFdISVRFU1BBQ0U6IC9bIFxcdFxcclxcbl0vLFxuXHRcdFx0XHRESUdJVDogL1tcXGRdLyxcblx0XHRcdFx0U0lHTjogL1stK10vLFxuXHRcdFx0XHRQT0lOVDogL1xcLi8sXG5cdFx0XHRcdENPTU1BOiAvLC8sXG5cdFx0XHRcdEVYUDogL2UvaVxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gU3RhdGVzXG5cdFx0XHR2YXIgU0VQID0gMDtcblx0XHRcdHZhciBJTlQgPSAxO1xuXHRcdFx0dmFyIEZMT0FUID0gMjtcblx0XHRcdHZhciBFWFAgPSAzO1xuXG5cdFx0XHR2YXIgc3RhdGUgPSBTRVA7XG5cdFx0XHR2YXIgc2VlbkNvbW1hID0gdHJ1ZTtcblx0XHRcdHZhciByZXN1bHQgPSBbXSwgbnVtYmVyID0gJycsIGV4cG9uZW50ID0gJyc7XG5cblx0XHRcdGZ1bmN0aW9uIHRocm93U3ludGF4RXJyb3IoIGN1cnJlbnQsIGksIHBhcnRpYWwgKSB7XG5cblx0XHRcdFx0dmFyIGVycm9yID0gbmV3IFN5bnRheEVycm9yKCAnVW5leHBlY3RlZCBjaGFyYWN0ZXIgXCInICsgY3VycmVudCArICdcIiBhdCBpbmRleCAnICsgaSArICcuJyApO1xuXHRcdFx0XHRlcnJvci5wYXJ0aWFsID0gcGFydGlhbDtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gbmV3TnVtYmVyKCkge1xuXG5cdFx0XHRcdGlmICggbnVtYmVyICE9PSAnJyApIHtcblxuXHRcdFx0XHRcdGlmICggZXhwb25lbnQgPT09ICcnICkgcmVzdWx0LnB1c2goIE51bWJlciggbnVtYmVyICkgKTtcblx0XHRcdFx0XHRlbHNlIHJlc3VsdC5wdXNoKCBOdW1iZXIoIG51bWJlciApICogTWF0aC5wb3coIDEwLCBOdW1iZXIoIGV4cG9uZW50ICkgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRudW1iZXIgPSAnJztcblx0XHRcdFx0ZXhwb25lbnQgPSAnJztcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY3VycmVudCwgaSA9IDAsIGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBpbnB1dFsgaSBdO1xuXG5cdFx0XHRcdC8vIHBhcnNlIHVudGlsIG5leHQgbnVtYmVyXG5cdFx0XHRcdGlmICggc3RhdGUgPT09IFNFUCApIHtcblxuXHRcdFx0XHRcdC8vIGVhdCB3aGl0ZXNwYWNlXG5cdFx0XHRcdFx0aWYgKCBSRS5XSElURVNQQUNFLnRlc3QoIGN1cnJlbnQgKSApIHtcblxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBzdGFydCBuZXcgbnVtYmVyXG5cdFx0XHRcdFx0aWYgKCBSRS5ESUdJVC50ZXN0KCBjdXJyZW50ICkgfHwgUkUuU0lHTi50ZXN0KCBjdXJyZW50ICkgKSB7XG5cblx0XHRcdFx0XHRcdHN0YXRlID0gSU5UO1xuXHRcdFx0XHRcdFx0bnVtYmVyID0gY3VycmVudDtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBSRS5QT0lOVC50ZXN0KCBjdXJyZW50ICkgKSB7XG5cblx0XHRcdFx0XHRcdHN0YXRlID0gRkxPQVQ7XG5cdFx0XHRcdFx0XHRudW1iZXIgPSBjdXJyZW50O1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyB0aHJvdyBvbiBkb3VibGUgY29tbWFzIChlLmcuIFwiMSwgLCAyXCIpXG5cdFx0XHRcdFx0aWYgKCBSRS5DT01NQS50ZXN0KCBjdXJyZW50ICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggc2VlbkNvbW1hICkge1xuXG5cdFx0XHRcdFx0XHRcdHRocm93U3ludGF4RXJyb3IoIGN1cnJlbnQsIGksIHJlc3VsdCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHNlZW5Db21tYSA9IHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHBhcnNlIGludGVnZXIgcGFydFxuXHRcdFx0XHRpZiAoIHN0YXRlID09PSBJTlQgKSB7XG5cblx0XHRcdFx0XHRpZiAoIFJFLkRJR0lULnRlc3QoIGN1cnJlbnQgKSApIHtcblxuXHRcdFx0XHRcdFx0bnVtYmVyICs9IGN1cnJlbnQ7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggUkUuUE9JTlQudGVzdCggY3VycmVudCApICkge1xuXG5cdFx0XHRcdFx0XHRudW1iZXIgKz0gY3VycmVudDtcblx0XHRcdFx0XHRcdHN0YXRlID0gRkxPQVQ7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggUkUuRVhQLnRlc3QoIGN1cnJlbnQgKSApIHtcblxuXHRcdFx0XHRcdFx0c3RhdGUgPSBFWFA7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIHRocm93IG9uIGRvdWJsZSBzaWducyAoXCItKzFcIiksIGJ1dCBub3Qgb24gc2lnbiBhcyBzZXBhcmF0b3IgKFwiLTEtMlwiKVxuXHRcdFx0XHRcdGlmICggUkUuU0lHTi50ZXN0KCBjdXJyZW50IClcblx0XHRcdFx0XHRcdFx0JiYgbnVtYmVyLmxlbmd0aCA9PT0gMVxuXHRcdFx0XHRcdFx0XHQmJiBSRS5TSUdOLnRlc3QoIG51bWJlclsgMCBdICkgKSB7XG5cblx0XHRcdFx0XHRcdHRocm93U3ludGF4RXJyb3IoIGN1cnJlbnQsIGksIHJlc3VsdCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBwYXJzZSBkZWNpbWFsIHBhcnRcblx0XHRcdFx0aWYgKCBzdGF0ZSA9PT0gRkxPQVQgKSB7XG5cblx0XHRcdFx0XHRpZiAoIFJFLkRJR0lULnRlc3QoIGN1cnJlbnQgKSApIHtcblxuXHRcdFx0XHRcdFx0bnVtYmVyICs9IGN1cnJlbnQ7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggUkUuRVhQLnRlc3QoIGN1cnJlbnQgKSApIHtcblxuXHRcdFx0XHRcdFx0c3RhdGUgPSBFWFA7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIHRocm93IG9uIGRvdWJsZSBkZWNpbWFsIHBvaW50cyAoZS5nLiBcIjEuLjJcIilcblx0XHRcdFx0XHRpZiAoIFJFLlBPSU5ULnRlc3QoIGN1cnJlbnQgKSAmJiBudW1iZXJbIG51bWJlci5sZW5ndGggLSAxIF0gPT09ICcuJyApIHtcblxuXHRcdFx0XHRcdFx0dGhyb3dTeW50YXhFcnJvciggY3VycmVudCwgaSwgcmVzdWx0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHBhcnNlIGV4cG9uZW50IHBhcnRcblx0XHRcdFx0aWYgKCBzdGF0ZSA9PSBFWFAgKSB7XG5cblx0XHRcdFx0XHRpZiAoIFJFLkRJR0lULnRlc3QoIGN1cnJlbnQgKSApIHtcblxuXHRcdFx0XHRcdFx0ZXhwb25lbnQgKz0gY3VycmVudDtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBSRS5TSUdOLnRlc3QoIGN1cnJlbnQgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBleHBvbmVudCA9PT0gJycgKSB7XG5cblx0XHRcdFx0XHRcdFx0ZXhwb25lbnQgKz0gY3VycmVudDtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCBleHBvbmVudC5sZW5ndGggPT09IDEgJiYgUkUuU0lHTi50ZXN0KCBleHBvbmVudCApICkge1xuXG5cdFx0XHRcdFx0XHRcdHRocm93U3ludGF4RXJyb3IoIGN1cnJlbnQsIGksIHJlc3VsdCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cblx0XHRcdFx0Ly8gZW5kIG9mIG51bWJlclxuXHRcdFx0XHRpZiAoIFJFLldISVRFU1BBQ0UudGVzdCggY3VycmVudCApICkge1xuXG5cdFx0XHRcdFx0bmV3TnVtYmVyKCk7XG5cdFx0XHRcdFx0c3RhdGUgPSBTRVA7XG5cdFx0XHRcdFx0c2VlbkNvbW1hID0gZmFsc2U7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggUkUuQ09NTUEudGVzdCggY3VycmVudCApICkge1xuXG5cdFx0XHRcdFx0bmV3TnVtYmVyKCk7XG5cdFx0XHRcdFx0c3RhdGUgPSBTRVA7XG5cdFx0XHRcdFx0c2VlbkNvbW1hID0gdHJ1ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBSRS5TSUdOLnRlc3QoIGN1cnJlbnQgKSApIHtcblxuXHRcdFx0XHRcdG5ld051bWJlcigpO1xuXHRcdFx0XHRcdHN0YXRlID0gSU5UO1xuXHRcdFx0XHRcdG51bWJlciA9IGN1cnJlbnQ7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggUkUuUE9JTlQudGVzdCggY3VycmVudCApICkge1xuXG5cdFx0XHRcdFx0bmV3TnVtYmVyKCk7XG5cdFx0XHRcdFx0c3RhdGUgPSBGTE9BVDtcblx0XHRcdFx0XHRudW1iZXIgPSBjdXJyZW50O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aHJvd1N5bnRheEVycm9yKCBjdXJyZW50LCBpLCByZXN1bHQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gYWRkIHRoZSBsYXN0IG51bWJlciBmb3VuZCAoaWYgYW55KVxuXHRcdFx0bmV3TnVtYmVyKCk7XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHR9XG5cblx0XHQvLyBVbml0c1xuXG5cdFx0dmFyIHVuaXRzID0gWyAnbW0nLCAnY20nLCAnaW4nLCAncHQnLCAncGMnLCAncHgnIF07XG5cblx0XHQvLyBDb252ZXJzaW9uOiBbIGZyb21Vbml0IF1bIHRvVW5pdCBdICgtMSBtZWFucyBkcGkgZGVwZW5kZW50KVxuXHRcdHZhciB1bml0Q29udmVyc2lvbiA9IHtcblxuXHRcdFx0J21tJzoge1xuXHRcdFx0XHQnbW0nOiAxLFxuXHRcdFx0XHQnY20nOiAwLjEsXG5cdFx0XHRcdCdpbic6IDEgLyAyNS40LFxuXHRcdFx0XHQncHQnOiA3MiAvIDI1LjQsXG5cdFx0XHRcdCdwYyc6IDYgLyAyNS40LFxuXHRcdFx0XHQncHgnOiAtIDFcblx0XHRcdH0sXG5cdFx0XHQnY20nOiB7XG5cdFx0XHRcdCdtbSc6IDEwLFxuXHRcdFx0XHQnY20nOiAxLFxuXHRcdFx0XHQnaW4nOiAxIC8gMi41NCxcblx0XHRcdFx0J3B0JzogNzIgLyAyLjU0LFxuXHRcdFx0XHQncGMnOiA2IC8gMi41NCxcblx0XHRcdFx0J3B4JzogLSAxXG5cdFx0XHR9LFxuXHRcdFx0J2luJzoge1xuXHRcdFx0XHQnbW0nOiAyNS40LFxuXHRcdFx0XHQnY20nOiAyLjU0LFxuXHRcdFx0XHQnaW4nOiAxLFxuXHRcdFx0XHQncHQnOiA3Mixcblx0XHRcdFx0J3BjJzogNixcblx0XHRcdFx0J3B4JzogLSAxXG5cdFx0XHR9LFxuXHRcdFx0J3B0Jzoge1xuXHRcdFx0XHQnbW0nOiAyNS40IC8gNzIsXG5cdFx0XHRcdCdjbSc6IDIuNTQgLyA3Mixcblx0XHRcdFx0J2luJzogMSAvIDcyLFxuXHRcdFx0XHQncHQnOiAxLFxuXHRcdFx0XHQncGMnOiA2IC8gNzIsXG5cdFx0XHRcdCdweCc6IC0gMVxuXHRcdFx0fSxcblx0XHRcdCdwYyc6IHtcblx0XHRcdFx0J21tJzogMjUuNCAvIDYsXG5cdFx0XHRcdCdjbSc6IDIuNTQgLyA2LFxuXHRcdFx0XHQnaW4nOiAxIC8gNixcblx0XHRcdFx0J3B0JzogNzIgLyA2LFxuXHRcdFx0XHQncGMnOiAxLFxuXHRcdFx0XHQncHgnOiAtIDFcblx0XHRcdH0sXG5cdFx0XHQncHgnOiB7XG5cdFx0XHRcdCdweCc6IDFcblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBwYXJzZUZsb2F0V2l0aFVuaXRzKCBzdHJpbmcgKSB7XG5cblx0XHRcdHZhciB0aGVVbml0ID0gJ3B4JztcblxuXHRcdFx0aWYgKCB0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJyB8fCBzdHJpbmcgaW5zdGFuY2VvZiBTdHJpbmcgKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gdW5pdHMubGVuZ3RoOyBpIDwgbjsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciB1ID0gdW5pdHNbIGkgXTtcblxuXHRcdFx0XHRcdGlmICggc3RyaW5nLmVuZHNXaXRoKCB1ICkgKSB7XG5cblx0XHRcdFx0XHRcdHRoZVVuaXQgPSB1O1xuXHRcdFx0XHRcdFx0c3RyaW5nID0gc3RyaW5nLnN1YnN0cmluZyggMCwgc3RyaW5nLmxlbmd0aCAtIHUubGVuZ3RoICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHNjYWxlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIHRoZVVuaXQgPT09ICdweCcgJiYgc2NvcGUuZGVmYXVsdFVuaXQgIT09ICdweCcgKSB7XG5cblx0XHRcdFx0Ly8gQ29udmVyc2lvbiBzY2FsZSBmcm9tICBwaXhlbHMgdG8gaW5jaGVzLCB0aGVuIHRvIGRlZmF1bHQgdW5pdHNcblxuXHRcdFx0XHRzY2FsZSA9IHVuaXRDb252ZXJzaW9uWyAnaW4nIF1bIHNjb3BlLmRlZmF1bHRVbml0IF0gLyBzY29wZS5kZWZhdWx0RFBJO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHNjYWxlID0gdW5pdENvbnZlcnNpb25bIHRoZVVuaXQgXVsgc2NvcGUuZGVmYXVsdFVuaXQgXTtcblxuXHRcdFx0XHRpZiAoIHNjYWxlIDwgMCApIHtcblxuXHRcdFx0XHRcdC8vIENvbnZlcnNpb24gc2NhbGUgdG8gcGl4ZWxzXG5cblx0XHRcdFx0XHRzY2FsZSA9IHVuaXRDb252ZXJzaW9uWyB0aGVVbml0IF1bICdpbicgXSAqIHNjb3BlLmRlZmF1bHREUEk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzY2FsZSAqIHBhcnNlRmxvYXQoIHN0cmluZyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gVHJhbnNmb3Jtc1xuXG5cdFx0ZnVuY3Rpb24gZ2V0Tm9kZVRyYW5zZm9ybSggbm9kZSApIHtcblxuXHRcdFx0aWYgKCAhICggbm9kZS5oYXNBdHRyaWJ1dGUoICd0cmFuc2Zvcm0nICkgfHwgKCBub2RlLm5vZGVOYW1lID09PSAndXNlJyAmJiAoIG5vZGUuaGFzQXR0cmlidXRlKCAneCcgKSB8fCBub2RlLmhhc0F0dHJpYnV0ZSggJ3knICkgKSApICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHRyYW5zZm9ybSA9IHBhcnNlTm9kZVRyYW5zZm9ybSggbm9kZSApO1xuXG5cdFx0XHRpZiAoIHRyYW5zZm9ybVN0YWNrLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0dHJhbnNmb3JtLnByZW11bHRpcGx5KCB0cmFuc2Zvcm1TdGFja1sgdHJhbnNmb3JtU3RhY2subGVuZ3RoIC0gMSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y3VycmVudFRyYW5zZm9ybS5jb3B5KCB0cmFuc2Zvcm0gKTtcblx0XHRcdHRyYW5zZm9ybVN0YWNrLnB1c2goIHRyYW5zZm9ybSApO1xuXG5cdFx0XHRyZXR1cm4gdHJhbnNmb3JtO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VOb2RlVHJhbnNmb3JtKCBub2RlICkge1xuXG5cdFx0XHR2YXIgdHJhbnNmb3JtID0gbmV3IE1hdHJpeDMoKTtcblx0XHRcdHZhciBjdXJyZW50VHJhbnNmb3JtID0gdGVtcFRyYW5zZm9ybTA7XG5cblx0XHRcdGlmICggbm9kZS5ub2RlTmFtZSA9PT0gJ3VzZScgJiYgKCBub2RlLmhhc0F0dHJpYnV0ZSggJ3gnICkgfHwgbm9kZS5oYXNBdHRyaWJ1dGUoICd5JyApICkgKSB7XG5cblx0XHRcdFx0dmFyIHR4ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICd4JyApICk7XG5cdFx0XHRcdHZhciB0eSA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAneScgKSApO1xuXG5cdFx0XHRcdHRyYW5zZm9ybS50cmFuc2xhdGUoIHR4LCB0eSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbm9kZS5oYXNBdHRyaWJ1dGUoICd0cmFuc2Zvcm0nICkgKSB7XG5cblx0XHRcdFx0dmFyIHRyYW5zZm9ybXNUZXh0cyA9IG5vZGUuZ2V0QXR0cmlidXRlKCAndHJhbnNmb3JtJyApLnNwbGl0KCAnKScgKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgdEluZGV4ID0gdHJhbnNmb3Jtc1RleHRzLmxlbmd0aCAtIDE7IHRJbmRleCA+PSAwOyB0SW5kZXggLS0gKSB7XG5cblx0XHRcdFx0XHR2YXIgdHJhbnNmb3JtVGV4dCA9IHRyYW5zZm9ybXNUZXh0c1sgdEluZGV4IF0udHJpbSgpO1xuXG5cdFx0XHRcdFx0aWYgKCB0cmFuc2Zvcm1UZXh0ID09PSAnJyApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0dmFyIG9wZW5QYXJQb3MgPSB0cmFuc2Zvcm1UZXh0LmluZGV4T2YoICcoJyApO1xuXHRcdFx0XHRcdHZhciBjbG9zZVBhclBvcyA9IHRyYW5zZm9ybVRleHQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0aWYgKCBvcGVuUGFyUG9zID4gMCAmJiBvcGVuUGFyUG9zIDwgY2xvc2VQYXJQb3MgKSB7XG5cblx0XHRcdFx0XHRcdHZhciB0cmFuc2Zvcm1UeXBlID0gdHJhbnNmb3JtVGV4dC5zdWJzdHIoIDAsIG9wZW5QYXJQb3MgKTtcblxuXHRcdFx0XHRcdFx0dmFyIGFycmF5ID0gcGFyc2VGbG9hdHMoIHRyYW5zZm9ybVRleHQuc3Vic3RyKCBvcGVuUGFyUG9zICsgMSwgY2xvc2VQYXJQb3MgLSBvcGVuUGFyUG9zIC0gMSApICk7XG5cblx0XHRcdFx0XHRcdGN1cnJlbnRUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcblxuXHRcdFx0XHRcdFx0c3dpdGNoICggdHJhbnNmb3JtVHlwZSApIHtcblxuXHRcdFx0XHRcdFx0XHRjYXNlICd0cmFuc2xhdGUnOlxuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBhcnJheS5sZW5ndGggPj0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHR4ID0gYXJyYXlbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciB0eSA9IHR4O1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGFycmF5Lmxlbmd0aCA+PSAyICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5ID0gYXJyYXlbIDEgXTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50VHJhbnNmb3JtLnRyYW5zbGF0ZSggdHgsIHR5ICk7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlICdyb3RhdGUnOlxuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBhcnJheS5sZW5ndGggPj0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGFuZ2xlID0gMDtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBjeCA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgY3kgPSAwO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBBbmdsZVxuXHRcdFx0XHRcdFx0XHRcdFx0YW5nbGUgPSAtIGFycmF5WyAwIF0gKiBNYXRoLlBJIC8gMTgwO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGFycmF5Lmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENlbnRlciB4LCB5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGN4ID0gYXJyYXlbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y3kgPSBhcnJheVsgMiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJvdGF0ZSBhcm91bmQgY2VudGVyIChjeCwgY3kpXG5cdFx0XHRcdFx0XHRcdFx0XHR0ZW1wVHJhbnNmb3JtMS5pZGVudGl0eSgpLnRyYW5zbGF0ZSggLSBjeCwgLSBjeSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0dGVtcFRyYW5zZm9ybTIuaWRlbnRpdHkoKS5yb3RhdGUoIGFuZ2xlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR0ZW1wVHJhbnNmb3JtMy5tdWx0aXBseU1hdHJpY2VzKCB0ZW1wVHJhbnNmb3JtMiwgdGVtcFRyYW5zZm9ybTEgKTtcblx0XHRcdFx0XHRcdFx0XHRcdHRlbXBUcmFuc2Zvcm0xLmlkZW50aXR5KCkudHJhbnNsYXRlKCBjeCwgY3kgKTtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRUcmFuc2Zvcm0ubXVsdGlwbHlNYXRyaWNlcyggdGVtcFRyYW5zZm9ybTEsIHRlbXBUcmFuc2Zvcm0zICk7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlICdzY2FsZSc6XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGFycmF5Lmxlbmd0aCA+PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgc2NhbGVYID0gYXJyYXlbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBzY2FsZVkgPSBzY2FsZVg7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggYXJyYXkubGVuZ3RoID49IDIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0c2NhbGVZID0gYXJyYXlbIDEgXTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50VHJhbnNmb3JtLnNjYWxlKCBzY2FsZVgsIHNjYWxlWSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAnc2tld1gnOlxuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBhcnJheS5sZW5ndGggPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRUcmFuc2Zvcm0uc2V0KFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQxLCBNYXRoLnRhbiggYXJyYXlbIDAgXSAqIE1hdGguUEkgLyAxODAgKSwgMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0MCwgMSwgMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0MCwgMCwgMVxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3NrZXdZJzpcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggYXJyYXkubGVuZ3RoID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50VHJhbnNmb3JtLnNldChcblx0XHRcdFx0XHRcdFx0XHRcdFx0MSwgMCwgMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0TWF0aC50YW4oIGFycmF5WyAwIF0gKiBNYXRoLlBJIC8gMTgwICksIDEsIDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDAsIDAsIDFcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlICdtYXRyaXgnOlxuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBhcnJheS5sZW5ndGggPT09IDYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRUcmFuc2Zvcm0uc2V0KFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhcnJheVsgMCBdLCBhcnJheVsgMiBdLCBhcnJheVsgNCBdLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhcnJheVsgMSBdLCBhcnJheVsgMyBdLCBhcnJheVsgNSBdLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQwLCAwLCAxXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRyYW5zZm9ybS5wcmVtdWx0aXBseSggY3VycmVudFRyYW5zZm9ybSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJhbnNmb3JtO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJhbnNmb3JtUGF0aCggcGF0aCwgbSApIHtcblxuXHRcdFx0ZnVuY3Rpb24gdHJhbnNmVmVjMiggdjIgKSB7XG5cblx0XHRcdFx0dGVtcFYzLnNldCggdjIueCwgdjIueSwgMSApLmFwcGx5TWF0cml4MyggbSApO1xuXG5cdFx0XHRcdHYyLnNldCggdGVtcFYzLngsIHRlbXBWMy55ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGlzUm90YXRlZCA9IGlzVHJhbnNmb3JtUm90YXRlZCggbSApO1xuXG5cdFx0XHR2YXIgc3ViUGF0aHMgPSBwYXRoLnN1YlBhdGhzO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBzdWJQYXRocy5sZW5ndGg7IGkgPCBuOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBzdWJQYXRoID0gc3ViUGF0aHNbIGkgXTtcblx0XHRcdFx0dmFyIGN1cnZlcyA9IHN1YlBhdGguY3VydmVzO1xuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IGN1cnZlcy5sZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgY3VydmUgPSBjdXJ2ZXNbIGogXTtcblxuXHRcdFx0XHRcdGlmICggY3VydmUuaXNMaW5lQ3VydmUgKSB7XG5cblx0XHRcdFx0XHRcdHRyYW5zZlZlYzIoIGN1cnZlLnYxICk7XG5cdFx0XHRcdFx0XHR0cmFuc2ZWZWMyKCBjdXJ2ZS52MiApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VydmUuaXNDdWJpY0JlemllckN1cnZlICkge1xuXG5cdFx0XHRcdFx0XHR0cmFuc2ZWZWMyKCBjdXJ2ZS52MCApO1xuXHRcdFx0XHRcdFx0dHJhbnNmVmVjMiggY3VydmUudjEgKTtcblx0XHRcdFx0XHRcdHRyYW5zZlZlYzIoIGN1cnZlLnYyICk7XG5cdFx0XHRcdFx0XHR0cmFuc2ZWZWMyKCBjdXJ2ZS52MyApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VydmUuaXNRdWFkcmF0aWNCZXppZXJDdXJ2ZSApIHtcblxuXHRcdFx0XHRcdFx0dHJhbnNmVmVjMiggY3VydmUudjAgKTtcblx0XHRcdFx0XHRcdHRyYW5zZlZlYzIoIGN1cnZlLnYxICk7XG5cdFx0XHRcdFx0XHR0cmFuc2ZWZWMyKCBjdXJ2ZS52MiApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VydmUuaXNFbGxpcHNlQ3VydmUgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggaXNSb3RhdGVkICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1NWR0xvYWRlcjogRWxsaXB0aWMgYXJjIG9yIGVsbGlwc2Ugcm90YXRpb24gb3Igc2tld2luZyBpcyBub3QgaW1wbGVtZW50ZWQuJyApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHRlbXBWMi5zZXQoIGN1cnZlLmFYLCBjdXJ2ZS5hWSApO1xuXHRcdFx0XHRcdFx0dHJhbnNmVmVjMiggdGVtcFYyICk7XG5cdFx0XHRcdFx0XHRjdXJ2ZS5hWCA9IHRlbXBWMi54O1xuXHRcdFx0XHRcdFx0Y3VydmUuYVkgPSB0ZW1wVjIueTtcblxuXHRcdFx0XHRcdFx0Y3VydmUueFJhZGl1cyAqPSBnZXRUcmFuc2Zvcm1TY2FsZVgoIG0gKTtcblx0XHRcdFx0XHRcdGN1cnZlLnlSYWRpdXMgKj0gZ2V0VHJhbnNmb3JtU2NhbGVZKCBtICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc1RyYW5zZm9ybVJvdGF0ZWQoIG0gKSB7XG5cblx0XHRcdHJldHVybiBtLmVsZW1lbnRzWyAxIF0gIT09IDAgfHwgbS5lbGVtZW50c1sgMyBdICE9PSAwO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0VHJhbnNmb3JtU2NhbGVYKCBtICkge1xuXG5cdFx0XHR2YXIgdGUgPSBtLmVsZW1lbnRzO1xuXHRcdFx0cmV0dXJuIE1hdGguc3FydCggdGVbIDAgXSAqIHRlWyAwIF0gKyB0ZVsgMSBdICogdGVbIDEgXSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0VHJhbnNmb3JtU2NhbGVZKCBtICkge1xuXG5cdFx0XHR2YXIgdGUgPSBtLmVsZW1lbnRzO1xuXHRcdFx0cmV0dXJuIE1hdGguc3FydCggdGVbIDMgXSAqIHRlWyAzIF0gKyB0ZVsgNCBdICogdGVbIDQgXSApO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdHZhciBwYXRocyA9IFtdO1xuXHRcdHZhciBzdHlsZXNoZWV0cyA9IHt9O1xuXG5cdFx0dmFyIHRyYW5zZm9ybVN0YWNrID0gW107XG5cblx0XHR2YXIgdGVtcFRyYW5zZm9ybTAgPSBuZXcgTWF0cml4MygpO1xuXHRcdHZhciB0ZW1wVHJhbnNmb3JtMSA9IG5ldyBNYXRyaXgzKCk7XG5cdFx0dmFyIHRlbXBUcmFuc2Zvcm0yID0gbmV3IE1hdHJpeDMoKTtcblx0XHR2YXIgdGVtcFRyYW5zZm9ybTMgPSBuZXcgTWF0cml4MygpO1xuXHRcdHZhciB0ZW1wVjIgPSBuZXcgVmVjdG9yMigpO1xuXHRcdHZhciB0ZW1wVjMgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0dmFyIGN1cnJlbnRUcmFuc2Zvcm0gPSBuZXcgTWF0cml4MygpO1xuXG5cdFx0dmFyIHhtbCA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoIHRleHQsICdpbWFnZS9zdmcreG1sJyApOyAvLyBhcHBsaWNhdGlvbi94bWxcblxuXHRcdHBhcnNlTm9kZSggeG1sLmRvY3VtZW50RWxlbWVudCwge1xuXHRcdFx0ZmlsbDogJyMwMDAnLFxuXHRcdFx0ZmlsbE9wYWNpdHk6IDEsXG5cdFx0XHRzdHJva2VPcGFjaXR5OiAxLFxuXHRcdFx0c3Ryb2tlV2lkdGg6IDEsXG5cdFx0XHRzdHJva2VMaW5lSm9pbjogJ21pdGVyJyxcblx0XHRcdHN0cm9rZUxpbmVDYXA6ICdidXR0Jyxcblx0XHRcdHN0cm9rZU1pdGVyTGltaXQ6IDRcblx0XHR9ICk7XG5cblx0XHR2YXIgZGF0YSA9IHsgcGF0aHM6IHBhdGhzLCB4bWw6IHhtbC5kb2N1bWVudEVsZW1lbnQgfTtcblxuXHRcdC8vIGNvbnNvbGUubG9nKCBwYXRocyApO1xuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxufSApO1xuXG5TVkdMb2FkZXIuZ2V0U3Ryb2tlU3R5bGUgPSBmdW5jdGlvbiAoIHdpZHRoLCBjb2xvciwgbGluZUpvaW4sIGxpbmVDYXAsIG1pdGVyTGltaXQgKSB7XG5cblx0Ly8gUGFyYW0gd2lkdGg6IFN0cm9rZSB3aWR0aFxuXHQvLyBQYXJhbSBjb2xvcjogQXMgcmV0dXJuZWQgYnkgVEhSRUUuQ29sb3IuZ2V0U3R5bGUoKVxuXHQvLyBQYXJhbSBsaW5lSm9pbjogT25lIG9mIFwicm91bmRcIiwgXCJiZXZlbFwiLCBcIm1pdGVyXCIgb3IgXCJtaXRlci1saW1pdFwiXG5cdC8vIFBhcmFtIGxpbmVDYXA6IE9uZSBvZiBcInJvdW5kXCIsIFwic3F1YXJlXCIgb3IgXCJidXR0XCJcblx0Ly8gUGFyYW0gbWl0ZXJMaW1pdDogTWF4aW11bSBqb2luIGxlbmd0aCwgaW4gbXVsdGlwbGVzIG9mIHRoZSBcIndpZHRoXCIgcGFyYW1ldGVyIChqb2luIGlzIHRydW5jYXRlZCBpZiBpdCBleGNlZWRzIHRoYXQgZGlzdGFuY2UpXG5cdC8vIFJldHVybnMgc3R5bGUgb2JqZWN0XG5cblx0d2lkdGggPSB3aWR0aCAhPT0gdW5kZWZpbmVkID8gd2lkdGggOiAxO1xuXHRjb2xvciA9IGNvbG9yICE9PSB1bmRlZmluZWQgPyBjb2xvciA6ICcjMDAwJztcblx0bGluZUpvaW4gPSBsaW5lSm9pbiAhPT0gdW5kZWZpbmVkID8gbGluZUpvaW4gOiAnbWl0ZXInO1xuXHRsaW5lQ2FwID0gbGluZUNhcCAhPT0gdW5kZWZpbmVkID8gbGluZUNhcCA6ICdidXR0Jztcblx0bWl0ZXJMaW1pdCA9IG1pdGVyTGltaXQgIT09IHVuZGVmaW5lZCA/IG1pdGVyTGltaXQgOiA0O1xuXG5cdHJldHVybiB7XG5cdFx0c3Ryb2tlQ29sb3I6IGNvbG9yLFxuXHRcdHN0cm9rZVdpZHRoOiB3aWR0aCxcblx0XHRzdHJva2VMaW5lSm9pbjogbGluZUpvaW4sXG5cdFx0c3Ryb2tlTGluZUNhcDogbGluZUNhcCxcblx0XHRzdHJva2VNaXRlckxpbWl0OiBtaXRlckxpbWl0XG5cdH07XG5cbn07XG5cblNWR0xvYWRlci5wb2ludHNUb1N0cm9rZSA9IGZ1bmN0aW9uICggcG9pbnRzLCBzdHlsZSwgYXJjRGl2aXNpb25zLCBtaW5EaXN0YW5jZSApIHtcblxuXHQvLyBHZW5lcmF0ZXMgYSBzdHJva2Ugd2l0aCBzb21lIHdpdGRoIGFyb3VuZCB0aGUgZ2l2ZW4gcGF0aC5cblx0Ly8gVGhlIHBhdGggY2FuIGJlIG9wZW4gb3IgY2xvc2VkIChsYXN0IHBvaW50IGVxdWFscyB0byBmaXJzdCBwb2ludClcblx0Ly8gUGFyYW0gcG9pbnRzOiBBcnJheSBvZiBWZWN0b3IyRCAodGhlIHBhdGgpLiBNaW5pbXVtIDIgcG9pbnRzLlxuXHQvLyBQYXJhbSBzdHlsZTogT2JqZWN0IHdpdGggU1ZHIHByb3BlcnRpZXMgYXMgcmV0dXJuZWQgYnkgU1ZHTG9hZGVyLmdldFN0cm9rZVN0eWxlKCksIG9yIFNWR0xvYWRlci5wYXJzZSgpIGluIHRoZSBwYXRoLnVzZXJEYXRhLnN0eWxlIG9iamVjdFxuXHQvLyBQYXJhbXMgYXJjRGl2aXNpb25zOiBBcmMgZGl2aXNpb25zIGZvciByb3VuZCBqb2lucyBhbmQgZW5kY2Fwcy4gKE9wdGlvbmFsKVxuXHQvLyBQYXJhbSBtaW5EaXN0YW5jZTogUG9pbnRzIGNsb3NlciB0byB0aGlzIGRpc3RhbmNlIHdpbGwgYmUgbWVyZ2VkLiAoT3B0aW9uYWwpXG5cdC8vIFJldHVybnMgQnVmZmVyR2VvbWV0cnkgd2l0aCBzdHJva2UgdHJpYW5nbGVzIChJbiBwbGFuZSB6ID0gMCkuIFVWIGNvb3JkaW5hdGVzIGFyZSBnZW5lcmF0ZWQgKCd1JyBhbG9uZyBwYXRoLiAndicgYWNyb3NzIGl0LCBmcm9tIGxlZnQgdG8gcmlnaHQpXG5cblx0dmFyIHZlcnRpY2VzID0gW107XG5cdHZhciBub3JtYWxzID0gW107XG5cdHZhciB1dnMgPSBbXTtcblxuXHRpZiAoIFNWR0xvYWRlci5wb2ludHNUb1N0cm9rZVdpdGhCdWZmZXJzKCBwb2ludHMsIHN0eWxlLCBhcmNEaXZpc2lvbnMsIG1pbkRpc3RhbmNlLCB2ZXJ0aWNlcywgbm9ybWFscywgdXZzICkgPT09IDAgKSB7XG5cblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9XG5cblx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG5cdHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuU1ZHTG9hZGVyLnBvaW50c1RvU3Ryb2tlV2l0aEJ1ZmZlcnMgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIHRlbXBWMl8xID0gbmV3IFZlY3RvcjIoKTtcblx0dmFyIHRlbXBWMl8yID0gbmV3IFZlY3RvcjIoKTtcblx0dmFyIHRlbXBWMl8zID0gbmV3IFZlY3RvcjIoKTtcblx0dmFyIHRlbXBWMl80ID0gbmV3IFZlY3RvcjIoKTtcblx0dmFyIHRlbXBWMl81ID0gbmV3IFZlY3RvcjIoKTtcblx0dmFyIHRlbXBWMl82ID0gbmV3IFZlY3RvcjIoKTtcblx0dmFyIHRlbXBWMl83ID0gbmV3IFZlY3RvcjIoKTtcblx0dmFyIGxhc3RQb2ludEwgPSBuZXcgVmVjdG9yMigpO1xuXHR2YXIgbGFzdFBvaW50UiA9IG5ldyBWZWN0b3IyKCk7XG5cdHZhciBwb2ludDBMID0gbmV3IFZlY3RvcjIoKTtcblx0dmFyIHBvaW50MFIgPSBuZXcgVmVjdG9yMigpO1xuXHR2YXIgY3VycmVudFBvaW50TCA9IG5ldyBWZWN0b3IyKCk7XG5cdHZhciBjdXJyZW50UG9pbnRSID0gbmV3IFZlY3RvcjIoKTtcblx0dmFyIG5leHRQb2ludEwgPSBuZXcgVmVjdG9yMigpO1xuXHR2YXIgbmV4dFBvaW50UiA9IG5ldyBWZWN0b3IyKCk7XG5cdHZhciBpbm5lclBvaW50ID0gbmV3IFZlY3RvcjIoKTtcblx0dmFyIG91dGVyUG9pbnQgPSBuZXcgVmVjdG9yMigpO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoIHBvaW50cywgc3R5bGUsIGFyY0RpdmlzaW9ucywgbWluRGlzdGFuY2UsIHZlcnRpY2VzLCBub3JtYWxzLCB1dnMsIHZlcnRleE9mZnNldCApIHtcblxuXHRcdC8vIFRoaXMgZnVuY3Rpb24gY2FuIGJlIGNhbGxlZCB0byB1cGRhdGUgZXhpc3RpbmcgYXJyYXlzIG9yIGJ1ZmZlcnMuXG5cdFx0Ly8gQWNjZXB0cyBzYW1lIHBhcmFtZXRlcnMgYXMgcG9pbnRzVG9TdHJva2UsIHBsdXMgdGhlIGJ1ZmZlcnMgYW5kIG9wdGlvbmFsIG9mZnNldC5cblx0XHQvLyBQYXJhbSB2ZXJ0ZXhPZmZzZXQ6IE9mZnNldCB2ZXJ0aWNlcyB0byBzdGFydCB3cml0aW5nIGluIHRoZSBidWZmZXJzICgzIGVsZW1lbnRzL3ZlcnRleCBmb3IgdmVydGljZXMgYW5kIG5vcm1hbHMsIGFuZCAyIGVsZW1lbnRzL3ZlcnRleCBmb3IgdXZzKVxuXHRcdC8vIFJldHVybnMgbnVtYmVyIG9mIHdyaXR0ZW4gdmVydGljZXMgLyBub3JtYWxzIC8gdXZzIHBhaXJzXG5cdFx0Ly8gaWYgJ3ZlcnRpY2VzJyBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkIG5vIHRyaWFuZ2xlcyB3aWxsIGJlIGdlbmVyYXRlZCwgYnV0IHRoZSByZXR1cm5lZCB2ZXJ0aWNlcyBjb3VudCB3aWxsIHN0aWxsIGJlIHZhbGlkICh1c2VmdWwgdG8gcHJlYWxsb2NhdGUgdGhlIGJ1ZmZlcnMpXG5cdFx0Ly8gJ25vcm1hbHMnIGFuZCAndXZzJyBidWZmZXJzIGFyZSBvcHRpb25hbFxuXG5cdFx0YXJjRGl2aXNpb25zID0gYXJjRGl2aXNpb25zICE9PSB1bmRlZmluZWQgPyBhcmNEaXZpc2lvbnMgOiAxMjtcblx0XHRtaW5EaXN0YW5jZSA9IG1pbkRpc3RhbmNlICE9PSB1bmRlZmluZWQgPyBtaW5EaXN0YW5jZSA6IDAuMDAxO1xuXHRcdHZlcnRleE9mZnNldCA9IHZlcnRleE9mZnNldCAhPT0gdW5kZWZpbmVkID8gdmVydGV4T2Zmc2V0IDogMDtcblxuXHRcdC8vIEZpcnN0IGVuc3VyZSB0aGVyZSBhcmUgbm8gZHVwbGljYXRlZCBwb2ludHNcblx0XHRwb2ludHMgPSByZW1vdmVEdXBsaWNhdGVkUG9pbnRzKCBwb2ludHMgKTtcblxuXHRcdHZhciBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuXG5cdFx0aWYgKCBudW1Qb2ludHMgPCAyICkgcmV0dXJuIDA7XG5cblx0XHR2YXIgaXNDbG9zZWQgPSBwb2ludHNbIDAgXS5lcXVhbHMoIHBvaW50c1sgbnVtUG9pbnRzIC0gMSBdICk7XG5cblx0XHR2YXIgY3VycmVudFBvaW50O1xuXHRcdHZhciBwcmV2aW91c1BvaW50ID0gcG9pbnRzWyAwIF07XG5cdFx0dmFyIG5leHRQb2ludDtcblxuXHRcdHZhciBzdHJva2VXaWR0aDIgPSBzdHlsZS5zdHJva2VXaWR0aCAvIDI7XG5cblx0XHR2YXIgZGVsdGFVID0gMSAvICggbnVtUG9pbnRzIC0gMSApO1xuXHRcdHZhciB1MCA9IDA7XG5cblx0XHR2YXIgaW5uZXJTaWRlTW9kaWZpZWQ7XG5cdFx0dmFyIGpvaW5Jc09uTGVmdFNpZGU7XG5cdFx0dmFyIGlzTWl0ZXI7XG5cdFx0dmFyIGluaXRpYWxKb2luSXNPbkxlZnRTaWRlID0gZmFsc2U7XG5cblx0XHR2YXIgbnVtVmVydGljZXMgPSAwO1xuXHRcdHZhciBjdXJyZW50Q29vcmRpbmF0ZSA9IHZlcnRleE9mZnNldCAqIDM7XG5cdFx0dmFyIGN1cnJlbnRDb29yZGluYXRlVVYgPSB2ZXJ0ZXhPZmZzZXQgKiAyO1xuXG5cdFx0Ly8gR2V0IGluaXRpYWwgbGVmdCBhbmQgcmlnaHQgc3Ryb2tlIHBvaW50c1xuXHRcdGdldE5vcm1hbCggcG9pbnRzWyAwIF0sIHBvaW50c1sgMSBdLCB0ZW1wVjJfMSApLm11bHRpcGx5U2NhbGFyKCBzdHJva2VXaWR0aDIgKTtcblx0XHRsYXN0UG9pbnRMLmNvcHkoIHBvaW50c1sgMCBdICkuc3ViKCB0ZW1wVjJfMSApO1xuXHRcdGxhc3RQb2ludFIuY29weSggcG9pbnRzWyAwIF0gKS5hZGQoIHRlbXBWMl8xICk7XG5cdFx0cG9pbnQwTC5jb3B5KCBsYXN0UG9pbnRMICk7XG5cdFx0cG9pbnQwUi5jb3B5KCBsYXN0UG9pbnRSICk7XG5cblx0XHRmb3IgKCB2YXIgaVBvaW50ID0gMTsgaVBvaW50IDwgbnVtUG9pbnRzOyBpUG9pbnQgKysgKSB7XG5cblx0XHRcdGN1cnJlbnRQb2ludCA9IHBvaW50c1sgaVBvaW50IF07XG5cblx0XHRcdC8vIEdldCBuZXh0IHBvaW50XG5cdFx0XHRpZiAoIGlQb2ludCA9PT0gbnVtUG9pbnRzIC0gMSApIHtcblxuXHRcdFx0XHRpZiAoIGlzQ2xvc2VkICkge1xuXG5cdFx0XHRcdFx0Ly8gU2tpcCBkdXBsaWNhdGVkIGluaXRpYWwgcG9pbnRcblx0XHRcdFx0XHRuZXh0UG9pbnQgPSBwb2ludHNbIDEgXTtcblxuXHRcdFx0XHR9IGVsc2UgbmV4dFBvaW50ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG5leHRQb2ludCA9IHBvaW50c1sgaVBvaW50ICsgMSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIE5vcm1hbCBvZiBwcmV2aW91cyBzZWdtZW50IGluIHRlbXBWMl8xXG5cdFx0XHR2YXIgbm9ybWFsMSA9IHRlbXBWMl8xO1xuXHRcdFx0Z2V0Tm9ybWFsKCBwcmV2aW91c1BvaW50LCBjdXJyZW50UG9pbnQsIG5vcm1hbDEgKTtcblxuXHRcdFx0dGVtcFYyXzMuY29weSggbm9ybWFsMSApLm11bHRpcGx5U2NhbGFyKCBzdHJva2VXaWR0aDIgKTtcblx0XHRcdGN1cnJlbnRQb2ludEwuY29weSggY3VycmVudFBvaW50ICkuc3ViKCB0ZW1wVjJfMyApO1xuXHRcdFx0Y3VycmVudFBvaW50Ui5jb3B5KCBjdXJyZW50UG9pbnQgKS5hZGQoIHRlbXBWMl8zICk7XG5cblx0XHRcdHZhciB1MSA9IHUwICsgZGVsdGFVO1xuXG5cdFx0XHRpbm5lclNpZGVNb2RpZmllZCA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoIG5leHRQb2ludCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIE5vcm1hbCBvZiBuZXh0IHNlZ21lbnQgaW4gdGVtcFYyXzJcblx0XHRcdFx0Z2V0Tm9ybWFsKCBjdXJyZW50UG9pbnQsIG5leHRQb2ludCwgdGVtcFYyXzIgKTtcblxuXHRcdFx0XHR0ZW1wVjJfMy5jb3B5KCB0ZW1wVjJfMiApLm11bHRpcGx5U2NhbGFyKCBzdHJva2VXaWR0aDIgKTtcblx0XHRcdFx0bmV4dFBvaW50TC5jb3B5KCBjdXJyZW50UG9pbnQgKS5zdWIoIHRlbXBWMl8zICk7XG5cdFx0XHRcdG5leHRQb2ludFIuY29weSggY3VycmVudFBvaW50ICkuYWRkKCB0ZW1wVjJfMyApO1xuXG5cdFx0XHRcdGpvaW5Jc09uTGVmdFNpZGUgPSB0cnVlO1xuXHRcdFx0XHR0ZW1wVjJfMy5zdWJWZWN0b3JzKCBuZXh0UG9pbnQsIHByZXZpb3VzUG9pbnQgKTtcblx0XHRcdFx0aWYgKCBub3JtYWwxLmRvdCggdGVtcFYyXzMgKSA8IDAgKSB7XG5cblx0XHRcdFx0XHRqb2luSXNPbkxlZnRTaWRlID0gZmFsc2U7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaVBvaW50ID09PSAxICkgaW5pdGlhbEpvaW5Jc09uTGVmdFNpZGUgPSBqb2luSXNPbkxlZnRTaWRlO1xuXG5cdFx0XHRcdHRlbXBWMl8zLnN1YlZlY3RvcnMoIG5leHRQb2ludCwgY3VycmVudFBvaW50ICk7XG5cdFx0XHRcdHRlbXBWMl8zLm5vcm1hbGl6ZSgpO1xuXHRcdFx0XHR2YXIgZG90ID0gTWF0aC5hYnMoIG5vcm1hbDEuZG90KCB0ZW1wVjJfMyApICk7XG5cblx0XHRcdFx0Ly8gSWYgcGF0aCBpcyBzdHJhaWdodCwgZG9uJ3QgY3JlYXRlIGpvaW5cblx0XHRcdFx0aWYgKCBkb3QgIT09IDAgKSB7XG5cblx0XHRcdFx0XHQvLyBDb21wdXRlIGlubmVyIGFuZCBvdXRlciBzZWdtZW50IGludGVyc2VjdGlvbnNcblx0XHRcdFx0XHR2YXIgbWl0ZXJTaWRlID0gc3Ryb2tlV2lkdGgyIC8gZG90O1xuXHRcdFx0XHRcdHRlbXBWMl8zLm11bHRpcGx5U2NhbGFyKCAtIG1pdGVyU2lkZSApO1xuXHRcdFx0XHRcdHRlbXBWMl80LnN1YlZlY3RvcnMoIGN1cnJlbnRQb2ludCwgcHJldmlvdXNQb2ludCApO1xuXHRcdFx0XHRcdHRlbXBWMl81LmNvcHkoIHRlbXBWMl80ICkuc2V0TGVuZ3RoKCBtaXRlclNpZGUgKS5hZGQoIHRlbXBWMl8zICk7XG5cdFx0XHRcdFx0aW5uZXJQb2ludC5jb3B5KCB0ZW1wVjJfNSApLm5lZ2F0ZSgpO1xuXHRcdFx0XHRcdHZhciBtaXRlckxlbmd0aDIgPSB0ZW1wVjJfNS5sZW5ndGgoKTtcblx0XHRcdFx0XHR2YXIgc2VnbWVudExlbmd0aFByZXYgPSB0ZW1wVjJfNC5sZW5ndGgoKTtcblx0XHRcdFx0XHR0ZW1wVjJfNC5kaXZpZGVTY2FsYXIoIHNlZ21lbnRMZW5ndGhQcmV2ICk7XG5cdFx0XHRcdFx0dGVtcFYyXzYuc3ViVmVjdG9ycyggbmV4dFBvaW50LCBjdXJyZW50UG9pbnQgKTtcblx0XHRcdFx0XHR2YXIgc2VnbWVudExlbmd0aE5leHQgPSB0ZW1wVjJfNi5sZW5ndGgoKTtcblx0XHRcdFx0XHR0ZW1wVjJfNi5kaXZpZGVTY2FsYXIoIHNlZ21lbnRMZW5ndGhOZXh0ICk7XG5cdFx0XHRcdFx0Ly8gQ2hlY2sgdGhhdCBwcmV2aW91cyBhbmQgbmV4dCBzZWdtZW50cyBkb2Vzbid0IG92ZXJsYXAgd2l0aCB0aGUgaW5uZXJQb2ludCBvZiBpbnRlcnNlY3Rpb25cblx0XHRcdFx0XHRpZiAoIHRlbXBWMl80LmRvdCggaW5uZXJQb2ludCApIDwgc2VnbWVudExlbmd0aFByZXYgJiYgdGVtcFYyXzYuZG90KCBpbm5lclBvaW50ICkgPCBzZWdtZW50TGVuZ3RoTmV4dCApIHtcblxuXHRcdFx0XHRcdFx0aW5uZXJTaWRlTW9kaWZpZWQgPSB0cnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0ZXJQb2ludC5jb3B5KCB0ZW1wVjJfNSApLmFkZCggY3VycmVudFBvaW50ICk7XG5cdFx0XHRcdFx0aW5uZXJQb2ludC5hZGQoIGN1cnJlbnRQb2ludCApO1xuXG5cdFx0XHRcdFx0aXNNaXRlciA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKCBpbm5lclNpZGVNb2RpZmllZCApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBqb2luSXNPbkxlZnRTaWRlICkge1xuXG5cdFx0XHRcdFx0XHRcdG5leHRQb2ludFIuY29weSggaW5uZXJQb2ludCApO1xuXHRcdFx0XHRcdFx0XHRjdXJyZW50UG9pbnRSLmNvcHkoIGlubmVyUG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRuZXh0UG9pbnRMLmNvcHkoIGlubmVyUG9pbnQgKTtcblx0XHRcdFx0XHRcdFx0Y3VycmVudFBvaW50TC5jb3B5KCBpbm5lclBvaW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFRoZSBzZWdtZW50IHRyaWFuZ2xlcyBhcmUgZ2VuZXJhdGVkIGhlcmUgaWYgdGhlcmUgd2FzIG92ZXJsYXBwaW5nXG5cblx0XHRcdFx0XHRcdG1ha2VTZWdtZW50VHJpYW5nbGVzKCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBzdHlsZS5zdHJva2VMaW5lSm9pbiApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnYmV2ZWwnOlxuXG5cdFx0XHRcdFx0XHRcdG1ha2VTZWdtZW50V2l0aEJldmVsSm9pbiggam9pbklzT25MZWZ0U2lkZSwgaW5uZXJTaWRlTW9kaWZpZWQsIHUxICk7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3JvdW5kJzpcblxuXHRcdFx0XHRcdFx0XHQvLyBTZWdtZW50IHRyaWFuZ2xlc1xuXG5cdFx0XHRcdFx0XHRcdGNyZWF0ZVNlZ21lbnRUcmlhbmdsZXNXaXRoTWlkZGxlU2VjdGlvbiggam9pbklzT25MZWZ0U2lkZSwgaW5uZXJTaWRlTW9kaWZpZWQgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBKb2luIHRyaWFuZ2xlc1xuXG5cdFx0XHRcdFx0XHRcdGlmICggam9pbklzT25MZWZ0U2lkZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdG1ha2VDaXJjdWxhclNlY3RvciggY3VycmVudFBvaW50LCBjdXJyZW50UG9pbnRMLCBuZXh0UG9pbnRMLCB1MSwgMCApO1xuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRtYWtlQ2lyY3VsYXJTZWN0b3IoIGN1cnJlbnRQb2ludCwgbmV4dFBvaW50UiwgY3VycmVudFBvaW50UiwgdTEsIDEgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ21pdGVyJzpcblx0XHRcdFx0XHRcdGNhc2UgJ21pdGVyLWNsaXAnOlxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdFx0XHR2YXIgbWl0ZXJGcmFjdGlvbiA9ICggc3Ryb2tlV2lkdGgyICogc3R5bGUuc3Ryb2tlTWl0ZXJMaW1pdCApIC8gbWl0ZXJMZW5ndGgyO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggbWl0ZXJGcmFjdGlvbiA8IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgam9pbiBtaXRlciBsZW5ndGggZXhjZWVkcyB0aGUgbWl0ZXIgbGltaXRcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggc3R5bGUuc3Ryb2tlTGluZUpvaW4gIT09ICdtaXRlci1jbGlwJyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0bWFrZVNlZ21lbnRXaXRoQmV2ZWxKb2luKCBqb2luSXNPbkxlZnRTaWRlLCBpbm5lclNpZGVNb2RpZmllZCwgdTEgKTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU2VnbWVudCB0cmlhbmdsZXNcblxuXHRcdFx0XHRcdFx0XHRcdFx0Y3JlYXRlU2VnbWVudFRyaWFuZ2xlc1dpdGhNaWRkbGVTZWN0aW9uKCBqb2luSXNPbkxlZnRTaWRlLCBpbm5lclNpZGVNb2RpZmllZCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBNaXRlci1jbGlwIGpvaW4gdHJpYW5nbGVzXG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggam9pbklzT25MZWZ0U2lkZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0ZW1wVjJfNi5zdWJWZWN0b3JzKCBvdXRlclBvaW50LCBjdXJyZW50UG9pbnRMICkubXVsdGlwbHlTY2FsYXIoIG1pdGVyRnJhY3Rpb24gKS5hZGQoIGN1cnJlbnRQb2ludEwgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGVtcFYyXzcuc3ViVmVjdG9ycyggb3V0ZXJQb2ludCwgbmV4dFBvaW50TCApLm11bHRpcGx5U2NhbGFyKCBtaXRlckZyYWN0aW9uICkuYWRkKCBuZXh0UG9pbnRMICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRMLCB1MSwgMCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIHRlbXBWMl82LCB1MSwgMCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludCwgdTEsIDAuNSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50LCB1MSwgMC41ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggdGVtcFYyXzYsIHUxLCAwICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggdGVtcFYyXzcsIHUxLCAwICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUxLCAwLjUgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCB0ZW1wVjJfNywgdTEsIDAgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBuZXh0UG9pbnRMLCB1MSwgMCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRlbXBWMl82LnN1YlZlY3RvcnMoIG91dGVyUG9pbnQsIGN1cnJlbnRQb2ludFIgKS5tdWx0aXBseVNjYWxhciggbWl0ZXJGcmFjdGlvbiApLmFkZCggY3VycmVudFBvaW50UiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0ZW1wVjJfNy5zdWJWZWN0b3JzKCBvdXRlclBvaW50LCBuZXh0UG9pbnRSICkubXVsdGlwbHlTY2FsYXIoIG1pdGVyRnJhY3Rpb24gKS5hZGQoIG5leHRQb2ludFIgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludFIsIHUxLCAxICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggdGVtcFYyXzYsIHUxLCAxICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50LCB1MSwgMC41ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUxLCAwLjUgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCB0ZW1wVjJfNiwgdTEsIDEgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCB0ZW1wVjJfNywgdTEsIDEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludCwgdTEsIDAuNSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIHRlbXBWMl83LCB1MSwgMSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG5leHRQb2ludFIsIHUxLCAxICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gTWl0ZXIgam9pbiBzZWdtZW50IHRyaWFuZ2xlc1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBpbm5lclNpZGVNb2RpZmllZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gT3B0aW1pemVkIHNlZ21lbnQgKyBqb2luIHRyaWFuZ2xlc1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpvaW5Jc09uTGVmdFNpZGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRSLCB1MCwgMSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludEwsIHUwLCAwICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggb3V0ZXJQb2ludCwgdTEsIDAgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludFIsIHUwLCAxICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggb3V0ZXJQb2ludCwgdTEsIDAgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBpbm5lclBvaW50LCB1MSwgMSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50UiwgdTAsIDEgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRMLCB1MCwgMCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG91dGVyUG9pbnQsIHUxLCAxICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRMLCB1MCwgMCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGlubmVyUG9pbnQsIHUxLCAwICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggb3V0ZXJQb2ludCwgdTEsIDEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggam9pbklzT25MZWZ0U2lkZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRuZXh0UG9pbnRMLmNvcHkoIG91dGVyUG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRuZXh0UG9pbnRSLmNvcHkoIG91dGVyUG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBBZGQgZXh0cmEgbWl0ZXIgam9pbiB0cmlhbmdsZXNcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqb2luSXNPbkxlZnRTaWRlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50TCwgdTEsIDAgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBvdXRlclBvaW50LCB1MSwgMCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludCwgdTEsIDAuNSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50LCB1MSwgMC41ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggb3V0ZXJQb2ludCwgdTEsIDAgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBuZXh0UG9pbnRMLCB1MSwgMCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50UiwgdTEsIDEgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBvdXRlclBvaW50LCB1MSwgMSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludCwgdTEsIDAuNSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50LCB1MSwgMC41ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggb3V0ZXJQb2ludCwgdTEsIDEgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBuZXh0UG9pbnRSLCB1MSwgMSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRpc01pdGVyID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIFRoZSBzZWdtZW50IHRyaWFuZ2xlcyBhcmUgZ2VuZXJhdGVkIGhlcmUgd2hlbiB0d28gY29uc2VjdXRpdmUgcG9pbnRzIGFyZSBjb2xsaW5lYXJcblxuXHRcdFx0XHRcdG1ha2VTZWdtZW50VHJpYW5nbGVzKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFRoZSBzZWdtZW50IHRyaWFuZ2xlcyBhcmUgZ2VuZXJhdGVkIGhlcmUgaWYgaXQgaXMgdGhlIGVuZGluZyBzZWdtZW50XG5cblx0XHRcdFx0bWFrZVNlZ21lbnRUcmlhbmdsZXMoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICEgaXNDbG9zZWQgJiYgaVBvaW50ID09PSBudW1Qb2ludHMgLSAxICkge1xuXG5cdFx0XHRcdC8vIFN0YXJ0IGxpbmUgZW5kY2FwXG5cdFx0XHRcdGFkZENhcEdlb21ldHJ5KCBwb2ludHNbIDAgXSwgcG9pbnQwTCwgcG9pbnQwUiwgam9pbklzT25MZWZ0U2lkZSwgdHJ1ZSwgdTAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZW1lbnQgbG9vcCB2YXJpYWJsZXNcblxuXHRcdFx0dTAgPSB1MTtcblxuXHRcdFx0cHJldmlvdXNQb2ludCA9IGN1cnJlbnRQb2ludDtcblxuXHRcdFx0bGFzdFBvaW50TC5jb3B5KCBuZXh0UG9pbnRMICk7XG5cdFx0XHRsYXN0UG9pbnRSLmNvcHkoIG5leHRQb2ludFIgKTtcblxuXHRcdH1cblxuXHRcdGlmICggISBpc0Nsb3NlZCApIHtcblxuXHRcdFx0Ly8gRW5kaW5nIGxpbmUgZW5kY2FwXG5cdFx0XHRhZGRDYXBHZW9tZXRyeSggY3VycmVudFBvaW50LCBjdXJyZW50UG9pbnRMLCBjdXJyZW50UG9pbnRSLCBqb2luSXNPbkxlZnRTaWRlLCBmYWxzZSwgdTEgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGlubmVyU2lkZU1vZGlmaWVkICYmIHZlcnRpY2VzICkge1xuXG5cdFx0XHQvLyBNb2RpZnkgcGF0aCBmaXJzdCBzZWdtZW50IHZlcnRpY2VzIHRvIGFkanVzdCB0byB0aGUgc2VnbWVudHMgaW5uZXIgYW5kIG91dGVyIGludGVyc2VjdGlvbnNcblxuXHRcdFx0dmFyIGxhc3RPdXRlciA9IG91dGVyUG9pbnQ7XG5cdFx0XHR2YXIgbGFzdElubmVyID0gaW5uZXJQb2ludDtcblxuXHRcdFx0aWYgKCBpbml0aWFsSm9pbklzT25MZWZ0U2lkZSAhPT0gam9pbklzT25MZWZ0U2lkZSApIHtcblxuXHRcdFx0XHRsYXN0T3V0ZXIgPSBpbm5lclBvaW50O1xuXHRcdFx0XHRsYXN0SW5uZXIgPSBvdXRlclBvaW50O1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggam9pbklzT25MZWZ0U2lkZSApIHtcblxuXHRcdFx0XHRpZiAoIGlzTWl0ZXIgfHwgaW5pdGlhbEpvaW5Jc09uTGVmdFNpZGUgKSB7XG5cblx0XHRcdFx0XHRsYXN0SW5uZXIudG9BcnJheSggdmVydGljZXMsIDAgKiAzICk7XG5cdFx0XHRcdFx0bGFzdElubmVyLnRvQXJyYXkoIHZlcnRpY2VzLCAzICogMyApO1xuXG5cdFx0XHRcdFx0aWYgKCBpc01pdGVyICkge1xuXG5cdFx0XHRcdFx0XHRsYXN0T3V0ZXIudG9BcnJheSggdmVydGljZXMsIDEgKiAzICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggaXNNaXRlciB8fCAhIGluaXRpYWxKb2luSXNPbkxlZnRTaWRlICkge1xuXG5cdFx0XHRcdFx0bGFzdElubmVyLnRvQXJyYXkoIHZlcnRpY2VzLCAxICogMyApO1xuXHRcdFx0XHRcdGxhc3RJbm5lci50b0FycmF5KCB2ZXJ0aWNlcywgMyAqIDMgKTtcblxuXHRcdFx0XHRcdGlmICggaXNNaXRlciApIHtcblxuXHRcdFx0XHRcdFx0bGFzdE91dGVyLnRvQXJyYXkoIHZlcnRpY2VzLCAwICogMyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bVZlcnRpY2VzO1xuXG5cdFx0Ly8gLS0gRW5kIG9mIGFsZ29yaXRobVxuXG5cdFx0Ly8gLS0gRnVuY3Rpb25zXG5cblx0XHRmdW5jdGlvbiBnZXROb3JtYWwoIHAxLCBwMiwgcmVzdWx0ICkge1xuXG5cdFx0XHRyZXN1bHQuc3ViVmVjdG9ycyggcDIsIHAxICk7XG5cdFx0XHRyZXR1cm4gcmVzdWx0LnNldCggLSByZXN1bHQueSwgcmVzdWx0LnggKS5ub3JtYWxpemUoKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZFZlcnRleCggcG9zaXRpb24sIHUsIHYgKSB7XG5cblx0XHRcdGlmICggdmVydGljZXMgKSB7XG5cblx0XHRcdFx0dmVydGljZXNbIGN1cnJlbnRDb29yZGluYXRlIF0gPSBwb3NpdGlvbi54O1xuXHRcdFx0XHR2ZXJ0aWNlc1sgY3VycmVudENvb3JkaW5hdGUgKyAxIF0gPSBwb3NpdGlvbi55O1xuXHRcdFx0XHR2ZXJ0aWNlc1sgY3VycmVudENvb3JkaW5hdGUgKyAyIF0gPSAwO1xuXG5cdFx0XHRcdGlmICggbm9ybWFscyApIHtcblxuXHRcdFx0XHRcdG5vcm1hbHNbIGN1cnJlbnRDb29yZGluYXRlIF0gPSAwO1xuXHRcdFx0XHRcdG5vcm1hbHNbIGN1cnJlbnRDb29yZGluYXRlICsgMSBdID0gMDtcblx0XHRcdFx0XHRub3JtYWxzWyBjdXJyZW50Q29vcmRpbmF0ZSArIDIgXSA9IDE7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGN1cnJlbnRDb29yZGluYXRlICs9IDM7XG5cblx0XHRcdFx0aWYgKCB1dnMgKSB7XG5cblx0XHRcdFx0XHR1dnNbIGN1cnJlbnRDb29yZGluYXRlVVYgXSA9IHU7XG5cdFx0XHRcdFx0dXZzWyBjdXJyZW50Q29vcmRpbmF0ZVVWICsgMSBdID0gdjtcblxuXHRcdFx0XHRcdGN1cnJlbnRDb29yZGluYXRlVVYgKz0gMjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0bnVtVmVydGljZXMgKz0gMztcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG1ha2VDaXJjdWxhclNlY3RvciggY2VudGVyLCBwMSwgcDIsIHUsIHYgKSB7XG5cblx0XHRcdC8vIHBhcmFtIHAxLCBwMjogUG9pbnRzIGluIHRoZSBjaXJjbGUgYXJjLlxuXHRcdFx0Ly8gcDEgYW5kIHAyIGFyZSBpbiBjbG9ja3dpc2UgZGlyZWN0aW9uLlxuXG5cdFx0XHR0ZW1wVjJfMS5jb3B5KCBwMSApLnN1YiggY2VudGVyICkubm9ybWFsaXplKCk7XG5cdFx0XHR0ZW1wVjJfMi5jb3B5KCBwMiApLnN1YiggY2VudGVyICkubm9ybWFsaXplKCk7XG5cblx0XHRcdHZhciBhbmdsZSA9IE1hdGguUEk7XG5cdFx0XHR2YXIgZG90ID0gdGVtcFYyXzEuZG90KCB0ZW1wVjJfMiApO1xuXHRcdFx0aWYgKCBNYXRoLmFicyggZG90ICkgPCAxICkgYW5nbGUgPSBNYXRoLmFicyggTWF0aC5hY29zKCBkb3QgKSApO1xuXG5cdFx0XHRhbmdsZSAvPSBhcmNEaXZpc2lvbnM7XG5cblx0XHRcdHRlbXBWMl8zLmNvcHkoIHAxICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBhcmNEaXZpc2lvbnMgLSAxOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0dGVtcFYyXzQuY29weSggdGVtcFYyXzMgKS5yb3RhdGVBcm91bmQoIGNlbnRlciwgYW5nbGUgKTtcblxuXHRcdFx0XHRhZGRWZXJ0ZXgoIHRlbXBWMl8zLCB1LCB2ICk7XG5cdFx0XHRcdGFkZFZlcnRleCggdGVtcFYyXzQsIHUsIHYgKTtcblx0XHRcdFx0YWRkVmVydGV4KCBjZW50ZXIsIHUsIDAuNSApO1xuXG5cdFx0XHRcdHRlbXBWMl8zLmNvcHkoIHRlbXBWMl80ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0YWRkVmVydGV4KCB0ZW1wVjJfNCwgdSwgdiApO1xuXHRcdFx0YWRkVmVydGV4KCBwMiwgdSwgdiApO1xuXHRcdFx0YWRkVmVydGV4KCBjZW50ZXIsIHUsIDAuNSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbWFrZVNlZ21lbnRUcmlhbmdsZXMoKSB7XG5cblx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50UiwgdTAsIDEgKTtcblx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50TCwgdTAsIDAgKTtcblx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50TCwgdTEsIDAgKTtcblxuXHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRSLCB1MCwgMSApO1xuXHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRMLCB1MSwgMSApO1xuXHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRSLCB1MSwgMCApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbWFrZVNlZ21lbnRXaXRoQmV2ZWxKb2luKCBqb2luSXNPbkxlZnRTaWRlLCBpbm5lclNpZGVNb2RpZmllZCwgdSApIHtcblxuXHRcdFx0aWYgKCBpbm5lclNpZGVNb2RpZmllZCApIHtcblxuXHRcdFx0XHQvLyBPcHRpbWl6ZWQgc2VnbWVudCArIGJldmVsIHRyaWFuZ2xlc1xuXG5cdFx0XHRcdGlmICggam9pbklzT25MZWZ0U2lkZSApIHtcblxuXHRcdFx0XHRcdC8vIFBhdGggc2VnbWVudHMgdHJpYW5nbGVzXG5cblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludFIsIHUwLCAxICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRMLCB1MCwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50TCwgdTEsIDAgKTtcblxuXHRcdFx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50UiwgdTAsIDEgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludEwsIHUxLCAwICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBpbm5lclBvaW50LCB1MSwgMSApO1xuXG5cdFx0XHRcdFx0Ly8gQmV2ZWwgam9pbiB0cmlhbmdsZVxuXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRMLCB1LCAwICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBuZXh0UG9pbnRMLCB1LCAwICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBpbm5lclBvaW50LCB1LCAwLjUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gUGF0aCBzZWdtZW50cyB0cmlhbmdsZXNcblxuXHRcdFx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50UiwgdTAsIDEgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludEwsIHUwLCAwICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRSLCB1MSwgMSApO1xuXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRMLCB1MCwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggaW5uZXJQb2ludCwgdTEsIDAgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludFIsIHUxLCAxICk7XG5cblx0XHRcdFx0XHQvLyBCZXZlbCBqb2luIHRyaWFuZ2xlXG5cblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludFIsIHUsIDEgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG5leHRQb2ludFIsIHUsIDAgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGlubmVyUG9pbnQsIHUsIDAuNSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBCZXZlbCBqb2luIHRyaWFuZ2xlLiBUaGUgc2VnbWVudCB0cmlhbmdsZXMgYXJlIGRvbmUgaW4gdGhlIG1haW4gbG9vcFxuXG5cdFx0XHRcdGlmICggam9pbklzT25MZWZ0U2lkZSApIHtcblxuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50TCwgdSwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggbmV4dFBvaW50TCwgdSwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50LCB1LCAwLjUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRSLCB1LCAxICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBuZXh0UG9pbnRSLCB1LCAwICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUsIDAuNSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY3JlYXRlU2VnbWVudFRyaWFuZ2xlc1dpdGhNaWRkbGVTZWN0aW9uKCBqb2luSXNPbkxlZnRTaWRlLCBpbm5lclNpZGVNb2RpZmllZCApIHtcblxuXHRcdFx0aWYgKCBpbm5lclNpZGVNb2RpZmllZCApIHtcblxuXHRcdFx0XHRpZiAoIGpvaW5Jc09uTGVmdFNpZGUgKSB7XG5cblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludFIsIHUwLCAxICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRMLCB1MCwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50TCwgdTEsIDAgKTtcblxuXHRcdFx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50UiwgdTAsIDEgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludEwsIHUxLCAwICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBpbm5lclBvaW50LCB1MSwgMSApO1xuXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRMLCB1MCwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50LCB1MSwgMC41ICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBpbm5lclBvaW50LCB1MSwgMSApO1xuXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUxLCAwLjUgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG5leHRQb2ludEwsIHUwLCAwICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBpbm5lclBvaW50LCB1MSwgMSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludFIsIHUwLCAxICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRMLCB1MCwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50UiwgdTEsIDEgKTtcblxuXHRcdFx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50TCwgdTAsIDAgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGlubmVyUG9pbnQsIHUxLCAwICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRSLCB1MSwgMSApO1xuXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRSLCB1MCwgMSApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggaW5uZXJQb2ludCwgdTEsIDAgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludCwgdTEsIDAuNSApO1xuXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUxLCAwLjUgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGlubmVyUG9pbnQsIHUxLCAwICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBuZXh0UG9pbnRSLCB1MCwgMSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWRkQ2FwR2VvbWV0cnkoIGNlbnRlciwgcDEsIHAyLCBqb2luSXNPbkxlZnRTaWRlLCBzdGFydCwgdSApIHtcblxuXHRcdFx0Ly8gcGFyYW0gY2VudGVyOiBFbmQgcG9pbnQgb2YgdGhlIHBhdGhcblx0XHRcdC8vIHBhcmFtIHAxLCBwMjogTGVmdCBhbmQgcmlnaHQgY2FwIHBvaW50c1xuXG5cdFx0XHRzd2l0Y2ggKCBzdHlsZS5zdHJva2VMaW5lQ2FwICkge1xuXG5cdFx0XHRcdGNhc2UgJ3JvdW5kJzpcblxuXHRcdFx0XHRcdGlmICggc3RhcnQgKSB7XG5cblx0XHRcdFx0XHRcdG1ha2VDaXJjdWxhclNlY3RvciggY2VudGVyLCBwMiwgcDEsIHUsIDAuNSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0bWFrZUNpcmN1bGFyU2VjdG9yKCBjZW50ZXIsIHAxLCBwMiwgdSwgMC41ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdzcXVhcmUnOlxuXG5cdFx0XHRcdFx0aWYgKCBzdGFydCApIHtcblxuXHRcdFx0XHRcdFx0dGVtcFYyXzEuc3ViVmVjdG9ycyggcDEsIGNlbnRlciApO1xuXHRcdFx0XHRcdFx0dGVtcFYyXzIuc2V0KCB0ZW1wVjJfMS55LCAtIHRlbXBWMl8xLnggKTtcblxuXHRcdFx0XHRcdFx0dGVtcFYyXzMuYWRkVmVjdG9ycyggdGVtcFYyXzEsIHRlbXBWMl8yICkuYWRkKCBjZW50ZXIgKTtcblx0XHRcdFx0XHRcdHRlbXBWMl80LnN1YlZlY3RvcnMoIHRlbXBWMl8yLCB0ZW1wVjJfMSApLmFkZCggY2VudGVyICk7XG5cblx0XHRcdFx0XHRcdC8vIE1vZGlmeSBhbHJlYWR5IGV4aXN0aW5nIHZlcnRpY2VzXG5cdFx0XHRcdFx0XHRpZiAoIGpvaW5Jc09uTGVmdFNpZGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0dGVtcFYyXzMudG9BcnJheSggdmVydGljZXMsIDEgKiAzICk7XG5cdFx0XHRcdFx0XHRcdHRlbXBWMl80LnRvQXJyYXkoIHZlcnRpY2VzLCAwICogMyApO1xuXHRcdFx0XHRcdFx0XHR0ZW1wVjJfNC50b0FycmF5KCB2ZXJ0aWNlcywgMyAqIDMgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHR0ZW1wVjJfMy50b0FycmF5KCB2ZXJ0aWNlcywgMSAqIDMgKTtcblx0XHRcdFx0XHRcdFx0dGVtcFYyXzMudG9BcnJheSggdmVydGljZXMsIDMgKiAzICk7XG5cdFx0XHRcdFx0XHRcdHRlbXBWMl80LnRvQXJyYXkoIHZlcnRpY2VzLCAwICogMyApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR0ZW1wVjJfMS5zdWJWZWN0b3JzKCBwMiwgY2VudGVyICk7XG5cdFx0XHRcdFx0XHR0ZW1wVjJfMi5zZXQoIHRlbXBWMl8xLnksIC0gdGVtcFYyXzEueCApO1xuXG5cdFx0XHRcdFx0XHR0ZW1wVjJfMy5hZGRWZWN0b3JzKCB0ZW1wVjJfMSwgdGVtcFYyXzIgKS5hZGQoIGNlbnRlciApO1xuXHRcdFx0XHRcdFx0dGVtcFYyXzQuc3ViVmVjdG9ycyggdGVtcFYyXzIsIHRlbXBWMl8xICkuYWRkKCBjZW50ZXIgKTtcblxuXHRcdFx0XHRcdFx0dmFyIHZsID0gdmVydGljZXMubGVuZ3RoO1xuXG5cdFx0XHRcdFx0XHQvLyBNb2RpZnkgYWxyZWFkeSBleGlzdGluZyB2ZXJ0aWNlc1xuXHRcdFx0XHRcdFx0aWYgKCBqb2luSXNPbkxlZnRTaWRlICkge1xuXG5cdFx0XHRcdFx0XHRcdHRlbXBWMl8zLnRvQXJyYXkoIHZlcnRpY2VzLCB2bCAtIDEgKiAzICk7XG5cdFx0XHRcdFx0XHRcdHRlbXBWMl80LnRvQXJyYXkoIHZlcnRpY2VzLCB2bCAtIDIgKiAzICk7XG5cdFx0XHRcdFx0XHRcdHRlbXBWMl80LnRvQXJyYXkoIHZlcnRpY2VzLCB2bCAtIDQgKiAzICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0dGVtcFYyXzMudG9BcnJheSggdmVydGljZXMsIHZsIC0gMiAqIDMgKTtcblx0XHRcdFx0XHRcdFx0dGVtcFYyXzQudG9BcnJheSggdmVydGljZXMsIHZsIC0gMSAqIDMgKTtcblx0XHRcdFx0XHRcdFx0dGVtcFYyXzQudG9BcnJheSggdmVydGljZXMsIHZsIC0gNCAqIDMgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbW92ZUR1cGxpY2F0ZWRQb2ludHMoIHBvaW50cyApIHtcblxuXHRcdFx0Ly8gQ3JlYXRlcyBhIG5ldyBhcnJheSBpZiBuZWNlc3Nhcnkgd2l0aCBkdXBsaWNhdGVkIHBvaW50cyByZW1vdmVkLlxuXHRcdFx0Ly8gVGhpcyBkb2VzIG5vdCByZW1vdmUgZHVwbGljYXRlZCBpbml0aWFsIGFuZCBlbmRpbmcgcG9pbnRzIG9mIGEgY2xvc2VkIHBhdGguXG5cblx0XHRcdHZhciBkdXBQb2ludHMgPSBmYWxzZTtcblx0XHRcdGZvciAoIHZhciBpID0gMSwgbiA9IHBvaW50cy5sZW5ndGggLSAxOyBpIDwgbjsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIHBvaW50c1sgaSBdLmRpc3RhbmNlVG8oIHBvaW50c1sgaSArIDEgXSApIDwgbWluRGlzdGFuY2UgKSB7XG5cblx0XHRcdFx0XHRkdXBQb2ludHMgPSB0cnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICEgZHVwUG9pbnRzICkgcmV0dXJuIHBvaW50cztcblxuXHRcdFx0dmFyIG5ld1BvaW50cyA9IFtdO1xuXHRcdFx0bmV3UG9pbnRzLnB1c2goIHBvaW50c1sgMCBdICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMSwgbiA9IHBvaW50cy5sZW5ndGggLSAxOyBpIDwgbjsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIHBvaW50c1sgaSBdLmRpc3RhbmNlVG8oIHBvaW50c1sgaSArIDEgXSApID49IG1pbkRpc3RhbmNlICkge1xuXG5cdFx0XHRcdFx0bmV3UG9pbnRzLnB1c2goIHBvaW50c1sgaSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdG5ld1BvaW50cy5wdXNoKCBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF0gKTtcblxuXHRcdFx0cmV0dXJuIG5ld1BvaW50cztcblxuXHRcdH1cblxuXHR9O1xuXG59KCk7XG5cbk9iamVjdDNELkRlZmF1bHRVcC5zZXQoMCwgMCwgMSk7XG52YXIgZGVmYXVsdENvbG9yID0gJ2hvdHBpbmsnO1xudmFyIHRyYXZlcnNlQ2hpbGRyZW4gPSBmdW5jdGlvbiAoY2hpbGQsIG9wYWNpdHksIHNoYWRvdykge1xuICAgIGlmIChjaGlsZC5pc01lc2gpIHtcbiAgICAgICAgaWYgKHNoYWRvdykge1xuICAgICAgICAgICAgY2hpbGQuY2FzdFNoYWRvdyA9IHRydWU7XG4gICAgICAgICAgICBjaGlsZC5yZWNlaXZlU2hhZG93ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3BhY2l0eSAhPT0gMS4wKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQubWF0ZXJpYWwuaXNNYXRlcmlhbCkge1xuICAgICAgICAgICAgICAgIGNoaWxkLm1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjaGlsZC5tYXRlcmlhbC5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGQubWF0ZXJpYWwpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQubWF0ZXJpYWwuZm9yRWFjaChmdW5jdGlvbiAobWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdC50cmFuc3BhcmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG1hdC5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChjaGlsZC50eXBlID09PSAnUG9pbnRMaWdodCcpIHtcbiAgICAgICAgY2hpbGQudmlzaWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGlsZC5pc09iamVjdDNEIHx8IGNoaWxkLmlzR3JvdXApIHtcbiAgICAgICAgY2hpbGQuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQyKSB7XG4gICAgICAgICAgICB0cmF2ZXJzZUNoaWxkcmVuKGNoaWxkMiwgb3BhY2l0eSwgc2hhZG93KTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbnZhciBTVExBc3NldCA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHZhciBtb2RlbCA9IHVzZUxvYWRlcihTVExMb2FkZXIsIHByb3BzLnVybCk7XG4gICAgdmFyIHNjZW5lID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiBtb2RlbC5jbG9uZSgpOyB9LCBbbW9kZWxdKTtcbiAgICAvLyBjb25zb2xlLmxvZygnTG9hZGluZzogJylcbiAgICAvLyBjb25zb2xlLmxvZyhwcm9wcylcbiAgICAvLyB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vICAgICAvLyBzY2VuZS5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgIC8vICAgICAvLyAgICAgdHJhdmVyc2VDaGlsZHJlbihjaGlsZCwgcHJvcHMub3BhY2l0eSwgdHJ1ZSlcbiAgICAvLyAgICAgLy8gfSlcbiAgICAvLyAgICAgc2NlbmUubmFtZSA9ICdsb2FkZWQnXG4gICAgLy8gfSlcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIsIHsgcG9zaXRpb246IFtwcm9wcy50WzBdLCBwcm9wcy50WzFdLCBwcm9wcy50WzJdXSwgcXVhdGVybmlvbjogW3Byb3BzLnFbMF0sIHByb3BzLnFbMV0sIHByb3BzLnFbMl0sIHByb3BzLnFbM11dLCBzY2FsZTogW3Byb3BzLnNjYWxlWzBdLCBwcm9wcy5zY2FsZVsxXSwgcHJvcHMuc2NhbGVbMl1dLCBjYXN0U2hhZG93OiB0cnVlLCByZWNlaXZlU2hhZG93OiB0cnVlLCBuYW1lOiAnbG9hZGVkJyB9LFxuICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIsIHsgb2JqZWN0OiBzY2VuZSwgYXR0YWNoOiBcImdlb21ldHJ5XCIgfSksXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJtZXNoU3RhbmRhcmRNYXRlcmlhbFwiLCB7IGNvbG9yOiBwcm9wcy5jb2xvciA/IHByb3BzLmNvbG9yIDogZGVmYXVsdENvbG9yLCB0cmFuc3BhcmVudDogcHJvcHMub3BhY2l0eSAhPT0gMS4wID8gdHJ1ZSA6IGZhbHNlLCBvcGFjaXR5OiBwcm9wcy5vcGFjaXR5ID8gcHJvcHMub3BhY2l0eSA6IDEuMCB9KSkpO1xufTtcbnZhciBHTFRGQXNzZXQgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgbW9kZWwgPSB1c2VMb2FkZXIoR0xURkxvYWRlciwgcHJvcHMudXJsKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBtb2RlbC5zY2VuZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgdHJhdmVyc2VDaGlsZHJlbihjaGlsZCwgcHJvcHMub3BhY2l0eSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1lc2hcIiwgeyBwb3NpdGlvbjogW3Byb3BzLnRbMF0sIHByb3BzLnRbMV0sIHByb3BzLnRbMl1dLCBxdWF0ZXJuaW9uOiBbcHJvcHMucVswXSwgcHJvcHMucVsxXSwgcHJvcHMucVsyXSwgcHJvcHMucVszXV0sIHNjYWxlOiBbcHJvcHMuc2NhbGVbMF0sIHByb3BzLnNjYWxlWzFdLCBwcm9wcy5zY2FsZVsyXV0sIGNhc3RTaGFkb3c6IHRydWUsIHJlY2VpdmVTaGFkb3c6IHRydWUgfSxcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLCB7IG9iamVjdDogbW9kZWwuc2NlbmUsIG9wYWNpdHk6IHByb3BzLm9wYWNpdHksIGNhc3RTaGFkb3c6IHRydWUsIHJlY2VpdmVTaGFkb3c6IHRydWUgfSkpKTtcbn07XG52YXIgQ29sbGFkYUFzc2V0ID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIG1vZGVsID0gdXNlTG9hZGVyKENvbGxhZGFMb2FkZXIsIHByb3BzLnVybCk7XG4gICAgdmFyIHNjZW5lID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiBtb2RlbC5zY2VuZS5jbG9uZSgpOyB9LCBbbW9kZWwuc2NlbmVdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBzY2VuZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgdHJhdmVyc2VDaGlsZHJlbihjaGlsZCwgcHJvcHMub3BhY2l0eSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzY2VuZS5uYW1lID0gJ2xvYWRlZCc7XG4gICAgICAgIC8vIGlmIChwcm9wcy5xKSB7XG4gICAgICAgIC8vICAgICBtb2RlbC5zY2VuZS5xdWF0ZXJuaW9uLnNldChcbiAgICAgICAgLy8gICAgICAgICBwcm9wcy5xWzBdLFxuICAgICAgICAvLyAgICAgICAgIHByb3BzLnFbMV0sXG4gICAgICAgIC8vICAgICAgICAgcHJvcHMucVsyXSxcbiAgICAgICAgLy8gICAgICAgICBwcm9wcy5xWzNdXG4gICAgICAgIC8vICAgICApXG4gICAgICAgIC8vIH1cbiAgICB9KTtcbiAgICAvLyByZXR1cm4gKFxuICAgIC8vICAgICA8Z3JvdXBcbiAgICAvLyAgICAgICAgIHBvc2l0aW9uPXtwcm9wcy50fVxuICAgIC8vICAgICAgICAgY2FzdFNoYWRvdz17dHJ1ZX1cbiAgICAvLyAgICAgICAgIHJlY2VpdmVTaGFkb3c9e3RydWV9XG4gICAgLy8gICAgICAgICBzY2FsZT17cHJvcHMuc2NhbGV9XG4gICAgLy8gICAgICAgICBxdWF0ZXJuaW9uPXtwcm9wcy5xfVxuICAgIC8vICAgICA+XG4gICAgLy8gICAgICAgICA8cHJpbWl0aXZlIG9iamVjdD17bW9kZWwuc2NlbmV9IC8+XG4gICAgLy8gICAgIDwvZ3JvdXA+XG4gICAgLy8gKVxuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLCB7IG9iamVjdDogc2NlbmUsIHBvc2l0aW9uOiBwcm9wcy50LCBzY2FsZTogcHJvcHMuc2NhbGUsIHF1YXRlcm5pb246IHByb3BzLnEgfSkpO1xufTtcbnZhciBPQkpBc3NldCA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHZhciBtdGx1cmwgPSBwcm9wcy51cmwuc2xpY2UoMCwgcHJvcHMudXJsLmxlbmd0aCAtIDMpICsgJ210bCc7XG4gICAgdmFyIG1hdGVyaWFscyA9IHVzZUxvYWRlcihNVExMb2FkZXIsIG10bHVybCk7XG4gICAgdmFyIG1vZGVsID0gdXNlTG9hZGVyKE9CSkxvYWRlciwgcHJvcHMudXJsLCBmdW5jdGlvbiAobG9hZGVyKSB7XG4gICAgICAgIG1hdGVyaWFscy5wcmVsb2FkKCk7XG4gICAgICAgIC8vIGxvYWRlci5zZXRNYXRlcmlhbHMobWF0ZXJpYWxzKVxuICAgIH0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1vZGVsLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICB0cmF2ZXJzZUNoaWxkcmVuKGNoaWxkLCBwcm9wcy5vcGFjaXR5LCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibWVzaFwiLCB7IHBvc2l0aW9uOiBbcHJvcHMudFswXSwgcHJvcHMudFsxXSwgcHJvcHMudFsyXV0sIHF1YXRlcm5pb246IFtwcm9wcy5xWzBdLCBwcm9wcy5xWzFdLCBwcm9wcy5xWzJdLCBwcm9wcy5xWzNdXSwgc2NhbGU6IFtwcm9wcy5zY2FsZVswXSwgcHJvcHMuc2NhbGVbMV0sIHByb3BzLnNjYWxlWzJdXSwgY2FzdFNoYWRvdzogdHJ1ZSwgcmVjZWl2ZVNoYWRvdzogdHJ1ZSB9LFxuICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIsIHsgb2JqZWN0OiBtb2RlbCB9KSkpO1xufTtcbnZhciBWUk1MQXNzZXQgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgbW9kZWwgPSB1c2VMb2FkZXIoVlJNTExvYWRlciwgcHJvcHMudXJsKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBtb2RlbC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgdHJhdmVyc2VDaGlsZHJlbihjaGlsZCwgcHJvcHMub3BhY2l0eSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1lc2hcIiwgeyBwb3NpdGlvbjogW3Byb3BzLnRbMF0sIHByb3BzLnRbMV0sIHByb3BzLnRbMl1dLCBxdWF0ZXJuaW9uOiBbcHJvcHMucVswXSwgcHJvcHMucVsxXSwgcHJvcHMucVsyXSwgcHJvcHMucVszXV0sIHNjYWxlOiBbcHJvcHMuc2NhbGVbMF0sIHByb3BzLnNjYWxlWzFdLCBwcm9wcy5zY2FsZVsyXV0sIGNhc3RTaGFkb3c6IHRydWUsIHJlY2VpdmVTaGFkb3c6IHRydWUgfSxcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLCB7IG9iamVjdDogbW9kZWwgfSkpKTtcbn07XG52YXIgUENEQXNzZXQgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgbW9kZWwgPSB1c2VMb2FkZXIoUENETG9hZGVyLCBwcm9wcy51cmwpO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIG1vZGVsLm1hdGVyaWFsLmNvbG9yID0gcHJvcHMuY29sb3JcbiAgICAgICAgLy8gICAgID8gbmV3IFRIUkVFLkNvbG9yKHByb3BzLmNvbG9yKVxuICAgICAgICAvLyAgICAgOiBuZXcgVEhSRUUuQ29sb3IoZGVmYXVsdENvbG9yKVxuICAgICAgICAvLyBtb2RlbC5tYXRlcmlhbC50cmFuc3BhcmVudCA9IHByb3BzLm9wYWNpdHkgIT09IDEuMCA/IHRydWUgOiBmYWxzZVxuICAgICAgICAvLyBtb2RlbC5tYXRlcmlhbC5vcGFjaXR5ID0gcHJvcHMub3BhY2l0eSA/IHByb3BzLm9wYWNpdHkgOiAxLjBcbiAgICB9KTtcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIsIHsgcG9zaXRpb246IFtwcm9wcy50WzBdLCBwcm9wcy50WzFdLCBwcm9wcy50WzJdXSwgcXVhdGVybmlvbjogW3Byb3BzLnFbMF0sIHByb3BzLnFbMV0sIHByb3BzLnFbMl0sIHByb3BzLnFbM11dLCBzY2FsZTogW3Byb3BzLnNjYWxlWzBdLCBwcm9wcy5zY2FsZVsxXSwgcHJvcHMuc2NhbGVbMl1dLCBjYXN0U2hhZG93OiB0cnVlLCByZWNlaXZlU2hhZG93OiB0cnVlIH0sXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIiwgeyBvYmplY3Q6IG1vZGVsIH0pKSk7XG59O1xudmFyIFBMWUFzc2V0ID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIG1vZGVsID0gdXNlTG9hZGVyKFBMWUxvYWRlciwgcHJvcHMudXJsKTtcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIsIHsgcG9zaXRpb246IFtwcm9wcy50WzBdLCBwcm9wcy50WzFdLCBwcm9wcy50WzJdXSwgcXVhdGVybmlvbjogW3Byb3BzLnFbMF0sIHByb3BzLnFbMV0sIHByb3BzLnFbMl0sIHByb3BzLnFbM11dLCBzY2FsZTogW3Byb3BzLnNjYWxlWzBdLCBwcm9wcy5zY2FsZVsxXSwgcHJvcHMuc2NhbGVbMl1dLCBjYXN0U2hhZG93OiB0cnVlLCByZWNlaXZlU2hhZG93OiB0cnVlIH0sXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIiwgeyBvYmplY3Q6IG1vZGVsLCBhdHRhY2g6IFwiZ2VvbWV0cnlcIiB9KSxcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1lc2hTdGFuZGFyZE1hdGVyaWFsXCIsIHsgY29sb3I6IHByb3BzLmNvbG9yID8gcHJvcHMuY29sb3IgOiBkZWZhdWx0Q29sb3IsIHRyYW5zcGFyZW50OiBwcm9wcy5vcGFjaXR5ICE9PSAxLjAgPyB0cnVlIDogZmFsc2UsIG9wYWNpdHk6IHByb3BzLm9wYWNpdHkgPyBwcm9wcy5vcGFjaXR5IDogMS4wIH0pKSk7XG59O1xudmFyIEZCWEFzc2V0ID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIG1vZGVsID0gdXNlTG9hZGVyKEZCWExvYWRlciwgcHJvcHMudXJsKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBtb2RlbC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgdHJhdmVyc2VDaGlsZHJlbihjaGlsZCwgcHJvcHMub3BhY2l0eSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1lc2hcIiwgeyBwb3NpdGlvbjogW3Byb3BzLnRbMF0sIHByb3BzLnRbMV0sIHByb3BzLnRbMl1dLCBxdWF0ZXJuaW9uOiBbcHJvcHMucVswXSwgcHJvcHMucVsxXSwgcHJvcHMucVsyXSwgcHJvcHMucVszXV0sIHNjYWxlOiBbcHJvcHMuc2NhbGVbMF0sIHByb3BzLnNjYWxlWzFdLCBwcm9wcy5zY2FsZVsyXV0sIGNhc3RTaGFkb3c6IHRydWUsIHJlY2VpdmVTaGFkb3c6IHRydWUgfSxcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLCB7IG9iamVjdDogbW9kZWwgfSkpKTtcbn07XG52YXIgU1ZHU2hhcGUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgc2hhcGUgPSBfYS5zaGFwZSwgY29sb3IgPSBfYS5jb2xvciwgaW5kZXggPSBfYS5pbmRleCwgb3BhY2l0eSA9IF9hLm9wYWNpdHk7XG4gICAgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibWVzaFwiLCBudWxsLFxuICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibWVzaExhbWJlcnRNYXRlcmlhbFwiLCB7IGF0dGFjaDogXCJtYXRlcmlhbFwiLCBjb2xvcjogY29sb3IsIHBvbHlnb25PZmZzZXQ6IHRydWUsIHBvbHlnb25PZmZzZXRGYWN0b3I6IGluZGV4ICogLTAuMSwgdHJhbnNwYXJlbnQ6IG9wYWNpdHkgIT09IDEuMCA/IHRydWUgOiBmYWxzZSwgb3BhY2l0eTogb3BhY2l0eSA/IG9wYWNpdHkgOiAxLjAgfSksXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzaGFwZUJ1ZmZlckdlb21ldHJ5XCIsIHsgYXR0YWNoOiBcImdlb21ldHJ5XCIsIGFyZ3M6IFtzaGFwZV0gfSkpKTtcbn07XG52YXIgU1ZHQXNzZXQgPSBSZWFjdF9fZGVmYXVsdC5tZW1vKGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHZhciBwYXRocyA9IHVzZUxvYWRlcihTVkdMb2FkZXIsIHByb3BzLnVybCkucGF0aHM7XG4gICAgdmFyIHNoYXBlcyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcGF0aHMuZmxhdE1hcChmdW5jdGlvbiAocGF0aCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoXG4gICAgICAgICAgICAgICAgLnRvU2hhcGVzKHRydWUpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoc2hhcGUpIHsgcmV0dXJuICh7IGluZGV4OiBpbmRleCwgc2hhcGU6IHNoYXBlLCBjb2xvcjogcGF0aC5jb2xvciB9KTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sIFtwYXRoc10pO1xuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsIHsgY2hpbGRyZW46IHNoYXBlcy5tYXAoZnVuY3Rpb24gKG5ld1Byb3BzLCBrZXkpIHsgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFNWR1NoYXBlLCBfX2Fzc2lnbih7IGtleToga2V5LCBvcGFjaXR5OiBwcm9wcy5vcGFjaXR5IH0sIG5ld1Byb3BzKSkpOyB9KSwgc2NhbGU6IFtcbiAgICAgICAgICAgIC0wLjAxICogcHJvcHMuc2NhbGVbMF0sXG4gICAgICAgICAgICAwLjAxICogcHJvcHMuc2NhbGVbMV0sXG4gICAgICAgICAgICAwLjAxICogcHJvcHMuc2NhbGVbMl0sXG4gICAgICAgIF0sIHBvc2l0aW9uOiBbcHJvcHMudFswXSwgcHJvcHMudFsxXSwgcHJvcHMudFsyXV0sIHF1YXRlcm5pb246IFtwcm9wcy5xWzBdLCBwcm9wcy5xWzFdLCBwcm9wcy5xWzJdLCBwcm9wcy5xWzNdXSB9KSk7XG59KTtcbnZhciBMb2FkZXIgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgZXh0ID0gcHJvcHMuZmlsZW5hbWUuc3BsaXQoJy4nKS5wb3AoKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciB1cmwgPSBwcm9wcy5maWxlbmFtZTtcbiAgICB1cmwgPSBcInJldHJpZXZlL1wiICsgdXJsO1xuICAgIHN3aXRjaCAoZXh0KSB7XG4gICAgICAgIGNhc2UgJ3N0bCc6XG4gICAgICAgICAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTVExBc3NldCwgX19hc3NpZ24oeyB1cmw6IHVybCB9LCBwcm9wcykpO1xuICAgICAgICBjYXNlICdnbHRmJzpcbiAgICAgICAgY2FzZSAnZ2xiJzpcbiAgICAgICAgICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEdMVEZBc3NldCwgX19hc3NpZ24oeyB1cmw6IHVybCB9LCBwcm9wcykpO1xuICAgICAgICBjYXNlICdkYWUnOlxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ29sbGFkYUFzc2V0LCBfX2Fzc2lnbih7IHVybDogdXJsIH0sIHByb3BzKSk7XG4gICAgICAgIGNhc2UgJ29iaic6XG4gICAgICAgICAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChPQkpBc3NldCwgX19hc3NpZ24oeyB1cmw6IHVybCB9LCBwcm9wcykpO1xuICAgICAgICBjYXNlICd3cmwnOlxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoVlJNTEFzc2V0LCBfX2Fzc2lnbih7IHVybDogdXJsIH0sIHByb3BzKSk7XG4gICAgICAgIGNhc2UgJ3BjZCc6XG4gICAgICAgICAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChQQ0RBc3NldCwgX19hc3NpZ24oeyB1cmw6IHVybCB9LCBwcm9wcykpO1xuICAgICAgICBjYXNlICdwbHknOlxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUExZQXNzZXQsIF9fYXNzaWduKHsgdXJsOiB1cmwgfSwgcHJvcHMpKTtcbiAgICAgICAgY2FzZSAnZmJ4JzpcbiAgICAgICAgICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEZCWEFzc2V0LCBfX2Fzc2lnbih7IHVybDogdXJsIH0sIHByb3BzKSk7XG4gICAgICAgIGNhc2UgJ3N2Zyc6XG4gICAgICAgICAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTVkdBc3NldCwgX19hc3NpZ24oeyB1cmw6IHVybCB9LCBwcm9wcykpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ29sbGFkYUFzc2V0LCBfX2Fzc2lnbih7IHVybDogdXJsIH0sIHByb3BzKSk7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgTG9hZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9hZGVyLTFjYjVhZGE3LmpzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../react-swift/dist/Loader-1cb5ada7.js\n");

/***/ })

}]);